/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/airbnb-browser-shims/browser-only.js":
/*!***********************************************************!*\
  !*** ./node_modules/airbnb-browser-shims/browser-only.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* eslint global-require: 0 */

// Fixes super-constructor calls in IE9/10
__webpack_require__(/*! ima-babel6-polyfill */ "./node_modules/ima-babel6-polyfill/index.js");

// document.contains polyfill
__webpack_require__(/*! ./document-contains */ "./node_modules/airbnb-browser-shims/document-contains.js");

// console.* polyfill for old browsers
__webpack_require__(/*! console-polyfill */ "./node_modules/console-polyfill/index.js");

__webpack_require__(/*! whatwg-fetch */ "./node_modules/whatwg-fetch/fetch.js");

if (typeof window !== 'undefined') {
  // Element.classList polyfill
  __webpack_require__(/*! classlist-polyfill */ "./node_modules/classlist-polyfill/src/index.js");

  // Element.closest polyfill
  __webpack_require__(/*! element-closest */ "./node_modules/element-closest/element-closest.js");

  // Polyfill for smooth scrolling behavior
  (__webpack_require__(/*! smoothscroll-polyfill */ "./node_modules/smoothscroll-polyfill/dist/smoothscroll.js").polyfill)();

  // Polyfill window.matchMedia (primarily for IE9)
  __webpack_require__(/*! matchmedia-polyfill */ "./node_modules/matchmedia-polyfill/matchMedia.js");
  __webpack_require__(/*! matchmedia-polyfill/matchMedia.addListener */ "./node_modules/matchmedia-polyfill/matchMedia.addListener.js");

  // Polyfill window.location.origin (for IE < 11)
  __webpack_require__(/*! window-location-origin */ "./node_modules/window-location-origin/src/window-location-origin.js");

  // for <= IE 9, Opera mini
  __webpack_require__(/*! input-placeholder-polyfill */ "./node_modules/input-placeholder-polyfill/dist/main.min.js");

  __webpack_require__(/*! intersection-observer */ "./node_modules/intersection-observer/intersection-observer.js");

  // KeyboardEvent.key shim
  __webpack_require__(/*! shim-keyboard-event-key */ "./node_modules/shim-keyboard-event-key/index.js");
}

// :focus-visible shim
__webpack_require__(/*! focus-visible */ "./node_modules/focus-visible/dist/focus-visible.js");

__webpack_require__(/*! raf/polyfill */ "./node_modules/raf/polyfill.js");

__webpack_require__.g.requestIdleCallback = __webpack_require__(/*! ric-shim */ "./node_modules/ric-shim/index.js");

__webpack_require__.g.cancelIdleCallback = __webpack_require__.g.requestIdleCallback.cancelIdleCallback;

var hasSymbols = typeof Symbol === 'function' && Symbol.iterator;

/* globals TouchList */
if (hasSymbols && typeof TouchList === 'function' && typeof TouchList.prototype[Symbol.iterator] !== 'function') {
  TouchList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
}


/***/ }),

/***/ "./node_modules/airbnb-browser-shims/document-contains.js":
/*!****************************************************************!*\
  !*** ./node_modules/airbnb-browser-shims/document-contains.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! document.contains/auto */ "./node_modules/document.contains/auto.js");


/***/ }),

/***/ "./node_modules/airbnb-browser-shims/index.js":
/*!****************************************************!*\
  !*** ./node_modules/airbnb-browser-shims/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* eslint global-require: 0 */

__webpack_require__(/*! airbnb-js-shims */ "./node_modules/airbnb-js-shims/index.js");

__webpack_require__(/*! ./browser-only */ "./node_modules/airbnb-browser-shims/browser-only.js");


/***/ }),

/***/ "./node_modules/airbnb-js-shims/index.js":
/*!***********************************************!*\
  !*** ./node_modules/airbnb-js-shims/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! ./target/es5 */ "./node_modules/airbnb-js-shims/target/es5.js");


/***/ }),

/***/ "./node_modules/airbnb-js-shims/target/es2015.js":
/*!*******************************************************!*\
  !*** ./node_modules/airbnb-js-shims/target/es2015.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! es6-shim */ "./node_modules/es6-shim/es6-shim.js");

__webpack_require__(/*! function.prototype.name/shim */ "./node_modules/function.prototype.name/shim.js")();

__webpack_require__(/*! ./es2016 */ "./node_modules/airbnb-js-shims/target/es2016.js");


/***/ }),

/***/ "./node_modules/airbnb-js-shims/target/es2016.js":
/*!*******************************************************!*\
  !*** ./node_modules/airbnb-js-shims/target/es2016.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// Array#includes is stage 4, in ES7/ES2016
__webpack_require__(/*! array-includes/shim */ "./node_modules/array-includes/shim.js")();

__webpack_require__(/*! ./es2017 */ "./node_modules/airbnb-js-shims/target/es2017.js");


/***/ }),

/***/ "./node_modules/airbnb-js-shims/target/es2017.js":
/*!*******************************************************!*\
  !*** ./node_modules/airbnb-js-shims/target/es2017.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// Object.values/Object.entries are stage 4, in ES2017
__webpack_require__(/*! object.values/shim */ "./node_modules/object.values/shim.js")();
__webpack_require__(/*! object.entries/shim */ "./node_modules/object.entries/shim.js")();

// String#padStart/String#padEnd are stage 4, in ES2017
__webpack_require__(/*! string.prototype.padstart/shim */ "./node_modules/string.prototype.padstart/shim.js")();
__webpack_require__(/*! string.prototype.padend/shim */ "./node_modules/string.prototype.padend/shim.js")();

// Object.getOwnPropertyDescriptors is stage 4, in ES2017
__webpack_require__(/*! object.getownpropertydescriptors/shim */ "./node_modules/object.getownpropertydescriptors/shim.js")();

__webpack_require__(/*! ./es2018 */ "./node_modules/airbnb-js-shims/target/es2018.js");


/***/ }),

/***/ "./node_modules/airbnb-js-shims/target/es2018.js":
/*!*******************************************************!*\
  !*** ./node_modules/airbnb-js-shims/target/es2018.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (typeof Promise === 'function') {
  __webpack_require__(/*! promise.prototype.finally/auto */ "./node_modules/promise.prototype.finally/auto.js"); // eslint-disable-line global-require
}

__webpack_require__(/*! ./es2019 */ "./node_modules/airbnb-js-shims/target/es2019.js");


/***/ }),

/***/ "./node_modules/airbnb-js-shims/target/es2019.js":
/*!*******************************************************!*\
  !*** ./node_modules/airbnb-js-shims/target/es2019.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! array.prototype.flat/auto */ "./node_modules/array.prototype.flat/auto.js");
__webpack_require__(/*! array.prototype.flatmap/auto */ "./node_modules/array.prototype.flatmap/auto.js");

__webpack_require__(/*! symbol.prototype.description/auto */ "./node_modules/symbol.prototype.description/auto.js");

__webpack_require__(/*! object.fromentries/auto */ "./node_modules/object.fromentries/auto.js");

__webpack_require__(/*! ./es2020 */ "./node_modules/airbnb-js-shims/target/es2020.js");


/***/ }),

/***/ "./node_modules/airbnb-js-shims/target/es2020.js":
/*!*******************************************************!*\
  !*** ./node_modules/airbnb-js-shims/target/es2020.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! string.prototype.matchall/auto */ "./node_modules/string.prototype.matchall/auto.js");

__webpack_require__(/*! globalthis/auto */ "./node_modules/globalthis/auto.js");

__webpack_require__(/*! promise.allsettled/auto */ "./node_modules/promise.allsettled/auto.js");


/***/ }),

/***/ "./node_modules/airbnb-js-shims/target/es5.js":
/*!****************************************************!*\
  !*** ./node_modules/airbnb-js-shims/target/es5.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! es5-shim */ "./node_modules/es5-shim/es5-shim.js");
__webpack_require__(/*! es5-shim/es5-sham */ "./node_modules/es5-shim/es5-sham.js");

__webpack_require__(/*! ./es2015 */ "./node_modules/airbnb-js-shims/target/es2015.js");


/***/ }),

/***/ "./node_modules/array-includes/implementation.js":
/*!*******************************************************!*\
  !*** ./node_modules/array-includes/implementation.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ToIntegerOrInfinity = __webpack_require__(/*! es-abstract/2021/ToIntegerOrInfinity */ "./node_modules/es-abstract/2021/ToIntegerOrInfinity.js");
var ToLength = __webpack_require__(/*! es-abstract/2021/ToLength */ "./node_modules/es-abstract/2021/ToLength.js");
var ToObject = __webpack_require__(/*! es-abstract/2021/ToObject */ "./node_modules/es-abstract/2021/ToObject.js");
var SameValueZero = __webpack_require__(/*! es-abstract/2021/SameValueZero */ "./node_modules/es-abstract/2021/SameValueZero.js");
var $isNaN = __webpack_require__(/*! es-abstract/helpers/isNaN */ "./node_modules/es-abstract/helpers/isNaN.js");
var $isFinite = __webpack_require__(/*! es-abstract/helpers/isFinite */ "./node_modules/es-abstract/helpers/isFinite.js");
var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
var isString = __webpack_require__(/*! is-string */ "./node_modules/is-string/index.js");

var $charAt = callBound('String.prototype.charAt');
var $indexOf = GetIntrinsic('%Array.prototype.indexOf%'); // TODO: use callBind.apply without breaking IE 8
var $max = GetIntrinsic('%Math.max%');

module.exports = function includes(searchElement) {
	var fromIndex = arguments.length > 1 ? ToIntegerOrInfinity(arguments[1]) : 0;
	if ($indexOf && !$isNaN(searchElement) && $isFinite(fromIndex) && typeof searchElement !== 'undefined') {
		return $indexOf.apply(this, arguments) > -1;
	}

	var O = ToObject(this);
	var length = ToLength(O.length);
	if (length === 0) {
		return false;
	}
	var k = fromIndex >= 0 ? fromIndex : $max(0, length + fromIndex);
	while (k < length) {
		if (SameValueZero(searchElement, isString(O) ? $charAt(O, k) : O[k])) {
			return true;
		}
		k += 1;
	}
	return false;
};


/***/ }),

/***/ "./node_modules/array-includes/polyfill.js":
/*!*************************************************!*\
  !*** ./node_modules/array-includes/polyfill.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/array-includes/implementation.js");

module.exports = function getPolyfill() {
	return Array.prototype.includes || implementation;
};


/***/ }),

/***/ "./node_modules/array-includes/shim.js":
/*!*********************************************!*\
  !*** ./node_modules/array-includes/shim.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/array-includes/polyfill.js");

module.exports = function shimArrayPrototypeIncludes() {
	var polyfill = getPolyfill();
	define(
		Array.prototype,
		{ includes: polyfill },
		{ includes: function () { return Array.prototype.includes !== polyfill; } }
	);
	return polyfill;
};


/***/ }),

/***/ "./node_modules/array.prototype.flat/auto.js":
/*!***************************************************!*\
  !*** ./node_modules/array.prototype.flat/auto.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! ./shim */ "./node_modules/array.prototype.flat/shim.js")();


/***/ }),

/***/ "./node_modules/array.prototype.flat/implementation.js":
/*!*************************************************************!*\
  !*** ./node_modules/array.prototype.flat/implementation.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ArraySpeciesCreate = __webpack_require__(/*! es-abstract/2021/ArraySpeciesCreate */ "./node_modules/es-abstract/2021/ArraySpeciesCreate.js");
var FlattenIntoArray = __webpack_require__(/*! es-abstract/2021/FlattenIntoArray */ "./node_modules/es-abstract/2021/FlattenIntoArray.js");
var Get = __webpack_require__(/*! es-abstract/2021/Get */ "./node_modules/es-abstract/2021/Get.js");
var ToIntegerOrInfinity = __webpack_require__(/*! es-abstract/2021/ToIntegerOrInfinity */ "./node_modules/es-abstract/2021/ToIntegerOrInfinity.js");
var ToLength = __webpack_require__(/*! es-abstract/2021/ToLength */ "./node_modules/es-abstract/2021/ToLength.js");
var ToObject = __webpack_require__(/*! es-abstract/2021/ToObject */ "./node_modules/es-abstract/2021/ToObject.js");

module.exports = function flat() {
	var O = ToObject(this);
	var sourceLen = ToLength(Get(O, 'length'));

	var depthNum = 1;
	if (arguments.length > 0 && typeof arguments[0] !== 'undefined') {
		depthNum = ToIntegerOrInfinity(arguments[0]);
	}

	var A = ArraySpeciesCreate(O, 0);
	FlattenIntoArray(A, O, sourceLen, 0, depthNum);
	return A;
};


/***/ }),

/***/ "./node_modules/array.prototype.flat/polyfill.js":
/*!*******************************************************!*\
  !*** ./node_modules/array.prototype.flat/polyfill.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/array.prototype.flat/implementation.js");

module.exports = function getPolyfill() {
	return Array.prototype.flat || implementation;
};


/***/ }),

/***/ "./node_modules/array.prototype.flat/shim.js":
/*!***************************************************!*\
  !*** ./node_modules/array.prototype.flat/shim.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/array.prototype.flat/polyfill.js");

module.exports = function shimFlat() {
	var polyfill = getPolyfill();
	define(
		Array.prototype,
		{ flat: polyfill },
		{ flat: function () { return Array.prototype.flat !== polyfill; } }
	);
	return polyfill;
};


/***/ }),

/***/ "./node_modules/array.prototype.flatmap/auto.js":
/*!******************************************************!*\
  !*** ./node_modules/array.prototype.flatmap/auto.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! ./shim */ "./node_modules/array.prototype.flatmap/shim.js")();


/***/ }),

/***/ "./node_modules/array.prototype.flatmap/implementation.js":
/*!****************************************************************!*\
  !*** ./node_modules/array.prototype.flatmap/implementation.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ArraySpeciesCreate = __webpack_require__(/*! es-abstract/2021/ArraySpeciesCreate */ "./node_modules/es-abstract/2021/ArraySpeciesCreate.js");
var FlattenIntoArray = __webpack_require__(/*! es-abstract/2021/FlattenIntoArray */ "./node_modules/es-abstract/2021/FlattenIntoArray.js");
var Get = __webpack_require__(/*! es-abstract/2021/Get */ "./node_modules/es-abstract/2021/Get.js");
var IsCallable = __webpack_require__(/*! es-abstract/2021/IsCallable */ "./node_modules/es-abstract/2021/IsCallable.js");
var ToLength = __webpack_require__(/*! es-abstract/2021/ToLength */ "./node_modules/es-abstract/2021/ToLength.js");
var ToObject = __webpack_require__(/*! es-abstract/2021/ToObject */ "./node_modules/es-abstract/2021/ToObject.js");

module.exports = function flatMap(mapperFunction) {
	var O = ToObject(this);
	var sourceLen = ToLength(Get(O, 'length'));

	if (!IsCallable(mapperFunction)) {
		throw new TypeError('mapperFunction must be a function');
	}

	var T;
	if (arguments.length > 1) {
		T = arguments[1];
	}

	var A = ArraySpeciesCreate(O, 0);
	FlattenIntoArray(A, O, sourceLen, 0, 1, mapperFunction, T);
	return A;
};


/***/ }),

/***/ "./node_modules/array.prototype.flatmap/polyfill.js":
/*!**********************************************************!*\
  !*** ./node_modules/array.prototype.flatmap/polyfill.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/array.prototype.flatmap/implementation.js");

module.exports = function getPolyfill() {
	return Array.prototype.flatMap || implementation;
};


/***/ }),

/***/ "./node_modules/array.prototype.flatmap/shim.js":
/*!******************************************************!*\
  !*** ./node_modules/array.prototype.flatmap/shim.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/array.prototype.flatmap/polyfill.js");

module.exports = function shimFlatMap() {
	var polyfill = getPolyfill();
	define(
		Array.prototype,
		{ flatMap: polyfill },
		{ flatMap: function () { return Array.prototype.flatMap !== polyfill; } }
	);
	return polyfill;
};


/***/ }),

/***/ "./node_modules/array.prototype.map/implementation.js":
/*!************************************************************!*\
  !*** ./node_modules/array.prototype.map/implementation.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ArraySpeciesCreate = __webpack_require__(/*! es-abstract/2021/ArraySpeciesCreate */ "./node_modules/es-abstract/2021/ArraySpeciesCreate.js");
var Call = __webpack_require__(/*! es-abstract/2021/Call */ "./node_modules/es-abstract/2021/Call.js");
var CreateDataPropertyOrThrow = __webpack_require__(/*! es-abstract/2021/CreateDataPropertyOrThrow */ "./node_modules/es-abstract/2021/CreateDataPropertyOrThrow.js");
var Get = __webpack_require__(/*! es-abstract/2021/Get */ "./node_modules/es-abstract/2021/Get.js");
var HasProperty = __webpack_require__(/*! es-abstract/2021/HasProperty */ "./node_modules/es-abstract/2021/HasProperty.js");
var IsCallable = __webpack_require__(/*! es-abstract/2021/IsCallable */ "./node_modules/es-abstract/2021/IsCallable.js");
var ToUint32 = __webpack_require__(/*! es-abstract/2021/ToUint32 */ "./node_modules/es-abstract/2021/ToUint32.js");
var ToObject = __webpack_require__(/*! es-abstract/2021/ToObject */ "./node_modules/es-abstract/2021/ToObject.js");
var ToString = __webpack_require__(/*! es-abstract/2021/ToString */ "./node_modules/es-abstract/2021/ToString.js");

var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");

var isString = __webpack_require__(/*! is-string */ "./node_modules/is-string/index.js");

// Check failure of by-index access of string characters (IE < 9) and failure of `0 in boxedString` (Rhino)
var boxedString = Object('a');
var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

var strSplit = callBound('String.prototype.split');

module.exports = function map(callbackfn) {
	var O = ToObject(this);
	var self = splitString && isString(O) ? strSplit(O, '') : O;
	var len = ToUint32(self.length);

	// If no callback function or if callback is not a callable function
	if (!IsCallable(callbackfn)) {
		throw new TypeError('Array.prototype.map callback must be a function');
	}

	var T;
	if (arguments.length > 1) {
		T = arguments[1];
	}

	var A = ArraySpeciesCreate(O, len);
	var k = 0;
	while (k < len) {
		var Pk = ToString(k);
		var kPresent = HasProperty(O, Pk);
		if (kPresent) {
			var kValue = Get(O, Pk);
			var mappedValue = Call(callbackfn, T, [kValue, k, O]);
			CreateDataPropertyOrThrow(A, Pk, mappedValue);
		}
		k += 1;
	}

	return A;
};


/***/ }),

/***/ "./node_modules/array.prototype.map/index.js":
/*!***************************************************!*\
  !*** ./node_modules/array.prototype.map/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");
var RequireObjectCoercible = __webpack_require__(/*! es-abstract/2021/RequireObjectCoercible */ "./node_modules/es-abstract/2021/RequireObjectCoercible.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");

var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/array.prototype.map/implementation.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/array.prototype.map/polyfill.js");
var polyfill = getPolyfill();
var shim = __webpack_require__(/*! ./shim */ "./node_modules/array.prototype.map/shim.js");

var $slice = callBound('Array.prototype.slice');

// eslint-disable-next-line no-unused-vars
var boundMapShim = function map(array, callbackfn) {
	RequireObjectCoercible(array);
	return polyfill.apply(array, $slice(arguments, 1));
};
define(boundMapShim, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = boundMapShim;


/***/ }),

/***/ "./node_modules/array.prototype.map/polyfill.js":
/*!******************************************************!*\
  !*** ./node_modules/array.prototype.map/polyfill.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var arrayMethodBoxesProperly = __webpack_require__(/*! es-array-method-boxes-properly */ "./node_modules/es-array-method-boxes-properly/index.js");

var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/array.prototype.map/implementation.js");

module.exports = function getPolyfill() {
	var method = Array.prototype.map;
	return arrayMethodBoxesProperly(method) ? method : implementation;
};


/***/ }),

/***/ "./node_modules/array.prototype.map/shim.js":
/*!**************************************************!*\
  !*** ./node_modules/array.prototype.map/shim.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/array.prototype.map/polyfill.js");

module.exports = function shimArrayPrototypeMap() {
	var polyfill = getPolyfill();
	define(
		Array.prototype,
		{ map: polyfill },
		{ map: function () { return Array.prototype.map !== polyfill; } }
	);
	return polyfill;
};


/***/ }),

/***/ "./node_modules/call-bind/callBound.js":
/*!*********************************************!*\
  !*** ./node_modules/call-bind/callBound.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var callBind = __webpack_require__(/*! ./ */ "./node_modules/call-bind/index.js");

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),

/***/ "./node_modules/call-bind/index.js":
/*!*****************************************!*\
  !*** ./node_modules/call-bind/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	var func = $reflectApply(bind, $call, arguments);
	if ($gOPD && $defineProperty) {
		var desc = $gOPD(func, 'length');
		if (desc.configurable) {
			// original length, plus the receiver, minus any additional arguments (after the receiver)
			$defineProperty(
				func,
				'length',
				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
			);
		}
	}
	return func;
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


/***/ }),

/***/ "./node_modules/classlist-polyfill/src/index.js":
/*!******************************************************!*\
  !*** ./node_modules/classlist-polyfill/src/index.js ***!
  \******************************************************/
/***/ (() => {

/*
 * classList.js: Cross-browser full element.classList implementation.
 * 1.1.20170427
 *
 * By Eli Grey, http://eligrey.com
 * License: Dedicated to the public domain.
 *   See https://github.com/eligrey/classList.js/blob/master/LICENSE.md
 */

/*global self, document, DOMException */

/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */

if ("document" in window.self) {

// Full polyfill for browsers with no classList support
// Including IE < Edge missing SVGElement.classList
if (!("classList" in document.createElement("_")) 
	|| document.createElementNS && !("classList" in document.createElementNS("http://www.w3.org/2000/svg","g"))) {

(function (view) {

"use strict";

if (!('Element' in view)) return;

var
	  classListProp = "classList"
	, protoProp = "prototype"
	, elemCtrProto = view.Element[protoProp]
	, objCtr = Object
	, strTrim = String[protoProp].trim || function () {
		return this.replace(/^\s+|\s+$/g, "");
	}
	, arrIndexOf = Array[protoProp].indexOf || function (item) {
		var
			  i = 0
			, len = this.length
		;
		for (; i < len; i++) {
			if (i in this && this[i] === item) {
				return i;
			}
		}
		return -1;
	}
	// Vendors: please allow content code to instantiate DOMExceptions
	, DOMEx = function (type, message) {
		this.name = type;
		this.code = DOMException[type];
		this.message = message;
	}
	, checkTokenAndGetIndex = function (classList, token) {
		if (token === "") {
			throw new DOMEx(
				  "SYNTAX_ERR"
				, "An invalid or illegal string was specified"
			);
		}
		if (/\s/.test(token)) {
			throw new DOMEx(
				  "INVALID_CHARACTER_ERR"
				, "String contains an invalid character"
			);
		}
		return arrIndexOf.call(classList, token);
	}
	, ClassList = function (elem) {
		var
			  trimmedClasses = strTrim.call(elem.getAttribute("class") || "")
			, classes = trimmedClasses ? trimmedClasses.split(/\s+/) : []
			, i = 0
			, len = classes.length
		;
		for (; i < len; i++) {
			this.push(classes[i]);
		}
		this._updateClassName = function () {
			elem.setAttribute("class", this.toString());
		};
	}
	, classListProto = ClassList[protoProp] = []
	, classListGetter = function () {
		return new ClassList(this);
	}
;
// Most DOMException implementations don't allow calling DOMException's toString()
// on non-DOMExceptions. Error's toString() is sufficient here.
DOMEx[protoProp] = Error[protoProp];
classListProto.item = function (i) {
	return this[i] || null;
};
classListProto.contains = function (token) {
	token += "";
	return checkTokenAndGetIndex(this, token) !== -1;
};
classListProto.add = function () {
	var
		  tokens = arguments
		, i = 0
		, l = tokens.length
		, token
		, updated = false
	;
	do {
		token = tokens[i] + "";
		if (checkTokenAndGetIndex(this, token) === -1) {
			this.push(token);
			updated = true;
		}
	}
	while (++i < l);

	if (updated) {
		this._updateClassName();
	}
};
classListProto.remove = function () {
	var
		  tokens = arguments
		, i = 0
		, l = tokens.length
		, token
		, updated = false
		, index
	;
	do {
		token = tokens[i] + "";
		index = checkTokenAndGetIndex(this, token);
		while (index !== -1) {
			this.splice(index, 1);
			updated = true;
			index = checkTokenAndGetIndex(this, token);
		}
	}
	while (++i < l);

	if (updated) {
		this._updateClassName();
	}
};
classListProto.toggle = function (token, force) {
	token += "";

	var
		  result = this.contains(token)
		, method = result ?
			force !== true && "remove"
		:
			force !== false && "add"
	;

	if (method) {
		this[method](token);
	}

	if (force === true || force === false) {
		return force;
	} else {
		return !result;
	}
};
classListProto.toString = function () {
	return this.join(" ");
};

if (objCtr.defineProperty) {
	var classListPropDesc = {
		  get: classListGetter
		, enumerable: true
		, configurable: true
	};
	try {
		objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
	} catch (ex) { // IE 8 doesn't support enumerable:true
		// adding undefined to fight this issue https://github.com/eligrey/classList.js/issues/36
		// modernie IE8-MSW7 machine has IE8 8.0.6001.18702 and is affected
		if (ex.number === undefined || ex.number === -0x7FF5EC54) {
			classListPropDesc.enumerable = false;
			objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
		}
	}
} else if (objCtr[protoProp].__defineGetter__) {
	elemCtrProto.__defineGetter__(classListProp, classListGetter);
}

}(window.self));

}

// There is full or partial native classList support, so just check if we need
// to normalize the add/remove and toggle APIs.

(function () {
	"use strict";

	var testElement = document.createElement("_");

	testElement.classList.add("c1", "c2");

	// Polyfill for IE 10/11 and Firefox <26, where classList.add and
	// classList.remove exist but support only one argument at a time.
	if (!testElement.classList.contains("c2")) {
		var createMethod = function(method) {
			var original = DOMTokenList.prototype[method];

			DOMTokenList.prototype[method] = function(token) {
				var i, len = arguments.length;

				for (i = 0; i < len; i++) {
					token = arguments[i];
					original.call(this, token);
				}
			};
		};
		createMethod('add');
		createMethod('remove');
	}

	testElement.classList.toggle("c3", false);

	// Polyfill for IE 10 and Firefox <24, where classList.toggle does not
	// support the second argument.
	if (testElement.classList.contains("c3")) {
		var _toggle = DOMTokenList.prototype.toggle;

		DOMTokenList.prototype.toggle = function(token, force) {
			if (1 in arguments && !this.contains(token) === !force) {
				return force;
			} else {
				return _toggle.call(this, token);
			}
		};

	}

	testElement = null;
}());

}


/***/ }),

/***/ "./node_modules/console-polyfill/index.js":
/*!************************************************!*\
  !*** ./node_modules/console-polyfill/index.js ***!
  \************************************************/
/***/ (function() {

// Console-polyfill. MIT license.
// https://github.com/paulmillr/console-polyfill
// Make it safe to do console.log() always.
(function(global) {
  'use strict';
  if (!global.console) {
    global.console = {};
  }
  var con = global.console;
  var prop, method;
  var dummy = function() {};
  var properties = ['memory'];
  var methods = ('assert,clear,count,debug,dir,dirxml,error,exception,group,' +
     'groupCollapsed,groupEnd,info,log,markTimeline,profile,profiles,profileEnd,' +
     'show,table,time,timeEnd,timeline,timelineEnd,timeStamp,trace,warn').split(',');
  while (prop = properties.pop()) if (!con[prop]) con[prop] = {};
  while (method = methods.pop()) if (!con[method]) con[method] = dummy;
  // Using `this` for web workers & supports Browserify / Webpack.
})(typeof window === 'undefined' ? this : window);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./cloudyman/client/src/styles.css":
/*!*******************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./cloudyman/client/src/styles.css ***!
  \*******************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "html,\nbody {\n  overflow-x: hidden;\n  overflow-y: hidden;\n}\n\nhtml,\nbody,\ncanvas,\nimg,\nh1,\n#title,\n#up,\n#right,\n#down,\n#left, {\n  user-select: none;\n}\n\nbody {\n  position: relative;\n  display: flex;\n  width: 100vw;\n  height: 100vh;\n  margin: 0;\n  overflow: hidden;\n  font-family: Verdana, Geneva, Tahoma, sans-serif;\n  flex-direction: column;\n  background-color: #000;\n  align-items: center;\n  justify-content: center;\n}\n\nbutton {\n  padding: 0;\n  font-weight: 900;\n  background: none;\n  border: none;\n}\n\n#fadeOut {\n  position: absolute;\n  top: 0;\n  z-index: 2;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  user-select: none;\n  background-color: #000;\n  opacity: 100%;\n  animation: fadeOut 1s linear 0s forwards;\n  touch-action: none;\n}\n\n#app {\n  display: flex;\n  width: 100%;\n  height: 100%;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: center;\n}\n\n#gameWrapper {\n  position: relative;\n  display: flex;\n  max-width: 100%;\n  max-height: 100%;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  animation: fadeIn 1s linear 0s forwards;\n}\n\n#blackScreen,\n#game {\n  position: absolute;\n  top: 2%;\n  width: auto;\n  height: 49%;\n  background-color: black;\n  border-radius: 5%;\n}\n\n#blackScreen {\n  display: flex;\n  min-width: 68%;\n  flex-direction: column;\n  user-select: none;\n  justify-content: center;\n  align-items: center;\n  touch-action: none;\n}\n\n#title {\n  position: absolute;\n  top: 44%;\n  z-index: 3;\n  margin: 0;\n  font-size: 100%;\n  color: white;\n  user-select: none;\n  opacity: 0%;\n  transform: scale(1);\n  animation: fadeIn 0.3s linear 1.5s forwards;\n  touch-action: none;\n}\n\n#background {\n  z-index: 1;\n  max-width: 100%;\n  max-height: 100%;\n  pointer-events: none;\n  user-select: none;\n  touch-action: none;\n}\n\n#controls {\n  pointer-events: none;\n}\n\n#up,\n#right,\n#down,\n#left {\n  position: absolute;\n  z-index: 5;\n  width: 15%;\n  height: 10%;\n}\n\n#right,\n#left {\n  transform: rotate(90deg);\n}\n\n#up {\n  top: 53.6%;\n  left: 16.3%;\n}\n\n#right {\n  top: 61.8%;\n  left: 31%;\n}\n\n#down {\n  top: 70%;\n  left: 16.3%;\n}\n\n#left {\n  top: 61.8%;\n  left: 1.5%;\n}\n\n#zoom {\n  position: fixed;\n  right: -10px;\n  bottom: -10px;\n  z-index: 6;\n  width: 100px;\n  height: 50px;\n  padding: 10px 20px 20px 10px;\n  font-size: 15px;\n  color: black;\n  white-space: nowrap;\n  visibility: hidden;\n  background-color: rgba(255, 255, 255, 0.5);\n  border-radius: 10px;\n}\n\n@media (min-width: 400px), (min-height: 960px) {\n  #title {\n    font-size: 200%;\n  }\n\n  #zoom {\n    visibility: visible;\n  }\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0%;\n  }\n\n  to {\n    opacity: 100%;\n  }\n}\n\n@keyframes fadeOut {\n  from {\n    opacity: 100%;\n  }\n\n  to {\n    opacity: 0%;\n  }\n}\n", "",{"version":3,"sources":["webpack://./cloudyman/client/src/styles.css"],"names":[],"mappings":"AAAA;;EAEE,kBAAkB;EAClB,kBAAkB;AACpB;;AAEA;;;;;;;;;;EAUE,iBAAiB;AACnB;;AAEA;EACE,kBAAkB;EAClB,aAAa;EACb,YAAY;EACZ,aAAa;EACb,SAAS;EACT,gBAAgB;EAChB,gDAAgD;EAChD,sBAAsB;EACtB,sBAAsB;EACtB,mBAAmB;EACnB,uBAAuB;AACzB;;AAEA;EACE,UAAU;EACV,gBAAgB;EAChB,gBAAgB;EAChB,YAAY;AACd;;AAEA;EACE,kBAAkB;EAClB,MAAM;EACN,UAAU;EACV,WAAW;EACX,YAAY;EACZ,oBAAoB;EACpB,iBAAiB;EACjB,sBAAsB;EACtB,aAAa;EACb,wCAAwC;EACxC,kBAAkB;AACpB;;AAEA;EACE,aAAa;EACb,WAAW;EACX,YAAY;EACZ,sBAAsB;EACtB,2BAA2B;EAC3B,mBAAmB;AACrB;;AAEA;EACE,kBAAkB;EAClB,aAAa;EACb,eAAe;EACf,gBAAgB;EAChB,sBAAsB;EACtB,uBAAuB;EACvB,mBAAmB;EACnB,uCAAuC;AACzC;;AAEA;;EAEE,kBAAkB;EAClB,OAAO;EACP,WAAW;EACX,WAAW;EACX,uBAAuB;EACvB,iBAAiB;AACnB;;AAEA;EACE,aAAa;EACb,cAAc;EACd,sBAAsB;EACtB,iBAAiB;EACjB,uBAAuB;EACvB,mBAAmB;EACnB,kBAAkB;AACpB;;AAEA;EACE,kBAAkB;EAClB,QAAQ;EACR,UAAU;EACV,SAAS;EACT,eAAe;EACf,YAAY;EACZ,iBAAiB;EACjB,WAAW;EACX,mBAAmB;EACnB,2CAA2C;EAC3C,kBAAkB;AACpB;;AAEA;EACE,UAAU;EACV,eAAe;EACf,gBAAgB;EAChB,oBAAoB;EACpB,iBAAiB;EACjB,kBAAkB;AACpB;;AAEA;EACE,oBAAoB;AACtB;;AAEA;;;;EAIE,kBAAkB;EAClB,UAAU;EACV,UAAU;EACV,WAAW;AACb;;AAEA;;EAEE,wBAAwB;AAC1B;;AAEA;EACE,UAAU;EACV,WAAW;AACb;;AAEA;EACE,UAAU;EACV,SAAS;AACX;;AAEA;EACE,QAAQ;EACR,WAAW;AACb;;AAEA;EACE,UAAU;EACV,UAAU;AACZ;;AAEA;EACE,eAAe;EACf,YAAY;EACZ,aAAa;EACb,UAAU;EACV,YAAY;EACZ,YAAY;EACZ,4BAA4B;EAC5B,eAAe;EACf,YAAY;EACZ,mBAAmB;EACnB,kBAAkB;EAClB,0CAA0C;EAC1C,mBAAmB;AACrB;;AAEA;EACE;IACE,eAAe;EACjB;;EAEA;IACE,mBAAmB;EACrB;AACF;;AAEA;EACE;IACE,WAAW;EACb;;EAEA;IACE,aAAa;EACf;AACF;;AAEA;EACE;IACE,aAAa;EACf;;EAEA;IACE,WAAW;EACb;AACF","sourcesContent":["html,\nbody {\n  overflow-x: hidden;\n  overflow-y: hidden;\n}\n\nhtml,\nbody,\ncanvas,\nimg,\nh1,\n#title,\n#up,\n#right,\n#down,\n#left, {\n  user-select: none;\n}\n\nbody {\n  position: relative;\n  display: flex;\n  width: 100vw;\n  height: 100vh;\n  margin: 0;\n  overflow: hidden;\n  font-family: Verdana, Geneva, Tahoma, sans-serif;\n  flex-direction: column;\n  background-color: #000;\n  align-items: center;\n  justify-content: center;\n}\n\nbutton {\n  padding: 0;\n  font-weight: 900;\n  background: none;\n  border: none;\n}\n\n#fadeOut {\n  position: absolute;\n  top: 0;\n  z-index: 2;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  user-select: none;\n  background-color: #000;\n  opacity: 100%;\n  animation: fadeOut 1s linear 0s forwards;\n  touch-action: none;\n}\n\n#app {\n  display: flex;\n  width: 100%;\n  height: 100%;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: center;\n}\n\n#gameWrapper {\n  position: relative;\n  display: flex;\n  max-width: 100%;\n  max-height: 100%;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  animation: fadeIn 1s linear 0s forwards;\n}\n\n#blackScreen,\n#game {\n  position: absolute;\n  top: 2%;\n  width: auto;\n  height: 49%;\n  background-color: black;\n  border-radius: 5%;\n}\n\n#blackScreen {\n  display: flex;\n  min-width: 68%;\n  flex-direction: column;\n  user-select: none;\n  justify-content: center;\n  align-items: center;\n  touch-action: none;\n}\n\n#title {\n  position: absolute;\n  top: 44%;\n  z-index: 3;\n  margin: 0;\n  font-size: 100%;\n  color: white;\n  user-select: none;\n  opacity: 0%;\n  transform: scale(1);\n  animation: fadeIn 0.3s linear 1.5s forwards;\n  touch-action: none;\n}\n\n#background {\n  z-index: 1;\n  max-width: 100%;\n  max-height: 100%;\n  pointer-events: none;\n  user-select: none;\n  touch-action: none;\n}\n\n#controls {\n  pointer-events: none;\n}\n\n#up,\n#right,\n#down,\n#left {\n  position: absolute;\n  z-index: 5;\n  width: 15%;\n  height: 10%;\n}\n\n#right,\n#left {\n  transform: rotate(90deg);\n}\n\n#up {\n  top: 53.6%;\n  left: 16.3%;\n}\n\n#right {\n  top: 61.8%;\n  left: 31%;\n}\n\n#down {\n  top: 70%;\n  left: 16.3%;\n}\n\n#left {\n  top: 61.8%;\n  left: 1.5%;\n}\n\n#zoom {\n  position: fixed;\n  right: -10px;\n  bottom: -10px;\n  z-index: 6;\n  width: 100px;\n  height: 50px;\n  padding: 10px 20px 20px 10px;\n  font-size: 15px;\n  color: black;\n  white-space: nowrap;\n  visibility: hidden;\n  background-color: rgba(255, 255, 255, 0.5);\n  border-radius: 10px;\n}\n\n@media (min-width: 400px), (min-height: 960px) {\n  #title {\n    font-size: 200%;\n  }\n\n  #zoom {\n    visibility: visible;\n  }\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0%;\n  }\n\n  to {\n    opacity: 100%;\n  }\n}\n\n@keyframes fadeOut {\n  from {\n    opacity: 100%;\n  }\n\n  to {\n    opacity: 0%;\n  }\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/the-new-css-reset/css/reset.css":
/*!********************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/the-new-css-reset/css/reset.css ***!
  \********************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/*** The new CSS Reset - version 1.4.1 (last updated 23.11.2021) ***/\n\n/*\n    Remove all the styles of the \"User-Agent-Stylesheet\", except for the 'display' property\n    - The \"symbol *\" part is to solve Firefox SVG sprite bug\n */\n*:where(:not(iframe, canvas, img, svg, video):not(svg *, symbol *)) {\n    all: unset;\n    display: revert;\n}\n\n/* Preferred box-sizing value */\n*,\n*::before,\n*::after {\n    box-sizing: border-box;\n}\n\n/* Remove list styles (bullets/numbers) */\nol, ul {\n    list-style: none;\n}\n\n/* For images to not be able to exceed their container */\nimg {\n    max-width: 100%;\n}\n\n/* removes spacing between cells in tables */\ntable {\n    border-collapse: collapse;\n}\n\n/* revert the 'white-space' property for textarea elements on Safari */\ntextarea {\n    white-space: revert;\n}\n\n/* revert for bug in Chromium browsers\n   - fix for the content editable attribute will work properly. */\n:where([contenteditable]){\n    -moz-user-modify: read-write;\n    -webkit-user-modify: read-write;\n    overflow-wrap: break-word;\n    -webkit-line-break: after-white-space;\n}", "",{"version":3,"sources":["webpack://./node_modules/the-new-css-reset/css/reset.css"],"names":[],"mappings":"AAAA,oEAAoE;;AAEpE;;;EAGE;AACF;IACI,UAAU;IACV,eAAe;AACnB;;AAEA,+BAA+B;AAC/B;;;IAGI,sBAAsB;AAC1B;;AAEA,yCAAyC;AACzC;IACI,gBAAgB;AACpB;;AAEA,wDAAwD;AACxD;IACI,eAAe;AACnB;;AAEA,4CAA4C;AAC5C;IACI,yBAAyB;AAC7B;;AAEA,sEAAsE;AACtE;IACI,mBAAmB;AACvB;;AAEA;iEACiE;AACjE;IACI,4BAA4B;IAC5B,+BAA+B;IAC/B,yBAAyB;IACzB,qCAAqC;AACzC","sourcesContent":["/*** The new CSS Reset - version 1.4.1 (last updated 23.11.2021) ***/\n\n/*\n    Remove all the styles of the \"User-Agent-Stylesheet\", except for the 'display' property\n    - The \"symbol *\" part is to solve Firefox SVG sprite bug\n */\n*:where(:not(iframe, canvas, img, svg, video):not(svg *, symbol *)) {\n    all: unset;\n    display: revert;\n}\n\n/* Preferred box-sizing value */\n*,\n*::before,\n*::after {\n    box-sizing: border-box;\n}\n\n/* Remove list styles (bullets/numbers) */\nol, ul {\n    list-style: none;\n}\n\n/* For images to not be able to exceed their container */\nimg {\n    max-width: 100%;\n}\n\n/* removes spacing between cells in tables */\ntable {\n    border-collapse: collapse;\n}\n\n/* revert the 'white-space' property for textarea elements on Safari */\ntextarea {\n    white-space: revert;\n}\n\n/* revert for bug in Chromium browsers\n   - fix for the content editable attribute will work properly. */\n:where([contenteditable]){\n    -moz-user-modify: read-write;\n    -webkit-user-modify: read-write;\n    overflow-wrap: break-word;\n    -webkit-line-break: after-white-space;\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/define-properties/index.js":
/*!*************************************************!*\
  !*** ./node_modules/define-properties/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var keys = __webpack_require__(/*! object-keys */ "./node_modules/object-keys/index.js");
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
	var obj = {};
	try {
		origDefineProperty(obj, 'x', { enumerable: false, value: obj });
		// eslint-disable-next-line no-unused-vars, no-restricted-syntax
		for (var _ in obj) { // jscs:ignore disallowUnusedVariables
			return false;
		}
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		origDefineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;


/***/ }),

/***/ "./node_modules/document.contains/auto.js":
/*!************************************************!*\
  !*** ./node_modules/document.contains/auto.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! ./shim */ "./node_modules/document.contains/shim.js")();


/***/ }),

/***/ "./node_modules/document.contains/implementation.js":
/*!**********************************************************!*\
  !*** ./node_modules/document.contains/implementation.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";


module.exports = function contains(other) {
	if (arguments.length < 1) {
		throw new TypeError('1 argument is required');
	}
	if (typeof other !== 'object') {
		throw new TypeError('Argument 1 (”other“) to Node.contains must be an instance of Node');
	}

	var node = other;
	do {
		if (this === node) {
			return true;
		}
		if (node) {
			node = node.parentNode;
		}
	} while (node);

	return false;
};


/***/ }),

/***/ "./node_modules/document.contains/polyfill.js":
/*!****************************************************!*\
  !*** ./node_modules/document.contains/polyfill.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/document.contains/implementation.js");

module.exports = function getPolyfill() {
	if (typeof document !== 'undefined') {
		if (document.contains) {
			return document.contains;
		}
		if (document.body && document.body.contains) {
			try {
				if (typeof document.body.contains.call(document, '') === 'boolean') {
					return document.body.contains;
				}
			} catch (e) { /**/ }
		}
	}
	return implementation;
};


/***/ }),

/***/ "./node_modules/document.contains/shim.js":
/*!************************************************!*\
  !*** ./node_modules/document.contains/shim.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/document.contains/polyfill.js");

module.exports = function shimContains() {
	var polyfill = getPolyfill();
	if (typeof document !== 'undefined') {
		define(
			document,
			{ contains: polyfill },
			{ contains: function () { return document.contains !== polyfill; } }
		);
		if (typeof Element !== 'undefined') {
			define(
				Element.prototype,
				{ contains: polyfill },
				{ contains: function () { return Element.prototype.contains !== polyfill; } }
			);
		}
	}
	return polyfill;
};


/***/ }),

/***/ "./node_modules/element-closest/element-closest.js":
/*!*********************************************************!*\
  !*** ./node_modules/element-closest/element-closest.js ***!
  \*********************************************************/
/***/ (() => {

// element-closest | CC0-1.0 | github.com/jonathantneal/closest

(function (ElementProto) {
	if (typeof ElementProto.matches !== 'function') {
		ElementProto.matches = ElementProto.msMatchesSelector || ElementProto.mozMatchesSelector || ElementProto.webkitMatchesSelector || function matches(selector) {
			var element = this;
			var elements = (element.document || element.ownerDocument).querySelectorAll(selector);
			var index = 0;

			while (elements[index] && elements[index] !== element) {
				++index;
			}

			return Boolean(elements[index]);
		};
	}

	if (typeof ElementProto.closest !== 'function') {
		ElementProto.closest = function closest(selector) {
			var element = this;

			while (element && element.nodeType === 1) {
				if (element.matches(selector)) {
					return element;
				}

				element = element.parentNode;
			}

			return null;
		};
	}
})(window.Element.prototype);


/***/ }),

/***/ "./node_modules/es-array-method-boxes-properly/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/es-array-method-boxes-properly/index.js ***!
  \**************************************************************/
/***/ ((module) => {

module.exports = function properlyBoxed(method) {
	// Check node 0.6.21 bug where third parameter is not boxed
	var properlyBoxesNonStrict = true;
	var properlyBoxesStrict = true;
	var threwException = false;
	if (typeof method === 'function') {
		try {
			// eslint-disable-next-line max-params
			method.call('f', function (_, __, O) {
				if (typeof O !== 'object') {
					properlyBoxesNonStrict = false;
				}
			});

			method.call(
				[null],
				function () {
					'use strict';

					properlyBoxesStrict = typeof this === 'string'; // eslint-disable-line no-invalid-this
				},
				'x'
			);
		} catch (e) {
			threwException = true;
		}
		return !threwException && properlyBoxesNonStrict && properlyBoxesStrict;
	}
	return false;
};


/***/ }),

/***/ "./node_modules/es-get-iterator/node_modules/isarray/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/es-get-iterator/node_modules/isarray/index.js ***!
  \********************************************************************/
/***/ ((module) => {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/es-to-primitive/es2015.js":
/*!************************************************!*\
  !*** ./node_modules/es-to-primitive/es2015.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';

var isPrimitive = __webpack_require__(/*! ./helpers/isPrimitive */ "./node_modules/es-to-primitive/helpers/isPrimitive.js");
var isCallable = __webpack_require__(/*! is-callable */ "./node_modules/is-callable/index.js");
var isDate = __webpack_require__(/*! is-date-object */ "./node_modules/is-date-object/index.js");
var isSymbol = __webpack_require__(/*! is-symbol */ "./node_modules/is-symbol/index.js");

var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
	if (typeof O === 'undefined' || O === null) {
		throw new TypeError('Cannot call method on ' + O);
	}
	if (typeof hint !== 'string' || (hint !== 'number' && hint !== 'string')) {
		throw new TypeError('hint must be "string" or "number"');
	}
	var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
	var method, result, i;
	for (i = 0; i < methodNames.length; ++i) {
		method = O[methodNames[i]];
		if (isCallable(method)) {
			result = method.call(O);
			if (isPrimitive(result)) {
				return result;
			}
		}
	}
	throw new TypeError('No default value');
};

var GetMethod = function GetMethod(O, P) {
	var func = O[P];
	if (func !== null && typeof func !== 'undefined') {
		if (!isCallable(func)) {
			throw new TypeError(func + ' returned for property ' + P + ' of object ' + O + ' is not a function');
		}
		return func;
	}
	return void 0;
};

// http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive
module.exports = function ToPrimitive(input) {
	if (isPrimitive(input)) {
		return input;
	}
	var hint = 'default';
	if (arguments.length > 1) {
		if (arguments[1] === String) {
			hint = 'string';
		} else if (arguments[1] === Number) {
			hint = 'number';
		}
	}

	var exoticToPrim;
	if (hasSymbols) {
		if (Symbol.toPrimitive) {
			exoticToPrim = GetMethod(input, Symbol.toPrimitive);
		} else if (isSymbol(input)) {
			exoticToPrim = Symbol.prototype.valueOf;
		}
	}
	if (typeof exoticToPrim !== 'undefined') {
		var result = exoticToPrim.call(input, hint);
		if (isPrimitive(result)) {
			return result;
		}
		throw new TypeError('unable to convert exotic object to primitive');
	}
	if (hint === 'default' && (isDate(input) || isSymbol(input))) {
		hint = 'string';
	}
	return ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);
};


/***/ }),

/***/ "./node_modules/es-to-primitive/es5.js":
/*!*********************************************!*\
  !*** ./node_modules/es-to-primitive/es5.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var toStr = Object.prototype.toString;

var isPrimitive = __webpack_require__(/*! ./helpers/isPrimitive */ "./node_modules/es-to-primitive/helpers/isPrimitive.js");

var isCallable = __webpack_require__(/*! is-callable */ "./node_modules/is-callable/index.js");

// http://ecma-international.org/ecma-262/5.1/#sec-8.12.8
var ES5internalSlots = {
	'[[DefaultValue]]': function (O) {
		var actualHint;
		if (arguments.length > 1) {
			actualHint = arguments[1];
		} else {
			actualHint = toStr.call(O) === '[object Date]' ? String : Number;
		}

		if (actualHint === String || actualHint === Number) {
			var methods = actualHint === String ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
			var value, i;
			for (i = 0; i < methods.length; ++i) {
				if (isCallable(O[methods[i]])) {
					value = O[methods[i]]();
					if (isPrimitive(value)) {
						return value;
					}
				}
			}
			throw new TypeError('No default value');
		}
		throw new TypeError('invalid [[DefaultValue]] hint supplied');
	}
};

// http://ecma-international.org/ecma-262/5.1/#sec-9.1
module.exports = function ToPrimitive(input) {
	if (isPrimitive(input)) {
		return input;
	}
	if (arguments.length > 1) {
		return ES5internalSlots['[[DefaultValue]]'](input, arguments[1]);
	}
	return ES5internalSlots['[[DefaultValue]]'](input);
};


/***/ }),

/***/ "./node_modules/es-to-primitive/helpers/isPrimitive.js":
/*!*************************************************************!*\
  !*** ./node_modules/es-to-primitive/helpers/isPrimitive.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function isPrimitive(value) {
	return value === null || (typeof value !== 'function' && typeof value !== 'object');
};


/***/ }),

/***/ "./node_modules/es5-shim/es5-sham.js":
/*!*******************************************!*\
  !*** ./node_modules/es5-shim/es5-sham.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * https://github.com/es-shims/es5-shim
 * @license es5-shim Copyright 2009-2020 by contributors, MIT License
 * see https://github.com/es-shims/es5-shim/blob/master/LICENSE
 */

// vim: ts=4 sts=4 sw=4 expandtab

// Add semicolon to prevent IIFE from being passed as argument to concatenated code.
; // eslint-disable-line no-extra-semi

// UMD (Universal Module Definition)
// see https://github.com/umdjs/umd/blob/master/templates/returnExports.js
(function (root, factory) {
    'use strict';

    /* global define */
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {

    var call = Function.call;
    var prototypeOfObject = Object.prototype;
    var owns = call.bind(prototypeOfObject.hasOwnProperty);
    var isEnumerable = call.bind(prototypeOfObject.propertyIsEnumerable);
    var toStr = call.bind(prototypeOfObject.toString);

    // If JS engine supports accessors creating shortcuts.
    var defineGetter;
    var defineSetter;
    var lookupGetter;
    var lookupSetter;
    var supportsAccessors = owns(prototypeOfObject, '__defineGetter__');
    if (supportsAccessors) {
        /* eslint-disable no-underscore-dangle, no-restricted-properties */
        defineGetter = call.bind(prototypeOfObject.__defineGetter__);
        defineSetter = call.bind(prototypeOfObject.__defineSetter__);
        lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
        lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
        /* eslint-enable no-underscore-dangle, no-restricted-properties */
    }

    var isPrimitive = function isPrimitive(o) {
        return o == null || (typeof o !== 'object' && typeof o !== 'function');
    };

    // ES5 15.2.3.2
    // http://es5.github.com/#x15.2.3.2
    if (!Object.getPrototypeOf) {
        // https://github.com/es-shims/es5-shim/issues#issue/2
        // http://ejohn.org/blog/objectgetprototypeof/
        // recommended by fschaefer on github
        //
        // sure, and webreflection says ^_^
        // ... this will nerever possibly return null
        // ... Opera Mini breaks here with infinite loops
        Object.getPrototypeOf = function getPrototypeOf(object) {
            // eslint-disable-next-line no-proto
            var proto = object.__proto__;
            if (proto || proto == null) { // `undefined` is for pre-proto browsers
                return proto;
            } else if (toStr(object.constructor) === '[object Function]') {
                return object.constructor.prototype;
            } else if (object instanceof Object) {
                return prototypeOfObject;
            }
            // Correctly return null for Objects created with `Object.create(null)`
            // (shammed or native) or `{ __proto__: null}`.  Also returns null for
            // cross-realm objects on browsers that lack `__proto__` support (like
            // IE <11), but that's the best we can do.
            return null;

        };
    }

    // ES5 15.2.3.3
    // http://es5.github.com/#x15.2.3.3

    // check whether getOwnPropertyDescriptor works if it's given. Otherwise, shim partially.
    if (Object.defineProperty) {
        var doesGetOwnPropertyDescriptorWork = function doesGetOwnPropertyDescriptorWork(object) {
            try {
                object.sentinel = 0; // eslint-disable-line no-param-reassign
                return Object.getOwnPropertyDescriptor(object, 'sentinel').value === 0;
            } catch (exception) {
                return false;
            }
        };
        var getOwnPropertyDescriptorWorksOnObject = doesGetOwnPropertyDescriptorWork({});
        var getOwnPropertyDescriptorWorksOnDom = typeof document === 'undefined'
            || doesGetOwnPropertyDescriptorWork(document.createElement('div'));
        if (!getOwnPropertyDescriptorWorksOnDom || !getOwnPropertyDescriptorWorksOnObject) {
            var getOwnPropertyDescriptorFallback = Object.getOwnPropertyDescriptor;
        }
    }

    if (!Object.getOwnPropertyDescriptor || getOwnPropertyDescriptorFallback) {
        var ERR_NON_OBJECT = 'Object.getOwnPropertyDescriptor called on a non-object: ';

        /* eslint-disable no-proto */
        Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
            if (isPrimitive(object)) {
                throw new TypeError(ERR_NON_OBJECT + object);
            }

            // make a valiant attempt to use the real getOwnPropertyDescriptor
            // for I8's DOM elements.
            if (getOwnPropertyDescriptorFallback) {
                try {
                    return getOwnPropertyDescriptorFallback.call(Object, object, property);
                } catch (exception) {
                    // try the shim if the real one doesn't work
                }
            }

            var descriptor;

            // If object does not owns property return undefined immediately.
            if (!owns(object, property)) {
                return descriptor;
            }

            // If object has a property then it's for sure `configurable`, and
            // probably `enumerable`. Detect enumerability though.
            descriptor = {
                enumerable: isEnumerable(object, property),
                configurable: true
            };

            // If JS engine supports accessor properties then property may be a
            // getter or setter.
            if (supportsAccessors) {
                // Unfortunately `__lookupGetter__` will return a getter even
                // if object has own non getter property along with a same named
                // inherited getter. To avoid misbehavior we temporary remove
                // `__proto__` so that `__lookupGetter__` will return getter only
                // if it's owned by an object.
                var prototype = object.__proto__;
                var notPrototypeOfObject = object !== prototypeOfObject;
                // avoid recursion problem, breaking in Opera Mini when
                // Object.getOwnPropertyDescriptor(Object.prototype, 'toString')
                // or any other Object.prototype accessor
                if (notPrototypeOfObject) {
                    object.__proto__ = prototypeOfObject; // eslint-disable-line no-param-reassign
                }

                var getter = lookupGetter(object, property);
                var setter = lookupSetter(object, property);

                if (notPrototypeOfObject) {
                    // Once we have getter and setter we can put values back.
                    object.__proto__ = prototype; // eslint-disable-line no-param-reassign
                }

                if (getter || setter) {
                    if (getter) {
                        descriptor.get = getter;
                    }
                    if (setter) {
                        descriptor.set = setter;
                    }
                    // If it was accessor property we're done and return here
                    // in order to avoid adding `value` to the descriptor.
                    return descriptor;
                }
            }

            // If we got this far we know that object has an own property that is
            // not an accessor so we set it as a value and return descriptor.
            descriptor.value = object[property];
            descriptor.writable = true;
            return descriptor;
        };
        /* eslint-enable no-proto */
    }

    // ES5 15.2.3.4
    // http://es5.github.com/#x15.2.3.4
    if (!Object.getOwnPropertyNames) {
        Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
            return Object.keys(object);
        };
    }

    // ES5 15.2.3.5
    // http://es5.github.com/#x15.2.3.5
    if (!Object.create) {

        // Contributed by Brandon Benvie, October, 2012
        var createEmpty;
        var supportsProto = !({ __proto__: null } instanceof Object);
        // the following produces false positives
        // in Opera Mini => not a reliable check
        // Object.prototype.__proto__ === null

        // Check for document.domain and active x support
        // No need to use active x approach when document.domain is not set
        // see https://github.com/es-shims/es5-shim/issues/150
        // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
        /* global ActiveXObject */
        var shouldUseActiveX = function shouldUseActiveX() {
            // return early if document.domain not set
            if (!document.domain) {
                return false;
            }

            try {
                return !!new ActiveXObject('htmlfile');
            } catch (exception) {
                return false;
            }
        };

        // This supports IE8 when document.domain is used
        // see https://github.com/es-shims/es5-shim/issues/150
        // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
        var getEmptyViaActiveX = function getEmptyViaActiveX() {
            var empty;
            var xDoc;

            xDoc = new ActiveXObject('htmlfile');

            var script = 'script';
            xDoc.write('<' + script + '></' + script + '>');
            xDoc.close();

            empty = xDoc.parentWindow.Object.prototype;
            xDoc = null;

            return empty;
        };

        // The original implementation using an iframe
        // before the activex approach was added
        // see https://github.com/es-shims/es5-shim/issues/150
        var getEmptyViaIFrame = function getEmptyViaIFrame() {
            var iframe = document.createElement('iframe');
            var parent = document.body || document.documentElement;
            var empty;

            iframe.style.display = 'none';
            parent.appendChild(iframe);
            // eslint-disable-next-line no-script-url
            iframe.src = 'javascript:';

            empty = iframe.contentWindow.Object.prototype;
            parent.removeChild(iframe);
            iframe = null;

            return empty;
        };

        /* global document */
        if (supportsProto || typeof document === 'undefined') {
            createEmpty = function () {
                return { __proto__: null };
            };
        } else {
            // In old IE __proto__ can't be used to manually set `null`, nor does
            // any other method exist to make an object that inherits from nothing,
            // aside from Object.prototype itself. Instead, create a new global
            // object and *steal* its Object.prototype and strip it bare. This is
            // used as the prototype to create nullary objects.
            createEmpty = function () {
                // Determine which approach to use
                // see https://github.com/es-shims/es5-shim/issues/150
                var empty = shouldUseActiveX() ? getEmptyViaActiveX() : getEmptyViaIFrame();

                delete empty.constructor;
                delete empty.hasOwnProperty;
                delete empty.propertyIsEnumerable;
                delete empty.isPrototypeOf;
                delete empty.toLocaleString;
                delete empty.toString;
                delete empty.valueOf;

                var Empty = function Empty() {};
                Empty.prototype = empty;
                // short-circuit future calls
                createEmpty = function () {
                    return new Empty();
                };
                return new Empty();
            };
        }

        Object.create = function create(prototype, properties) {

            var object;
            var Type = function Type() {}; // An empty constructor.

            if (prototype === null) {
                object = createEmpty();
            } else if (isPrimitive(prototype)) {
                // In the native implementation `parent` can be `null`
                // OR *any* `instanceof Object`  (Object|Function|Array|RegExp|etc)
                // Use `typeof` tho, b/c in old IE, DOM elements are not `instanceof Object`
                // like they are in modern browsers. Using `Object.create` on DOM elements
                // is...err...probably inappropriate, but the native version allows for it.
                throw new TypeError('Object prototype may only be an Object or null'); // same msg as Chrome
            } else {
                Type.prototype = prototype;
                object = new Type();
                // IE has no built-in implementation of `Object.getPrototypeOf`
                // neither `__proto__`, but this manually setting `__proto__` will
                // guarantee that `Object.getPrototypeOf` will work as expected with
                // objects created using `Object.create`
                // eslint-disable-next-line no-proto
                object.__proto__ = prototype;
            }

            if (properties !== void 0) {
                Object.defineProperties(object, properties);
            }

            return object;
        };
    }

    // ES5 15.2.3.6
    // http://es5.github.com/#x15.2.3.6

    // Patch for WebKit and IE8 standard mode
    // Designed by hax <hax.github.com>
    // related issue: https://github.com/es-shims/es5-shim/issues#issue/5
    // IE8 Reference:
    //     http://msdn.microsoft.com/en-us/library/dd282900.aspx
    //     http://msdn.microsoft.com/en-us/library/dd229916.aspx
    // WebKit Bugs:
    //     https://bugs.webkit.org/show_bug.cgi?id=36423

    var doesDefinePropertyWork = function doesDefinePropertyWork(object) {
        try {
            Object.defineProperty(object, 'sentinel', {});
            return 'sentinel' in object;
        } catch (exception) {
            return false;
        }
    };

    // check whether defineProperty works if it's given. Otherwise,
    // shim partially.
    if (Object.defineProperty) {
        var definePropertyWorksOnObject = doesDefinePropertyWork({});
        var definePropertyWorksOnDom = typeof document === 'undefined'
            || doesDefinePropertyWork(document.createElement('div'));
        if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
            var definePropertyFallback = Object.defineProperty,
                definePropertiesFallback = Object.defineProperties;
        }
    }

    if (!Object.defineProperty || definePropertyFallback) {
        var ERR_NON_OBJECT_DESCRIPTOR = 'Property description must be an object: ';
        var ERR_NON_OBJECT_TARGET = 'Object.defineProperty called on non-object: ';
        var ERR_ACCESSORS_NOT_SUPPORTED = 'getters & setters can not be defined on this javascript engine';

        Object.defineProperty = function defineProperty(object, property, descriptor) {
            if (isPrimitive(object)) {
                throw new TypeError(ERR_NON_OBJECT_TARGET + object);
            }
            if (isPrimitive(descriptor)) {
                throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
            }
            // make a valiant attempt to use the real defineProperty
            // for I8's DOM elements.
            if (definePropertyFallback) {
                try {
                    return definePropertyFallback.call(Object, object, property, descriptor);
                } catch (exception) {
                    // try the shim if the real one doesn't work
                }
            }

            // If it's a data property.
            if ('value' in descriptor) {
                // fail silently if 'writable', 'enumerable', or 'configurable'
                // are requested but not supported
                /*
                // alternate approach:
                if ( // can't implement these features; allow false but not true
                    ('writable' in descriptor && !descriptor.writable) ||
                    ('enumerable' in descriptor && !descriptor.enumerable) ||
                    ('configurable' in descriptor && !descriptor.configurable)
                ))
                    throw new RangeError(
                        'This implementation of Object.defineProperty does not support configurable, enumerable, or writable.'
                    );
                */

                if (supportsAccessors && (lookupGetter(object, property) || lookupSetter(object, property))) {
                    // As accessors are supported only on engines implementing
                    // `__proto__` we can safely override `__proto__` while defining
                    // a property to make sure that we don't hit an inherited
                    // accessor.
                    /* eslint-disable no-proto, no-param-reassign */
                    var prototype = object.__proto__;
                    object.__proto__ = prototypeOfObject;
                    // Deleting a property anyway since getter / setter may be
                    // defined on object itself.
                    delete object[property];
                    object[property] = descriptor.value;
                    // Setting original `__proto__` back now.
                    object.__proto__ = prototype;
                    /* eslint-enable no-proto, no-param-reassign */
                } else {
                    object[property] = descriptor.value; // eslint-disable-line no-param-reassign
                }
            } else {
                var hasGetter = 'get' in descriptor;
                var hasSetter = 'set' in descriptor;
                if (!supportsAccessors && (hasGetter || hasSetter)) {
                    throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
                }
                // If we got that far then getters and setters can be defined !!
                if (hasGetter) {
                    defineGetter(object, property, descriptor.get);
                }
                if (hasSetter) {
                    defineSetter(object, property, descriptor.set);
                }
            }
            return object;
        };
    }

    // ES5 15.2.3.7
    // http://es5.github.com/#x15.2.3.7
    if (!Object.defineProperties || definePropertiesFallback) {
        Object.defineProperties = function defineProperties(object, properties) {
            // make a valiant attempt to use the real defineProperties
            if (definePropertiesFallback) {
                try {
                    return definePropertiesFallback.call(Object, object, properties);
                } catch (exception) {
                    // try the shim if the real one doesn't work
                }
            }

            Object.keys(properties).forEach(function (property) {
                if (property !== '__proto__') {
                    Object.defineProperty(object, property, properties[property]);
                }
            });
            return object;
        };
    }

    // ES5 15.2.3.8
    // http://es5.github.com/#x15.2.3.8
    if (!Object.seal) {
        Object.seal = function seal(object) {
            if (Object(object) !== object) {
                throw new TypeError('Object.seal can only be called on Objects.');
            }
            // this is misleading and breaks feature-detection, but
            // allows "securable" code to "gracefully" degrade to working
            // but insecure code.
            return object;
        };
    }

    // ES5 15.2.3.9
    // http://es5.github.com/#x15.2.3.9
    if (!Object.freeze) {
        Object.freeze = function freeze(object) {
            if (Object(object) !== object) {
                throw new TypeError('Object.freeze can only be called on Objects.');
            }
            // this is misleading and breaks feature-detection, but
            // allows "securable" code to "gracefully" degrade to working
            // but insecure code.
            return object;
        };
    }

    // detect a Rhino bug and patch it
    try {
        Object.freeze(function () {});
    } catch (exception) {
        Object.freeze = (function (freezeObject) {
            return function freeze(object) {
                if (typeof object === 'function') {
                    return object;
                }
                return freezeObject(object);

            };
        }(Object.freeze));
    }

    // ES5 15.2.3.10
    // http://es5.github.com/#x15.2.3.10
    if (!Object.preventExtensions) {
        Object.preventExtensions = function preventExtensions(object) {
            if (Object(object) !== object) {
                throw new TypeError('Object.preventExtensions can only be called on Objects.');
            }
            // this is misleading and breaks feature-detection, but
            // allows "securable" code to "gracefully" degrade to working
            // but insecure code.
            return object;
        };
    }

    // ES5 15.2.3.11
    // http://es5.github.com/#x15.2.3.11
    if (!Object.isSealed) {
        Object.isSealed = function isSealed(object) {
            if (Object(object) !== object) {
                throw new TypeError('Object.isSealed can only be called on Objects.');
            }
            return false;
        };
    }

    // ES5 15.2.3.12
    // http://es5.github.com/#x15.2.3.12
    if (!Object.isFrozen) {
        Object.isFrozen = function isFrozen(object) {
            if (Object(object) !== object) {
                throw new TypeError('Object.isFrozen can only be called on Objects.');
            }
            return false;
        };
    }

    // ES5 15.2.3.13
    // http://es5.github.com/#x15.2.3.13
    if (!Object.isExtensible) {
        Object.isExtensible = function isExtensible(object) {
            // 1. If Type(O) is not Object throw a TypeError exception.
            if (Object(object) !== object) {
                throw new TypeError('Object.isExtensible can only be called on Objects.');
            }
            // 2. Return the Boolean value of the [[Extensible]] internal property of O.
            var name = '';
            while (owns(object, name)) {
                name += '?';
            }
            object[name] = true; // eslint-disable-line no-param-reassign
            var returnValue = owns(object, name);
            delete object[name]; // eslint-disable-line no-param-reassign
            return returnValue;
        };
    }

}));


/***/ }),

/***/ "./node_modules/es5-shim/es5-shim.js":
/*!*******************************************!*\
  !*** ./node_modules/es5-shim/es5-shim.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * https://github.com/es-shims/es5-shim
 * @license es5-shim Copyright 2009-2020 by contributors, MIT License
 * see https://github.com/es-shims/es5-shim/blob/master/LICENSE
 */

// vim: ts=4 sts=4 sw=4 expandtab

// Add semicolon to prevent IIFE from being passed as argument to concatenated code.
; // eslint-disable-line no-extra-semi

// UMD (Universal Module Definition)
// see https://github.com/umdjs/umd/blob/master/templates/returnExports.js
(function (root, factory) {
    'use strict';

    /* global define */
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    /**
     * Brings an environment as close to ECMAScript 5 compliance
     * as is possible with the facilities of erstwhile engines.
     *
     * Annotated ES5: http://es5.github.com/ (specific links below)
     * ES5 Spec: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
     * Required reading: http://javascriptweblog.wordpress.com/2011/12/05/extending-javascript-natives/
     */

    // Shortcut to an often accessed properties, in order to avoid multiple
    // dereference that costs universally. This also holds a reference to known-good
    // functions.
    var $Array = Array;
    var ArrayPrototype = $Array.prototype;
    var $Object = Object;
    var ObjectPrototype = $Object.prototype;
    var $Function = Function;
    var FunctionPrototype = $Function.prototype;
    var $String = String;
    var StringPrototype = $String.prototype;
    var $Number = Number;
    var NumberPrototype = $Number.prototype;
    var array_slice = ArrayPrototype.slice;
    var array_splice = ArrayPrototype.splice;
    var array_push = ArrayPrototype.push;
    var array_unshift = ArrayPrototype.unshift;
    var array_concat = ArrayPrototype.concat;
    var array_join = ArrayPrototype.join;
    var call = FunctionPrototype.call;
    var apply = FunctionPrototype.apply;
    var max = Math.max;
    var min = Math.min;
    var floor = Math.floor;
    var abs = Math.abs;
    var pow = Math.pow;
    var round = Math.round;
    var log = Math.log;
    var LOG10E = Math.LOG10E;
    var log10 = Math.log10 || function log10(value) {
        return log(value) * LOG10E;
    };

    // Having a toString local variable name breaks in Opera so use to_string.
    var to_string = ObjectPrototype.toString;

    /* eslint-disable one-var-declaration-per-line, no-redeclare, max-statements-per-line */
    var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
    var isCallable; /* inlined from https://npmjs.com/is-callable */ var fnToStr = Function.prototype.toString, constructorRegex = /^\s*class /, isES6ClassFn = function isES6ClassFn(value) { try { var fnStr = fnToStr.call(value); var singleStripped = fnStr.replace(/\/\/.*\n/g, ''); var multiStripped = singleStripped.replace(/\/\*[.\s\S]*\*\//g, ''); var spaceStripped = multiStripped.replace(/\n/mg, ' ').replace(/ {2}/g, ' '); return constructorRegex.test(spaceStripped); } catch (e) { return false; /* not a function */ } }, tryFunctionObject = function tryFunctionObject(value) { try { if (isES6ClassFn(value)) { return false; } fnToStr.call(value); return true; } catch (e) { return false; } }, fnClass = '[object Function]', genClass = '[object GeneratorFunction]', isCallable = function isCallable(value) { if (!value) { return false; } if (typeof value !== 'function' && typeof value !== 'object') { return false; } if (hasToStringTag) { return tryFunctionObject(value); } if (isES6ClassFn(value)) { return false; } var strClass = to_string.call(value); return strClass === fnClass || strClass === genClass; };

    var isRegex; /* inlined from https://npmjs.com/is-regex */ var regexExec = RegExp.prototype.exec, tryRegexExec = function tryRegexExec(value) { try { regexExec.call(value); return true; } catch (e) { return false; } }, regexClass = '[object RegExp]'; isRegex = function isRegex(value) { if (typeof value !== 'object') { return false; } return hasToStringTag ? tryRegexExec(value) : to_string.call(value) === regexClass; };
    var isString; /* inlined from https://npmjs.com/is-string */ var strValue = String.prototype.valueOf, tryStringObject = function tryStringObject(value) { try { strValue.call(value); return true; } catch (e) { return false; } }, stringClass = '[object String]'; isString = function isString(value) { if (typeof value === 'string') { return true; } if (typeof value !== 'object') { return false; } return hasToStringTag ? tryStringObject(value) : to_string.call(value) === stringClass; };
    /* eslint-enable one-var-declaration-per-line, no-redeclare, max-statements-per-line */

    /* inlined from http://npmjs.com/define-properties */
    var supportsDescriptors = $Object.defineProperty && (function () {
        try {
            var obj = {};
            $Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
            // eslint-disable-next-line no-unreachable-loop, max-statements-per-line
            for (var _ in obj) { return false; } // jscs:ignore disallowUnusedVariables
            return obj.x === obj;
        } catch (e) { /* this is ES3 */
            return false;
        }
    }());
    var defineProperties = (function (has) {
        // Define configurable, writable, and non-enumerable props
        // if they don't exist.
        var defineProperty;
        if (supportsDescriptors) {
            defineProperty = function (object, name, method, forceAssign) {
                if (!forceAssign && (name in object)) {
                    return;
                }
                $Object.defineProperty(object, name, {
                    configurable: true,
                    enumerable: false,
                    writable: true,
                    value: method
                });
            };
        } else {
            defineProperty = function (object, name, method, forceAssign) {
                if (!forceAssign && (name in object)) {
                    return;
                }
                object[name] = method; // eslint-disable-line no-param-reassign
            };
        }
        return function defineProperties(object, map, forceAssign) {
            for (var name in map) {
                if (has.call(map, name)) {
                    defineProperty(object, name, map[name], forceAssign);
                }
            }
        };
    }(ObjectPrototype.hasOwnProperty));

    //
    // Util
    // ======
    //

    /* replaceable with https://npmjs.com/package/es-abstract /helpers/isPrimitive */
    var isPrimitive = function isPrimitive(input) {
        var type = typeof input;
        return input === null || (type !== 'object' && type !== 'function');
    };

    var isActualNaN = $Number.isNaN || function isActualNaN(x) {
        return x !== x;
    };

    var ES = {
        // ES5 9.4
        // http://es5.github.com/#x9.4
        // http://jsperf.com/to-integer
        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToInteger */
        ToInteger: function ToInteger(num) {
            var n = +num;
            if (isActualNaN(n)) {
                n = 0;
            } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
                n = (n > 0 || -1) * floor(abs(n));
            }
            return n;
        },

        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToPrimitive */
        ToPrimitive: function ToPrimitive(input) {
            var val, valueOf, toStr;
            if (isPrimitive(input)) {
                return input;
            }
            valueOf = input.valueOf;
            if (isCallable(valueOf)) {
                val = valueOf.call(input);
                if (isPrimitive(val)) {
                    return val;
                }
            }
            toStr = input.toString;
            if (isCallable(toStr)) {
                val = toStr.call(input);
                if (isPrimitive(val)) {
                    return val;
                }
            }
            throw new TypeError();
        },

        // ES5 9.9
        // http://es5.github.com/#x9.9
        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToObject */
        ToObject: function (o) {
            if (o == null) { // this matches both null and undefined
                throw new TypeError("can't convert " + o + ' to object');
            }
            return $Object(o);
        },

        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToUint32 */
        ToUint32: function ToUint32(x) {
            return x >>> 0;
        }
    };

    //
    // Function
    // ========
    //

    // ES-5 15.3.4.5
    // http://es5.github.com/#x15.3.4.5

    var Empty = function Empty() {};

    defineProperties(FunctionPrototype, {
        bind: function bind(that) { // .length is 1
            // 1. Let Target be the this value.
            var target = this;
            // 2. If IsCallable(Target) is false, throw a TypeError exception.
            if (!isCallable(target)) {
                throw new TypeError('Function.prototype.bind called on incompatible ' + target);
            }
            // 3. Let A be a new (possibly empty) internal list of all of the
            //   argument values provided after thisArg (arg1, arg2 etc), in order.
            // XXX slicedArgs will stand in for "A" if used
            var args = array_slice.call(arguments, 1); // for normal call
            // 4. Let F be a new native ECMAScript object.
            // 11. Set the [[Prototype]] internal property of F to the standard
            //   built-in Function prototype object as specified in 15.3.3.1.
            // 12. Set the [[Call]] internal property of F as described in
            //   15.3.4.5.1.
            // 13. Set the [[Construct]] internal property of F as described in
            //   15.3.4.5.2.
            // 14. Set the [[HasInstance]] internal property of F as described in
            //   15.3.4.5.3.
            var bound;
            var binder = function () {

                if (this instanceof bound) {
                    // 15.3.4.5.2 [[Construct]]
                    // When the [[Construct]] internal method of a function object,
                    // F that was created using the bind function is called with a
                    // list of arguments ExtraArgs, the following steps are taken:
                    // 1. Let target be the value of F's [[TargetFunction]]
                    //   internal property.
                    // 2. If target has no [[Construct]] internal method, a
                    //   TypeError exception is thrown.
                    // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                    //   property.
                    // 4. Let args be a new list containing the same values as the
                    //   list boundArgs in the same order followed by the same
                    //   values as the list ExtraArgs in the same order.
                    // 5. Return the result of calling the [[Construct]] internal
                    //   method of target providing args as the arguments.

                    var result = apply.call(
                        target,
                        this,
                        array_concat.call(args, array_slice.call(arguments))
                    );
                    if ($Object(result) === result) {
                        return result;
                    }
                    return this;

                }
                // 15.3.4.5.1 [[Call]]
                // When the [[Call]] internal method of a function object, F,
                // which was created using the bind function is called with a
                // this value and a list of arguments ExtraArgs, the following
                // steps are taken:
                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 2. Let boundThis be the value of F's [[BoundThis]] internal
                //   property.
                // 3. Let target be the value of F's [[TargetFunction]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Call]] internal method
                //   of target providing boundThis as the this value and
                //   providing args as the arguments.

                // equiv: target.call(this, ...boundArgs, ...args)
                return apply.call(
                    target,
                    that,
                    array_concat.call(args, array_slice.call(arguments))
                );

            };

            // 15. If the [[Class]] internal property of Target is "Function", then
            //     a. Let L be the length property of Target minus the length of A.
            //     b. Set the length own property of F to either 0 or L, whichever is
            //       larger.
            // 16. Else set the length own property of F to 0.

            var boundLength = max(0, target.length - args.length);

            // 17. Set the attributes of the length own property of F to the values
            //   specified in 15.3.5.1.
            var boundArgs = [];
            for (var i = 0; i < boundLength; i++) {
                array_push.call(boundArgs, '$' + i);
            }

            // XXX Build a dynamic function with desired amount of arguments is the only
            // way to set the length property of a function.
            // In environments where Content Security Policies enabled (Chrome extensions,
            // for ex.) all use of eval or Function costructor throws an exception.
            // However in all of these environments Function.prototype.bind exists
            // and so this code will never be executed.
            bound = $Function('binder', 'return function (' + array_join.call(boundArgs, ',') + '){ return binder.apply(this, arguments); }')(binder);

            if (target.prototype) {
                Empty.prototype = target.prototype;
                bound.prototype = new Empty();
                // Clean up dangling references.
                Empty.prototype = null;
            }

            // TODO
            // 18. Set the [[Extensible]] internal property of F to true.

            // TODO
            // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
            // 20. Call the [[DefineOwnProperty]] internal method of F with
            //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
            //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
            //   false.
            // 21. Call the [[DefineOwnProperty]] internal method of F with
            //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
            //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
            //   and false.

            // TODO
            // NOTE Function objects created using Function.prototype.bind do not
            // have a prototype property or the [[Code]], [[FormalParameters]], and
            // [[Scope]] internal properties.
            // XXX can't delete prototype in pure-js.

            // 22. Return F.
            return bound;
        }
    });

    // _Please note: Shortcuts are defined after `Function.prototype.bind` as we
    // use it in defining shortcuts.
    var owns = call.bind(ObjectPrototype.hasOwnProperty);
    var toStr = call.bind(ObjectPrototype.toString);
    var arraySlice = call.bind(array_slice);
    var arraySliceApply = apply.bind(array_slice);
    /* globals document */
    if (typeof document === 'object' && document && document.documentElement) {
        try {
            arraySlice(document.documentElement.childNodes);
        } catch (e) {
            var origArraySlice = arraySlice;
            var origArraySliceApply = arraySliceApply;
            arraySlice = function arraySliceIE(arr) {
                var r = [];
                var i = arr.length;
                while (i-- > 0) {
                    r[i] = arr[i];
                }
                return origArraySliceApply(r, origArraySlice(arguments, 1));
            };
            arraySliceApply = function arraySliceApplyIE(arr, args) {
                return origArraySliceApply(arraySlice(arr), args);
            };
        }
    }
    var strSlice = call.bind(StringPrototype.slice);
    var strSplit = call.bind(StringPrototype.split);
    var strIndexOf = call.bind(StringPrototype.indexOf);
    var pushCall = call.bind(array_push);
    var isEnum = call.bind(ObjectPrototype.propertyIsEnumerable);
    var arraySort = call.bind(ArrayPrototype.sort);

    //
    // Array
    // =====
    //

    var isArray = $Array.isArray || function isArray(obj) {
        return toStr(obj) === '[object Array]';
    };

    // ES5 15.4.4.12
    // http://es5.github.com/#x15.4.4.13
    // Return len+argCount.
    // [bugfix, ielt8]
    // IE < 8 bug: [].unshift(0) === undefined but should be "1"
    var hasUnshiftReturnValueBug = [].unshift(0) !== 1;
    defineProperties(ArrayPrototype, {
        unshift: function () {
            array_unshift.apply(this, arguments);
            return this.length;
        }
    }, hasUnshiftReturnValueBug);

    // ES5 15.4.3.2
    // http://es5.github.com/#x15.4.3.2
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
    defineProperties($Array, { isArray: isArray });

    // The IsCallable() check in the Array functions
    // has been replaced with a strict check on the
    // internal class of the object to trap cases where
    // the provided function was actually a regular
    // expression literal, which in V8 and
    // JavaScriptCore is a typeof "function".  Only in
    // V8 are regular expression literals permitted as
    // reduce parameters, so it is desirable in the
    // general case for the shim to match the more
    // strict and common behavior of rejecting regular
    // expressions.

    // ES5 15.4.4.18
    // http://es5.github.com/#x15.4.4.18
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/forEach

    // Check failure of by-index access of string characters (IE < 9)
    // and failure of `0 in boxedString` (Rhino)
    var boxedString = $Object('a');
    var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

    var properlyBoxesContext = function properlyBoxed(method) {
        // Check node 0.6.21 bug where third parameter is not boxed
        var properlyBoxesNonStrict = true;
        var properlyBoxesStrict = true;
        var threwException = false;
        if (method) {
            try {
                method.call('foo', function (_, __, context) {
                    if (typeof context !== 'object') {
                        properlyBoxesNonStrict = false;
                    }
                });

                method.call([1], function () {
                    'use strict';

                    properlyBoxesStrict = typeof this === 'string';
                }, 'x');
            } catch (e) {
                threwException = true;
            }
        }
        return !!method && !threwException && properlyBoxesNonStrict && properlyBoxesStrict;
    };

    defineProperties(ArrayPrototype, {
        forEach: function forEach(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var i = -1;
            var length = ES.ToUint32(self.length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.forEach callback must be a function');
            }

            while (++i < length) {
                if (i in self) {
                    // Invoke the callback function with call, passing arguments:
                    // context, property value, property key, thisArg object
                    if (typeof T === 'undefined') {
                        callbackfn(self[i], i, object);
                    } else {
                        callbackfn.call(T, self[i], i, object);
                    }
                }
            }
        }
    }, !properlyBoxesContext(ArrayPrototype.forEach));

    // ES5 15.4.4.19
    // http://es5.github.com/#x15.4.4.19
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
    defineProperties(ArrayPrototype, {
        map: function map(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var result = $Array(length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.map callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self) {
                    if (typeof T === 'undefined') {
                        result[i] = callbackfn(self[i], i, object);
                    } else {
                        result[i] = callbackfn.call(T, self[i], i, object);
                    }
                }
            }
            return result;
        }
    }, !properlyBoxesContext(ArrayPrototype.map));

    // ES5 15.4.4.20
    // http://es5.github.com/#x15.4.4.20
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
    defineProperties(ArrayPrototype, {
        filter: function filter(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var result = [];
            var value;
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.filter callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self) {
                    value = self[i];
                    if (typeof T === 'undefined' ? callbackfn(value, i, object) : callbackfn.call(T, value, i, object)) {
                        pushCall(result, value);
                    }
                }
            }
            return result;
        }
    }, !properlyBoxesContext(ArrayPrototype.filter));

    // ES5 15.4.4.16
    // http://es5.github.com/#x15.4.4.16
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every
    defineProperties(ArrayPrototype, {
        every: function every(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.every callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self && !(typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
                    return false;
                }
            }
            return true;
        }
    }, !properlyBoxesContext(ArrayPrototype.every));

    // ES5 15.4.4.17
    // http://es5.github.com/#x15.4.4.17
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some
    defineProperties(ArrayPrototype, {
        some: function some(callbackfn/*, thisArg */) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.some callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self && (typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
                    return true;
                }
            }
            return false;
        }
    }, !properlyBoxesContext(ArrayPrototype.some));

    // ES5 15.4.4.21
    // http://es5.github.com/#x15.4.4.21
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce
    var reduceCoercesToObject = false;
    if (ArrayPrototype.reduce) {
        reduceCoercesToObject = typeof ArrayPrototype.reduce.call('es5', function (_, __, ___, list) {
            return list;
        }) === 'object';
    }
    defineProperties(ArrayPrototype, {
        reduce: function reduce(callbackfn/*, initialValue*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.reduce callback must be a function');
            }

            // no value to return if no initial value and an empty array
            if (length === 0 && arguments.length === 1) {
                throw new TypeError('reduce of empty array with no initial value');
            }

            var i = 0;
            var result;
            if (arguments.length >= 2) {
                result = arguments[1];
            } else {
                do {
                    if (i in self) {
                        result = self[i++];
                        break;
                    }

                    // if array contains no values, no initial value to return
                    if (++i >= length) {
                        throw new TypeError('reduce of empty array with no initial value');
                    }
                } while (true);
            }

            for (; i < length; i++) {
                if (i in self) {
                    result = callbackfn(result, self[i], i, object);
                }
            }

            return result;
        }
    }, !reduceCoercesToObject);

    // ES5 15.4.4.22
    // http://es5.github.com/#x15.4.4.22
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduceRight
    var reduceRightCoercesToObject = false;
    if (ArrayPrototype.reduceRight) {
        reduceRightCoercesToObject = typeof ArrayPrototype.reduceRight.call('es5', function (_, __, ___, list) {
            return list;
        }) === 'object';
    }
    defineProperties(ArrayPrototype, {
        reduceRight: function reduceRight(callbackfn/*, initial*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.reduceRight callback must be a function');
            }

            // no value to return if no initial value, empty array
            if (length === 0 && arguments.length === 1) {
                throw new TypeError('reduceRight of empty array with no initial value');
            }

            var result;
            var i = length - 1;
            if (arguments.length >= 2) {
                result = arguments[1];
            } else {
                do {
                    if (i in self) {
                        result = self[i--];
                        break;
                    }

                    // if array contains no values, no initial value to return
                    if (--i < 0) {
                        throw new TypeError('reduceRight of empty array with no initial value');
                    }
                } while (true);
            }

            if (i < 0) {
                return result;
            }

            do {
                if (i in self) {
                    result = callbackfn(result, self[i], i, object);
                }
            } while (i--);

            return result;
        }
    }, !reduceRightCoercesToObject);

    // ES5 15.4.4.14
    // http://es5.github.com/#x15.4.4.14
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
    var hasFirefox2IndexOfBug = ArrayPrototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
    defineProperties(ArrayPrototype, {
        indexOf: function indexOf(searchElement/*, fromIndex */) {
            var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
            var length = ES.ToUint32(self.length);

            if (length === 0) {
                return -1;
            }

            var i = 0;
            if (arguments.length > 1) {
                i = ES.ToInteger(arguments[1]);
            }

            // handle negative indices
            i = i >= 0 ? i : max(0, length + i);
            for (; i < length; i++) {
                if (i in self && self[i] === searchElement) {
                    return i;
                }
            }
            return -1;
        }
    }, hasFirefox2IndexOfBug);

    // ES5 15.4.4.15
    // http://es5.github.com/#x15.4.4.15
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf
    var hasFirefox2LastIndexOfBug = ArrayPrototype.lastIndexOf && [0, 1].lastIndexOf(0, -3) !== -1;
    defineProperties(ArrayPrototype, {
        lastIndexOf: function lastIndexOf(searchElement/*, fromIndex */) {
            var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
            var length = ES.ToUint32(self.length);

            if (length === 0) {
                return -1;
            }
            var i = length - 1;
            if (arguments.length > 1) {
                i = min(i, ES.ToInteger(arguments[1]));
            }
            // handle negative indices
            i = i >= 0 ? i : length - abs(i);
            for (; i >= 0; i--) {
                if (i in self && searchElement === self[i]) {
                    return i;
                }
            }
            return -1;
        }
    }, hasFirefox2LastIndexOfBug);

    // ES5 15.4.4.12
    // http://es5.github.com/#x15.4.4.12
    var spliceNoopReturnsEmptyArray = (function () {
        var a = [1, 2];
        var result = a.splice();
        return a.length === 2 && isArray(result) && result.length === 0;
    }());
    defineProperties(ArrayPrototype, {
        // Safari 5.0 bug where .splice() returns undefined
        splice: function splice(start, deleteCount) {
            if (arguments.length === 0) {
                return [];
            }
            return array_splice.apply(this, arguments);

        }
    }, !spliceNoopReturnsEmptyArray);

    var spliceWorksWithEmptyObject = (function () {
        var obj = {};
        ArrayPrototype.splice.call(obj, 0, 0, 1);
        return obj.length === 1;
    }());
    defineProperties(ArrayPrototype, {
        splice: function splice(start, deleteCount) {
            if (arguments.length === 0) {
                return [];
            }
            var args = arguments;
            this.length = max(ES.ToInteger(this.length), 0);
            if (arguments.length > 0 && typeof deleteCount !== 'number') {
                args = arraySlice(arguments);
                if (args.length < 2) {
                    pushCall(args, this.length - start);
                } else {
                    args[1] = ES.ToInteger(deleteCount);
                }
            }
            return array_splice.apply(this, args);
        }
    }, !spliceWorksWithEmptyObject);
    var spliceWorksWithLargeSparseArrays = (function () {
        // Per https://github.com/es-shims/es5-shim/issues/295
        // Safari 7/8 breaks with sparse arrays of size 1e5 or greater
        var arr = new $Array(1e5);
        // note: the index MUST be 8 or larger or the test will false pass
        arr[8] = 'x';
        arr.splice(1, 1);
        // note: this test must be defined *after* the indexOf shim
        // per https://github.com/es-shims/es5-shim/issues/313
        return arr.indexOf('x') === 7;
    }());
    var spliceWorksWithSmallSparseArrays = (function () {
        // Per https://github.com/es-shims/es5-shim/issues/295
        // Opera 12.15 breaks on this, no idea why.
        var n = 256;
        var arr = [];
        arr[n] = 'a';
        arr.splice(n + 1, 0, 'b');
        return arr[n] === 'a';
    }());
    defineProperties(ArrayPrototype, {
        splice: function splice(start, deleteCount) {
            var O = ES.ToObject(this);
            var A = [];
            var len = ES.ToUint32(O.length);
            var relativeStart = ES.ToInteger(start);
            var actualStart = relativeStart < 0 ? max((len + relativeStart), 0) : min(relativeStart, len);
            var actualDeleteCount = arguments.length === 0
                ? 0
                : arguments.length === 1
                    ? len - actualStart
                    : min(max(ES.ToInteger(deleteCount), 0), len - actualStart);

            var k = 0;
            var from;
            while (k < actualDeleteCount) {
                from = $String(actualStart + k);
                if (owns(O, from)) {
                    A[k] = O[from];
                }
                k += 1;
            }

            var items = arraySlice(arguments, 2);
            var itemCount = items.length;
            var to;
            if (itemCount < actualDeleteCount) {
                k = actualStart;
                var maxK = len - actualDeleteCount;
                while (k < maxK) {
                    from = $String(k + actualDeleteCount);
                    to = $String(k + itemCount);
                    if (owns(O, from)) {
                        O[to] = O[from];
                    } else {
                        delete O[to];
                    }
                    k += 1;
                }
                k = len;
                var minK = len - actualDeleteCount + itemCount;
                while (k > minK) {
                    delete O[k - 1];
                    k -= 1;
                }
            } else if (itemCount > actualDeleteCount) {
                k = len - actualDeleteCount;
                while (k > actualStart) {
                    from = $String(k + actualDeleteCount - 1);
                    to = $String(k + itemCount - 1);
                    if (owns(O, from)) {
                        O[to] = O[from];
                    } else {
                        delete O[to];
                    }
                    k -= 1;
                }
            }
            k = actualStart;
            for (var i = 0; i < items.length; ++i) {
                O[k] = items[i];
                k += 1;
            }
            O.length = len - actualDeleteCount + itemCount;

            return A;
        }
    }, !spliceWorksWithLargeSparseArrays || !spliceWorksWithSmallSparseArrays);

    var originalJoin = ArrayPrototype.join;
    var hasStringJoinBug;
    try {
        hasStringJoinBug = Array.prototype.join.call('123', ',') !== '1,2,3';
    } catch (e) {
        hasStringJoinBug = true;
    }
    if (hasStringJoinBug) {
        defineProperties(ArrayPrototype, {
            join: function join(separator) {
                var sep = typeof separator === 'undefined' ? ',' : separator;
                return originalJoin.call(isString(this) ? strSplit(this, '') : this, sep);
            }
        }, hasStringJoinBug);
    }

    var hasJoinUndefinedBug = [1, 2].join(undefined) !== '1,2';
    if (hasJoinUndefinedBug) {
        defineProperties(ArrayPrototype, {
            join: function join(separator) {
                var sep = typeof separator === 'undefined' ? ',' : separator;
                return originalJoin.call(this, sep);
            }
        }, hasJoinUndefinedBug);
    }

    var pushShim = function push(item) {
        var O = ES.ToObject(this);
        var n = ES.ToUint32(O.length);
        var i = 0;
        while (i < arguments.length) {
            O[n + i] = arguments[i];
            i += 1;
        }
        O.length = n + i;
        return n + i;
    };

    var pushIsNotGeneric = (function () {
        var obj = {};
        var result = Array.prototype.push.call(obj, undefined);
        return result !== 1 || obj.length !== 1 || typeof obj[0] !== 'undefined' || !owns(obj, 0);
    }());
    defineProperties(ArrayPrototype, {
        push: function push(item) {
            if (isArray(this)) {
                return array_push.apply(this, arguments);
            }
            return pushShim.apply(this, arguments);
        }
    }, pushIsNotGeneric);

    // This fixes a very weird bug in Opera 10.6 when pushing `undefined
    var pushUndefinedIsWeird = (function () {
        var arr = [];
        var result = arr.push(undefined);
        return result !== 1 || arr.length !== 1 || typeof arr[0] !== 'undefined' || !owns(arr, 0);
    }());
    defineProperties(ArrayPrototype, { push: pushShim }, pushUndefinedIsWeird);

    // ES5 15.2.3.14
    // http://es5.github.io/#x15.4.4.10
    // Fix boxed string bug
    defineProperties(ArrayPrototype, {
        slice: function (start, end) {
            var arr = isString(this) ? strSplit(this, '') : this;
            return arraySliceApply(arr, arguments);
        }
    }, splitString);

    var sortIgnoresNonFunctions = (function () {
        try {
            [1, 2].sort(null);
        } catch (e) {
            try {
                [1, 2].sort({});
            } catch (e2) {
                return false;
            }
        }
        return true;
    }());
    var sortThrowsOnRegex = (function () {
        // this is a problem in Firefox 4, in which `typeof /a/ === 'function'`
        try {
            [1, 2].sort(/a/);
            return false;
        } catch (e) {}
        return true;
    }());
    var sortIgnoresUndefined = (function () {
        // applies in IE 8, for one.
        try {
            [1, 2].sort(undefined);
            return true;
        } catch (e) {}
        return false;
    }());
    defineProperties(ArrayPrototype, {
        sort: function sort(compareFn) {
            if (typeof compareFn === 'undefined') {
                return arraySort(this);
            }
            if (!isCallable(compareFn)) {
                throw new TypeError('Array.prototype.sort callback must be a function');
            }
            return arraySort(this, compareFn);
        }
    }, sortIgnoresNonFunctions || !sortIgnoresUndefined || !sortThrowsOnRegex);

    //
    // Object
    // ======
    //

    // ES5 15.2.3.14
    // http://es5.github.com/#x15.2.3.14

    // http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
    // eslint-disable-next-line quote-props
    var hasDontEnumBug = !isEnum({ 'toString': null }, 'toString'); // jscs:ignore disallowQuotedKeysInObjects
    var hasProtoEnumBug = isEnum(function () {}, 'prototype');
    var hasStringEnumBug = !owns('x', '0');
    var equalsConstructorPrototype = function (o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
    };
    var excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true,

        $width: true,
        $height: true,
        $top: true,
        $localStorage: true
    };
    var hasAutomationEqualityBug = (function () {
        /* globals window */
        if (typeof window === 'undefined') {
            return false;
        }
        for (var k in window) {
            try {
                if (!excludedKeys['$' + k] && owns(window, k) && window[k] !== null && typeof window[k] === 'object') {
                    equalsConstructorPrototype(window[k]);
                }
            } catch (e) {
                return true;
            }
        }
        return false;
    }());
    var equalsConstructorPrototypeIfNotBuggy = function (object) {
        if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
            return equalsConstructorPrototype(object);
        }
        try {
            return equalsConstructorPrototype(object);
        } catch (e) {
            return false;
        }
    };
    var dontEnums = [
        'toString',
        'toLocaleString',
        'valueOf',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'constructor'
    ];
    var dontEnumsLength = dontEnums.length;

    // taken directly from https://github.com/ljharb/is-arguments/blob/master/index.js
    // can be replaced with require('is-arguments') if we ever use a build process instead
    var isStandardArguments = function isArguments(value) {
        return toStr(value) === '[object Arguments]';
    };
    var isLegacyArguments = function isArguments(value) {
        return value !== null
            && typeof value === 'object'
            && typeof value.length === 'number'
            && value.length >= 0
            && !isArray(value)
            && isCallable(value.callee);
    };
    var isArguments = isStandardArguments(arguments) ? isStandardArguments : isLegacyArguments;

    defineProperties($Object, {
        keys: function keys(object) {
            var isFn = isCallable(object);
            var isArgs = isArguments(object);
            var isObject = object !== null && typeof object === 'object';
            var isStr = isObject && isString(object);

            if (!isObject && !isFn && !isArgs) {
                throw new TypeError('Object.keys called on a non-object');
            }

            var theKeys = [];
            var skipProto = hasProtoEnumBug && isFn;
            if ((isStr && hasStringEnumBug) || isArgs) {
                for (var i = 0; i < object.length; ++i) {
                    pushCall(theKeys, $String(i));
                }
            }

            if (!isArgs) {
                for (var name in object) {
                    if (!(skipProto && name === 'prototype') && owns(object, name)) {
                        pushCall(theKeys, $String(name));
                    }
                }
            }

            if (hasDontEnumBug) {
                var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
                for (var j = 0; j < dontEnumsLength; j++) {
                    var dontEnum = dontEnums[j];
                    if (!(skipConstructor && dontEnum === 'constructor') && owns(object, dontEnum)) {
                        pushCall(theKeys, dontEnum);
                    }
                }
            }
            return theKeys;
        }
    });

    var keysWorksWithArguments = $Object.keys && (function () {
        // Safari 5.0 bug
        return $Object.keys(arguments).length === 2;
    }(1, 2));
    var keysHasArgumentsLengthBug = $Object.keys && (function () {
        var argKeys = $Object.keys(arguments);
        return arguments.length !== 1 || argKeys.length !== 1 || argKeys[0] !== 1;
    }(1));
    var originalKeys = $Object.keys;
    defineProperties($Object, {
        keys: function keys(object) {
            if (isArguments(object)) {
                return originalKeys(arraySlice(object));
            }
            return originalKeys(object);

        }
    }, !keysWorksWithArguments || keysHasArgumentsLengthBug);

    //
    // Date
    // ====
    //

    var hasNegativeMonthYearBug = new Date(-3509827329600292).getUTCMonth() !== 0;
    var aNegativeTestDate = new Date(-1509842289600292);
    var aPositiveTestDate = new Date(1449662400000);
    var hasToUTCStringFormatBug = aNegativeTestDate.toUTCString() !== 'Mon, 01 Jan -45875 11:59:59 GMT';
    var hasToDateStringFormatBug;
    var hasToStringFormatBug;
    var timeZoneOffset = aNegativeTestDate.getTimezoneOffset();
    if (timeZoneOffset < -720) {
        hasToDateStringFormatBug = aNegativeTestDate.toDateString() !== 'Tue Jan 02 -45875';
        hasToStringFormatBug = !(/^Thu Dec 10 2015 \d\d:\d\d:\d\d GMT[-+]\d\d\d\d(?: |$)/).test(String(aPositiveTestDate));
    } else {
        hasToDateStringFormatBug = aNegativeTestDate.toDateString() !== 'Mon Jan 01 -45875';
        hasToStringFormatBug = !(/^Wed Dec 09 2015 \d\d:\d\d:\d\d GMT[-+]\d\d\d\d(?: |$)/).test(String(aPositiveTestDate));
    }

    var originalGetFullYear = call.bind(Date.prototype.getFullYear);
    var originalGetMonth = call.bind(Date.prototype.getMonth);
    var originalGetDate = call.bind(Date.prototype.getDate);
    var originalGetUTCFullYear = call.bind(Date.prototype.getUTCFullYear);
    var originalGetUTCMonth = call.bind(Date.prototype.getUTCMonth);
    var originalGetUTCDate = call.bind(Date.prototype.getUTCDate);
    var originalGetUTCDay = call.bind(Date.prototype.getUTCDay);
    var originalGetUTCHours = call.bind(Date.prototype.getUTCHours);
    var originalGetUTCMinutes = call.bind(Date.prototype.getUTCMinutes);
    var originalGetUTCSeconds = call.bind(Date.prototype.getUTCSeconds);
    var originalGetUTCMilliseconds = call.bind(Date.prototype.getUTCMilliseconds);
    var dayName = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    var monthName = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    var daysInMonth = function daysInMonth(month, year) {
        return originalGetDate(new Date(year, month, 0));
    };

    defineProperties(Date.prototype, {
        getFullYear: function getFullYear() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetFullYear(this);
            if (year < 0 && originalGetMonth(this) > 11) {
                return year + 1;
            }
            return year;
        },
        getMonth: function getMonth() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetFullYear(this);
            var month = originalGetMonth(this);
            if (year < 0 && month > 11) {
                return 0;
            }
            return month;
        },
        getDate: function getDate() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetFullYear(this);
            var month = originalGetMonth(this);
            var date = originalGetDate(this);
            if (year < 0 && month > 11) {
                if (month === 12) {
                    return date;
                }
                var days = daysInMonth(0, year + 1);
                return (days - date) + 1;
            }
            return date;
        },
        getUTCFullYear: function getUTCFullYear() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetUTCFullYear(this);
            if (year < 0 && originalGetUTCMonth(this) > 11) {
                return year + 1;
            }
            return year;
        },
        getUTCMonth: function getUTCMonth() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetUTCFullYear(this);
            var month = originalGetUTCMonth(this);
            if (year < 0 && month > 11) {
                return 0;
            }
            return month;
        },
        getUTCDate: function getUTCDate() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetUTCFullYear(this);
            var month = originalGetUTCMonth(this);
            var date = originalGetUTCDate(this);
            if (year < 0 && month > 11) {
                if (month === 12) {
                    return date;
                }
                var days = daysInMonth(0, year + 1);
                return (days - date) + 1;
            }
            return date;
        }
    }, hasNegativeMonthYearBug);

    defineProperties(Date.prototype, {
        toUTCString: function toUTCString() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var day = originalGetUTCDay(this);
            var date = originalGetUTCDate(this);
            var month = originalGetUTCMonth(this);
            var year = originalGetUTCFullYear(this);
            var hour = originalGetUTCHours(this);
            var minute = originalGetUTCMinutes(this);
            var second = originalGetUTCSeconds(this);
            return dayName[day] + ', '
                + (date < 10 ? '0' + date : date) + ' '
                + monthName[month] + ' '
                + year + ' '
                + (hour < 10 ? '0' + hour : hour) + ':'
                + (minute < 10 ? '0' + minute : minute) + ':'
                + (second < 10 ? '0' + second : second) + ' GMT';
        }
    }, hasNegativeMonthYearBug || hasToUTCStringFormatBug);

    // Opera 12 has `,`
    defineProperties(Date.prototype, {
        toDateString: function toDateString() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var day = this.getDay();
            var date = this.getDate();
            var month = this.getMonth();
            var year = this.getFullYear();
            return dayName[day] + ' '
                + monthName[month] + ' '
                + (date < 10 ? '0' + date : date) + ' '
                + year;
        }
    }, hasNegativeMonthYearBug || hasToDateStringFormatBug);

    // can't use defineProperties here because of toString enumeration issue in IE <= 8
    if (hasNegativeMonthYearBug || hasToStringFormatBug) {
        Date.prototype.toString = function toString() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var day = this.getDay();
            var date = this.getDate();
            var month = this.getMonth();
            var year = this.getFullYear();
            var hour = this.getHours();
            var minute = this.getMinutes();
            var second = this.getSeconds();
            var timezoneOffset = this.getTimezoneOffset();
            var hoursOffset = floor(abs(timezoneOffset) / 60);
            var minutesOffset = floor(abs(timezoneOffset) % 60);
            return dayName[day] + ' '
                + monthName[month] + ' '
                + (date < 10 ? '0' + date : date) + ' '
                + year + ' '
                + (hour < 10 ? '0' + hour : hour) + ':'
                + (minute < 10 ? '0' + minute : minute) + ':'
                + (second < 10 ? '0' + second : second) + ' GMT'
                + (timezoneOffset > 0 ? '-' : '+')
                + (hoursOffset < 10 ? '0' + hoursOffset : hoursOffset)
                + (minutesOffset < 10 ? '0' + minutesOffset : minutesOffset);
        };
        if (supportsDescriptors) {
            $Object.defineProperty(Date.prototype, 'toString', {
                configurable: true,
                enumerable: false,
                writable: true
            });
        }
    }

    // ES5 15.9.5.43
    // http://es5.github.com/#x15.9.5.43
    // This function returns a String value represent the instance in time
    // represented by this Date object. The format of the String is the Date Time
    // string format defined in 15.9.1.15. All fields are present in the String.
    // The time zone is always UTC, denoted by the suffix Z. If the time value of
    // this object is not a finite Number a RangeError exception is thrown.
    var negativeDate = -62198755200000;
    var negativeYearString = '-000001';
    var hasNegativeDateBug = Date.prototype.toISOString && new Date(negativeDate).toISOString().indexOf(negativeYearString) === -1; // eslint-disable-line max-len
    var hasSafari51DateBug = Date.prototype.toISOString && new Date(-1).toISOString() !== '1969-12-31T23:59:59.999Z';

    var getTime = call.bind(Date.prototype.getTime);

    defineProperties(Date.prototype, {
        toISOString: function toISOString() {
            if (!isFinite(this) || !isFinite(getTime(this))) {
                // Adope Photoshop requires the second check.
                throw new RangeError('Date.prototype.toISOString called on non-finite value.');
            }

            var year = originalGetUTCFullYear(this);

            var month = originalGetUTCMonth(this);
            // see https://github.com/es-shims/es5-shim/issues/111
            year += floor(month / 12);
            month = ((month % 12) + 12) % 12;

            // the date time string format is specified in 15.9.1.15.
            var result = [
                month + 1,
                originalGetUTCDate(this),
                originalGetUTCHours(this),
                originalGetUTCMinutes(this),
                originalGetUTCSeconds(this)
            ];
            year = (
                (year < 0 ? '-' : (year > 9999 ? '+' : ''))
                + strSlice('00000' + abs(year), (0 <= year && year <= 9999) ? -4 : -6)
            );

            for (var i = 0; i < result.length; ++i) {
                // pad months, days, hours, minutes, and seconds to have two digits.
                result[i] = strSlice('00' + result[i], -2);
            }
            // pad milliseconds to have three digits.
            return (
                year + '-' + arraySlice(result, 0, 2).join('-')
                + 'T' + arraySlice(result, 2).join(':') + '.'
                + strSlice('000' + originalGetUTCMilliseconds(this), -3) + 'Z'
            );
        }
    }, hasNegativeDateBug || hasSafari51DateBug);

    // ES5 15.9.5.44
    // http://es5.github.com/#x15.9.5.44
    // This function provides a String representation of a Date object for use by
    // JSON.stringify (15.12.3).
    var dateToJSONIsSupported = (function () {
        try {
            return Date.prototype.toJSON
                && new Date(NaN).toJSON() === null
                && new Date(negativeDate).toJSON().indexOf(negativeYearString) !== -1
                && Date.prototype.toJSON.call({ // generic
                    toISOString: function () { return true; }
                });
        } catch (e) {
            return false;
        }
    }());
    if (!dateToJSONIsSupported) {
        Date.prototype.toJSON = function toJSON(key) {
            // When the toJSON method is called with argument key, the following
            // steps are taken:

            // 1.  Let O be the result of calling ToObject, giving it the this
            // value as its argument.
            // 2. Let tv be ES.ToPrimitive(O, hint Number).
            var O = $Object(this);
            var tv = ES.ToPrimitive(O);
            // 3. If tv is a Number and is not finite, return null.
            if (typeof tv === 'number' && !isFinite(tv)) {
                return null;
            }
            // 4. Let toISO be the result of calling the [[Get]] internal method of
            // O with argument "toISOString".
            var toISO = O.toISOString;
            // 5. If IsCallable(toISO) is false, throw a TypeError exception.
            if (!isCallable(toISO)) {
                throw new TypeError('toISOString property is not callable');
            }
            // 6. Return the result of calling the [[Call]] internal method of
            //  toISO with O as the this value and an empty argument list.
            return toISO.call(O);

            // NOTE 1 The argument is ignored.

            // NOTE 2 The toJSON function is intentionally generic; it does not
            // require that its this value be a Date object. Therefore, it can be
            // transferred to other kinds of objects for use as a method. However,
            // it does require that any such object have a toISOString method. An
            // object is free to use the argument key to filter its
            // stringification.
        };
    }

    // ES5 15.9.4.2
    // http://es5.github.com/#x15.9.4.2
    // based on work shared by Daniel Friesen (dantman)
    // http://gist.github.com/303249
    var supportsExtendedYears = Date.parse('+033658-09-27T01:46:40.000Z') === 1e15;
    var acceptsInvalidDates = !isNaN(Date.parse('2012-04-04T24:00:00.500Z')) || !isNaN(Date.parse('2012-11-31T23:59:59.000Z')) || !isNaN(Date.parse('2012-12-31T23:59:60.000Z'));
    var doesNotParseY2KNewYear = isNaN(Date.parse('2000-01-01T00:00:00.000Z'));
    if (doesNotParseY2KNewYear || acceptsInvalidDates || !supportsExtendedYears) {
        // XXX global assignment won't work in embeddings that use
        // an alternate object for the context.
        var maxSafeUnsigned32Bit = pow(2, 31) - 1;
        var hasSafariSignedIntBug = isActualNaN(new Date(1970, 0, 1, 0, 0, 0, maxSafeUnsigned32Bit + 1).getTime());
        // eslint-disable-next-line no-implicit-globals, no-global-assign
        Date = (function (NativeDate) {
            // Date.length === 7
            var DateShim = function Date(Y, M, D, h, m, s, ms) {
                var length = arguments.length;
                var date;
                if (this instanceof NativeDate) {
                    var seconds = s;
                    var millis = ms;
                    if (hasSafariSignedIntBug && length >= 7 && ms > maxSafeUnsigned32Bit) {
                        // work around a Safari 8/9 bug where it treats the seconds as signed
                        var msToShift = floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
                        var sToShift = floor(msToShift / 1e3);
                        seconds += sToShift;
                        millis -= sToShift * 1e3;
                    }
                    date = length === 1 && $String(Y) === Y // isString(Y)
                        // We explicitly pass it through parse:
                        ? new NativeDate(DateShim.parse(Y))
                        // We have to manually make calls depending on argument
                        // length here
                        : length >= 7 ? new NativeDate(Y, M, D, h, m, seconds, millis)
                            : length >= 6 ? new NativeDate(Y, M, D, h, m, seconds)
                                : length >= 5 ? new NativeDate(Y, M, D, h, m)
                                    : length >= 4 ? new NativeDate(Y, M, D, h)
                                        : length >= 3 ? new NativeDate(Y, M, D)
                                            : length >= 2 ? new NativeDate(Y, M)
                                                : length >= 1 ? new NativeDate(Y instanceof NativeDate ? +Y : Y)
                                                    : new NativeDate();
                } else {
                    date = NativeDate.apply(this, arguments);
                }
                if (!isPrimitive(date)) {
                    // Prevent mixups with unfixed Date object
                    defineProperties(date, { constructor: DateShim }, true);
                }
                return date;
            };

            // 15.9.1.15 Date Time String Format.
            var isoDateExpression = new RegExp('^'
                + '(\\d{4}|[+-]\\d{6})' // four-digit year capture or sign + 6-digit extended year
                + '(?:-(\\d{2})' // optional month capture
                + '(?:-(\\d{2})' // optional day capture
                + '(?:' // capture hours:minutes:seconds.milliseconds
                    + 'T(\\d{2})' // hours capture
                    + ':(\\d{2})' // minutes capture
                    + '(?:' // optional :seconds.milliseconds
                        + ':(\\d{2})' // seconds capture
                        + '(?:(\\.\\d{1,}))?' // milliseconds capture
                    + ')?'
                + '(' // capture UTC offset component
                    + 'Z|' // UTC capture
                    + '(?:' // offset specifier +/-hours:minutes
                        + '([-+])' // sign capture
                        + '(\\d{2})' // hours offset capture
                        + ':(\\d{2})' // minutes offset capture
                    + ')'
                + ')?)?)?)?'
            + '$');

            var months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];

            var dayFromMonth = function dayFromMonth(year, month) {
                var t = month > 1 ? 1 : 0;
                return (
                    months[month]
                    + floor((year - 1969 + t) / 4)
                    - floor((year - 1901 + t) / 100)
                    + floor((year - 1601 + t) / 400)
                    + (365 * (year - 1970))
                );
            };

            var toUTC = function toUTC(t) {
                var s = 0;
                var ms = t;
                if (hasSafariSignedIntBug && ms > maxSafeUnsigned32Bit) {
                    // work around a Safari 8/9 bug where it treats the seconds as signed
                    var msToShift = floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
                    var sToShift = floor(msToShift / 1e3);
                    s += sToShift;
                    ms -= sToShift * 1e3;
                }
                return $Number(new NativeDate(1970, 0, 1, 0, 0, s, ms));
            };

            // Copy any custom methods a 3rd party library may have added
            for (var key in NativeDate) {
                if (owns(NativeDate, key)) {
                    DateShim[key] = NativeDate[key];
                }
            }

            // Copy "native" methods explicitly; they may be non-enumerable
            defineProperties(DateShim, {
                now: NativeDate.now,
                UTC: NativeDate.UTC
            }, true);
            DateShim.prototype = NativeDate.prototype;
            defineProperties(DateShim.prototype, { constructor: DateShim }, true);

            // Upgrade Date.parse to handle simplified ISO 8601 strings
            var parseShim = function parse(string) {
                var match = isoDateExpression.exec(string);
                if (match) {
                    // parse months, days, hours, minutes, seconds, and milliseconds
                    // provide default values if necessary
                    // parse the UTC offset component
                    var year = $Number(match[1]),
                        month = $Number(match[2] || 1) - 1,
                        day = $Number(match[3] || 1) - 1,
                        hour = $Number(match[4] || 0),
                        minute = $Number(match[5] || 0),
                        second = $Number(match[6] || 0),
                        millisecond = floor($Number(match[7] || 0) * 1000),
                        // When time zone is missed, local offset should be used
                        // (ES 5.1 bug)
                        // see https://bugs.ecmascript.org/show_bug.cgi?id=112
                        isLocalTime = Boolean(match[4] && !match[8]),
                        signOffset = match[9] === '-' ? 1 : -1,
                        hourOffset = $Number(match[10] || 0),
                        minuteOffset = $Number(match[11] || 0),
                        result;
                    var hasMinutesOrSecondsOrMilliseconds = minute > 0 || second > 0 || millisecond > 0;
                    if (
                        hour < (hasMinutesOrSecondsOrMilliseconds ? 24 : 25)
                        && minute < 60 && second < 60 && millisecond < 1000
                        && month > -1 && month < 12 && hourOffset < 24
                        && minuteOffset < 60 // detect invalid offsets
                        && day > -1
                        && day < (dayFromMonth(year, month + 1) - dayFromMonth(year, month))
                    ) {
                        result = (
                            ((dayFromMonth(year, month) + day) * 24)
                            + hour
                            + (hourOffset * signOffset)
                        ) * 60;
                        result = ((
                            ((result + minute + (minuteOffset * signOffset)) * 60)
                            + second
                        ) * 1000) + millisecond;
                        if (isLocalTime) {
                            result = toUTC(result);
                        }
                        if (-8.64e15 <= result && result <= 8.64e15) {
                            return result;
                        }
                    }
                    return NaN;
                }
                return NativeDate.parse.apply(this, arguments);
            };
            defineProperties(DateShim, { parse: parseShim });

            return DateShim;
        }(Date));
    }

    // ES5 15.9.4.4
    // http://es5.github.com/#x15.9.4.4
    if (!Date.now) {
        Date.now = function now() {
            return new Date().getTime();
        };
    }

    //
    // Number
    // ======
    //

    // ES5.1 15.7.4.5
    // http://es5.github.com/#x15.7.4.5
    var hasToFixedBugs = NumberPrototype.toFixed && (
        (0.00008).toFixed(3) !== '0.000'
        || (0.9).toFixed(0) !== '1'
        || (1.255).toFixed(2) !== '1.25'
        || (1000000000000000128).toFixed(0) !== '1000000000000000128'
    );

    var toFixedHelpers = {
        base: 1e7,
        size: 6,
        data: [0, 0, 0, 0, 0, 0],
        multiply: function multiply(n, c) {
            var i = -1;
            var c2 = c;
            while (++i < toFixedHelpers.size) {
                c2 += n * toFixedHelpers.data[i];
                toFixedHelpers.data[i] = c2 % toFixedHelpers.base;
                c2 = floor(c2 / toFixedHelpers.base);
            }
        },
        divide: function divide(n) {
            var i = toFixedHelpers.size;
            var c = 0;
            while (--i >= 0) {
                c += toFixedHelpers.data[i];
                toFixedHelpers.data[i] = floor(c / n);
                c = (c % n) * toFixedHelpers.base;
            }
        },
        numToString: function numToString() {
            var i = toFixedHelpers.size;
            var s = '';
            while (--i >= 0) {
                if (s !== '' || i === 0 || toFixedHelpers.data[i] !== 0) {
                    var t = $String(toFixedHelpers.data[i]);
                    if (s === '') {
                        s = t;
                    } else {
                        s += strSlice('0000000', 0, 7 - t.length) + t;
                    }
                }
            }
            return s;
        },
        pow: function pow(x, n, acc) {
            return (n === 0 ? acc : (n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc)));
        },
        log: function log(x) {
            var n = 0;
            var x2 = x;
            while (x2 >= 4096) {
                n += 12;
                x2 /= 4096;
            }
            while (x2 >= 2) {
                n += 1;
                x2 /= 2;
            }
            return n;
        }
    };

    var toFixedShim = function toFixed(fractionDigits) {
        var f, x, s, m, e, z, j, k;

        // Test for NaN and round fractionDigits down
        f = $Number(fractionDigits);
        f = isActualNaN(f) ? 0 : floor(f);

        if (f < 0 || f > 20) {
            throw new RangeError('Number.toFixed called with invalid number of decimals');
        }

        x = $Number(this);

        if (isActualNaN(x)) {
            return 'NaN';
        }

        // If it is too big or small, return the string value of the number
        if (x <= -1e21 || x >= 1e21) {
            return $String(x);
        }

        s = '';

        if (x < 0) {
            s = '-';
            x = -x;
        }

        m = '0';

        if (x > 1e-21) {
            // 1e-21 < x < 1e21
            // -70 < log2(x) < 70
            e = toFixedHelpers.log(x * toFixedHelpers.pow(2, 69, 1)) - 69;
            z = (e < 0 ? x * toFixedHelpers.pow(2, -e, 1) : x / toFixedHelpers.pow(2, e, 1));
            z *= 0x10000000000000; // pow(2, 52);
            e = 52 - e;

            // -18 < e < 122
            // x = z / 2 ^ e
            if (e > 0) {
                toFixedHelpers.multiply(0, z);
                j = f;

                while (j >= 7) {
                    toFixedHelpers.multiply(1e7, 0);
                    j -= 7;
                }

                toFixedHelpers.multiply(toFixedHelpers.pow(10, j, 1), 0);
                j = e - 1;

                while (j >= 23) {
                    toFixedHelpers.divide(1 << 23);
                    j -= 23;
                }

                toFixedHelpers.divide(1 << j);
                toFixedHelpers.multiply(1, 1);
                toFixedHelpers.divide(2);
                m = toFixedHelpers.numToString();
            } else {
                toFixedHelpers.multiply(0, z);
                toFixedHelpers.multiply(1 << (-e), 0);
                m = toFixedHelpers.numToString() + strSlice('0.00000000000000000000', 2, 2 + f);
            }
        }

        if (f > 0) {
            k = m.length;

            if (k <= f) {
                m = s + strSlice('0.0000000000000000000', 0, f - k + 2) + m;
            } else {
                m = s + strSlice(m, 0, k - f) + '.' + strSlice(m, k - f);
            }
        } else {
            m = s + m;
        }

        return m;
    };
    defineProperties(NumberPrototype, { toFixed: toFixedShim }, hasToFixedBugs);

    var hasToExponentialRoundingBug = (function () {
        try {
            return (-6.9e-11).toExponential(4) !== '-6.9000e-11';
        } catch (e) {
            return false;
        }
    }());
    var toExponentialAllowsInfiniteDigits = (function () {
        try {
            (1).toExponential(Infinity);
            (1).toExponential(-Infinity);
            return true;
        } catch (e) {
            return false;
        }
    }());
    var originalToExponential = call.bind(NumberPrototype.toExponential);
    var numberToString = call.bind(NumberPrototype.toString);
    defineProperties(NumberPrototype, {
        toExponential: function toExponential(fractionDigits) {
            // 1: Let x be this Number value.
            var x = $Number(this);

            if (typeof fractionDigits === 'undefined') {
                return originalToExponential(x);
            }
            var f = ES.ToInteger(fractionDigits);
            if (isActualNaN(x)) {
                return 'NaN';
            }

            if (f < 0 || f > 20) {
                // this will probably have thrown already
                return originalToExponential(x, f);
            }

            // only cases left are a finite receiver + in-range fractionDigits

            // implementation adapted from https://gist.github.com/SheetJSDev/1100ad56b9f856c95299ed0e068eea08

            // 4: Let s be the empty string
            var s = '';

            // 5: If x < 0
            if (x < 0) {
                s = '-';
                x = -x;
            }

            // 6: If x = +Infinity
            if (x === Infinity) {
                return s + 'Infinity';
            }

            // 7: If fractionDigits is not undefined and (f < 0 or f > 20), throw a RangeError exception.
            if (typeof fractionDigits !== 'undefined' && (f < 0 || f > 20)) {
                throw new RangeError('Fraction digits ' + fractionDigits + ' out of range');
            }

            var m = '';
            var e = 0;
            var c = '';
            var d = '';

            // 8: If x = 0 then
            if (x === 0) {
                e = 0;
                f = 0;
                m = '0';
            } else { // 9: Else, x != 0
                var L = log10(x);
                e = floor(L); // 10 ** e <= x and x < 10 ** (e+1)
                var n = 0;
                if (typeof fractionDigits !== 'undefined') { // eslint-disable-line no-negated-condition
                    var w = pow(10, e - f); // x / 10 ** (f+1) < w and w <= x / 10 ** f
                    n = round(x / w); // 10 ** f <= n and n < 10 ** (f+1)
                    if (2 * x >= (((2 * n) + 1) * w)) {
                        n += 1; // pick larger value
                    }
                    if (n >= pow(10, f + 1)) { // 10e-1 = 1e0
                        n /= 10;
                        e += 1;
                    }
                } else {
                    f = 16; // start from Math.ceil(Math.log10(Number.MAX_SAFE_INTEGER)) and loop down
                    var guess_n = round(pow(10, L - e + f));
                    var target_f = f;
                    while (f-- > 0) {
                        guess_n = round(pow(10, L - e + f));
                        if (
                            abs((guess_n * pow(10, e - f)) - x)
                            <= abs((n * pow(10, e - target_f)) - x)
                        ) {
                            target_f = f;
                            n = guess_n;
                        }
                    }
                }
                m = numberToString(n, 10);
                if (typeof fractionDigits === 'undefined') {
                    while (strSlice(m, -1) === '0') {
                        m = strSlice(m, 0, -1);
                        d += 1;
                    }
                }
            }

            // 10: If f != 0, then
            if (f !== 0) {
                m = strSlice(m, 0, 1) + '.' + strSlice(m, 1);
            }

            // 11: If e = 0, then
            if (e === 0) {
                c = '+';
                d = '0';
            } else { // 12: Else
                c = e > 0 ? '+' : '-';
                d = numberToString(abs(e), 10);
            }

            // 13: Let m be the concatenation of the four Strings m, "e", c, and d.
            m += 'e' + c + d;

            // 14: Return the concatenation of the Strings s and m.
            return s + m;
        }
    }, hasToExponentialRoundingBug || toExponentialAllowsInfiniteDigits);

    var hasToPrecisionUndefinedBug = (function () {
        try {
            return 1.0.toPrecision(undefined) === '1';
        } catch (e) {
            return true;
        }
    }());
    var originalToPrecision = call.bind(NumberPrototype.toPrecision);
    defineProperties(NumberPrototype, {
        toPrecision: function toPrecision(precision) {
            return typeof precision === 'undefined' ? originalToPrecision(this) : originalToPrecision(this, precision);
        }
    }, hasToPrecisionUndefinedBug);

    //
    // String
    // ======
    //

    // ES5 15.5.4.14
    // http://es5.github.com/#x15.5.4.14

    // [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
    // Many browsers do not split properly with regular expressions or they
    // do not perform the split correctly under obscure conditions.
    // See http://blog.stevenlevithan.com/archives/cross-browser-split
    // I've tested in many browsers and this seems to cover the deviant ones:
    //    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
    //    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
    //    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
    //       [undefined, "t", undefined, "e", ...]
    //    ''.split(/.?/) should be [], not [""]
    //    '.'.split(/()()/) should be ["."], not ["", "", "."]

    if (
        'ab'.split(/(?:ab)*/).length !== 2
        || '.'.split(/(.?)(.?)/).length !== 4
        || 'tesst'.split(/(s)*/)[1] === 't'
        || 'test'.split(/(?:)/, -1).length !== 4
        || ''.split(/.?/).length
        || '.'.split(/()()/).length > 1
    ) {
        (function () {
            var compliantExecNpcg = typeof (/()??/).exec('')[1] === 'undefined'; // NPCG: nonparticipating capturing group
            var maxSafe32BitInt = pow(2, 32) - 1;

            StringPrototype.split = function split(separator, limit) {
                var string = String(this);
                if (typeof separator === 'undefined' && limit === 0) {
                    return [];
                }

                // If `separator` is not a regex, use native split
                if (!isRegex(separator)) {
                    return strSplit(this, separator, limit);
                }

                var output = [];
                var flags = (separator.ignoreCase ? 'i' : '')
                            + (separator.multiline ? 'm' : '')
                            + (separator.unicode ? 'u' : '') // in ES6
                            + (separator.sticky ? 'y' : ''), // Firefox 3+ and ES6
                    lastLastIndex = 0,
                    // Make `global` and avoid `lastIndex` issues by working with a copy
                    separator2, match, lastIndex, lastLength;
                var separatorCopy = new RegExp(separator.source, flags + 'g');
                if (!compliantExecNpcg) {
                    // Doesn't need flags gy, but they don't hurt
                    separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
                }
                /* Values for `limit`, per the spec:
                 * If undefined: 4294967295 // maxSafe32BitInt
                 * If 0, Infinity, or NaN: 0
                 * If positive number: limit = floor(limit); if (limit > 4294967295) limit -= 4294967296;
                 * If negative number: 4294967296 - floor(abs(limit))
                 * If other: Type-convert, then use the above rules
                 */
                var splitLimit = typeof limit === 'undefined' ? maxSafe32BitInt : ES.ToUint32(limit);
                match = separatorCopy.exec(string);
                while (match) {
                    // `separatorCopy.lastIndex` is not reliable cross-browser
                    lastIndex = match.index + match[0].length;
                    if (lastIndex > lastLastIndex) {
                        pushCall(output, strSlice(string, lastLastIndex, match.index));
                        // Fix browsers whose `exec` methods don't consistently return `undefined` for
                        // nonparticipating capturing groups
                        if (!compliantExecNpcg && match.length > 1) {
                            /* eslint-disable no-loop-func */
                            match[0].replace(separator2, function () {
                                for (var i = 1; i < arguments.length - 2; i++) {
                                    if (typeof arguments[i] === 'undefined') {
                                        match[i] = void 0;
                                    }
                                }
                            });
                            /* eslint-enable no-loop-func */
                        }
                        if (match.length > 1 && match.index < string.length) {
                            array_push.apply(output, arraySlice(match, 1));
                        }
                        lastLength = match[0].length;
                        lastLastIndex = lastIndex;
                        if (output.length >= splitLimit) {
                            break;
                        }
                    }
                    if (separatorCopy.lastIndex === match.index) {
                        separatorCopy.lastIndex++; // Avoid an infinite loop
                    }
                    match = separatorCopy.exec(string);
                }
                if (lastLastIndex === string.length) {
                    if (lastLength || !separatorCopy.test('')) {
                        pushCall(output, '');
                    }
                } else {
                    pushCall(output, strSlice(string, lastLastIndex));
                }
                return output.length > splitLimit ? arraySlice(output, 0, splitLimit) : output;
            };
        }());

    // [bugfix, chrome]
    // If separator is undefined, then the result array contains just one String,
    // which is the this value (converted to a String). If limit is not undefined,
    // then the output array is truncated so that it contains no more than limit
    // elements.
    // "0".split(undefined, 0) -> []
    } else if ('0'.split(void 0, 0).length) {
        StringPrototype.split = function split(separator, limit) {
            if (typeof separator === 'undefined' && limit === 0) {
                return [];
            }
            return strSplit(this, separator, limit);
        };
    }

    var str_replace = StringPrototype.replace;
    var replaceReportsGroupsCorrectly = (function () {
        var groups = [];
        'x'.replace(/x(.)?/g, function (match, group) {
            pushCall(groups, group);
        });
        return groups.length === 1 && typeof groups[0] === 'undefined';
    }());

    if (!replaceReportsGroupsCorrectly) {
        StringPrototype.replace = function replace(searchValue, replaceValue) {
            var isFn = isCallable(replaceValue);
            var hasCapturingGroups = isRegex(searchValue) && (/\)[*?]/).test(searchValue.source);
            if (!isFn || !hasCapturingGroups) {
                return str_replace.call(this, searchValue, replaceValue);
            }
            var wrappedReplaceValue = function (match) {
                var length = arguments.length;
                var originalLastIndex = searchValue.lastIndex;
                searchValue.lastIndex = 0; // eslint-disable-line no-param-reassign
                var args = searchValue.exec(match) || [];
                searchValue.lastIndex = originalLastIndex; // eslint-disable-line no-param-reassign
                pushCall(args, arguments[length - 2], arguments[length - 1]);
                return replaceValue.apply(this, args);
            };
            return str_replace.call(this, searchValue, wrappedReplaceValue);

        };
    }

    // ECMA-262, 3rd B.2.3
    // Not an ECMAScript standard, although ECMAScript 3rd Edition has a
    // non-normative section suggesting uniform semantics and it should be
    // normalized across all browsers
    // [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
    var string_substr = StringPrototype.substr;
    var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
    defineProperties(StringPrototype, {
        substr: function substr(start, length) {
            var normalizedStart = start;
            if (start < 0) {
                normalizedStart = max(this.length + start, 0);
            }
            return string_substr.call(this, normalizedStart, length);
        }
    }, hasNegativeSubstrBug);

    // ES5 15.5.4.20
    // whitespace from: http://es5.github.io/#x15.5.4.20
    var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003'
        + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028'
        + '\u2029\uFEFF';
    var zeroWidth = '\u200b';
    var wsRegexChars = '[' + ws + ']';
    var trimBeginRegexp = new RegExp('^' + wsRegexChars + wsRegexChars + '*');
    var trimEndRegexp = new RegExp(wsRegexChars + wsRegexChars + '*$');
    var hasTrimWhitespaceBug = StringPrototype.trim && (ws.trim() || !zeroWidth.trim());
    defineProperties(StringPrototype, {
        // http://blog.stevenlevithan.com/archives/faster-trim-javascript
        // http://perfectionkills.com/whitespace-deviations/
        trim: function trim() {
            if (typeof this === 'undefined' || this === null) {
                throw new TypeError("can't convert " + this + ' to object');
            }
            return $String(this).replace(trimBeginRegexp, '').replace(trimEndRegexp, '');
        }
    }, hasTrimWhitespaceBug);
    var trim = call.bind(String.prototype.trim);

    var hasLastIndexBug = StringPrototype.lastIndexOf && 'abcあい'.lastIndexOf('あい', 2) !== -1;
    defineProperties(StringPrototype, {
        lastIndexOf: function lastIndexOf(searchString) {
            if (typeof this === 'undefined' || this === null) {
                throw new TypeError("can't convert " + this + ' to object');
            }
            var S = $String(this);
            var searchStr = $String(searchString);
            var numPos = arguments.length > 1 ? $Number(arguments[1]) : NaN;
            var pos = isActualNaN(numPos) ? Infinity : ES.ToInteger(numPos);
            var start = min(max(pos, 0), S.length);
            var searchLen = searchStr.length;
            var k = start + searchLen;
            while (k > 0) {
                k = max(0, k - searchLen);
                var index = strIndexOf(strSlice(S, k, start + searchLen), searchStr);
                if (index !== -1) {
                    return k + index;
                }
            }
            return -1;
        }
    }, hasLastIndexBug);

    var originalLastIndexOf = StringPrototype.lastIndexOf;
    defineProperties(StringPrototype, {
        lastIndexOf: function lastIndexOf(searchString) {
            return originalLastIndexOf.apply(this, arguments);
        }
    }, StringPrototype.lastIndexOf.length !== 1);

    var hexRegex = /^[-+]?0[xX]/;

    // ES-5 15.1.2.2
    // eslint-disable-next-line radix
    if (parseInt(ws + '08') !== 8 || parseInt(ws + '0x16') !== 22) {
        // eslint-disable-next-line no-global-assign, no-implicit-globals
        parseInt = (function (origParseInt) {
            return function parseInt(str, radix) {
                var string = trim(String(str));
                var defaultedRadix = $Number(radix) || (hexRegex.test(string) ? 16 : 10);
                return origParseInt(string, defaultedRadix);
            };
        }(parseInt));
    }
    // Edge 15-18
    var parseIntFailsToThrowOnBoxedSymbols = (function () {
        if (typeof Symbol !== 'function') {
            return false;
        }
        try {
            // eslint-disable-next-line radix
            parseInt(Object(Symbol.iterator));
            return true;
        } catch (e) { /**/ }

        try {
            // eslint-disable-next-line radix
            parseInt(Symbol.iterator);
            return true;
        } catch (e) { /**/ }

        return false;
    }());
    if (parseIntFailsToThrowOnBoxedSymbols) {
        var symbolValueOf = Symbol.prototype.valueOf;
        // eslint-disable-next-line no-global-assign, no-implicit-globals
        parseInt = (function (origParseInt) {
            return function parseInt(str, radix) {
                var isSym = typeof str === 'symbol';
                if (!isSym && str && typeof str === 'object') {
                    try {
                        symbolValueOf.call(str);
                        isSym = true;
                    } catch (e) { /**/ }
                }
                if (isSym) {
                    // handle Symbols in node 8.3/8.4
                    // eslint-disable-next-line no-implicit-coercion, no-unused-expressions
                    '' + str; // jscs:ignore disallowImplicitTypeConversion
                }
                var string = trim(String(str));
                var defaultedRadix = $Number(radix) || (hexRegex.test(string) ? 16 : 10);
                return origParseInt(string, defaultedRadix);
            };
        }(parseInt));
    }

    // https://es5.github.io/#x15.1.2.3
    if (1 / parseFloat('-0') !== -Infinity) {
        // eslint-disable-next-line no-global-assign, no-implicit-globals, no-native-reassign
        parseFloat = (function (origParseFloat) {
            return function parseFloat(string) {
                var inputString = trim(String(string));
                var result = origParseFloat(inputString);
                return result === 0 && strSlice(inputString, 0, 1) === '-' ? -0 : result;
            };
        }(parseFloat));
    }

    if (String(new RangeError('test')) !== 'RangeError: test') {
        var errorToStringShim = function toString() {
            if (typeof this === 'undefined' || this === null) {
                throw new TypeError("can't convert " + this + ' to object');
            }
            var name = this.name;
            if (typeof name === 'undefined') {
                name = 'Error';
            } else if (typeof name !== 'string') {
                name = $String(name);
            }
            var msg = this.message;
            if (typeof msg === 'undefined') {
                msg = '';
            } else if (typeof msg !== 'string') {
                msg = $String(msg);
            }
            if (!name) {
                return msg;
            }
            if (!msg) {
                return name;
            }
            return name + ': ' + msg;
        };
        // can't use defineProperties here because of toString enumeration issue in IE <= 8
        Error.prototype.toString = errorToStringShim;
    }

    if (supportsDescriptors) {
        var ensureNonEnumerable = function (obj, prop) {
            if (isEnum(obj, prop)) {
                var desc = Object.getOwnPropertyDescriptor(obj, prop);
                if (desc.configurable) {
                    desc.enumerable = false;
                    Object.defineProperty(obj, prop, desc);
                }
            }
        };
        ensureNonEnumerable(Error.prototype, 'message');
        if (Error.prototype.message !== '') {
            Error.prototype.message = '';
        }
        ensureNonEnumerable(Error.prototype, 'name');
    }

    if (String(/a/mig) !== '/a/gim') {
        var regexToString = function toString() {
            var str = '/' + this.source + '/';
            if (this.global) {
                str += 'g';
            }
            if (this.ignoreCase) {
                str += 'i';
            }
            if (this.multiline) {
                str += 'm';
            }
            return str;
        };
        // can't use defineProperties here because of toString enumeration issue in IE <= 8
        RegExp.prototype.toString = regexToString;
    }
}));


/***/ }),

/***/ "./node_modules/es6-shim/es6-shim.js":
/*!*******************************************!*\
  !*** ./node_modules/es6-shim/es6-shim.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * https://github.com/paulmillr/es6-shim
 * @license es6-shim Copyright 2013-2016 by Paul Miller (http://paulmillr.com)
 *   and contributors,  MIT License
 * es6-shim: v0.35.4
 * see https://github.com/paulmillr/es6-shim/blob/0.35.3/LICENSE
 * Details and documentation:
 * https://github.com/paulmillr/es6-shim/
 */

// UMD (Universal Module Definition)
// see https://github.com/umdjs/umd/blob/master/returnExports.js
(function (root, factory) {
  /*global define */
  if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(this, function () {
  'use strict';

  var _apply = Function.call.bind(Function.apply);
  var _call = Function.call.bind(Function.call);
  var isArray = Array.isArray;
  var keys = Object.keys;

  var not = function notThunker(func) {
    return function notThunk() {
      return !_apply(func, this, arguments);
    };
  };
  var throwsError = function (func) {
    try {
      func();
      return false;
    } catch (e) {
      return true;
    }
  };
  var valueOrFalseIfThrows = function valueOrFalseIfThrows(func) {
    try {
      return func();
    } catch (e) {
      return false;
    }
  };

  var isCallableWithoutNew = not(throwsError);
  var arePropertyDescriptorsSupported = function () {
    // if Object.defineProperty exists but throws, it's IE 8
    return !throwsError(function () {
      return Object.defineProperty({}, 'x', { get: function () { } }); // eslint-disable-line getter-return
    });
  };
  var supportsDescriptors = !!Object.defineProperty && arePropertyDescriptorsSupported();
  var functionsHaveNames = (function foo() {}).name === 'foo'; // eslint-disable-line no-extra-parens

  var _forEach = Function.call.bind(Array.prototype.forEach);
  var _reduce = Function.call.bind(Array.prototype.reduce);
  var _filter = Function.call.bind(Array.prototype.filter);
  var _some = Function.call.bind(Array.prototype.some);

  var defineProperty = function (object, name, value, force) {
    if (!force && name in object) { return; }
    if (supportsDescriptors) {
      Object.defineProperty(object, name, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: value
      });
    } else {
      object[name] = value;
    }
  };

  // Define configurable, writable and non-enumerable props
  // if they don’t exist.
  var defineProperties = function (object, map, forceOverride) {
    _forEach(keys(map), function (name) {
      var method = map[name];
      defineProperty(object, name, method, !!forceOverride);
    });
  };

  var _toString = Function.call.bind(Object.prototype.toString);
  var isCallable =  false ? 0 : function IsCallableFast(x) { return typeof x === 'function'; };

  var Value = {
    getter: function (object, name, getter) {
      if (!supportsDescriptors) {
        throw new TypeError('getters require true ES5 support');
      }
      Object.defineProperty(object, name, {
        configurable: true,
        enumerable: false,
        get: getter
      });
    },
    proxy: function (originalObject, key, targetObject) {
      if (!supportsDescriptors) {
        throw new TypeError('getters require true ES5 support');
      }
      var originalDescriptor = Object.getOwnPropertyDescriptor(originalObject, key);
      Object.defineProperty(targetObject, key, {
        configurable: originalDescriptor.configurable,
        enumerable: originalDescriptor.enumerable,
        get: function getKey() { return originalObject[key]; },
        set: function setKey(value) { originalObject[key] = value; }
      });
    },
    redefine: function (object, property, newValue) {
      if (supportsDescriptors) {
        var descriptor = Object.getOwnPropertyDescriptor(object, property);
        descriptor.value = newValue;
        Object.defineProperty(object, property, descriptor);
      } else {
        object[property] = newValue;
      }
    },
    defineByDescriptor: function (object, property, descriptor) {
      if (supportsDescriptors) {
        Object.defineProperty(object, property, descriptor);
      } else if ('value' in descriptor) {
        object[property] = descriptor.value;
      }
    },
    preserveToString: function (target, source) {
      if (source && isCallable(source.toString)) {
        defineProperty(target, 'toString', source.toString.bind(source), true);
      }
    }
  };

  // Simple shim for Object.create on ES3 browsers
  // (unlike real shim, no attempt to support `prototype === null`)
  var create = Object.create || function (prototype, properties) {
    var Prototype = function Prototype() {};
    Prototype.prototype = prototype;
    var object = new Prototype();
    if (typeof properties !== 'undefined') {
      keys(properties).forEach(function (key) {
        Value.defineByDescriptor(object, key, properties[key]);
      });
    }
    return object;
  };

  var supportsSubclassing = function (C, f) {
    if (!Object.setPrototypeOf) { return false; /* skip test on IE < 11 */ }
    return valueOrFalseIfThrows(function () {
      var Sub = function Subclass(arg) {
        var o = new C(arg);
        Object.setPrototypeOf(o, Subclass.prototype);
        return o;
      };
      Object.setPrototypeOf(Sub, C);
      Sub.prototype = create(C.prototype, {
        constructor: { value: Sub }
      });
      return f(Sub);
    });
  };

  var getGlobal = function () {
    /* global self, window */
    // the only reliable means to get the global object is
    // `Function('return this')()`
    // However, this causes CSP violations in Chrome apps.
    if (typeof self !== 'undefined') { return self; }
    if (typeof window !== 'undefined') { return window; }
    if (typeof __webpack_require__.g !== 'undefined') { return __webpack_require__.g; }
    throw new Error('unable to locate global object');
  };

  var globals = getGlobal();
  var globalIsFinite = globals.isFinite;
  var _indexOf = Function.call.bind(String.prototype.indexOf);
  var _arrayIndexOfApply = Function.apply.bind(Array.prototype.indexOf);
  var _concat = Function.call.bind(Array.prototype.concat);
  // var _sort = Function.call.bind(Array.prototype.sort);
  var _strSlice = Function.call.bind(String.prototype.slice);
  var _push = Function.call.bind(Array.prototype.push);
  var _pushApply = Function.apply.bind(Array.prototype.push);
  var _join = Function.call.bind(Array.prototype.join);
  var _shift = Function.call.bind(Array.prototype.shift);
  var _max = Math.max;
  var _min = Math.min;
  var _floor = Math.floor;
  var _abs = Math.abs;
  var _exp = Math.exp;
  var _log = Math.log;
  var _sqrt = Math.sqrt;
  var _hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
  var ArrayIterator; // make our implementation private
  var noop = function () {};

  var OrigMap = globals.Map;
  var origMapDelete = OrigMap && OrigMap.prototype['delete'];
  var origMapGet = OrigMap && OrigMap.prototype.get;
  var origMapHas = OrigMap && OrigMap.prototype.has;
  var origMapSet = OrigMap && OrigMap.prototype.set;

  var Symbol = globals.Symbol || {};
  var symbolSpecies = Symbol.species || '@@species';

  var numberIsNaN = Number.isNaN || function isNaN(value) {
    // NaN !== NaN, but they are identical.
    // NaNs are the only non-reflexive value, i.e., if x !== x,
    // then x is NaN.
    // isNaN is broken: it converts its argument to number, so
    // isNaN('foo') => true
    return value !== value;
  };
  var numberIsFinite = Number.isFinite || function isFinite(value) {
    return typeof value === 'number' && globalIsFinite(value);
  };
  var _sign = isCallable(Math.sign) ? Math.sign : function sign(value) {
    var number = Number(value);
    if (number === 0) { return number; }
    if (numberIsNaN(number)) { return number; }
    return number < 0 ? -1 : 1;
  };
  var _log1p = function log1p(value) {
    var x = Number(value);
    if (x < -1 || numberIsNaN(x)) { return NaN; }
    if (x === 0 || x === Infinity) { return x; }
    if (x === -1) { return -Infinity; }

    return (1 + x) - 1 === 0 ? x : x * (_log(1 + x) / ((1 + x) - 1));
  };

  // taken directly from https://github.com/ljharb/is-arguments/blob/master/index.js
  // can be replaced with require('is-arguments') if we ever use a build process instead
  var isStandardArguments = function isArguments(value) {
    return _toString(value) === '[object Arguments]';
  };
  var isLegacyArguments = function isArguments(value) {
    return value !== null &&
      typeof value === 'object' &&
      typeof value.length === 'number' &&
      value.length >= 0 &&
      _toString(value) !== '[object Array]' &&
      _toString(value.callee) === '[object Function]';
  };
  var isArguments = isStandardArguments(arguments) ? isStandardArguments : isLegacyArguments;

  var Type = {
    primitive: function (x) { return x === null || (typeof x !== 'function' && typeof x !== 'object'); },
    string: function (x) { return _toString(x) === '[object String]'; },
    regex: function (x) { return _toString(x) === '[object RegExp]'; },
    symbol: function (x) {
      return typeof globals.Symbol === 'function' && typeof x === 'symbol';
    }
  };

  var overrideNative = function overrideNative(object, property, replacement) {
    var original = object[property];
    defineProperty(object, property, replacement, true);
    Value.preserveToString(object[property], original);
  };

  // eslint-disable-next-line no-restricted-properties
  var hasSymbols = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' && Type.symbol(Symbol());

  // This is a private name in the es6 spec, equal to '[Symbol.iterator]'
  // we're going to use an arbitrary _-prefixed name to make our shims
  // work properly with each other, even though we don't have full Iterator
  // support.  That is, `Array.from(map.keys())` will work, but we don't
  // pretend to export a "real" Iterator interface.
  var $iterator$ = Type.symbol(Symbol.iterator) ? Symbol.iterator : '_es6-shim iterator_';
  // Firefox ships a partial implementation using the name @@iterator.
  // https://bugzilla.mozilla.org/show_bug.cgi?id=907077#c14
  // So use that name if we detect it.
  if (globals.Set && typeof new globals.Set()['@@iterator'] === 'function') {
    $iterator$ = '@@iterator';
  }

  // Reflect
  if (!globals.Reflect) {
    defineProperty(globals, 'Reflect', {}, true);
  }
  var Reflect = globals.Reflect;

  var $String = String;

  /* global document */
  var domAll = (typeof document === 'undefined' || !document) ? null : document.all;
  var isNullOrUndefined = domAll == null ? function isNullOrUndefined(x) {
    return x == null;
  } : function isNullOrUndefinedAndNotDocumentAll(x) {
    return x == null && x !== domAll;
  };

  var ES = {
    // http://www.ecma-international.org/ecma-262/6.0/#sec-call
    Call: function Call(F, V) {
      var args = arguments.length > 2 ? arguments[2] : [];
      if (!ES.IsCallable(F)) {
        throw new TypeError(F + ' is not a function');
      }
      return _apply(F, V, args);
    },

    RequireObjectCoercible: function (x, optMessage) {
      if (isNullOrUndefined(x)) {
        throw new TypeError(optMessage || 'Cannot call method on ' + x);
      }
      return x;
    },

    // This might miss the "(non-standard exotic and does not implement
    // [[Call]])" case from
    // http://www.ecma-international.org/ecma-262/6.0/#sec-typeof-operator-runtime-semantics-evaluation
    // but we can't find any evidence these objects exist in practice.
    // If we find some in the future, you could test `Object(x) === x`,
    // which is reliable according to
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toobject
    // but is not well optimized by runtimes and creates an object
    // whenever it returns false, and thus is very slow.
    TypeIsObject: function (x) {
      if (x === void 0 || x === null || x === true || x === false) {
        return false;
      }
      return typeof x === 'function' || typeof x === 'object' || x === domAll;
    },

    ToObject: function (o, optMessage) {
      return Object(ES.RequireObjectCoercible(o, optMessage));
    },

    IsCallable: isCallable,

    IsConstructor: function (x) {
      // We can't tell callables from constructors in ES5
      return ES.IsCallable(x);
    },

    ToInt32: function (x) {
      return ES.ToNumber(x) >> 0;
    },

    ToUint32: function (x) {
      return ES.ToNumber(x) >>> 0;
    },

    ToNumber: function (value) {
      if (hasSymbols && _toString(value) === '[object Symbol]') {
        throw new TypeError('Cannot convert a Symbol value to a number');
      }
      return +value;
    },

    ToInteger: function (value) {
      var number = ES.ToNumber(value);
      if (numberIsNaN(number)) { return 0; }
      if (number === 0 || !numberIsFinite(number)) { return number; }
      return (number > 0 ? 1 : -1) * _floor(_abs(number));
    },

    ToLength: function (value) {
      var len = ES.ToInteger(value);
      if (len <= 0) { return 0; } // includes converting -0 to +0
      if (len > Number.MAX_SAFE_INTEGER) { return Number.MAX_SAFE_INTEGER; }
      return len;
    },

    SameValue: function (a, b) {
      if (a === b) {
        // 0 === -0, but they are not identical.
        if (a === 0) { return 1 / a === 1 / b; }
        return true;
      }
      return numberIsNaN(a) && numberIsNaN(b);
    },

    SameValueZero: function (a, b) {
      // same as SameValue except for SameValueZero(+0, -0) == true
      return (a === b) || (numberIsNaN(a) && numberIsNaN(b));
    },

    IsIterable: function (o) {
      return ES.TypeIsObject(o) && (typeof o[$iterator$] !== 'undefined' || isArguments(o));
    },

    GetIterator: function (o) {
      if (isArguments(o)) {
        // special case support for `arguments`
        return new ArrayIterator(o, 'value');
      }
      var itFn = ES.GetMethod(o, $iterator$);
      if (!ES.IsCallable(itFn)) {
        // Better diagnostics if itFn is null or undefined
        throw new TypeError('value is not an iterable');
      }
      var it = ES.Call(itFn, o);
      if (!ES.TypeIsObject(it)) {
        throw new TypeError('bad iterator');
      }
      return it;
    },

    GetMethod: function (o, p) {
      var func = ES.ToObject(o)[p];
      if (isNullOrUndefined(func)) {
        return void 0;
      }
      if (!ES.IsCallable(func)) {
        throw new TypeError('Method not callable: ' + p);
      }
      return func;
    },

    IteratorComplete: function (iterResult) {
      return !!iterResult.done;
    },

    IteratorClose: function (iterator, completionIsThrow) {
      var returnMethod = ES.GetMethod(iterator, 'return');
      if (returnMethod === void 0) {
        return;
      }
      var innerResult, innerException;
      try {
        innerResult = ES.Call(returnMethod, iterator);
      } catch (e) {
        innerException = e;
      }
      if (completionIsThrow) {
        return;
      }
      if (innerException) {
        throw innerException;
      }
      if (!ES.TypeIsObject(innerResult)) {
        throw new TypeError("Iterator's return method returned a non-object.");
      }
    },

    IteratorNext: function (it) {
      var result = arguments.length > 1 ? it.next(arguments[1]) : it.next();
      if (!ES.TypeIsObject(result)) {
        throw new TypeError('bad iterator');
      }
      return result;
    },

    IteratorStep: function (it) {
      var result = ES.IteratorNext(it);
      var done = ES.IteratorComplete(result);
      return done ? false : result;
    },

    Construct: function (C, args, newTarget, isES6internal) {
      var target = typeof newTarget === 'undefined' ? C : newTarget;

      if (!isES6internal && Reflect.construct) {
        // Try to use Reflect.construct if available
        return Reflect.construct(C, args, target);
      }
      // OK, we have to fake it.  This will only work if the
      // C.[[ConstructorKind]] == "base" -- but that's the only
      // kind we can make in ES5 code anyway.

      // OrdinaryCreateFromConstructor(target, "%ObjectPrototype%")
      var proto = target.prototype;
      if (!ES.TypeIsObject(proto)) {
        proto = Object.prototype;
      }
      var obj = create(proto);
      // Call the constructor.
      var result = ES.Call(C, obj, args);
      return ES.TypeIsObject(result) ? result : obj;
    },

    SpeciesConstructor: function (O, defaultConstructor) {
      var C = O.constructor;
      if (C === void 0) {
        return defaultConstructor;
      }
      if (!ES.TypeIsObject(C)) {
        throw new TypeError('Bad constructor');
      }
      var S = C[symbolSpecies];
      if (isNullOrUndefined(S)) {
        return defaultConstructor;
      }
      if (!ES.IsConstructor(S)) {
        throw new TypeError('Bad @@species');
      }
      return S;
    },

    CreateHTML: function (string, tag, attribute, value) {
      var S = ES.ToString(string);
      var p1 = '<' + tag;
      if (attribute !== '') {
        var V = ES.ToString(value);
        var escapedV = V.replace(/"/g, '&quot;');
        p1 += ' ' + attribute + '="' + escapedV + '"';
      }
      var p2 = p1 + '>';
      var p3 = p2 + S;
      return p3 + '</' + tag + '>';
    },

    IsRegExp: function IsRegExp(argument) {
      if (!ES.TypeIsObject(argument)) {
        return false;
      }
      var isRegExp = argument[Symbol.match];
      if (typeof isRegExp !== 'undefined') {
        return !!isRegExp;
      }
      return Type.regex(argument);
    },

    ToString: function ToString(string) {
      if (hasSymbols && _toString(string) === '[object Symbol]') {
        throw new TypeError('Cannot convert a Symbol value to a number');
      }
      return $String(string);
    }
  };

  // Well-known Symbol shims
  if (supportsDescriptors && hasSymbols) {
    var defineWellKnownSymbol = function defineWellKnownSymbol(name) {
      if (Type.symbol(Symbol[name])) {
        return Symbol[name];
      }
      // eslint-disable-next-line no-restricted-properties
      var sym = Symbol['for']('Symbol.' + name);
      Object.defineProperty(Symbol, name, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: sym
      });
      return sym;
    };
    if (!Type.symbol(Symbol.search)) {
      var symbolSearch = defineWellKnownSymbol('search');
      var originalSearch = String.prototype.search;
      defineProperty(RegExp.prototype, symbolSearch, function search(string) {
        return ES.Call(originalSearch, string, [this]);
      });
      var searchShim = function search(regexp) {
        var O = ES.RequireObjectCoercible(this);
        if (!isNullOrUndefined(regexp)) {
          var searcher = ES.GetMethod(regexp, symbolSearch);
          if (typeof searcher !== 'undefined') {
            return ES.Call(searcher, regexp, [O]);
          }
        }
        return ES.Call(originalSearch, O, [ES.ToString(regexp)]);
      };
      overrideNative(String.prototype, 'search', searchShim);
    }
    if (!Type.symbol(Symbol.replace)) {
      var symbolReplace = defineWellKnownSymbol('replace');
      var originalReplace = String.prototype.replace;
      defineProperty(RegExp.prototype, symbolReplace, function replace(string, replaceValue) {
        return ES.Call(originalReplace, string, [this, replaceValue]);
      });
      var replaceShim = function replace(searchValue, replaceValue) {
        var O = ES.RequireObjectCoercible(this);
        if (!isNullOrUndefined(searchValue)) {
          var replacer = ES.GetMethod(searchValue, symbolReplace);
          if (typeof replacer !== 'undefined') {
            return ES.Call(replacer, searchValue, [O, replaceValue]);
          }
        }
        return ES.Call(originalReplace, O, [ES.ToString(searchValue), replaceValue]);
      };
      overrideNative(String.prototype, 'replace', replaceShim);
    }
    if (!Type.symbol(Symbol.split)) {
      var symbolSplit = defineWellKnownSymbol('split');
      var originalSplit = String.prototype.split;
      defineProperty(RegExp.prototype, symbolSplit, function split(string, limit) {
        return ES.Call(originalSplit, string, [this, limit]);
      });
      var splitShim = function split(separator, limit) {
        var O = ES.RequireObjectCoercible(this);
        if (!isNullOrUndefined(separator)) {
          var splitter = ES.GetMethod(separator, symbolSplit);
          if (typeof splitter !== 'undefined') {
            return ES.Call(splitter, separator, [O, limit]);
          }
        }
        return ES.Call(originalSplit, O, [ES.ToString(separator), limit]);
      };
      overrideNative(String.prototype, 'split', splitShim);
    }
    var symbolMatchExists = Type.symbol(Symbol.match);
    var stringMatchIgnoresSymbolMatch = symbolMatchExists && (function () {
      // Firefox 41, through Nightly 45 has Symbol.match, but String#match ignores it.
      // Firefox 40 and below have Symbol.match but String#match works fine.
      var o = {};
      o[Symbol.match] = function () { return 42; };
      return 'a'.match(o) !== 42;
    }());
    if (!symbolMatchExists || stringMatchIgnoresSymbolMatch) {
      var symbolMatch = defineWellKnownSymbol('match');

      var originalMatch = String.prototype.match;
      defineProperty(RegExp.prototype, symbolMatch, function match(string) {
        return ES.Call(originalMatch, string, [this]);
      });

      var matchShim = function match(regexp) {
        var O = ES.RequireObjectCoercible(this);
        if (!isNullOrUndefined(regexp)) {
          var matcher = ES.GetMethod(regexp, symbolMatch);
          if (typeof matcher !== 'undefined') {
            return ES.Call(matcher, regexp, [O]);
          }
        }
        return ES.Call(originalMatch, O, [ES.ToString(regexp)]);
      };
      overrideNative(String.prototype, 'match', matchShim);
    }
  }

  var wrapConstructor = function wrapConstructor(original, replacement, keysToSkip) {
    Value.preserveToString(replacement, original);
    if (Object.setPrototypeOf) {
      // sets up proper prototype chain where possible
      Object.setPrototypeOf(original, replacement);
    }
    if (supportsDescriptors) {
      _forEach(Object.getOwnPropertyNames(original), function (key) {
        if (key in noop || keysToSkip[key]) { return; }
        Value.proxy(original, key, replacement);
      });
    } else {
      _forEach(Object.keys(original), function (key) {
        if (key in noop || keysToSkip[key]) { return; }
        replacement[key] = original[key];
      });
    }
    replacement.prototype = original.prototype;
    Value.redefine(original.prototype, 'constructor', replacement);
  };

  var defaultSpeciesGetter = function () { return this; };
  var addDefaultSpecies = function (C) {
    if (supportsDescriptors && !_hasOwnProperty(C, symbolSpecies)) {
      Value.getter(C, symbolSpecies, defaultSpeciesGetter);
    }
  };

  var addIterator = function (prototype, impl) {
    var implementation = impl || function iterator() { return this; };
    defineProperty(prototype, $iterator$, implementation);
    if (!prototype[$iterator$] && Type.symbol($iterator$)) {
      // implementations are buggy when $iterator$ is a Symbol
      prototype[$iterator$] = implementation;
    }
  };

  var createDataProperty = function createDataProperty(object, name, value) {
    if (supportsDescriptors) {
      Object.defineProperty(object, name, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: value
      });
    } else {
      object[name] = value;
    }
  };
  var createDataPropertyOrThrow = function createDataPropertyOrThrow(object, name, value) {
    createDataProperty(object, name, value);
    if (!ES.SameValue(object[name], value)) {
      throw new TypeError('property is nonconfigurable');
    }
  };

  var emulateES6construct = function (o, defaultNewTarget, defaultProto, slots) {
    // This is an es5 approximation to es6 construct semantics.  in es6,
    // 'new Foo' invokes Foo.[[Construct]] which (for almost all objects)
    // just sets the internal variable NewTarget (in es6 syntax `new.target`)
    // to Foo and then returns Foo().

    // Many ES6 object then have constructors of the form:
    // 1. If NewTarget is undefined, throw a TypeError exception
    // 2. Let xxx by OrdinaryCreateFromConstructor(NewTarget, yyy, zzz)

    // So we're going to emulate those first two steps.
    if (!ES.TypeIsObject(o)) {
      throw new TypeError('Constructor requires `new`: ' + defaultNewTarget.name);
    }
    var proto = defaultNewTarget.prototype;
    if (!ES.TypeIsObject(proto)) {
      proto = defaultProto;
    }
    var obj = create(proto);
    for (var name in slots) {
      if (_hasOwnProperty(slots, name)) {
        var value = slots[name];
        defineProperty(obj, name, value, true);
      }
    }
    return obj;
  };

  // Firefox 31 reports this function's length as 0
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1062484
  if (String.fromCodePoint && String.fromCodePoint.length !== 1) {
    var originalFromCodePoint = String.fromCodePoint;
    overrideNative(String, 'fromCodePoint', function fromCodePoint(codePoints) {
      return ES.Call(originalFromCodePoint, this, arguments);
    });
  }

  var StringShims = {
    fromCodePoint: function fromCodePoint(codePoints) {
      var result = [];
      var next;
      for (var i = 0, length = arguments.length; i < length; i++) {
        next = Number(arguments[i]);
        if (!ES.SameValue(next, ES.ToInteger(next)) || next < 0 || next > 0x10FFFF) {
          throw new RangeError('Invalid code point ' + next);
        }

        if (next < 0x10000) {
          _push(result, String.fromCharCode(next));
        } else {
          next -= 0x10000;
          _push(result, String.fromCharCode((next >> 10) + 0xD800));
          _push(result, String.fromCharCode((next % 0x400) + 0xDC00));
        }
      }
      return _join(result, '');
    },

    raw: function raw(template) {
      var numberOfSubstitutions = arguments.length - 1;
      var cooked = ES.ToObject(template, 'bad template');
      var raw = ES.ToObject(cooked.raw, 'bad raw value');
      var len = raw.length;
      var literalSegments = ES.ToLength(len);
      if (literalSegments <= 0) {
        return '';
      }

      var stringElements = [];
      var nextIndex = 0;
      var nextKey, next, nextSeg, nextSub;
      while (nextIndex < literalSegments) {
        nextKey = ES.ToString(nextIndex);
        nextSeg = ES.ToString(raw[nextKey]);
        _push(stringElements, nextSeg);
        if (nextIndex + 1 >= literalSegments) {
          break;
        }
        next = nextIndex + 1 < arguments.length ? arguments[nextIndex + 1] : '';
        nextSub = ES.ToString(next);
        _push(stringElements, nextSub);
        nextIndex += 1;
      }
      return _join(stringElements, '');
    }
  };
  if (String.raw && String.raw({ raw: { 0: 'x', 1: 'y', length: 2 } }) !== 'xy') {
    // IE 11 TP has a broken String.raw implementation
    overrideNative(String, 'raw', StringShims.raw);
  }
  defineProperties(String, StringShims);

  // Fast repeat, uses the `Exponentiation by squaring` algorithm.
  // Perf: http://jsperf.com/string-repeat2/2
  var stringRepeat = function repeat(s, times) {
    if (times < 1) { return ''; }
    if (times % 2) { return repeat(s, times - 1) + s; }
    var half = repeat(s, times / 2);
    return half + half;
  };
  var stringMaxLength = Infinity;

  var StringPrototypeShims = {
    repeat: function repeat(times) {
      var thisStr = ES.ToString(ES.RequireObjectCoercible(this));
      var numTimes = ES.ToInteger(times);
      if (numTimes < 0 || numTimes >= stringMaxLength) {
        throw new RangeError('repeat count must be less than infinity and not overflow maximum string size');
      }
      return stringRepeat(thisStr, numTimes);
    },

    startsWith: function startsWith(searchString) {
      var S = ES.ToString(ES.RequireObjectCoercible(this));
      if (ES.IsRegExp(searchString)) {
        throw new TypeError('Cannot call method "startsWith" with a regex');
      }
      var searchStr = ES.ToString(searchString);
      var position;
      if (arguments.length > 1) {
        position = arguments[1];
      }
      var start = _max(ES.ToInteger(position), 0);
      return _strSlice(S, start, start + searchStr.length) === searchStr;
    },

    endsWith: function endsWith(searchString) {
      var S = ES.ToString(ES.RequireObjectCoercible(this));
      if (ES.IsRegExp(searchString)) {
        throw new TypeError('Cannot call method "endsWith" with a regex');
      }
      var searchStr = ES.ToString(searchString);
      var len = S.length;
      var endPosition;
      if (arguments.length > 1) {
        endPosition = arguments[1];
      }
      var pos = typeof endPosition === 'undefined' ? len : ES.ToInteger(endPosition);
      var end = _min(_max(pos, 0), len);
      return _strSlice(S, end - searchStr.length, end) === searchStr;
    },

    includes: function includes(searchString) {
      if (ES.IsRegExp(searchString)) {
        throw new TypeError('"includes" does not accept a RegExp');
      }
      var searchStr = ES.ToString(searchString);
      var position;
      if (arguments.length > 1) {
        position = arguments[1];
      }
      // Somehow this trick makes method 100% compat with the spec.
      return _indexOf(this, searchStr, position) !== -1;
    },

    codePointAt: function codePointAt(pos) {
      var thisStr = ES.ToString(ES.RequireObjectCoercible(this));
      var position = ES.ToInteger(pos);
      var length = thisStr.length;
      if (position >= 0 && position < length) {
        var first = thisStr.charCodeAt(position);
        var isEnd = position + 1 === length;
        if (first < 0xD800 || first > 0xDBFF || isEnd) { return first; }
        var second = thisStr.charCodeAt(position + 1);
        if (second < 0xDC00 || second > 0xDFFF) { return first; }
        return ((first - 0xD800) * 1024) + (second - 0xDC00) + 0x10000;
      }
    }
  };
  if (String.prototype.includes && 'a'.includes('a', Infinity) !== false) {
    overrideNative(String.prototype, 'includes', StringPrototypeShims.includes);
  }

  if (String.prototype.startsWith && String.prototype.endsWith) {
    var startsWithRejectsRegex = throwsError(function () {
      /* throws if spec-compliant */
      return '/a/'.startsWith(/a/);
    });
    var startsWithHandlesInfinity = valueOrFalseIfThrows(function () {
      return 'abc'.startsWith('a', Infinity) === false;
    });
    if (!startsWithRejectsRegex || !startsWithHandlesInfinity) {
      // Firefox (< 37?) and IE 11 TP have a noncompliant startsWith implementation
      overrideNative(String.prototype, 'startsWith', StringPrototypeShims.startsWith);
      overrideNative(String.prototype, 'endsWith', StringPrototypeShims.endsWith);
    }
  }
  if (hasSymbols) {
    var startsWithSupportsSymbolMatch = valueOrFalseIfThrows(function () {
      var re = /a/;
      re[Symbol.match] = false;
      return '/a/'.startsWith(re);
    });
    if (!startsWithSupportsSymbolMatch) {
      overrideNative(String.prototype, 'startsWith', StringPrototypeShims.startsWith);
    }
    var endsWithSupportsSymbolMatch = valueOrFalseIfThrows(function () {
      var re = /a/;
      re[Symbol.match] = false;
      return '/a/'.endsWith(re);
    });
    if (!endsWithSupportsSymbolMatch) {
      overrideNative(String.prototype, 'endsWith', StringPrototypeShims.endsWith);
    }
    var includesSupportsSymbolMatch = valueOrFalseIfThrows(function () {
      var re = /a/;
      re[Symbol.match] = false;
      return '/a/'.includes(re);
    });
    if (!includesSupportsSymbolMatch) {
      overrideNative(String.prototype, 'includes', StringPrototypeShims.includes);
    }
  }

  defineProperties(String.prototype, StringPrototypeShims);

  // whitespace from: http://es5.github.io/#x15.5.4.20
  // implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324
  var ws = [
    '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003',
    '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028',
    '\u2029\uFEFF'
  ].join('');
  var trimRegexp = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');
  var trimShim = function trim() {
    return ES.ToString(ES.RequireObjectCoercible(this)).replace(trimRegexp, '');
  };
  var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
  var nonWSregex = new RegExp('[' + nonWS + ']', 'g');
  var isBadHexRegex = /^[-+]0x[0-9a-f]+$/i;
  var hasStringTrimBug = nonWS.trim().length !== nonWS.length;
  defineProperty(String.prototype, 'trim', trimShim, hasStringTrimBug);

  // Given an argument x, it will return an IteratorResult object,
  // with value set to x and done to false.
  // Given no arguments, it will return an iterator completion object.
  var iteratorResult = function (x) {
    return { value: x, done: arguments.length === 0 };
  };

  // see http://www.ecma-international.org/ecma-262/6.0/#sec-string.prototype-@@iterator
  var StringIterator = function (s) {
    ES.RequireObjectCoercible(s);
    this._s = ES.ToString(s);
    this._i = 0;
  };
  StringIterator.prototype.next = function () {
    var s = this._s;
    var i = this._i;
    if (typeof s === 'undefined' || i >= s.length) {
      this._s = void 0;
      return iteratorResult();
    }
    var first = s.charCodeAt(i);
    var second, len;
    if (first < 0xD800 || first > 0xDBFF || (i + 1) === s.length) {
      len = 1;
    } else {
      second = s.charCodeAt(i + 1);
      len = (second < 0xDC00 || second > 0xDFFF) ? 1 : 2;
    }
    this._i = i + len;
    return iteratorResult(s.substr(i, len));
  };
  addIterator(StringIterator.prototype);
  addIterator(String.prototype, function () {
    return new StringIterator(this);
  });

  var ArrayShims = {
    from: function from(items) {
      var C = this;
      var mapFn;
      if (arguments.length > 1) {
        mapFn = arguments[1];
      }
      var mapping, T;
      if (typeof mapFn === 'undefined') {
        mapping = false;
      } else {
        if (!ES.IsCallable(mapFn)) {
          throw new TypeError('Array.from: when provided, the second argument must be a function');
        }
        if (arguments.length > 2) {
          T = arguments[2];
        }
        mapping = true;
      }

      // Note that that Arrays will use ArrayIterator:
      // https://bugs.ecmascript.org/show_bug.cgi?id=2416
      var usingIterator = typeof (isArguments(items) || ES.GetMethod(items, $iterator$)) !== 'undefined';

      var length, result, i;
      if (usingIterator) {
        result = ES.IsConstructor(C) ? Object(new C()) : [];
        var iterator = ES.GetIterator(items);
        var next, nextValue;

        i = 0;
        while (true) {
          next = ES.IteratorStep(iterator);
          if (next === false) {
            break;
          }
          nextValue = next.value;
          try {
            if (mapping) {
              nextValue = typeof T === 'undefined' ? mapFn(nextValue, i) : _call(mapFn, T, nextValue, i);
            }
            result[i] = nextValue;
          } catch (e) {
            ES.IteratorClose(iterator, true);
            throw e;
          }
          i += 1;
        }
        length = i;
      } else {
        var arrayLike = ES.ToObject(items);
        length = ES.ToLength(arrayLike.length);
        result = ES.IsConstructor(C) ? Object(new C(length)) : new Array(length);
        var value;
        for (i = 0; i < length; ++i) {
          value = arrayLike[i];
          if (mapping) {
            value = typeof T === 'undefined' ? mapFn(value, i) : _call(mapFn, T, value, i);
          }
          createDataPropertyOrThrow(result, i, value);
        }
      }

      result.length = length;
      return result;
    },

    of: function of() {
      var len = arguments.length;
      var C = this;
      var A = isArray(C) || !ES.IsCallable(C) ? new Array(len) : ES.Construct(C, [len]);
      for (var k = 0; k < len; ++k) {
        createDataPropertyOrThrow(A, k, arguments[k]);
      }
      A.length = len;
      return A;
    }
  };
  defineProperties(Array, ArrayShims);
  addDefaultSpecies(Array);

  // Our ArrayIterator is private; see
  // https://github.com/paulmillr/es6-shim/issues/252
  ArrayIterator = function (array, kind) {
    this.i = 0;
    this.array = array;
    this.kind = kind;
  };

  defineProperties(ArrayIterator.prototype, {
    next: function () {
      var i = this.i;
      var array = this.array;
      if (!(this instanceof ArrayIterator)) {
        throw new TypeError('Not an ArrayIterator');
      }
      if (typeof array !== 'undefined') {
        var len = ES.ToLength(array.length);
        if (i < len) {
        //for (; i < len; i++) {
          var kind = this.kind;
          var retval;
          if (kind === 'key') {
            retval = i;
          } else if (kind === 'value') {
            retval = array[i];
          } else if (kind === 'entry') {
            retval = [i, array[i]];
          }
          this.i = i + 1;
          return iteratorResult(retval);
        }
      }
      this.array = void 0;
      return iteratorResult();
    }
  });
  addIterator(ArrayIterator.prototype);

  /*
  var orderKeys = function orderKeys(a, b) {
    var aNumeric = String(ES.ToInteger(a)) === a;
    var bNumeric = String(ES.ToInteger(b)) === b;
    if (aNumeric && bNumeric) {
      return b - a;
    } else if (aNumeric && !bNumeric) {
      return -1;
    } else if (!aNumeric && bNumeric) {
      return 1;
    } else {
      return a.localeCompare(b);
    }
  };

  var getAllKeys = function getAllKeys(object) {
    var ownKeys = [];
    var keys = [];

    for (var key in object) {
      _push(_hasOwnProperty(object, key) ? ownKeys : keys, key);
    }
    _sort(ownKeys, orderKeys);
    _sort(keys, orderKeys);

    return _concat(ownKeys, keys);
  };
  */

  // note: this is positioned here because it depends on ArrayIterator
  var arrayOfSupportsSubclassing = Array.of === ArrayShims.of || (function () {
    // Detects a bug in Webkit nightly r181886
    var Foo = function Foo(len) { this.length = len; };
    Foo.prototype = [];
    var fooArr = Array.of.apply(Foo, [1, 2]);
    return fooArr instanceof Foo && fooArr.length === 2;
  }());
  if (!arrayOfSupportsSubclassing) {
    overrideNative(Array, 'of', ArrayShims.of);
  }

  var ArrayPrototypeShims = {
    copyWithin: function copyWithin(target, start) {
      var o = ES.ToObject(this);
      var len = ES.ToLength(o.length);
      var relativeTarget = ES.ToInteger(target);
      var relativeStart = ES.ToInteger(start);
      var to = relativeTarget < 0 ? _max(len + relativeTarget, 0) : _min(relativeTarget, len);
      var from = relativeStart < 0 ? _max(len + relativeStart, 0) : _min(relativeStart, len);
      var end;
      if (arguments.length > 2) {
        end = arguments[2];
      }
      var relativeEnd = typeof end === 'undefined' ? len : ES.ToInteger(end);
      var finalItem = relativeEnd < 0 ? _max(len + relativeEnd, 0) : _min(relativeEnd, len);
      var count = _min(finalItem - from, len - to);
      var direction = 1;
      if (from < to && to < (from + count)) {
        direction = -1;
        from += count - 1;
        to += count - 1;
      }
      while (count > 0) {
        if (from in o) {
          o[to] = o[from];
        } else {
          delete o[to];
        }
        from += direction;
        to += direction;
        count -= 1;
      }
      return o;
    },

    fill: function fill(value) {
      var start;
      if (arguments.length > 1) {
        start = arguments[1];
      }
      var end;
      if (arguments.length > 2) {
        end = arguments[2];
      }
      var O = ES.ToObject(this);
      var len = ES.ToLength(O.length);
      start = ES.ToInteger(typeof start === 'undefined' ? 0 : start);
      end = ES.ToInteger(typeof end === 'undefined' ? len : end);

      var relativeStart = start < 0 ? _max(len + start, 0) : _min(start, len);
      var relativeEnd = end < 0 ? len + end : end;

      for (var i = relativeStart; i < len && i < relativeEnd; ++i) {
        O[i] = value;
      }
      return O;
    },

    find: function find(predicate) {
      var list = ES.ToObject(this);
      var length = ES.ToLength(list.length);
      if (!ES.IsCallable(predicate)) {
        throw new TypeError('Array#find: predicate must be a function');
      }
      var thisArg = arguments.length > 1 ? arguments[1] : null;
      for (var i = 0, value; i < length; i++) {
        value = list[i];
        if (thisArg) {
          if (_call(predicate, thisArg, value, i, list)) {
            return value;
          }
        } else if (predicate(value, i, list)) {
          return value;
        }
      }
    },

    findIndex: function findIndex(predicate) {
      var list = ES.ToObject(this);
      var length = ES.ToLength(list.length);
      if (!ES.IsCallable(predicate)) {
        throw new TypeError('Array#findIndex: predicate must be a function');
      }
      var thisArg = arguments.length > 1 ? arguments[1] : null;
      for (var i = 0; i < length; i++) {
        if (thisArg) {
          if (_call(predicate, thisArg, list[i], i, list)) {
            return i;
          }
        } else if (predicate(list[i], i, list)) {
          return i;
        }
      }
      return -1;
    },

    keys: function keys() {
      return new ArrayIterator(this, 'key');
    },

    values: function values() {
      return new ArrayIterator(this, 'value');
    },

    entries: function entries() {
      return new ArrayIterator(this, 'entry');
    }
  };
  // Safari 7.1 defines Array#keys and Array#entries natively,
  // but the resulting ArrayIterator objects don't have a "next" method.
  if (Array.prototype.keys && !ES.IsCallable([1].keys().next)) {
    delete Array.prototype.keys;
  }
  if (Array.prototype.entries && !ES.IsCallable([1].entries().next)) {
    delete Array.prototype.entries;
  }

  // Chrome 38 defines Array#keys and Array#entries, and Array#@@iterator, but not Array#values
  if (Array.prototype.keys && Array.prototype.entries && !Array.prototype.values && Array.prototype[$iterator$]) {
    defineProperties(Array.prototype, {
      values: Array.prototype[$iterator$]
    });
    if (Type.symbol(Symbol.unscopables)) {
      Array.prototype[Symbol.unscopables].values = true;
    }
  }
  // Chrome 40 defines Array#values with the incorrect name, although Array#{keys,entries} have the correct name
  if (functionsHaveNames && Array.prototype.values && Array.prototype.values.name !== 'values') {
    var originalArrayPrototypeValues = Array.prototype.values;
    overrideNative(Array.prototype, 'values', function values() { return ES.Call(originalArrayPrototypeValues, this, arguments); });
    defineProperty(Array.prototype, $iterator$, Array.prototype.values, true);
  }
  defineProperties(Array.prototype, ArrayPrototypeShims);

  if (1 / [true].indexOf(true, -0) < 0) {
    // indexOf when given a position arg of -0 should return +0.
    // https://github.com/tc39/ecma262/pull/316
    defineProperty(Array.prototype, 'indexOf', function indexOf(searchElement) {
      var value = _arrayIndexOfApply(this, arguments);
      if (value === 0 && (1 / value) < 0) {
        return 0;
      }
      return value;
    }, true);
  }

  addIterator(Array.prototype, function () { return this.values(); });
  // Chrome defines keys/values/entries on Array, but doesn't give us
  // any way to identify its iterator.  So add our own shimmed field.
  if (Object.getPrototypeOf) {
    addIterator(Object.getPrototypeOf([].values()));
  }

  // note: this is positioned here because it relies on Array#entries
  var arrayFromSwallowsNegativeLengths = (function () {
    // Detects a Firefox bug in v32
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1063993
    return valueOrFalseIfThrows(function () {
      return Array.from({ length: -1 }).length === 0;
    });
  }());
  var arrayFromHandlesIterables = (function () {
    // Detects a bug in Webkit nightly r181886
    var arr = Array.from([0].entries());
    return arr.length === 1 && isArray(arr[0]) && arr[0][0] === 0 && arr[0][1] === 0;
  }());
  if (!arrayFromSwallowsNegativeLengths || !arrayFromHandlesIterables) {
    overrideNative(Array, 'from', ArrayShims.from);
  }
  var arrayFromHandlesUndefinedMapFunction = (function () {
    // Microsoft Edge v0.11 throws if the mapFn argument is *provided* but undefined,
    // but the spec doesn't care if it's provided or not - undefined doesn't throw.
    return valueOrFalseIfThrows(function () {
      return Array.from([0], void 0);
    });
  }());
  if (!arrayFromHandlesUndefinedMapFunction) {
    var origArrayFrom = Array.from;
    overrideNative(Array, 'from', function from(items) {
      if (arguments.length > 1 && typeof arguments[1] !== 'undefined') {
        return ES.Call(origArrayFrom, this, arguments);
      } else {
        return _call(origArrayFrom, this, items);
      }
    });
  }

  var int32sAsOne = -(Math.pow(2, 32) - 1);
  var toLengthsCorrectly = function (method, reversed) {
    var obj = { length: int32sAsOne };
    obj[reversed ? (obj.length >>> 0) - 1 : 0] = true;
    return valueOrFalseIfThrows(function () {
      _call(method, obj, function () {
        // note: in nonconforming browsers, this will be called
        // -1 >>> 0 times, which is 4294967295, so the throw matters.
        throw new RangeError('should not reach here');
      }, []);
      return true;
    });
  };
  if (!toLengthsCorrectly(Array.prototype.forEach)) {
    var originalForEach = Array.prototype.forEach;
    overrideNative(Array.prototype, 'forEach', function forEach(callbackFn) {
      return ES.Call(originalForEach, this.length >= 0 ? this : [], arguments);
    });
  }
  if (!toLengthsCorrectly(Array.prototype.map)) {
    var originalMap = Array.prototype.map;
    overrideNative(Array.prototype, 'map', function map(callbackFn) {
      return ES.Call(originalMap, this.length >= 0 ? this : [], arguments);
    });
  }
  if (!toLengthsCorrectly(Array.prototype.filter)) {
    var originalFilter = Array.prototype.filter;
    overrideNative(Array.prototype, 'filter', function filter(callbackFn) {
      return ES.Call(originalFilter, this.length >= 0 ? this : [], arguments);
    });
  }
  if (!toLengthsCorrectly(Array.prototype.some)) {
    var originalSome = Array.prototype.some;
    overrideNative(Array.prototype, 'some', function some(callbackFn) {
      return ES.Call(originalSome, this.length >= 0 ? this : [], arguments);
    });
  }
  if (!toLengthsCorrectly(Array.prototype.every)) {
    var originalEvery = Array.prototype.every;
    overrideNative(Array.prototype, 'every', function every(callbackFn) {
      return ES.Call(originalEvery, this.length >= 0 ? this : [], arguments);
    });
  }
  if (!toLengthsCorrectly(Array.prototype.reduce)) {
    var originalReduce = Array.prototype.reduce;
    overrideNative(Array.prototype, 'reduce', function reduce(callbackFn) {
      return ES.Call(originalReduce, this.length >= 0 ? this : [], arguments);
    });
  }
  if (!toLengthsCorrectly(Array.prototype.reduceRight, true)) {
    var originalReduceRight = Array.prototype.reduceRight;
    overrideNative(Array.prototype, 'reduceRight', function reduceRight(callbackFn) {
      return ES.Call(originalReduceRight, this.length >= 0 ? this : [], arguments);
    });
  }

  var lacksOctalSupport = Number('0o10') !== 8;
  var lacksBinarySupport = Number('0b10') !== 2;
  var trimsNonWhitespace = _some(nonWS, function (c) {
    return Number(c + 0 + c) === 0;
  });
  if (lacksOctalSupport || lacksBinarySupport || trimsNonWhitespace) {
    var OrigNumber = Number;
    var binaryRegex = /^0b[01]+$/i;
    var octalRegex = /^0o[0-7]+$/i;
    // Note that in IE 8, RegExp.prototype.test doesn't seem to exist: ie, "test" is an own property of regexes. wtf.
    var isBinary = binaryRegex.test.bind(binaryRegex);
    var isOctal = octalRegex.test.bind(octalRegex);
    var toPrimitive = function (O, hint) { // need to replace this with `es-to-primitive/es6`
      var result;
      if (typeof O.valueOf === 'function') {
        result = O.valueOf();
        if (Type.primitive(result)) {
          return result;
        }
      }
      if (typeof O.toString === 'function') {
        result = O.toString();
        if (Type.primitive(result)) {
          return result;
        }
      }
      throw new TypeError('No default value');
    };
    var hasNonWS = nonWSregex.test.bind(nonWSregex);
    var isBadHex = isBadHexRegex.test.bind(isBadHexRegex);
    var NumberShim = (function () {
      // this is wrapped in an IIFE because of IE 6-8's wacky scoping issues with named function expressions.
      var NumberShim = function Number(value) {
        var primValue;
        if (arguments.length > 0) {
          primValue = Type.primitive(value) ? value : toPrimitive(value, 'number');
        } else {
          primValue = 0;
        }
        if (typeof primValue === 'string') {
          primValue = ES.Call(trimShim, primValue);
          if (isBinary(primValue)) {
            primValue = parseInt(_strSlice(primValue, 2), 2);
          } else if (isOctal(primValue)) {
            primValue = parseInt(_strSlice(primValue, 2), 8);
          } else if (hasNonWS(primValue) || isBadHex(primValue)) {
            primValue = NaN;
          }
        }
        var receiver = this;
        var valueOfSucceeds = valueOrFalseIfThrows(function () {
          OrigNumber.prototype.valueOf.call(receiver);
          return true;
        });
        if (receiver instanceof NumberShim && !valueOfSucceeds) {
          return new OrigNumber(primValue);
        }
        return OrigNumber(primValue);
      };
      return NumberShim;
    }());
    wrapConstructor(OrigNumber, NumberShim, {});
    // this is necessary for ES3 browsers, where these properties are non-enumerable.
    defineProperties(NumberShim, {
      NaN: OrigNumber.NaN,
      MAX_VALUE: OrigNumber.MAX_VALUE,
      MIN_VALUE: OrigNumber.MIN_VALUE,
      NEGATIVE_INFINITY: OrigNumber.NEGATIVE_INFINITY,
      POSITIVE_INFINITY: OrigNumber.POSITIVE_INFINITY
    });
    /* eslint-disable no-undef, no-global-assign */
    Number = NumberShim;
    Value.redefine(globals, 'Number', NumberShim);
    /* eslint-enable no-undef, no-global-assign */
  }

  var maxSafeInteger = Math.pow(2, 53) - 1;
  defineProperties(Number, {
    MAX_SAFE_INTEGER: maxSafeInteger,
    MIN_SAFE_INTEGER: -maxSafeInteger,
    EPSILON: 2.220446049250313e-16,

    parseInt: globals.parseInt,
    parseFloat: globals.parseFloat,

    isFinite: numberIsFinite,

    isInteger: function isInteger(value) {
      return numberIsFinite(value) && ES.ToInteger(value) === value;
    },

    isSafeInteger: function isSafeInteger(value) {
      return Number.isInteger(value) && _abs(value) <= Number.MAX_SAFE_INTEGER;
    },

    isNaN: numberIsNaN
  });
  // Firefox 37 has a conforming Number.parseInt, but it's not === to the global parseInt (fixed in v40)
  defineProperty(Number, 'parseInt', globals.parseInt, Number.parseInt !== globals.parseInt);

  // Work around bugs in Array#find and Array#findIndex -- early
  // implementations skipped holes in sparse arrays. (Note that the
  // implementations of find/findIndex indirectly use shimmed
  // methods of Number, so this test has to happen down here.)
  /* eslint-disable no-sparse-arrays */
  if ([, 1].find(function () { return true; }) === 1) {
    overrideNative(Array.prototype, 'find', ArrayPrototypeShims.find);
  }
  if ([, 1].findIndex(function () { return true; }) !== 0) {
    overrideNative(Array.prototype, 'findIndex', ArrayPrototypeShims.findIndex);
  }
  /* eslint-enable no-sparse-arrays */

  var isEnumerableOn = Function.bind.call(Function.bind, Object.prototype.propertyIsEnumerable);
  var ensureEnumerable = function ensureEnumerable(obj, prop) {
    if (supportsDescriptors && isEnumerableOn(obj, prop)) {
      Object.defineProperty(obj, prop, { enumerable: false });
    }
  };
  var sliceArgs = function sliceArgs() {
    // per https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
    // and https://gist.github.com/WebReflection/4327762cb87a8c634a29
    var initial = Number(this);
    var len = arguments.length;
    var desiredArgCount = len - initial;
    var args = new Array(desiredArgCount < 0 ? 0 : desiredArgCount);
    for (var i = initial; i < len; ++i) {
      args[i - initial] = arguments[i];
    }
    return args;
  };
  var assignTo = function assignTo(source) {
    return function assignToSource(target, key) {
      target[key] = source[key];
      return target;
    };
  };
  var assignReducer = function (target, source) {
    var sourceKeys = keys(Object(source));
    var symbols;
    if (ES.IsCallable(Object.getOwnPropertySymbols)) {
      symbols = _filter(Object.getOwnPropertySymbols(Object(source)), isEnumerableOn(source));
    }
    return _reduce(_concat(sourceKeys, symbols || []), assignTo(source), target);
  };

  var ObjectShims = {
    // 19.1.3.1
    assign: function (target, source) {
      var to = ES.ToObject(target, 'Cannot convert undefined or null to object');
      return _reduce(ES.Call(sliceArgs, 1, arguments), assignReducer, to);
    },

    // Added in WebKit in https://bugs.webkit.org/show_bug.cgi?id=143865
    is: function is(a, b) {
      return ES.SameValue(a, b);
    }
  };
  var assignHasPendingExceptions = Object.assign && Object.preventExtensions && (function () {
    // Firefox 37 still has "pending exception" logic in its Object.assign implementation,
    // which is 72% slower than our shim, and Firefox 40's native implementation.
    var thrower = Object.preventExtensions({ 1: 2 });
    try {
      Object.assign(thrower, 'xy');
    } catch (e) {
      return thrower[1] === 'y';
    }
  }());
  if (assignHasPendingExceptions) {
    overrideNative(Object, 'assign', ObjectShims.assign);
  }
  defineProperties(Object, ObjectShims);

  if (supportsDescriptors) {
    var ES5ObjectShims = {
      // 19.1.3.9
      // shim from https://gist.github.com/WebReflection/5593554
      setPrototypeOf: (function (Object, magic) {
        var set;

        var checkArgs = function (O, proto) {
          if (!ES.TypeIsObject(O)) {
            throw new TypeError('cannot set prototype on a non-object');
          }
          if (!(proto === null || ES.TypeIsObject(proto))) {
            throw new TypeError('can only set prototype to an object or null' + proto);
          }
        };

        var setPrototypeOf = function (O, proto) {
          checkArgs(O, proto);
          _call(set, O, proto);
          return O;
        };

        try {
          // this works already in Firefox and Safari
          set = Object.getOwnPropertyDescriptor(Object.prototype, magic).set;
          _call(set, {}, null);
        } catch (e) {
          if (Object.prototype !== {}[magic]) {
            // IE < 11 cannot be shimmed
            return;
          }
          // probably Chrome or some old Mobile stock browser
          set = function (proto) {
            this[magic] = proto;
          };
          // please note that this will **not** work
          // in those browsers that do not inherit
          // __proto__ by mistake from Object.prototype
          // in these cases we should probably throw an error
          // or at least be informed about the issue
          setPrototypeOf.polyfill = setPrototypeOf(
            setPrototypeOf({}, null),
            Object.prototype
          ) instanceof Object;
          // setPrototypeOf.polyfill === true means it works as meant
          // setPrototypeOf.polyfill === false means it's not 100% reliable
          // setPrototypeOf.polyfill === undefined
          // or
          // setPrototypeOf.polyfill ==  null means it's not a polyfill
          // which means it works as expected
          // we can even delete Object.prototype.__proto__;
        }
        return setPrototypeOf;
      }(Object, '__proto__'))
    };

    defineProperties(Object, ES5ObjectShims);
  }

  // Workaround bug in Opera 12 where setPrototypeOf(x, null) doesn't work,
  // but Object.create(null) does.
  if (Object.setPrototypeOf && Object.getPrototypeOf &&
      Object.getPrototypeOf(Object.setPrototypeOf({}, null)) !== null &&
      Object.getPrototypeOf(Object.create(null)) === null) {
    (function () {
      var FAKENULL = Object.create(null);
      var gpo = Object.getPrototypeOf;
      var spo = Object.setPrototypeOf;
      Object.getPrototypeOf = function (o) {
        var result = gpo(o);
        return result === FAKENULL ? null : result;
      };
      Object.setPrototypeOf = function (o, p) {
        var proto = p === null ? FAKENULL : p;
        return spo(o, proto);
      };
      Object.setPrototypeOf.polyfill = false;
    }());
  }

  var objectKeysAcceptsPrimitives = !throwsError(function () { return Object.keys('foo'); });
  if (!objectKeysAcceptsPrimitives) {
    var originalObjectKeys = Object.keys;
    overrideNative(Object, 'keys', function keys(value) {
      return originalObjectKeys(ES.ToObject(value));
    });
    keys = Object.keys;
  }
  var objectKeysRejectsRegex = throwsError(function () { return Object.keys(/a/g); });
  if (objectKeysRejectsRegex) {
    var regexRejectingObjectKeys = Object.keys;
    overrideNative(Object, 'keys', function keys(value) {
      if (Type.regex(value)) {
        var regexKeys = [];
        for (var k in value) {
          if (_hasOwnProperty(value, k)) {
            _push(regexKeys, k);
          }
        }
        return regexKeys;
      }
      return regexRejectingObjectKeys(value);
    });
    keys = Object.keys;
  }

  if (Object.getOwnPropertyNames) {
    var objectGOPNAcceptsPrimitives = !throwsError(function () { return Object.getOwnPropertyNames('foo'); });
    if (!objectGOPNAcceptsPrimitives) {
      var cachedWindowNames = typeof window === 'object' ? Object.getOwnPropertyNames(window) : [];
      var originalObjectGetOwnPropertyNames = Object.getOwnPropertyNames;
      overrideNative(Object, 'getOwnPropertyNames', function getOwnPropertyNames(value) {
        var val = ES.ToObject(value);
        if (_toString(val) === '[object Window]') {
          try {
            return originalObjectGetOwnPropertyNames(val);
          } catch (e) {
            // IE bug where layout engine calls userland gOPN for cross-domain `window` objects
            return _concat([], cachedWindowNames);
          }
        }
        return originalObjectGetOwnPropertyNames(val);
      });
    }
  }
  if (Object.getOwnPropertyDescriptor) {
    var objectGOPDAcceptsPrimitives = !throwsError(function () { return Object.getOwnPropertyDescriptor('foo', 'bar'); });
    if (!objectGOPDAcceptsPrimitives) {
      var originalObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      overrideNative(Object, 'getOwnPropertyDescriptor', function getOwnPropertyDescriptor(value, property) {
        return originalObjectGetOwnPropertyDescriptor(ES.ToObject(value), property);
      });
    }
  }
  if (Object.seal) {
    var objectSealAcceptsPrimitives = !throwsError(function () { return Object.seal('foo'); });
    if (!objectSealAcceptsPrimitives) {
      var originalObjectSeal = Object.seal;
      overrideNative(Object, 'seal', function seal(value) {
        if (!ES.TypeIsObject(value)) { return value; }
        return originalObjectSeal(value);
      });
    }
  }
  if (Object.isSealed) {
    var objectIsSealedAcceptsPrimitives = !throwsError(function () { return Object.isSealed('foo'); });
    if (!objectIsSealedAcceptsPrimitives) {
      var originalObjectIsSealed = Object.isSealed;
      overrideNative(Object, 'isSealed', function isSealed(value) {
        if (!ES.TypeIsObject(value)) { return true; }
        return originalObjectIsSealed(value);
      });
    }
  }
  if (Object.freeze) {
    var objectFreezeAcceptsPrimitives = !throwsError(function () { return Object.freeze('foo'); });
    if (!objectFreezeAcceptsPrimitives) {
      var originalObjectFreeze = Object.freeze;
      overrideNative(Object, 'freeze', function freeze(value) {
        if (!ES.TypeIsObject(value)) { return value; }
        return originalObjectFreeze(value);
      });
    }
  }
  if (Object.isFrozen) {
    var objectIsFrozenAcceptsPrimitives = !throwsError(function () { return Object.isFrozen('foo'); });
    if (!objectIsFrozenAcceptsPrimitives) {
      var originalObjectIsFrozen = Object.isFrozen;
      overrideNative(Object, 'isFrozen', function isFrozen(value) {
        if (!ES.TypeIsObject(value)) { return true; }
        return originalObjectIsFrozen(value);
      });
    }
  }
  if (Object.preventExtensions) {
    var objectPreventExtensionsAcceptsPrimitives = !throwsError(function () { return Object.preventExtensions('foo'); });
    if (!objectPreventExtensionsAcceptsPrimitives) {
      var originalObjectPreventExtensions = Object.preventExtensions;
      overrideNative(Object, 'preventExtensions', function preventExtensions(value) {
        if (!ES.TypeIsObject(value)) { return value; }
        return originalObjectPreventExtensions(value);
      });
    }
  }
  if (Object.isExtensible) {
    var objectIsExtensibleAcceptsPrimitives = !throwsError(function () { return Object.isExtensible('foo'); });
    if (!objectIsExtensibleAcceptsPrimitives) {
      var originalObjectIsExtensible = Object.isExtensible;
      overrideNative(Object, 'isExtensible', function isExtensible(value) {
        if (!ES.TypeIsObject(value)) { return false; }
        return originalObjectIsExtensible(value);
      });
    }
  }
  if (Object.getPrototypeOf) {
    var objectGetProtoAcceptsPrimitives = !throwsError(function () { return Object.getPrototypeOf('foo'); });
    if (!objectGetProtoAcceptsPrimitives) {
      var originalGetProto = Object.getPrototypeOf;
      overrideNative(Object, 'getPrototypeOf', function getPrototypeOf(value) {
        return originalGetProto(ES.ToObject(value));
      });
    }
  }

  var hasFlags = supportsDescriptors && (function () {
    var desc = Object.getOwnPropertyDescriptor(RegExp.prototype, 'flags');
    return desc && ES.IsCallable(desc.get);
  }());
  if (supportsDescriptors && !hasFlags) {
    var regExpFlagsGetter = function flags() {
      if (!ES.TypeIsObject(this)) {
        throw new TypeError('Method called on incompatible type: must be an object.');
      }
      var result = '';
      if (this.global) {
        result += 'g';
      }
      if (this.ignoreCase) {
        result += 'i';
      }
      if (this.multiline) {
        result += 'm';
      }
      if (this.unicode) {
        result += 'u';
      }
      if (this.sticky) {
        result += 'y';
      }
      return result;
    };

    Value.getter(RegExp.prototype, 'flags', regExpFlagsGetter);
  }

  var regExpSupportsFlagsWithRegex = supportsDescriptors && valueOrFalseIfThrows(function () {
    return String(new RegExp(/a/g, 'i')) === '/a/i';
  });
  var regExpNeedsToSupportSymbolMatch = hasSymbols && supportsDescriptors && (function () {
    // Edge 0.12 supports flags fully, but does not support Symbol.match
    var regex = /./;
    regex[Symbol.match] = false;
    return RegExp(regex) === regex;
  }());

  var regexToStringIsGeneric = valueOrFalseIfThrows(function () {
    return RegExp.prototype.toString.call({ source: 'abc' }) === '/abc/';
  });
  var regexToStringSupportsGenericFlags = regexToStringIsGeneric && valueOrFalseIfThrows(function () {
    return RegExp.prototype.toString.call({ source: 'a', flags: 'b' }) === '/a/b';
  });
  if (!regexToStringIsGeneric || !regexToStringSupportsGenericFlags) {
    var origRegExpToString = RegExp.prototype.toString;
    defineProperty(RegExp.prototype, 'toString', function toString() {
      var R = ES.RequireObjectCoercible(this);
      if (Type.regex(R)) {
        return _call(origRegExpToString, R);
      }
      var pattern = $String(R.source);
      var flags = $String(R.flags);
      return '/' + pattern + '/' + flags;
    }, true);
    Value.preserveToString(RegExp.prototype.toString, origRegExpToString);
  }

  if (supportsDescriptors && (!regExpSupportsFlagsWithRegex || regExpNeedsToSupportSymbolMatch)) {
    var flagsGetter = Object.getOwnPropertyDescriptor(RegExp.prototype, 'flags').get;
    var sourceDesc = Object.getOwnPropertyDescriptor(RegExp.prototype, 'source') || {};
    var legacySourceGetter = function () {
      // prior to it being a getter, it's own + nonconfigurable
      return this.source;
    };
    var sourceGetter = ES.IsCallable(sourceDesc.get) ? sourceDesc.get : legacySourceGetter;

    var OrigRegExp = RegExp;
    var RegExpShim = (function () {
      return function RegExp(pattern, flags) {
        var patternIsRegExp = ES.IsRegExp(pattern);
        var calledWithNew = this instanceof RegExp;
        if (!calledWithNew && patternIsRegExp && typeof flags === 'undefined' && pattern.constructor === RegExp) {
          return pattern;
        }

        var P = pattern;
        var F = flags;
        if (Type.regex(pattern)) {
          P = ES.Call(sourceGetter, pattern);
          F = typeof flags === 'undefined' ? ES.Call(flagsGetter, pattern) : flags;
          return new RegExp(P, F);
        } else if (patternIsRegExp) {
          P = pattern.source;
          F = typeof flags === 'undefined' ? pattern.flags : flags;
        }
        return new OrigRegExp(pattern, flags);
      };
    }());
    wrapConstructor(OrigRegExp, RegExpShim, {
      $input: true // Chrome < v39 & Opera < 26 have a nonstandard "$input" property
    });
    /* eslint-disable no-undef, no-global-assign */
    RegExp = RegExpShim;
    Value.redefine(globals, 'RegExp', RegExpShim);
    /* eslint-enable no-undef, no-global-assign */
  }

  if (supportsDescriptors) {
    var regexGlobals = {
      input: '$_',
      lastMatch: '$&',
      lastParen: '$+',
      leftContext: '$`',
      rightContext: '$\''
    };
    _forEach(keys(regexGlobals), function (prop) {
      if (prop in RegExp && !(regexGlobals[prop] in RegExp)) {
        Value.getter(RegExp, regexGlobals[prop], function get() {
          return RegExp[prop];
        });
      }
    });
  }
  addDefaultSpecies(RegExp);

  var inverseEpsilon = 1 / Number.EPSILON;
  var roundTiesToEven = function roundTiesToEven(n) {
    // Even though this reduces down to `return n`, it takes advantage of built-in rounding.
    return (n + inverseEpsilon) - inverseEpsilon;
  };
  var BINARY_32_EPSILON = Math.pow(2, -23);
  var BINARY_32_MAX_VALUE = Math.pow(2, 127) * (2 - BINARY_32_EPSILON);
  var BINARY_32_MIN_VALUE = Math.pow(2, -126);
  var E = Math.E;
  var LOG2E = Math.LOG2E;
  var LOG10E = Math.LOG10E;
  var numberCLZ = Number.prototype.clz;
  delete Number.prototype.clz; // Safari 8 has Number#clz

  var MathShims = {
    acosh: function acosh(value) {
      var x = Number(value);
      if (numberIsNaN(x) || value < 1) { return NaN; }
      if (x === 1) { return 0; }
      if (x === Infinity) { return x; }

      var xInvSquared = 1 / (x * x);
      if (x < 2) {
        return _log1p(x - 1 + (_sqrt(1 - xInvSquared) * x));
      }
      var halfX = x / 2;
      return _log1p(halfX + (_sqrt(1 - xInvSquared) * halfX) - 1) + (1 / LOG2E);
    },

    asinh: function asinh(value) {
      var x = Number(value);
      if (x === 0 || !globalIsFinite(x)) {
        return x;
      }

      var a = _abs(x);
      var aSquared = a * a;
      var s = _sign(x);
      if (a < 1) {
        return s * _log1p(a + (aSquared / (_sqrt(aSquared + 1) + 1)));
      }
      return s * (_log1p((a / 2) + (_sqrt(1 + (1 / aSquared)) * a / 2) - 1) + (1 / LOG2E));
    },

    atanh: function atanh(value) {
      var x = Number(value);

      if (x === 0) { return x; }
      if (x === -1) { return -Infinity; }
      if (x === 1) { return Infinity; }
      if (numberIsNaN(x) || x < -1 || x > 1) {
        return NaN;
      }

      var a = _abs(x);
      return _sign(x) * _log1p(2 * a / (1 - a)) / 2;
    },

    cbrt: function cbrt(value) {
      var x = Number(value);
      if (x === 0) { return x; }
      var negate = x < 0;
      var result;
      if (negate) { x = -x; }
      if (x === Infinity) {
        result = Infinity;
      } else {
        result = _exp(_log(x) / 3);
        // from http://en.wikipedia.org/wiki/Cube_root#Numerical_methods
        result = ((x / (result * result)) + (2 * result)) / 3;
      }
      return negate ? -result : result;
    },

    clz32: function clz32(value) {
      // See https://bugs.ecmascript.org/show_bug.cgi?id=2465
      var x = Number(value);
      var number = ES.ToUint32(x);
      if (number === 0) {
        return 32;
      }
      return numberCLZ ? ES.Call(numberCLZ, number) : 31 - _floor(_log(number + 0.5) * LOG2E);
    },

    cosh: function cosh(value) {
      var x = Number(value);
      if (x === 0) { return 1; } // +0 or -0
      if (numberIsNaN(x)) { return NaN; }
      if (!globalIsFinite(x)) { return Infinity; }

      var t = _exp(_abs(x) - 1);
      return (t + (1 / (t * E * E))) * (E / 2);
    },

    expm1: function expm1(value) {
      var x = Number(value);
      if (x === -Infinity) { return -1; }
      if (!globalIsFinite(x) || x === 0) { return x; }
      if (_abs(x) > 0.5) {
        return _exp(x) - 1;
      }
      // A more precise approximation using Taylor series expansion
      // from https://github.com/paulmillr/es6-shim/issues/314#issuecomment-70293986
      var t = x;
      var sum = 0;
      var n = 1;
      while (sum + t !== sum) {
        sum += t;
        n += 1;
        t *= x / n;
      }
      return sum;
    },

    hypot: function hypot(x, y) {
      var result = 0;
      var largest = 0;
      for (var i = 0; i < arguments.length; ++i) {
        var value = _abs(Number(arguments[i]));
        if (largest < value) {
          result *= (largest / value) * (largest / value);
          result += 1;
          largest = value;
        } else {
          result += value > 0 ? (value / largest) * (value / largest) : value;
        }
      }
      return largest === Infinity ? Infinity : largest * _sqrt(result);
    },

    log2: function log2(value) {
      return _log(value) * LOG2E;
    },

    log10: function log10(value) {
      return _log(value) * LOG10E;
    },

    log1p: _log1p,

    sign: _sign,

    sinh: function sinh(value) {
      var x = Number(value);
      if (!globalIsFinite(x) || x === 0) { return x; }

      var a = _abs(x);
      if (a < 1) {
        var u = Math.expm1(a);
        return _sign(x) * u * (1 + (1 / (u + 1))) / 2;
      }
      var t = _exp(a - 1);
      return _sign(x) * (t - (1 / (t * E * E))) * (E / 2);
    },

    tanh: function tanh(value) {
      var x = Number(value);
      if (numberIsNaN(x) || x === 0) { return x; }
      // can exit early at +-20 as JS loses precision for true value at this integer
      if (x >= 20) { return 1; }
      if (x <= -20) { return -1; }

      return (Math.expm1(x) - Math.expm1(-x)) / (_exp(x) + _exp(-x));
    },

    trunc: function trunc(value) {
      var x = Number(value);
      return x < 0 ? -_floor(-x) : _floor(x);
    },

    imul: function imul(x, y) {
      // taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul
      var a = ES.ToUint32(x);
      var b = ES.ToUint32(y);
      var ah = (a >>> 16) & 0xffff;
      var al = a & 0xffff;
      var bh = (b >>> 16) & 0xffff;
      var bl = b & 0xffff;
      // the shift by 0 fixes the sign on the high part
      // the final |0 converts the unsigned value into a signed value
      return (al * bl) + ((((ah * bl) + (al * bh)) << 16) >>> 0) | 0;
    },

    fround: function fround(x) {
      var v = Number(x);
      if (v === 0 || v === Infinity || v === -Infinity || numberIsNaN(v)) {
        return v;
      }
      var sign = _sign(v);
      var abs = _abs(v);
      if (abs < BINARY_32_MIN_VALUE) {
        return sign * roundTiesToEven(abs / BINARY_32_MIN_VALUE / BINARY_32_EPSILON) * BINARY_32_MIN_VALUE * BINARY_32_EPSILON;
      }
      // Veltkamp's splitting (?)
      var a = (1 + (BINARY_32_EPSILON / Number.EPSILON)) * abs;
      var result = a - (a - abs);
      if (result > BINARY_32_MAX_VALUE || numberIsNaN(result)) {
        return sign * Infinity;
      }
      return sign * result;
    }
  };

  var withinULPDistance = function withinULPDistance(result, expected, distance) {
    return _abs(1 - (result / expected)) / Number.EPSILON < (distance || 8);
  };

  defineProperties(Math, MathShims);
  // Chrome < 40 sinh returns ∞ for large numbers
  defineProperty(Math, 'sinh', MathShims.sinh, Math.sinh(710) === Infinity);
  // Chrome < 40 cosh returns ∞ for large numbers
  defineProperty(Math, 'cosh', MathShims.cosh, Math.cosh(710) === Infinity);
  // IE 11 TP has an imprecise log1p: reports Math.log1p(-1e-17) as 0
  defineProperty(Math, 'log1p', MathShims.log1p, Math.log1p(-1e-17) !== -1e-17);
  // IE 11 TP has an imprecise asinh: reports Math.asinh(-1e7) as not exactly equal to -Math.asinh(1e7)
  defineProperty(Math, 'asinh', MathShims.asinh, Math.asinh(-1e7) !== -Math.asinh(1e7));
  // Chrome < 54 asinh returns ∞ for large numbers and should not
  defineProperty(Math, 'asinh', MathShims.asinh, Math.asinh(1e+300) === Infinity);
  // Chrome < 54 atanh incorrectly returns 0 for large numbers
  defineProperty(Math, 'atanh', MathShims.atanh, Math.atanh(1e-300) === 0);
  // Chrome 40 has an imprecise Math.tanh with very small numbers
  defineProperty(Math, 'tanh', MathShims.tanh, Math.tanh(-2e-17) !== -2e-17);
  // Chrome 40 loses Math.acosh precision with high numbers
  defineProperty(Math, 'acosh', MathShims.acosh, Math.acosh(Number.MAX_VALUE) === Infinity);
  // Chrome < 54 has an inaccurate acosh for EPSILON deltas
  defineProperty(Math, 'acosh', MathShims.acosh, !withinULPDistance(Math.acosh(1 + Number.EPSILON), Math.sqrt(2 * Number.EPSILON)));
  // Firefox 38 on Windows
  defineProperty(Math, 'cbrt', MathShims.cbrt, !withinULPDistance(Math.cbrt(1e-300), 1e-100));
  // node 0.11 has an imprecise Math.sinh with very small numbers
  defineProperty(Math, 'sinh', MathShims.sinh, Math.sinh(-2e-17) !== -2e-17);
  // FF 35 on Linux reports 22025.465794806725 for Math.expm1(10)
  var expm1OfTen = Math.expm1(10);
  defineProperty(Math, 'expm1', MathShims.expm1, expm1OfTen > 22025.465794806719 || expm1OfTen < 22025.4657948067165168);
  // node v12.11 - v12.15 report NaN
  defineProperty(Math, 'hypot', MathShims.hypot, Math.hypot(Infinity, NaN) !== Infinity);

  var origMathRound = Math.round;
  // breaks in e.g. Safari 8, Internet Explorer 11, Opera 12
  var roundHandlesBoundaryConditions = Math.round(0.5 - (Number.EPSILON / 4)) === 0 &&
    Math.round(-0.5 + (Number.EPSILON / 3.99)) === 1;

  // When engines use Math.floor(x + 0.5) internally, Math.round can be buggy for large integers.
  // This behavior should be governed by "round to nearest, ties to even mode"
  // see http://www.ecma-international.org/ecma-262/6.0/#sec-terms-and-definitions-number-type
  // These are the boundary cases where it breaks.
  var smallestPositiveNumberWhereRoundBreaks = inverseEpsilon + 1;
  var largestPositiveNumberWhereRoundBreaks = (2 * inverseEpsilon) - 1;
  var roundDoesNotIncreaseIntegers = [
    smallestPositiveNumberWhereRoundBreaks,
    largestPositiveNumberWhereRoundBreaks
  ].every(function (num) {
    return Math.round(num) === num;
  });
  defineProperty(Math, 'round', function round(x) {
    var floor = _floor(x);
    var ceil = floor === -1 ? -0 : floor + 1;
    return x - floor < 0.5 ? floor : ceil;
  }, !roundHandlesBoundaryConditions || !roundDoesNotIncreaseIntegers);
  Value.preserveToString(Math.round, origMathRound);

  var origImul = Math.imul;
  if (Math.imul(0xffffffff, 5) !== -5) {
    // Safari 6.1, at least, reports "0" for this value
    Math.imul = MathShims.imul;
    Value.preserveToString(Math.imul, origImul);
  }
  if (Math.imul.length !== 2) {
    // Safari 8.0.4 has a length of 1
    // fixed in https://bugs.webkit.org/show_bug.cgi?id=143658
    overrideNative(Math, 'imul', function imul(x, y) {
      return ES.Call(origImul, Math, arguments);
    });
  }

  // Promises
  // Simplest possible implementation; use a 3rd-party library if you
  // want the best possible speed and/or long stack traces.
  var PromiseShim = (function () {
    var setTimeout = globals.setTimeout;
    // some environments don't have setTimeout - no way to shim here.
    if (typeof setTimeout !== 'function' && typeof setTimeout !== 'object') { return; }

    ES.IsPromise = function (promise) {
      if (!ES.TypeIsObject(promise)) {
        return false;
      }
      if (typeof promise._promise === 'undefined') {
        return false; // uninitialized, or missing our hidden field.
      }
      return true;
    };

    // "PromiseCapability" in the spec is what most promise implementations
    // call a "deferred".
    var PromiseCapability = function (C) {
      if (!ES.IsConstructor(C)) {
        throw new TypeError('Bad promise constructor');
      }
      var capability = this;
      var resolver = function (resolve, reject) {
        if (capability.resolve !== void 0 || capability.reject !== void 0) {
          throw new TypeError('Bad Promise implementation!');
        }
        capability.resolve = resolve;
        capability.reject = reject;
      };
      // Initialize fields to inform optimizers about the object shape.
      capability.resolve = void 0;
      capability.reject = void 0;
      capability.promise = new C(resolver);
      if (!(ES.IsCallable(capability.resolve) && ES.IsCallable(capability.reject))) {
        throw new TypeError('Bad promise constructor');
      }
    };

    // find an appropriate setImmediate-alike
    var makeZeroTimeout;
    if (typeof window !== 'undefined' && ES.IsCallable(window.postMessage)) {
      makeZeroTimeout = function () {
        // from http://dbaron.org/log/20100309-faster-timeouts
        var timeouts = [];
        var messageName = 'zero-timeout-message';
        var setZeroTimeout = function (fn) {
          _push(timeouts, fn);
          window.postMessage(messageName, '*');
        };
        var handleMessage = function (event) {
          if (event.source === window && event.data === messageName) {
            event.stopPropagation();
            if (timeouts.length === 0) { return; }
            var fn = _shift(timeouts);
            fn();
          }
        };
        window.addEventListener('message', handleMessage, true);
        return setZeroTimeout;
      };
    }
    var makePromiseAsap = function () {
      // An efficient task-scheduler based on a pre-existing Promise
      // implementation, which we can use even if we override the
      // global Promise below (in order to workaround bugs)
      // https://github.com/Raynos/observ-hash/issues/2#issuecomment-35857671
      var P = globals.Promise;
      var pr = P && P.resolve && P.resolve();
      return pr && function (task) {
        return pr.then(task);
      };
    };
    var enqueue = ES.IsCallable(globals.setImmediate) ?
      globals.setImmediate :
      typeof process === 'object' && process.nextTick ? process.nextTick : makePromiseAsap() ||
      (ES.IsCallable(makeZeroTimeout) ? makeZeroTimeout() : function (task) { setTimeout(task, 0); }); // fallback

    // Constants for Promise implementation
    var PROMISE_IDENTITY = function (x) { return x; };
    var PROMISE_THROWER = function (e) { throw e; };
    var PROMISE_PENDING = 0;
    var PROMISE_FULFILLED = 1;
    var PROMISE_REJECTED = 2;
    // We store fulfill/reject handlers and capabilities in a single array.
    var PROMISE_FULFILL_OFFSET = 0;
    var PROMISE_REJECT_OFFSET = 1;
    var PROMISE_CAPABILITY_OFFSET = 2;
    // This is used in an optimization for chaining promises via then.
    var PROMISE_FAKE_CAPABILITY = {};

    var enqueuePromiseReactionJob = function (handler, capability, argument) {
      enqueue(function () {
        promiseReactionJob(handler, capability, argument);
      });
    };

    var promiseReactionJob = function (handler, promiseCapability, argument) {
      var handlerResult, f;
      if (promiseCapability === PROMISE_FAKE_CAPABILITY) {
        // Fast case, when we don't actually need to chain through to a
        // (real) promiseCapability.
        return handler(argument);
      }
      try {
        handlerResult = handler(argument);
        f = promiseCapability.resolve;
      } catch (e) {
        handlerResult = e;
        f = promiseCapability.reject;
      }
      f(handlerResult);
    };

    var fulfillPromise = function (promise, value) {
      var _promise = promise._promise;
      var length = _promise.reactionLength;
      if (length > 0) {
        enqueuePromiseReactionJob(
          _promise.fulfillReactionHandler0,
          _promise.reactionCapability0,
          value
        );
        _promise.fulfillReactionHandler0 = void 0;
        _promise.rejectReactions0 = void 0;
        _promise.reactionCapability0 = void 0;
        if (length > 1) {
          for (var i = 1, idx = 0; i < length; i++, idx += 3) {
            enqueuePromiseReactionJob(
              _promise[idx + PROMISE_FULFILL_OFFSET],
              _promise[idx + PROMISE_CAPABILITY_OFFSET],
              value
            );
            promise[idx + PROMISE_FULFILL_OFFSET] = void 0;
            promise[idx + PROMISE_REJECT_OFFSET] = void 0;
            promise[idx + PROMISE_CAPABILITY_OFFSET] = void 0;
          }
        }
      }
      _promise.result = value;
      _promise.state = PROMISE_FULFILLED;
      _promise.reactionLength = 0;
    };

    var rejectPromise = function (promise, reason) {
      var _promise = promise._promise;
      var length = _promise.reactionLength;
      if (length > 0) {
        enqueuePromiseReactionJob(
          _promise.rejectReactionHandler0,
          _promise.reactionCapability0,
          reason
        );
        _promise.fulfillReactionHandler0 = void 0;
        _promise.rejectReactions0 = void 0;
        _promise.reactionCapability0 = void 0;
        if (length > 1) {
          for (var i = 1, idx = 0; i < length; i++, idx += 3) {
            enqueuePromiseReactionJob(
              _promise[idx + PROMISE_REJECT_OFFSET],
              _promise[idx + PROMISE_CAPABILITY_OFFSET],
              reason
            );
            promise[idx + PROMISE_FULFILL_OFFSET] = void 0;
            promise[idx + PROMISE_REJECT_OFFSET] = void 0;
            promise[idx + PROMISE_CAPABILITY_OFFSET] = void 0;
          }
        }
      }
      _promise.result = reason;
      _promise.state = PROMISE_REJECTED;
      _promise.reactionLength = 0;
    };

    var createResolvingFunctions = function (promise) {
      var alreadyResolved = false;
      var resolve = function (resolution) {
        var then;
        if (alreadyResolved) { return; }
        alreadyResolved = true;
        if (resolution === promise) {
          return rejectPromise(promise, new TypeError('Self resolution'));
        }
        if (!ES.TypeIsObject(resolution)) {
          return fulfillPromise(promise, resolution);
        }
        try {
          then = resolution.then;
        } catch (e) {
          return rejectPromise(promise, e);
        }
        if (!ES.IsCallable(then)) {
          return fulfillPromise(promise, resolution);
        }
        enqueue(function () {
          promiseResolveThenableJob(promise, resolution, then);
        });
      };
      var reject = function (reason) {
        if (alreadyResolved) { return; }
        alreadyResolved = true;
        return rejectPromise(promise, reason);
      };
      return { resolve: resolve, reject: reject };
    };

    var optimizedThen = function (then, thenable, resolve, reject) {
      // Optimization: since we discard the result, we can pass our
      // own then implementation a special hint to let it know it
      // doesn't have to create it.  (The PROMISE_FAKE_CAPABILITY
      // object is local to this implementation and unforgeable outside.)
      if (then === Promise$prototype$then) {
        _call(then, thenable, resolve, reject, PROMISE_FAKE_CAPABILITY);
      } else {
        _call(then, thenable, resolve, reject);
      }
    };
    var promiseResolveThenableJob = function (promise, thenable, then) {
      var resolvingFunctions = createResolvingFunctions(promise);
      var resolve = resolvingFunctions.resolve;
      var reject = resolvingFunctions.reject;
      try {
        optimizedThen(then, thenable, resolve, reject);
      } catch (e) {
        reject(e);
      }
    };

    var Promise$prototype, Promise$prototype$then;
    var Promise = (function () {
      var PromiseShim = function Promise(resolver) {
        if (!(this instanceof PromiseShim)) {
          throw new TypeError('Constructor Promise requires "new"');
        }
        if (this && this._promise) {
          throw new TypeError('Bad construction');
        }
        // see https://bugs.ecmascript.org/show_bug.cgi?id=2482
        if (!ES.IsCallable(resolver)) {
          throw new TypeError('not a valid resolver');
        }
        var promise = emulateES6construct(this, PromiseShim, Promise$prototype, {
          _promise: {
            result: void 0,
            state: PROMISE_PENDING,
            // The first member of the "reactions" array is inlined here,
            // since most promises only have one reaction.
            // We've also exploded the 'reaction' object to inline the
            // "handler" and "capability" fields, since both fulfill and
            // reject reactions share the same capability.
            reactionLength: 0,
            fulfillReactionHandler0: void 0,
            rejectReactionHandler0: void 0,
            reactionCapability0: void 0
          }
        });
        var resolvingFunctions = createResolvingFunctions(promise);
        var reject = resolvingFunctions.reject;
        try {
          resolver(resolvingFunctions.resolve, reject);
        } catch (e) {
          reject(e);
        }
        return promise;
      };
      return PromiseShim;
    }());
    Promise$prototype = Promise.prototype;

    var _promiseAllResolver = function (index, values, capability, remaining) {
      var alreadyCalled = false;
      return function (x) {
        if (alreadyCalled) { return; }
        alreadyCalled = true;
        values[index] = x;
        if ((--remaining.count) === 0) {
          var resolve = capability.resolve;
          resolve(values); // call w/ this===undefined
        }
      };
    };

    var performPromiseAll = function (iteratorRecord, C, resultCapability) {
      var it = iteratorRecord.iterator;
      var values = [];
      var remaining = { count: 1 };
      var next, nextValue;
      var index = 0;
      while (true) {
        try {
          next = ES.IteratorStep(it);
          if (next === false) {
            iteratorRecord.done = true;
            break;
          }
          nextValue = next.value;
        } catch (e) {
          iteratorRecord.done = true;
          throw e;
        }
        values[index] = void 0;
        var nextPromise = C.resolve(nextValue);
        var resolveElement = _promiseAllResolver(
          index,
          values,
          resultCapability,
          remaining
        );
        remaining.count += 1;
        optimizedThen(nextPromise.then, nextPromise, resolveElement, resultCapability.reject);
        index += 1;
      }
      if ((--remaining.count) === 0) {
        var resolve = resultCapability.resolve;
        resolve(values); // call w/ this===undefined
      }
      return resultCapability.promise;
    };

    var performPromiseRace = function (iteratorRecord, C, resultCapability) {
      var it = iteratorRecord.iterator;
      var next, nextValue, nextPromise;
      while (true) {
        try {
          next = ES.IteratorStep(it);
          if (next === false) {
            // NOTE: If iterable has no items, resulting promise will never
            // resolve; see:
            // https://github.com/domenic/promises-unwrapping/issues/75
            // https://bugs.ecmascript.org/show_bug.cgi?id=2515
            iteratorRecord.done = true;
            break;
          }
          nextValue = next.value;
        } catch (e) {
          iteratorRecord.done = true;
          throw e;
        }
        nextPromise = C.resolve(nextValue);
        optimizedThen(nextPromise.then, nextPromise, resultCapability.resolve, resultCapability.reject);
      }
      return resultCapability.promise;
    };

    defineProperties(Promise, {
      all: function all(iterable) {
        var C = this;
        if (!ES.TypeIsObject(C)) {
          throw new TypeError('Promise is not object');
        }
        var capability = new PromiseCapability(C);
        var iterator, iteratorRecord;
        try {
          iterator = ES.GetIterator(iterable);
          iteratorRecord = { iterator: iterator, done: false };
          return performPromiseAll(iteratorRecord, C, capability);
        } catch (e) {
          var exception = e;
          if (iteratorRecord && !iteratorRecord.done) {
            try {
              ES.IteratorClose(iterator, true);
            } catch (ee) {
              exception = ee;
            }
          }
          var reject = capability.reject;
          reject(exception);
          return capability.promise;
        }
      },

      race: function race(iterable) {
        var C = this;
        if (!ES.TypeIsObject(C)) {
          throw new TypeError('Promise is not object');
        }
        var capability = new PromiseCapability(C);
        var iterator, iteratorRecord;
        try {
          iterator = ES.GetIterator(iterable);
          iteratorRecord = { iterator: iterator, done: false };
          return performPromiseRace(iteratorRecord, C, capability);
        } catch (e) {
          var exception = e;
          if (iteratorRecord && !iteratorRecord.done) {
            try {
              ES.IteratorClose(iterator, true);
            } catch (ee) {
              exception = ee;
            }
          }
          var reject = capability.reject;
          reject(exception);
          return capability.promise;
        }
      },

      reject: function reject(reason) {
        var C = this;
        if (!ES.TypeIsObject(C)) {
          throw new TypeError('Bad promise constructor');
        }
        var capability = new PromiseCapability(C);
        var rejectFunc = capability.reject;
        rejectFunc(reason); // call with this===undefined
        return capability.promise;
      },

      resolve: function resolve(v) {
        // See https://esdiscuss.org/topic/fixing-promise-resolve for spec
        var C = this;
        if (!ES.TypeIsObject(C)) {
          throw new TypeError('Bad promise constructor');
        }
        if (ES.IsPromise(v)) {
          var constructor = v.constructor;
          if (constructor === C) {
            return v;
          }
        }
        var capability = new PromiseCapability(C);
        var resolveFunc = capability.resolve;
        resolveFunc(v); // call with this===undefined
        return capability.promise;
      }
    });

    defineProperties(Promise$prototype, {
      'catch': function (onRejected) {
        return this.then(null, onRejected);
      },

      then: function then(onFulfilled, onRejected) {
        var promise = this;
        if (!ES.IsPromise(promise)) { throw new TypeError('not a promise'); }
        var C = ES.SpeciesConstructor(promise, Promise);
        var resultCapability;
        var returnValueIsIgnored = arguments.length > 2 && arguments[2] === PROMISE_FAKE_CAPABILITY;
        if (returnValueIsIgnored && C === Promise) {
          resultCapability = PROMISE_FAKE_CAPABILITY;
        } else {
          resultCapability = new PromiseCapability(C);
        }
        // PerformPromiseThen(promise, onFulfilled, onRejected, resultCapability)
        // Note that we've split the 'reaction' object into its two
        // components, "capabilities" and "handler"
        // "capabilities" is always equal to `resultCapability`
        var fulfillReactionHandler = ES.IsCallable(onFulfilled) ? onFulfilled : PROMISE_IDENTITY;
        var rejectReactionHandler = ES.IsCallable(onRejected) ? onRejected : PROMISE_THROWER;
        var _promise = promise._promise;
        var value;
        if (_promise.state === PROMISE_PENDING) {
          if (_promise.reactionLength === 0) {
            _promise.fulfillReactionHandler0 = fulfillReactionHandler;
            _promise.rejectReactionHandler0 = rejectReactionHandler;
            _promise.reactionCapability0 = resultCapability;
          } else {
            var idx = 3 * (_promise.reactionLength - 1);
            _promise[idx + PROMISE_FULFILL_OFFSET] = fulfillReactionHandler;
            _promise[idx + PROMISE_REJECT_OFFSET] = rejectReactionHandler;
            _promise[idx + PROMISE_CAPABILITY_OFFSET] = resultCapability;
          }
          _promise.reactionLength += 1;
        } else if (_promise.state === PROMISE_FULFILLED) {
          value = _promise.result;
          enqueuePromiseReactionJob(
            fulfillReactionHandler,
            resultCapability,
            value
          );
        } else if (_promise.state === PROMISE_REJECTED) {
          value = _promise.result;
          enqueuePromiseReactionJob(
            rejectReactionHandler,
            resultCapability,
            value
          );
        } else {
          throw new TypeError('unexpected Promise state');
        }
        return resultCapability.promise;
      }
    });
    // This helps the optimizer by ensuring that methods which take
    // capabilities aren't polymorphic.
    PROMISE_FAKE_CAPABILITY = new PromiseCapability(Promise);
    Promise$prototype$then = Promise$prototype.then;

    return Promise;
  }());

  // Chrome's native Promise has extra methods that it shouldn't have. Let's remove them.
  if (globals.Promise) {
    delete globals.Promise.accept;
    delete globals.Promise.defer;
    delete globals.Promise.prototype.chain;
  }

  if (typeof PromiseShim === 'function') {
    // export the Promise constructor.
    defineProperties(globals, { Promise: PromiseShim });
    // In Chrome 33 (and thereabouts) Promise is defined, but the
    // implementation is buggy in a number of ways.  Let's check subclassing
    // support to see if we have a buggy implementation.
    var promiseSupportsSubclassing = supportsSubclassing(globals.Promise, function (S) {
      return S.resolve(42).then(function () {}) instanceof S;
    });
    var promiseIgnoresNonFunctionThenCallbacks = !throwsError(function () {
      return globals.Promise.reject(42).then(null, 5).then(null, noop);
    });
    var promiseRequiresObjectContext = throwsError(function () { return globals.Promise.call(3, noop); });
    // Promise.resolve() was errata'ed late in the ES6 process.
    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1170742
    //      https://code.google.com/p/v8/issues/detail?id=4161
    // It serves as a proxy for a number of other bugs in early Promise
    // implementations.
    var promiseResolveBroken = (function (Promise) {
      var p = Promise.resolve(5);
      p.constructor = {};
      var p2 = Promise.resolve(p);
      try {
        p2.then(null, noop).then(null, noop); // avoid "uncaught rejection" warnings in console
      } catch (e) {
        return true; // v8 native Promises break here https://code.google.com/p/chromium/issues/detail?id=575314
      }
      return p === p2; // This *should* be false!
    }(globals.Promise));

    // Chrome 46 (probably older too) does not retrieve a thenable's .then synchronously
    var getsThenSynchronously = supportsDescriptors && (function () {
      var count = 0;
      // eslint-disable-next-line getter-return
      var thenable = Object.defineProperty({}, 'then', { get: function () { count += 1; } });
      Promise.resolve(thenable);
      return count === 1;
    }());

    var BadResolverPromise = function BadResolverPromise(executor) {
      var p = new Promise(executor);
      executor(3, function () {});
      this.then = p.then;
      this.constructor = BadResolverPromise;
    };
    BadResolverPromise.prototype = Promise.prototype;
    BadResolverPromise.all = Promise.all;
    // Chrome Canary 49 (probably older too) has some implementation bugs
    var hasBadResolverPromise = valueOrFalseIfThrows(function () {
      return !!BadResolverPromise.all([1, 2]);
    });

    if (!promiseSupportsSubclassing || !promiseIgnoresNonFunctionThenCallbacks ||
        !promiseRequiresObjectContext || promiseResolveBroken ||
        !getsThenSynchronously || hasBadResolverPromise) {
      /* globals Promise: true */
      /* eslint-disable no-undef, no-global-assign */
      Promise = PromiseShim;
      /* eslint-enable no-undef, no-global-assign */
      overrideNative(globals, 'Promise', PromiseShim);
    }
    if (Promise.all.length !== 1) {
      var origAll = Promise.all;
      overrideNative(Promise, 'all', function all(iterable) {
        return ES.Call(origAll, this, arguments);
      });
    }
    if (Promise.race.length !== 1) {
      var origRace = Promise.race;
      overrideNative(Promise, 'race', function race(iterable) {
        return ES.Call(origRace, this, arguments);
      });
    }
    if (Promise.resolve.length !== 1) {
      var origResolve = Promise.resolve;
      overrideNative(Promise, 'resolve', function resolve(x) {
        return ES.Call(origResolve, this, arguments);
      });
    }
    if (Promise.reject.length !== 1) {
      var origReject = Promise.reject;
      overrideNative(Promise, 'reject', function reject(r) {
        return ES.Call(origReject, this, arguments);
      });
    }
    ensureEnumerable(Promise, 'all');
    ensureEnumerable(Promise, 'race');
    ensureEnumerable(Promise, 'resolve');
    ensureEnumerable(Promise, 'reject');
    addDefaultSpecies(Promise);
  }

  // Map and Set require a true ES5 environment
  // Their fast path also requires that the environment preserve
  // property insertion order, which is not guaranteed by the spec.
  var testOrder = function (a) {
    var b = keys(_reduce(a, function (o, k) {
      o[k] = true;
      return o;
    }, {}));
    return a.join(':') === b.join(':');
  };
  var preservesInsertionOrder = testOrder(['z', 'a', 'bb']);
  // some engines (eg, Chrome) only preserve insertion order for string keys
  var preservesNumericInsertionOrder = testOrder(['z', 1, 'a', '3', 2]);

  if (supportsDescriptors) {

    var fastkey = function fastkey(key, skipInsertionOrderCheck) {
      if (!skipInsertionOrderCheck && !preservesInsertionOrder) {
        return null;
      }
      if (isNullOrUndefined(key)) {
        return '^' + ES.ToString(key);
      } else if (typeof key === 'string') {
        return '$' + key;
      } else if (typeof key === 'number') {
        // note that -0 will get coerced to "0" when used as a property key
        if (!preservesNumericInsertionOrder) {
          return 'n' + key;
        }
        return key;
      } else if (typeof key === 'boolean') {
        return 'b' + key;
      }
      return null;
    };

    var emptyObject = function emptyObject() {
      // accomodate some older not-quite-ES5 browsers
      return Object.create ? Object.create(null) : {};
    };

    var addIterableToMap = function addIterableToMap(MapConstructor, map, iterable) {
      if (isArray(iterable) || Type.string(iterable)) {
        _forEach(iterable, function (entry) {
          if (!ES.TypeIsObject(entry)) {
            throw new TypeError('Iterator value ' + entry + ' is not an entry object');
          }
          map.set(entry[0], entry[1]);
        });
      } else if (iterable instanceof MapConstructor) {
        _call(MapConstructor.prototype.forEach, iterable, function (value, key) {
          map.set(key, value);
        });
      } else {
        var iter, adder;
        if (!isNullOrUndefined(iterable)) {
          adder = map.set;
          if (!ES.IsCallable(adder)) { throw new TypeError('bad map'); }
          iter = ES.GetIterator(iterable);
        }
        if (typeof iter !== 'undefined') {
          while (true) {
            var next = ES.IteratorStep(iter);
            if (next === false) { break; }
            var nextItem = next.value;
            try {
              if (!ES.TypeIsObject(nextItem)) {
                throw new TypeError('Iterator value ' + nextItem + ' is not an entry object');
              }
              _call(adder, map, nextItem[0], nextItem[1]);
            } catch (e) {
              ES.IteratorClose(iter, true);
              throw e;
            }
          }
        }
      }
    };
    var addIterableToSet = function addIterableToSet(SetConstructor, set, iterable) {
      if (isArray(iterable) || Type.string(iterable)) {
        _forEach(iterable, function (value) {
          set.add(value);
        });
      } else if (iterable instanceof SetConstructor) {
        _call(SetConstructor.prototype.forEach, iterable, function (value) {
          set.add(value);
        });
      } else {
        var iter, adder;
        if (!isNullOrUndefined(iterable)) {
          adder = set.add;
          if (!ES.IsCallable(adder)) { throw new TypeError('bad set'); }
          iter = ES.GetIterator(iterable);
        }
        if (typeof iter !== 'undefined') {
          while (true) {
            var next = ES.IteratorStep(iter);
            if (next === false) { break; }
            var nextValue = next.value;
            try {
              _call(adder, set, nextValue);
            } catch (e) {
              ES.IteratorClose(iter, true);
              throw e;
            }
          }
        }
      }
    };

    var collectionShims = {
      Map: (function () {

        var empty = {};

        var MapEntry = function MapEntry(key, value) {
          this.key = key;
          this.value = value;
          this.next = null;
          this.prev = null;
        };

        MapEntry.prototype.isRemoved = function isRemoved() {
          return this.key === empty;
        };

        var isMap = function isMap(map) {
          return !!map._es6map;
        };

        var requireMapSlot = function requireMapSlot(map, method) {
          if (!ES.TypeIsObject(map) || !isMap(map)) {
            throw new TypeError('Method Map.prototype.' + method + ' called on incompatible receiver ' + ES.ToString(map));
          }
        };

        var MapIterator = function MapIterator(map, kind) {
          requireMapSlot(map, '[[MapIterator]]');
          this.head = map._head;
          this.i = this.head;
          this.kind = kind;
        };

        MapIterator.prototype = {
          isMapIterator: true,
          next: function next() {
            if (!this.isMapIterator) {
              throw new TypeError('Not a MapIterator');
            }
            var i = this.i;
            var kind = this.kind;
            var head = this.head;
            if (typeof this.i === 'undefined') {
              return iteratorResult();
            }
            while (i.isRemoved() && i !== head) {
              // back up off of removed entries
              i = i.prev;
            }
            // advance to next unreturned element.
            var result;
            while (i.next !== head) {
              i = i.next;
              if (!i.isRemoved()) {
                if (kind === 'key') {
                  result = i.key;
                } else if (kind === 'value') {
                  result = i.value;
                } else {
                  result = [i.key, i.value];
                }
                this.i = i;
                return iteratorResult(result);
              }
            }
            // once the iterator is done, it is done forever.
            this.i = void 0;
            return iteratorResult();
          }
        };
        addIterator(MapIterator.prototype);

        var Map$prototype;
        var MapShim = function Map() {
          if (!(this instanceof Map)) {
            throw new TypeError('Constructor Map requires "new"');
          }
          if (this && this._es6map) {
            throw new TypeError('Bad construction');
          }
          var map = emulateES6construct(this, Map, Map$prototype, {
            _es6map: true,
            _head: null,
            _map: OrigMap ? new OrigMap() : null,
            _size: 0,
            _storage: emptyObject()
          });

          var head = new MapEntry(null, null);
          // circular doubly-linked list.
          /* eslint no-multi-assign: 1 */
          head.next = head.prev = head;
          map._head = head;

          // Optionally initialize map from iterable
          if (arguments.length > 0) {
            addIterableToMap(Map, map, arguments[0]);
          }
          return map;
        };
        Map$prototype = MapShim.prototype;

        Value.getter(Map$prototype, 'size', function () {
          if (typeof this._size === 'undefined') {
            throw new TypeError('size method called on incompatible Map');
          }
          return this._size;
        });

        defineProperties(Map$prototype, {
          get: function get(key) {
            requireMapSlot(this, 'get');
            var entry;
            var fkey = fastkey(key, true);
            if (fkey !== null) {
              // fast O(1) path
              entry = this._storage[fkey];
              if (entry) {
                return entry.value;
              } else {
                return;
              }
            }
            if (this._map) {
              // fast object key path
              entry = origMapGet.call(this._map, key);
              if (entry) {
                return entry.value;
              } else {
                return;
              }
            }
            var head = this._head;
            var i = head;
            while ((i = i.next) !== head) {
              if (ES.SameValueZero(i.key, key)) {
                return i.value;
              }
            }
          },

          has: function has(key) {
            requireMapSlot(this, 'has');
            var fkey = fastkey(key, true);
            if (fkey !== null) {
              // fast O(1) path
              return typeof this._storage[fkey] !== 'undefined';
            }
            if (this._map) {
              // fast object key path
              return origMapHas.call(this._map, key);
            }
            var head = this._head;
            var i = head;
            while ((i = i.next) !== head) {
              if (ES.SameValueZero(i.key, key)) {
                return true;
              }
            }
            return false;
          },

          set: function set(key, value) {
            requireMapSlot(this, 'set');
            var head = this._head;
            var i = head;
            var entry;
            var fkey = fastkey(key, true);
            if (fkey !== null) {
              // fast O(1) path
              if (typeof this._storage[fkey] !== 'undefined') {
                this._storage[fkey].value = value;
                return this;
              } else {
                entry = this._storage[fkey] = new MapEntry(key, value); /* eslint no-multi-assign: 1 */
                i = head.prev;
                // fall through
              }
            } else if (this._map) {
              // fast object key path
              if (origMapHas.call(this._map, key)) {
                origMapGet.call(this._map, key).value = value;
              } else {
                entry = new MapEntry(key, value);
                origMapSet.call(this._map, key, entry);
                i = head.prev;
                // fall through
              }
            }
            while ((i = i.next) !== head) {
              if (ES.SameValueZero(i.key, key)) {
                i.value = value;
                return this;
              }
            }
            entry = entry || new MapEntry(key, value);
            if (ES.SameValue(-0, key)) {
              entry.key = +0; // coerce -0 to +0 in entry
            }
            entry.next = this._head;
            entry.prev = this._head.prev;
            entry.prev.next = entry;
            entry.next.prev = entry;
            this._size += 1;
            return this;
          },

          'delete': function (key) {
            requireMapSlot(this, 'delete');
            var head = this._head;
            var i = head;
            var fkey = fastkey(key, true);
            if (fkey !== null) {
              // fast O(1) path
              if (typeof this._storage[fkey] === 'undefined') {
                return false;
              }
              i = this._storage[fkey].prev;
              delete this._storage[fkey];
              // fall through
            } else if (this._map) {
              // fast object key path
              if (!origMapHas.call(this._map, key)) {
                return false;
              }
              i = origMapGet.call(this._map, key).prev;
              origMapDelete.call(this._map, key);
              // fall through
            }
            while ((i = i.next) !== head) {
              if (ES.SameValueZero(i.key, key)) {
                i.key = empty;
                i.value = empty;
                i.prev.next = i.next;
                i.next.prev = i.prev;
                this._size -= 1;
                return true;
              }
            }
            return false;
          },

          clear: function clear() {
            /* eslint no-multi-assign: 1 */
            requireMapSlot(this, 'clear');
            this._map = OrigMap ? new OrigMap() : null;
            this._size = 0;
            this._storage = emptyObject();
            var head = this._head;
            var i = head;
            var p = i.next;
            while ((i = p) !== head) {
              i.key = empty;
              i.value = empty;
              p = i.next;
              i.next = i.prev = head;
            }
            head.next = head.prev = head;
          },

          keys: function keys() {
            requireMapSlot(this, 'keys');
            return new MapIterator(this, 'key');
          },

          values: function values() {
            requireMapSlot(this, 'values');
            return new MapIterator(this, 'value');
          },

          entries: function entries() {
            requireMapSlot(this, 'entries');
            return new MapIterator(this, 'key+value');
          },

          forEach: function forEach(callback) {
            requireMapSlot(this, 'forEach');
            var context = arguments.length > 1 ? arguments[1] : null;
            var it = this.entries();
            for (var entry = it.next(); !entry.done; entry = it.next()) {
              if (context) {
                _call(callback, context, entry.value[1], entry.value[0], this);
              } else {
                callback(entry.value[1], entry.value[0], this);
              }
            }
          }
        });
        addIterator(Map$prototype, Map$prototype.entries);

        return MapShim;
      }()),

      Set: (function () {
        var isSet = function isSet(set) {
          return set._es6set && typeof set._storage !== 'undefined';
        };
        var requireSetSlot = function requireSetSlot(set, method) {
          if (!ES.TypeIsObject(set) || !isSet(set)) {
            // https://github.com/paulmillr/es6-shim/issues/176
            throw new TypeError('Set.prototype.' + method + ' called on incompatible receiver ' + ES.ToString(set));
          }
        };

        // Creating a Map is expensive.  To speed up the common case of
        // Sets containing only string or numeric keys, we use an object
        // as backing storage and lazily create a full Map only when
        // required.
        var Set$prototype;
        var SetShim = function Set() {
          if (!(this instanceof Set)) {
            throw new TypeError('Constructor Set requires "new"');
          }
          if (this && this._es6set) {
            throw new TypeError('Bad construction');
          }
          var set = emulateES6construct(this, Set, Set$prototype, {
            _es6set: true,
            '[[SetData]]': null,
            _storage: emptyObject()
          });
          if (!set._es6set) {
            throw new TypeError('bad set');
          }

          // Optionally initialize Set from iterable
          if (arguments.length > 0) {
            addIterableToSet(Set, set, arguments[0]);
          }
          return set;
        };
        Set$prototype = SetShim.prototype;

        var decodeKey = function (key) {
          var k = key;
          if (k === '^null') {
            return null;
          } else if (k === '^undefined') {
            return void 0;
          } else {
            var first = k.charAt(0);
            if (first === '$') {
              return _strSlice(k, 1);
            } else if (first === 'n') {
              return +_strSlice(k, 1);
            } else if (first === 'b') {
              return k === 'btrue';
            }
          }
          return +k;
        };
        // Switch from the object backing storage to a full Map.
        var ensureMap = function ensureMap(set) {
          if (!set['[[SetData]]']) {
            var m = new collectionShims.Map();
            set['[[SetData]]'] = m;
            _forEach(keys(set._storage), function (key) {
              var k = decodeKey(key);
              m.set(k, k);
            });
            set['[[SetData]]'] = m;
          }
          set._storage = null; // free old backing storage
        };

        Value.getter(SetShim.prototype, 'size', function () {
          requireSetSlot(this, 'size');
          if (this._storage) {
            return keys(this._storage).length;
          }
          ensureMap(this);
          return this['[[SetData]]'].size;
        });

        defineProperties(SetShim.prototype, {
          has: function has(key) {
            requireSetSlot(this, 'has');
            var fkey;
            if (this._storage && (fkey = fastkey(key)) !== null) {
              return !!this._storage[fkey];
            }
            ensureMap(this);
            return this['[[SetData]]'].has(key);
          },

          add: function add(key) {
            requireSetSlot(this, 'add');
            var fkey;
            if (this._storage && (fkey = fastkey(key)) !== null) {
              this._storage[fkey] = true;
              return this;
            }
            ensureMap(this);
            this['[[SetData]]'].set(key, key);
            return this;
          },

          'delete': function (key) {
            requireSetSlot(this, 'delete');
            var fkey;
            if (this._storage && (fkey = fastkey(key)) !== null) {
              var hasFKey = _hasOwnProperty(this._storage, fkey);
              return (delete this._storage[fkey]) && hasFKey;
            }
            ensureMap(this);
            return this['[[SetData]]']['delete'](key);
          },

          clear: function clear() {
            requireSetSlot(this, 'clear');
            if (this._storage) {
              this._storage = emptyObject();
            }
            if (this['[[SetData]]']) {
              this['[[SetData]]'].clear();
            }
          },

          values: function values() {
            requireSetSlot(this, 'values');
            ensureMap(this);
            return new SetIterator(this['[[SetData]]'].values());
          },

          entries: function entries() {
            requireSetSlot(this, 'entries');
            ensureMap(this);
            return new SetIterator(this['[[SetData]]'].entries());
          },

          forEach: function forEach(callback) {
            requireSetSlot(this, 'forEach');
            var context = arguments.length > 1 ? arguments[1] : null;
            var entireSet = this;
            ensureMap(entireSet);
            this['[[SetData]]'].forEach(function (value, key) {
              if (context) {
                _call(callback, context, key, key, entireSet);
              } else {
                callback(key, key, entireSet);
              }
            });
          }
        });
        defineProperty(SetShim.prototype, 'keys', SetShim.prototype.values, true);
        addIterator(SetShim.prototype, SetShim.prototype.values);

        var SetIterator = function SetIterator(it) {
          this.it = it;
        };
        SetIterator.prototype = {
          isSetIterator: true,
          next: function next() {
            if (!this.isSetIterator) {
              throw new TypeError('Not a SetIterator');
            }
            return this.it.next();
          }
        };
        addIterator(SetIterator.prototype);

        return SetShim;
      }())
    };

    var isGoogleTranslate = globals.Set && !Set.prototype['delete'] && Set.prototype.remove && Set.prototype.items && Set.prototype.map && Array.isArray(new Set().keys);
    if (isGoogleTranslate) {
      // special-case force removal of wildly invalid Set implementation in Google Translate iframes
      // see https://github.com/paulmillr/es6-shim/issues/438 / https://twitter.com/ljharb/status/849335573114363904
      globals.Set = collectionShims.Set;
    }
    if (globals.Map || globals.Set) {
      // Safari 8, for example, doesn't accept an iterable.
      var mapAcceptsArguments = valueOrFalseIfThrows(function () { return new Map([[1, 2]]).get(1) === 2; });
      if (!mapAcceptsArguments) {
        globals.Map = function Map() {
          if (!(this instanceof Map)) {
            throw new TypeError('Constructor Map requires "new"');
          }
          var m = new OrigMap();
          if (arguments.length > 0) {
            addIterableToMap(Map, m, arguments[0]);
          }
          delete m.constructor;
          Object.setPrototypeOf(m, globals.Map.prototype);
          return m;
        };
        globals.Map.prototype = create(OrigMap.prototype);
        defineProperty(globals.Map.prototype, 'constructor', globals.Map, true);
        Value.preserveToString(globals.Map, OrigMap);
      }
      var testMap = new Map();
      var mapUsesSameValueZero = (function () {
        // Chrome 38-42, node 0.11/0.12, iojs 1/2 also have a bug when the Map has a size > 4
        var m = new Map([[1, 0], [2, 0], [3, 0], [4, 0]]);
        m.set(-0, m);
        return m.get(0) === m && m.get(-0) === m && m.has(0) && m.has(-0);
      }());
      var mapSupportsChaining = testMap.set(1, 2) === testMap;
      if (!mapUsesSameValueZero || !mapSupportsChaining) {
        overrideNative(Map.prototype, 'set', function set(k, v) {
          _call(origMapSet, this, k === 0 ? 0 : k, v);
          return this;
        });
      }
      if (!mapUsesSameValueZero) {
        defineProperties(Map.prototype, {
          get: function get(k) {
            return _call(origMapGet, this, k === 0 ? 0 : k);
          },
          has: function has(k) {
            return _call(origMapHas, this, k === 0 ? 0 : k);
          }
        }, true);
        Value.preserveToString(Map.prototype.get, origMapGet);
        Value.preserveToString(Map.prototype.has, origMapHas);
      }
      var testSet = new Set();
      var setUsesSameValueZero = Set.prototype['delete'] && Set.prototype.add && Set.prototype.has && (function (s) {
        s['delete'](0);
        s.add(-0);
        return !s.has(0);
      }(testSet));
      var setSupportsChaining = testSet.add(1) === testSet;
      if (!setUsesSameValueZero || !setSupportsChaining) {
        var origSetAdd = Set.prototype.add;
        Set.prototype.add = function add(v) {
          _call(origSetAdd, this, v === 0 ? 0 : v);
          return this;
        };
        Value.preserveToString(Set.prototype.add, origSetAdd);
      }
      if (!setUsesSameValueZero) {
        var origSetHas = Set.prototype.has;
        Set.prototype.has = function has(v) {
          return _call(origSetHas, this, v === 0 ? 0 : v);
        };
        Value.preserveToString(Set.prototype.has, origSetHas);
        var origSetDel = Set.prototype['delete'];
        Set.prototype['delete'] = function SetDelete(v) {
          return _call(origSetDel, this, v === 0 ? 0 : v);
        };
        Value.preserveToString(Set.prototype['delete'], origSetDel);
      }
      var mapSupportsSubclassing = supportsSubclassing(globals.Map, function (M) {
        var m = new M([]);
        // Firefox 32 is ok with the instantiating the subclass but will
        // throw when the map is used.
        m.set(42, 42);
        return m instanceof M;
      });
      // without Object.setPrototypeOf, subclassing is not possible
      var mapFailsToSupportSubclassing = Object.setPrototypeOf && !mapSupportsSubclassing;
      var mapRequiresNew = (function () {
        try {
          return !(globals.Map() instanceof globals.Map);
        } catch (e) {
          return e instanceof TypeError;
        }
      }());
      if (globals.Map.length !== 0 || mapFailsToSupportSubclassing || !mapRequiresNew) {
        globals.Map = function Map() {
          if (!(this instanceof Map)) {
            throw new TypeError('Constructor Map requires "new"');
          }
          var m = new OrigMap();
          if (arguments.length > 0) {
            addIterableToMap(Map, m, arguments[0]);
          }
          delete m.constructor;
          Object.setPrototypeOf(m, Map.prototype);
          return m;
        };
        globals.Map.prototype = OrigMap.prototype;
        defineProperty(globals.Map.prototype, 'constructor', globals.Map, true);
        Value.preserveToString(globals.Map, OrigMap);
      }
      var setSupportsSubclassing = supportsSubclassing(globals.Set, function (S) {
        var s = new S([]);
        s.add(42, 42);
        return s instanceof S;
      });
      // without Object.setPrototypeOf, subclassing is not possible
      var setFailsToSupportSubclassing = Object.setPrototypeOf && !setSupportsSubclassing;
      var setRequiresNew = (function () {
        try {
          return !(globals.Set() instanceof globals.Set);
        } catch (e) {
          return e instanceof TypeError;
        }
      }());
      if (globals.Set.length !== 0 || setFailsToSupportSubclassing || !setRequiresNew) {
        var OrigSet = globals.Set;
        globals.Set = function Set() {
          if (!(this instanceof Set)) {
            throw new TypeError('Constructor Set requires "new"');
          }
          var s = new OrigSet();
          if (arguments.length > 0) {
            addIterableToSet(Set, s, arguments[0]);
          }
          delete s.constructor;
          Object.setPrototypeOf(s, Set.prototype);
          return s;
        };
        globals.Set.prototype = OrigSet.prototype;
        defineProperty(globals.Set.prototype, 'constructor', globals.Set, true);
        Value.preserveToString(globals.Set, OrigSet);
      }
      var newMap = new globals.Map();
      var mapIterationThrowsStopIterator = !valueOrFalseIfThrows(function () {
        return newMap.keys().next().done;
      });
      /*
        - In Firefox < 23, Map#size is a function.
        - In all current Firefox, Set#entries/keys/values & Map#clear do not exist
        - https://bugzilla.mozilla.org/show_bug.cgi?id=869996
        - In Firefox 24, Map and Set do not implement forEach
        - In Firefox 25 at least, Map and Set are callable without "new"
      */
      if (
        typeof globals.Map.prototype.clear !== 'function' ||
        new globals.Set().size !== 0 ||
        newMap.size !== 0 ||
        typeof globals.Map.prototype.keys !== 'function' ||
        typeof globals.Set.prototype.keys !== 'function' ||
        typeof globals.Map.prototype.forEach !== 'function' ||
        typeof globals.Set.prototype.forEach !== 'function' ||
        isCallableWithoutNew(globals.Map) ||
        isCallableWithoutNew(globals.Set) ||
        typeof newMap.keys().next !== 'function' || // Safari 8
        mapIterationThrowsStopIterator || // Firefox 25
        !mapSupportsSubclassing
      ) {
        defineProperties(globals, {
          Map: collectionShims.Map,
          Set: collectionShims.Set
        }, true);
      }

      if (globals.Set.prototype.keys !== globals.Set.prototype.values) {
        // Fixed in WebKit with https://bugs.webkit.org/show_bug.cgi?id=144190
        defineProperty(globals.Set.prototype, 'keys', globals.Set.prototype.values, true);
      }

      // Shim incomplete iterator implementations.
      addIterator(Object.getPrototypeOf((new globals.Map()).keys()));
      addIterator(Object.getPrototypeOf((new globals.Set()).keys()));

      if (functionsHaveNames && globals.Set.prototype.has.name !== 'has') {
        // Microsoft Edge v0.11.10074.0 is missing a name on Set#has
        var anonymousSetHas = globals.Set.prototype.has;
        overrideNative(globals.Set.prototype, 'has', function has(key) {
          return _call(anonymousSetHas, this, key);
        });
      }
    }
    defineProperties(globals, collectionShims);
    addDefaultSpecies(globals.Map);
    addDefaultSpecies(globals.Set);
  }

  var throwUnlessTargetIsObject = function throwUnlessTargetIsObject(target) {
    if (!ES.TypeIsObject(target)) {
      throw new TypeError('target must be an object');
    }
  };

  // Some Reflect methods are basically the same as
  // those on the Object global, except that a TypeError is thrown if
  // target isn't an object. As well as returning a boolean indicating
  // the success of the operation.
  var ReflectShims = {
    // Apply method in a functional form.
    apply: function apply() {
      return ES.Call(ES.Call, null, arguments);
    },

    // New operator in a functional form.
    construct: function construct(constructor, args) {
      if (!ES.IsConstructor(constructor)) {
        throw new TypeError('First argument must be a constructor.');
      }
      var newTarget = arguments.length > 2 ? arguments[2] : constructor;
      if (!ES.IsConstructor(newTarget)) {
        throw new TypeError('new.target must be a constructor.');
      }
      return ES.Construct(constructor, args, newTarget, 'internal');
    },

    // When deleting a non-existent or configurable property,
    // true is returned.
    // When attempting to delete a non-configurable property,
    // it will return false.
    deleteProperty: function deleteProperty(target, key) {
      throwUnlessTargetIsObject(target);
      if (supportsDescriptors) {
        var desc = Object.getOwnPropertyDescriptor(target, key);

        if (desc && !desc.configurable) {
          return false;
        }
      }

      // Will return true.
      return delete target[key];
    },

    has: function has(target, key) {
      throwUnlessTargetIsObject(target);
      return key in target;
    }
  };

  if (Object.getOwnPropertyNames) {
    Object.assign(ReflectShims, {
      // Basically the result of calling the internal [[OwnPropertyKeys]].
      // Concatenating propertyNames and propertySymbols should do the trick.
      // This should continue to work together with a Symbol shim
      // which overrides Object.getOwnPropertyNames and implements
      // Object.getOwnPropertySymbols.
      ownKeys: function ownKeys(target) {
        throwUnlessTargetIsObject(target);
        var keys = Object.getOwnPropertyNames(target);

        if (ES.IsCallable(Object.getOwnPropertySymbols)) {
          _pushApply(keys, Object.getOwnPropertySymbols(target));
        }

        return keys;
      }
    });
  }

  var callAndCatchException = function ConvertExceptionToBoolean(func) {
    return !throwsError(func);
  };

  if (Object.preventExtensions) {
    Object.assign(ReflectShims, {
      isExtensible: function isExtensible(target) {
        throwUnlessTargetIsObject(target);
        return Object.isExtensible(target);
      },
      preventExtensions: function preventExtensions(target) {
        throwUnlessTargetIsObject(target);
        return callAndCatchException(function () {
          return Object.preventExtensions(target);
        });
      }
    });
  }

  if (supportsDescriptors) {
    var internalGet = function get(target, key, receiver) {
      var desc = Object.getOwnPropertyDescriptor(target, key);

      if (!desc) {
        var parent = Object.getPrototypeOf(target);

        if (parent === null) {
          return void 0;
        }

        return internalGet(parent, key, receiver);
      }

      if ('value' in desc) {
        return desc.value;
      }

      if (desc.get) {
        return ES.Call(desc.get, receiver);
      }

      return void 0;
    };

    var internalSet = function set(target, key, value, receiver) {
      var desc = Object.getOwnPropertyDescriptor(target, key);

      if (!desc) {
        var parent = Object.getPrototypeOf(target);

        if (parent !== null) {
          return internalSet(parent, key, value, receiver);
        }

        desc = {
          value: void 0,
          writable: true,
          enumerable: true,
          configurable: true
        };
      }

      if ('value' in desc) {
        if (!desc.writable) {
          return false;
        }

        if (!ES.TypeIsObject(receiver)) {
          return false;
        }

        var existingDesc = Object.getOwnPropertyDescriptor(receiver, key);

        if (existingDesc) {
          return Reflect.defineProperty(receiver, key, {
            value: value
          });
        } else {
          return Reflect.defineProperty(receiver, key, {
            value: value,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }

      if (desc.set) {
        _call(desc.set, receiver, value);
        return true;
      }

      return false;
    };

    Object.assign(ReflectShims, {
      defineProperty: function defineProperty(target, propertyKey, attributes) {
        throwUnlessTargetIsObject(target);
        return callAndCatchException(function () {
          return Object.defineProperty(target, propertyKey, attributes);
        });
      },

      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
        throwUnlessTargetIsObject(target);
        return Object.getOwnPropertyDescriptor(target, propertyKey);
      },

      // Syntax in a functional form.
      get: function get(target, key) {
        throwUnlessTargetIsObject(target);
        var receiver = arguments.length > 2 ? arguments[2] : target;

        return internalGet(target, key, receiver);
      },

      set: function set(target, key, value) {
        throwUnlessTargetIsObject(target);
        var receiver = arguments.length > 3 ? arguments[3] : target;

        return internalSet(target, key, value, receiver);
      }
    });
  }

  if (Object.getPrototypeOf) {
    var objectDotGetPrototypeOf = Object.getPrototypeOf;
    ReflectShims.getPrototypeOf = function getPrototypeOf(target) {
      throwUnlessTargetIsObject(target);
      return objectDotGetPrototypeOf(target);
    };
  }

  if (Object.setPrototypeOf && ReflectShims.getPrototypeOf) {
    var willCreateCircularPrototype = function (object, lastProto) {
      var proto = lastProto;
      while (proto) {
        if (object === proto) {
          return true;
        }
        proto = ReflectShims.getPrototypeOf(proto);
      }
      return false;
    };

    Object.assign(ReflectShims, {
      // Sets the prototype of the given object.
      // Returns true on success, otherwise false.
      setPrototypeOf: function setPrototypeOf(object, proto) {
        throwUnlessTargetIsObject(object);
        if (proto !== null && !ES.TypeIsObject(proto)) {
          throw new TypeError('proto must be an object or null');
        }

        // If they already are the same, we're done.
        if (proto === Reflect.getPrototypeOf(object)) {
          return true;
        }

        // Cannot alter prototype if object not extensible.
        if (Reflect.isExtensible && !Reflect.isExtensible(object)) {
          return false;
        }

        // Ensure that we do not create a circular prototype chain.
        if (willCreateCircularPrototype(object, proto)) {
          return false;
        }

        Object.setPrototypeOf(object, proto);

        return true;
      }
    });
  }
  var defineOrOverrideReflectProperty = function (key, shim) {
    if (!ES.IsCallable(globals.Reflect[key])) {
      defineProperty(globals.Reflect, key, shim);
    } else {
      var acceptsPrimitives = valueOrFalseIfThrows(function () {
        globals.Reflect[key](1);
        globals.Reflect[key](NaN);
        globals.Reflect[key](true);
        return true;
      });
      if (acceptsPrimitives) {
        overrideNative(globals.Reflect, key, shim);
      }
    }
  };
  Object.keys(ReflectShims).forEach(function (key) {
    defineOrOverrideReflectProperty(key, ReflectShims[key]);
  });
  var originalReflectGetProto = globals.Reflect.getPrototypeOf;
  if (functionsHaveNames && originalReflectGetProto && originalReflectGetProto.name !== 'getPrototypeOf') {
    overrideNative(globals.Reflect, 'getPrototypeOf', function getPrototypeOf(target) {
      return _call(originalReflectGetProto, globals.Reflect, target);
    });
  }
  if (globals.Reflect.setPrototypeOf) {
    if (valueOrFalseIfThrows(function () {
      globals.Reflect.setPrototypeOf(1, {});
      return true;
    })) {
      overrideNative(globals.Reflect, 'setPrototypeOf', ReflectShims.setPrototypeOf);
    }
  }
  if (globals.Reflect.defineProperty) {
    if (!valueOrFalseIfThrows(function () {
      var basic = !globals.Reflect.defineProperty(1, 'test', { value: 1 });
      // "extensible" fails on Edge 0.12
      var extensible = typeof Object.preventExtensions !== 'function' || !globals.Reflect.defineProperty(Object.preventExtensions({}), 'test', {});
      return basic && extensible;
    })) {
      overrideNative(globals.Reflect, 'defineProperty', ReflectShims.defineProperty);
    }
  }
  if (globals.Reflect.construct) {
    if (!valueOrFalseIfThrows(function () {
      var F = function F() {};
      return globals.Reflect.construct(function () {}, [], F) instanceof F;
    })) {
      overrideNative(globals.Reflect, 'construct', ReflectShims.construct);
    }
  }

  if (String(new Date(NaN)) !== 'Invalid Date') {
    var dateToString = Date.prototype.toString;
    var shimmedDateToString = function toString() {
      var valueOf = +this;
      if (valueOf !== valueOf) {
        return 'Invalid Date';
      }
      return ES.Call(dateToString, this);
    };
    overrideNative(Date.prototype, 'toString', shimmedDateToString);
  }

  // Annex B HTML methods
  // http://www.ecma-international.org/ecma-262/6.0/#sec-additional-properties-of-the-string.prototype-object
  var stringHTMLshims = {
    anchor: function anchor(name) { return ES.CreateHTML(this, 'a', 'name', name); },
    big: function big() { return ES.CreateHTML(this, 'big', '', ''); },
    blink: function blink() { return ES.CreateHTML(this, 'blink', '', ''); },
    bold: function bold() { return ES.CreateHTML(this, 'b', '', ''); },
    fixed: function fixed() { return ES.CreateHTML(this, 'tt', '', ''); },
    fontcolor: function fontcolor(color) { return ES.CreateHTML(this, 'font', 'color', color); },
    fontsize: function fontsize(size) { return ES.CreateHTML(this, 'font', 'size', size); },
    italics: function italics() { return ES.CreateHTML(this, 'i', '', ''); },
    link: function link(url) { return ES.CreateHTML(this, 'a', 'href', url); },
    small: function small() { return ES.CreateHTML(this, 'small', '', ''); },
    strike: function strike() { return ES.CreateHTML(this, 'strike', '', ''); },
    sub: function sub() { return ES.CreateHTML(this, 'sub', '', ''); },
    sup: function sub() { return ES.CreateHTML(this, 'sup', '', ''); }
  };
  _forEach(Object.keys(stringHTMLshims), function (key) {
    var method = String.prototype[key];
    var shouldOverwrite = false;
    if (ES.IsCallable(method)) {
      var output = _call(method, '', ' " ');
      var quotesCount = _concat([], output.match(/"/g)).length;
      shouldOverwrite = output !== output.toLowerCase() || quotesCount > 2;
    } else {
      shouldOverwrite = true;
    }
    if (shouldOverwrite) {
      overrideNative(String.prototype, key, stringHTMLshims[key]);
    }
  });

  var JSONstringifiesSymbols = (function () {
    // Microsoft Edge v0.12 stringifies Symbols incorrectly
    if (!hasSymbols) { return false; } // Symbols are not supported
    var stringify = typeof JSON === 'object' && typeof JSON.stringify === 'function' ? JSON.stringify : null;
    if (!stringify) { return false; } // JSON.stringify is not supported
    if (typeof stringify(Symbol()) !== 'undefined') { return true; } // Symbols should become `undefined`
    if (stringify([Symbol()]) !== '[null]') { return true; } // Symbols in arrays should become `null`
    var obj = { a: Symbol() };
    obj[Symbol()] = true;
    if (stringify(obj) !== '{}') { return true; } // Symbol-valued keys *and* Symbol-valued properties should be omitted
    return false;
  }());
  var JSONstringifyAcceptsObjectSymbol = valueOrFalseIfThrows(function () {
    // Chrome 45 throws on stringifying object symbols
    if (!hasSymbols) { return true; } // Symbols are not supported
    return JSON.stringify(Object(Symbol())) === '{}' && JSON.stringify([Object(Symbol())]) === '[{}]';
  });
  if (JSONstringifiesSymbols || !JSONstringifyAcceptsObjectSymbol) {
    var origStringify = JSON.stringify;
    overrideNative(JSON, 'stringify', function stringify(value) {
      if (typeof value === 'symbol') { return; }
      var replacer;
      if (arguments.length > 1) {
        replacer = arguments[1];
      }
      var args = [value];
      if (!isArray(replacer)) {
        var replaceFn = ES.IsCallable(replacer) ? replacer : null;
        var wrappedReplacer = function (key, val) {
          var parsedValue = replaceFn ? _call(replaceFn, this, key, val) : val;
          if (typeof parsedValue !== 'symbol') {
            if (Type.symbol(parsedValue)) {
              return assignTo({})(parsedValue);
            } else {
              return parsedValue;
            }
          }
        };
        args.push(wrappedReplacer);
      } else {
        // create wrapped replacer that handles an array replacer?
        args.push(replacer);
      }
      if (arguments.length > 2) {
        args.push(arguments[2]);
      }
      return origStringify.apply(this, args);
    });
  }

  return globals;
}));


/***/ }),

/***/ "./node_modules/focus-visible/dist/focus-visible.js":
/*!**********************************************************!*\
  !*** ./node_modules/focus-visible/dist/focus-visible.js ***!
  \**********************************************************/
/***/ (function() {

(function (global, factory) {
   true ? factory() :
  0;
}(this, (function () { 'use strict';

  /**
   * Applies the :focus-visible polyfill at the given scope.
   * A scope in this case is either the top-level Document or a Shadow Root.
   *
   * @param {(Document|ShadowRoot)} scope
   * @see https://github.com/WICG/focus-visible
   */
  function applyFocusVisiblePolyfill(scope) {
    var hadKeyboardEvent = true;
    var hadFocusVisibleRecently = false;
    var hadFocusVisibleRecentlyTimeout = null;

    var inputTypesAllowlist = {
      text: true,
      search: true,
      url: true,
      tel: true,
      email: true,
      password: true,
      number: true,
      date: true,
      month: true,
      week: true,
      time: true,
      datetime: true,
      'datetime-local': true
    };

    /**
     * Helper function for legacy browsers and iframes which sometimes focus
     * elements like document, body, and non-interactive SVG.
     * @param {Element} el
     */
    function isValidFocusTarget(el) {
      if (
        el &&
        el !== document &&
        el.nodeName !== 'HTML' &&
        el.nodeName !== 'BODY' &&
        'classList' in el &&
        'contains' in el.classList
      ) {
        return true;
      }
      return false;
    }

    /**
     * Computes whether the given element should automatically trigger the
     * `focus-visible` class being added, i.e. whether it should always match
     * `:focus-visible` when focused.
     * @param {Element} el
     * @return {boolean}
     */
    function focusTriggersKeyboardModality(el) {
      var type = el.type;
      var tagName = el.tagName;

      if (tagName === 'INPUT' && inputTypesAllowlist[type] && !el.readOnly) {
        return true;
      }

      if (tagName === 'TEXTAREA' && !el.readOnly) {
        return true;
      }

      if (el.isContentEditable) {
        return true;
      }

      return false;
    }

    /**
     * Add the `focus-visible` class to the given element if it was not added by
     * the author.
     * @param {Element} el
     */
    function addFocusVisibleClass(el) {
      if (el.classList.contains('focus-visible')) {
        return;
      }
      el.classList.add('focus-visible');
      el.setAttribute('data-focus-visible-added', '');
    }

    /**
     * Remove the `focus-visible` class from the given element if it was not
     * originally added by the author.
     * @param {Element} el
     */
    function removeFocusVisibleClass(el) {
      if (!el.hasAttribute('data-focus-visible-added')) {
        return;
      }
      el.classList.remove('focus-visible');
      el.removeAttribute('data-focus-visible-added');
    }

    /**
     * If the most recent user interaction was via the keyboard;
     * and the key press did not include a meta, alt/option, or control key;
     * then the modality is keyboard. Otherwise, the modality is not keyboard.
     * Apply `focus-visible` to any current active element and keep track
     * of our keyboard modality state with `hadKeyboardEvent`.
     * @param {KeyboardEvent} e
     */
    function onKeyDown(e) {
      if (e.metaKey || e.altKey || e.ctrlKey) {
        return;
      }

      if (isValidFocusTarget(scope.activeElement)) {
        addFocusVisibleClass(scope.activeElement);
      }

      hadKeyboardEvent = true;
    }

    /**
     * If at any point a user clicks with a pointing device, ensure that we change
     * the modality away from keyboard.
     * This avoids the situation where a user presses a key on an already focused
     * element, and then clicks on a different element, focusing it with a
     * pointing device, while we still think we're in keyboard modality.
     * @param {Event} e
     */
    function onPointerDown(e) {
      hadKeyboardEvent = false;
    }

    /**
     * On `focus`, add the `focus-visible` class to the target if:
     * - the target received focus as a result of keyboard navigation, or
     * - the event target is an element that will likely require interaction
     *   via the keyboard (e.g. a text box)
     * @param {Event} e
     */
    function onFocus(e) {
      // Prevent IE from focusing the document or HTML element.
      if (!isValidFocusTarget(e.target)) {
        return;
      }

      if (hadKeyboardEvent || focusTriggersKeyboardModality(e.target)) {
        addFocusVisibleClass(e.target);
      }
    }

    /**
     * On `blur`, remove the `focus-visible` class from the target.
     * @param {Event} e
     */
    function onBlur(e) {
      if (!isValidFocusTarget(e.target)) {
        return;
      }

      if (
        e.target.classList.contains('focus-visible') ||
        e.target.hasAttribute('data-focus-visible-added')
      ) {
        // To detect a tab/window switch, we look for a blur event followed
        // rapidly by a visibility change.
        // If we don't see a visibility change within 100ms, it's probably a
        // regular focus change.
        hadFocusVisibleRecently = true;
        window.clearTimeout(hadFocusVisibleRecentlyTimeout);
        hadFocusVisibleRecentlyTimeout = window.setTimeout(function() {
          hadFocusVisibleRecently = false;
        }, 100);
        removeFocusVisibleClass(e.target);
      }
    }

    /**
     * If the user changes tabs, keep track of whether or not the previously
     * focused element had .focus-visible.
     * @param {Event} e
     */
    function onVisibilityChange(e) {
      if (document.visibilityState === 'hidden') {
        // If the tab becomes active again, the browser will handle calling focus
        // on the element (Safari actually calls it twice).
        // If this tab change caused a blur on an element with focus-visible,
        // re-apply the class when the user switches back to the tab.
        if (hadFocusVisibleRecently) {
          hadKeyboardEvent = true;
        }
        addInitialPointerMoveListeners();
      }
    }

    /**
     * Add a group of listeners to detect usage of any pointing devices.
     * These listeners will be added when the polyfill first loads, and anytime
     * the window is blurred, so that they are active when the window regains
     * focus.
     */
    function addInitialPointerMoveListeners() {
      document.addEventListener('mousemove', onInitialPointerMove);
      document.addEventListener('mousedown', onInitialPointerMove);
      document.addEventListener('mouseup', onInitialPointerMove);
      document.addEventListener('pointermove', onInitialPointerMove);
      document.addEventListener('pointerdown', onInitialPointerMove);
      document.addEventListener('pointerup', onInitialPointerMove);
      document.addEventListener('touchmove', onInitialPointerMove);
      document.addEventListener('touchstart', onInitialPointerMove);
      document.addEventListener('touchend', onInitialPointerMove);
    }

    function removeInitialPointerMoveListeners() {
      document.removeEventListener('mousemove', onInitialPointerMove);
      document.removeEventListener('mousedown', onInitialPointerMove);
      document.removeEventListener('mouseup', onInitialPointerMove);
      document.removeEventListener('pointermove', onInitialPointerMove);
      document.removeEventListener('pointerdown', onInitialPointerMove);
      document.removeEventListener('pointerup', onInitialPointerMove);
      document.removeEventListener('touchmove', onInitialPointerMove);
      document.removeEventListener('touchstart', onInitialPointerMove);
      document.removeEventListener('touchend', onInitialPointerMove);
    }

    /**
     * When the polfyill first loads, assume the user is in keyboard modality.
     * If any event is received from a pointing device (e.g. mouse, pointer,
     * touch), turn off keyboard modality.
     * This accounts for situations where focus enters the page from the URL bar.
     * @param {Event} e
     */
    function onInitialPointerMove(e) {
      // Work around a Safari quirk that fires a mousemove on <html> whenever the
      // window blurs, even if you're tabbing out of the page. ¯\_(ツ)_/¯
      if (e.target.nodeName && e.target.nodeName.toLowerCase() === 'html') {
        return;
      }

      hadKeyboardEvent = false;
      removeInitialPointerMoveListeners();
    }

    // For some kinds of state, we are interested in changes at the global scope
    // only. For example, global pointer input, global key presses and global
    // visibility change should affect the state at every scope:
    document.addEventListener('keydown', onKeyDown, true);
    document.addEventListener('mousedown', onPointerDown, true);
    document.addEventListener('pointerdown', onPointerDown, true);
    document.addEventListener('touchstart', onPointerDown, true);
    document.addEventListener('visibilitychange', onVisibilityChange, true);

    addInitialPointerMoveListeners();

    // For focus and blur, we specifically care about state changes in the local
    // scope. This is because focus / blur events that originate from within a
    // shadow root are not re-dispatched from the host element if it was already
    // the active element in its own scope:
    scope.addEventListener('focus', onFocus, true);
    scope.addEventListener('blur', onBlur, true);

    // We detect that a node is a ShadowRoot by ensuring that it is a
    // DocumentFragment and also has a host property. This check covers native
    // implementation and polyfill implementation transparently. If we only cared
    // about the native implementation, we could just check if the scope was
    // an instance of a ShadowRoot.
    if (scope.nodeType === Node.DOCUMENT_FRAGMENT_NODE && scope.host) {
      // Since a ShadowRoot is a special kind of DocumentFragment, it does not
      // have a root element to add a class to. So, we add this attribute to the
      // host element instead:
      scope.host.setAttribute('data-js-focus-visible', '');
    } else if (scope.nodeType === Node.DOCUMENT_NODE) {
      document.documentElement.classList.add('js-focus-visible');
      document.documentElement.setAttribute('data-js-focus-visible', '');
    }
  }

  // It is important to wrap all references to global window and document in
  // these checks to support server-side rendering use cases
  // @see https://github.com/WICG/focus-visible/issues/199
  if (typeof window !== 'undefined' && typeof document !== 'undefined') {
    // Make the polyfill helper globally available. This can be used as a signal
    // to interested libraries that wish to coordinate with the polyfill for e.g.,
    // applying the polyfill to a shadow root:
    window.applyFocusVisiblePolyfill = applyFocusVisiblePolyfill;

    // Notify interested libraries of the polyfill's presence, in case the
    // polyfill was loaded lazily:
    var event;

    try {
      event = new CustomEvent('focus-visible-polyfill-ready');
    } catch (error) {
      // IE11 does not support using CustomEvent as a constructor directly:
      event = document.createEvent('CustomEvent');
      event.initCustomEvent('focus-visible-polyfill-ready', false, false, {});
    }

    window.dispatchEvent(event);
  }

  if (typeof document !== 'undefined') {
    // Apply the polyfill to the global document, so that no JavaScript
    // coordination is required to use the polyfill in the top-level document:
    applyFocusVisiblePolyfill(document);
  }

})));


/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/function-bind/implementation.js");

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ "./node_modules/function.prototype.name/implementation.js":
/*!****************************************************************!*\
  !*** ./node_modules/function.prototype.name/implementation.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var IsCallable = __webpack_require__(/*! es-abstract/2021/IsCallable */ "./node_modules/es-abstract/2021/IsCallable.js");
var functionsHaveNames = __webpack_require__(/*! functions-have-names */ "./node_modules/functions-have-names/index.js")();
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
var $functionToString = callBound('Function.prototype.toString');
var $stringMatch = callBound('String.prototype.match');

var classRegex = /^class /;

var isClass = function isClassConstructor(fn) {
	if (IsCallable(fn)) {
		return false;
	}
	if (typeof fn !== 'function') {
		return false;
	}
	try {
		var match = $stringMatch($functionToString(fn), classRegex);
		return !!match;
	} catch (e) {}
	return false;
};

var regex = /\s*function\s+([^(\s]*)\s*/;

var functionProto = Function.prototype;

module.exports = function getName() {
	if (!isClass(this) && !IsCallable(this)) {
		throw new TypeError('Function.prototype.name sham getter called on non-function');
	}
	if (functionsHaveNames) {
		return this.name;
	}
	if (this === functionProto) {
		return '';
	}
	var str = $functionToString(this);
	var match = $stringMatch(str, regex);
	var name = match && match[1];
	return name;
};


/***/ }),

/***/ "./node_modules/function.prototype.name/polyfill.js":
/*!**********************************************************!*\
  !*** ./node_modules/function.prototype.name/polyfill.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/function.prototype.name/implementation.js");

module.exports = function getPolyfill() {
	return implementation;
};


/***/ }),

/***/ "./node_modules/function.prototype.name/shim.js":
/*!******************************************************!*\
  !*** ./node_modules/function.prototype.name/shim.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var supportsDescriptors = (__webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js").supportsDescriptors);
var functionsHaveNames = __webpack_require__(/*! functions-have-names */ "./node_modules/functions-have-names/index.js")();
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/function.prototype.name/polyfill.js");
var defineProperty = Object.defineProperty;
var TypeErr = TypeError;

module.exports = function shimName() {
	var polyfill = getPolyfill();
	if (functionsHaveNames) {
		return polyfill;
	}
	if (!supportsDescriptors) {
		throw new TypeErr('Shimming Function.prototype.name support requires ES5 property descriptor support.');
	}
	var functionProto = Function.prototype;
	defineProperty(functionProto, 'name', {
		configurable: true,
		enumerable: false,
		get: function () {
			var name = polyfill.call(this);
			if (this !== functionProto) {
				defineProperty(this, 'name', {
					configurable: true,
					enumerable: false,
					value: name,
					writable: false
				});
			}
			return name;
		}
	});
	return polyfill;
};


/***/ }),

/***/ "./node_modules/functions-have-names/index.js":
/*!****************************************************!*\
  !*** ./node_modules/functions-have-names/index.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";


var functionsHaveNames = function functionsHaveNames() {
	return typeof function f() {}.name === 'string';
};

var gOPD = Object.getOwnPropertyDescriptor;
if (gOPD) {
	try {
		gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		gOPD = null;
	}
}

functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
	return functionsHaveNames() && gOPD && !!gOPD(function () {}, 'name').configurable;
};

var $bind = Function.prototype.bind;

functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
	return functionsHaveNames() && typeof $bind === 'function' && function f() {}.bind().name !== '';
};

module.exports = functionsHaveNames;


/***/ }),

/***/ "./node_modules/get-intrinsic/index.js":
/*!*********************************************!*\
  !*** ./node_modules/get-intrinsic/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var hasOwn = __webpack_require__(/*! has */ "./node_modules/has/src/index.js");
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ "./node_modules/get-symbol-description/getInferredName.js":
/*!****************************************************************!*\
  !*** ./node_modules/get-symbol-description/getInferredName.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";


var getInferredName;
try {
	// eslint-disable-next-line no-new-func
	getInferredName = Function('s', 'return { [s]() {} }[s].name;');
} catch (e) {}

var inferred = function () {};
module.exports = getInferredName && inferred.name === 'inferred' ? getInferredName : null;


/***/ }),

/***/ "./node_modules/get-symbol-description/index.js":
/*!******************************************************!*\
  !*** ./node_modules/get-symbol-description/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");

var $SyntaxError = GetIntrinsic('%SyntaxError%');
var getGlobalSymbolDescription = GetIntrinsic('%Symbol.keyFor%', true);
var thisSymbolValue = callBound('%Symbol.prototype.valueOf%', true);
var symToStr = callBound('Symbol.prototype.toString', true);

var getInferredName = __webpack_require__(/*! ./getInferredName */ "./node_modules/get-symbol-description/getInferredName.js");

/* eslint-disable consistent-return */
module.exports = callBound('%Symbol.prototype.description%', true) || function getSymbolDescription(symbol) {
	if (!thisSymbolValue) {
		throw new $SyntaxError('Symbols are not supported in this environment');
	}

	// will throw if not a symbol primitive or wrapper object
	var sym = thisSymbolValue(symbol);

	if (getInferredName) {
		var name = getInferredName(sym);
		if (name === '') {
			return;
		}
		return name.slice(1, -1); // name.slice('['.length, -']'.length);
	}

	var desc;
	if (getGlobalSymbolDescription) {
		desc = getGlobalSymbolDescription(sym);
		if (typeof desc === 'string') {
			return desc;
		}
	}

	desc = symToStr(sym).slice(7, -1); // str.slice('Symbol('.length, -')'.length);
	if (desc) {
		return desc;
	}
};


/***/ }),

/***/ "./node_modules/globalthis/auto.js":
/*!*****************************************!*\
  !*** ./node_modules/globalthis/auto.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! ./shim */ "./node_modules/globalthis/shim.js")();


/***/ }),

/***/ "./node_modules/globalthis/implementation.browser.js":
/*!***********************************************************!*\
  !*** ./node_modules/globalthis/implementation.browser.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
/* eslint no-negated-condition: 0, no-new-func: 0 */



if (typeof self !== 'undefined') {
	module.exports = self;
} else if (typeof window !== 'undefined') {
	module.exports = window;
} else {
	module.exports = Function('return this')();
}


/***/ }),

/***/ "./node_modules/globalthis/polyfill.js":
/*!*********************************************!*\
  !*** ./node_modules/globalthis/polyfill.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/globalthis/implementation.browser.js");

module.exports = function getPolyfill() {
	if (typeof __webpack_require__.g !== 'object' || !__webpack_require__.g || __webpack_require__.g.Math !== Math || __webpack_require__.g.Array !== Array) {
		return implementation;
	}
	return __webpack_require__.g;
};


/***/ }),

/***/ "./node_modules/globalthis/shim.js":
/*!*****************************************!*\
  !*** ./node_modules/globalthis/shim.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/globalthis/polyfill.js");

module.exports = function shimGlobal() {
	var polyfill = getPolyfill();
	if (define.supportsDescriptors) {
		var descriptor = Object.getOwnPropertyDescriptor(polyfill, 'globalThis');
		if (!descriptor || (descriptor.configurable && (descriptor.enumerable || descriptor.writable || globalThis !== polyfill))) { // eslint-disable-line max-len
			Object.defineProperty(polyfill, 'globalThis', {
				configurable: true,
				enumerable: false,
				value: polyfill,
				writable: false
			});
		}
	} else if (typeof globalThis !== 'object' || globalThis !== polyfill) {
		polyfill.globalThis = polyfill;
	}
	return polyfill;
};


/***/ }),

/***/ "./node_modules/has-symbols/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(/*! ./shams */ "./node_modules/has-symbols/shams.js");

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ "./node_modules/has-symbols/shams.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ "./node_modules/has-tostringtag/shams.js":
/*!***********************************************!*\
  !*** ./node_modules/has-tostringtag/shams.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasSymbols = __webpack_require__(/*! has-symbols/shams */ "./node_modules/has-symbols/shams.js");

module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};


/***/ }),

/***/ "./node_modules/has/src/index.js":
/*!***************************************!*\
  !*** ./node_modules/has/src/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);


/***/ }),

/***/ "./node_modules/ima-babel6-polyfill/index.js":
/*!***************************************************!*\
  !*** ./node_modules/ima-babel6-polyfill/index.js ***!
  \***************************************************/
/***/ (() => {

(function() {
	var testObject = {};

	if (!(Object.setPrototypeOf || testObject.__proto__)) {
		var nativeGetPrototypeOf = Object.getPrototypeOf;

		Object.getPrototypeOf = function(object) {
			if (object.__proto__) {
				return object.__proto__;
			} else {
				return nativeGetPrototypeOf.call(Object, object);
			}
		}
	}
})();


/***/ }),

/***/ "./node_modules/input-placeholder-polyfill/dist/main.min.js":
/*!******************************************************************!*\
  !*** ./node_modules/input-placeholder-polyfill/dist/main.min.js ***!
  \******************************************************************/
/***/ (() => {

function hidePlaceholderOnFocus(a){target=a.currentTarget?a.currentTarget:a.srcElement,target.value==target.getAttribute("placeholder")&&(target.value="")}function unfocusOnAnElement(a){target=a.currentTarget?a.currentTarget:a.srcElement,""==target.value&&(target.value=target.getAttribute("placeholder"))}if(!("placeholder"in document.createElement("input")))for(var inputs=document.getElementsByTagName("input"),i=0;i<inputs.length;i++)inputs[i].value||(inputs[i].value=inputs[i].getAttribute("placeholder")),inputs[i].addEventListener?(inputs[i].addEventListener("click",hidePlaceholderOnFocus,!1),inputs[i].addEventListener("blur",unfocusOnAnElement,!1)):inputs[i].attachEvent&&(inputs[i].attachEvent("onclick",hidePlaceholderOnFocus),inputs[i].attachEvent("onblur",unfocusOnAnElement));

/***/ }),

/***/ "./node_modules/internal-slot/index.js":
/*!*********************************************!*\
  !*** ./node_modules/internal-slot/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var has = __webpack_require__(/*! has */ "./node_modules/has/src/index.js");
var channel = __webpack_require__(/*! side-channel */ "./node_modules/side-channel/index.js")();

var $TypeError = GetIntrinsic('%TypeError%');

var SLOT = {
	assert: function (O, slot) {
		if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
			throw new $TypeError('`O` is not an object');
		}
		if (typeof slot !== 'string') {
			throw new $TypeError('`slot` must be a string');
		}
		channel.assert(O);
	},
	get: function (O, slot) {
		if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
			throw new $TypeError('`O` is not an object');
		}
		if (typeof slot !== 'string') {
			throw new $TypeError('`slot` must be a string');
		}
		var slots = channel.get(O);
		return slots && slots['$' + slot];
	},
	has: function (O, slot) {
		if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
			throw new $TypeError('`O` is not an object');
		}
		if (typeof slot !== 'string') {
			throw new $TypeError('`slot` must be a string');
		}
		var slots = channel.get(O);
		return !!slots && has(slots, '$' + slot);
	},
	set: function (O, slot, V) {
		if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
			throw new $TypeError('`O` is not an object');
		}
		if (typeof slot !== 'string') {
			throw new $TypeError('`slot` must be a string');
		}
		var slots = channel.get(O);
		if (!slots) {
			slots = {};
			channel.set(O, slots);
		}
		slots['$' + slot] = V;
	}
};

if (Object.freeze) {
	Object.freeze(SLOT);
}

module.exports = SLOT;


/***/ }),

/***/ "./node_modules/intersection-observer/intersection-observer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/intersection-observer/intersection-observer.js ***!
  \*********************************************************************/
/***/ (() => {

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.
 *
 *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 *
 */

(function(window, document) {
'use strict';


// Exits early if all IntersectionObserver and IntersectionObserverEntry
// features are natively supported.
if ('IntersectionObserver' in window &&
    'IntersectionObserverEntry' in window &&
    'intersectionRatio' in window.IntersectionObserverEntry.prototype) {

  // Minimal polyfill for Edge 15's lack of `isIntersecting`
  // See: https://github.com/w3c/IntersectionObserver/issues/211
  if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {
    Object.defineProperty(window.IntersectionObserverEntry.prototype,
      'isIntersecting', {
      get: function () {
        return this.intersectionRatio > 0;
      }
    });
  }
  return;
}


/**
 * An IntersectionObserver registry. This registry exists to hold a strong
 * reference to IntersectionObserver instances currently observing a target
 * element. Without this registry, instances without another reference may be
 * garbage collected.
 */
var registry = [];


/**
 * Creates the global IntersectionObserverEntry constructor.
 * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry
 * @param {Object} entry A dictionary of instance properties.
 * @constructor
 */
function IntersectionObserverEntry(entry) {
  this.time = entry.time;
  this.target = entry.target;
  this.rootBounds = entry.rootBounds;
  this.boundingClientRect = entry.boundingClientRect;
  this.intersectionRect = entry.intersectionRect || getEmptyRect();
  this.isIntersecting = !!entry.intersectionRect;

  // Calculates the intersection ratio.
  var targetRect = this.boundingClientRect;
  var targetArea = targetRect.width * targetRect.height;
  var intersectionRect = this.intersectionRect;
  var intersectionArea = intersectionRect.width * intersectionRect.height;

  // Sets intersection ratio.
  if (targetArea) {
    // Round the intersection ratio to avoid floating point math issues:
    // https://github.com/w3c/IntersectionObserver/issues/324
    this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));
  } else {
    // If area is zero and is intersecting, sets to 1, otherwise to 0
    this.intersectionRatio = this.isIntersecting ? 1 : 0;
  }
}


/**
 * Creates the global IntersectionObserver constructor.
 * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface
 * @param {Function} callback The function to be invoked after intersection
 *     changes have queued. The function is not invoked if the queue has
 *     been emptied by calling the `takeRecords` method.
 * @param {Object=} opt_options Optional configuration options.
 * @constructor
 */
function IntersectionObserver(callback, opt_options) {

  var options = opt_options || {};

  if (typeof callback != 'function') {
    throw new Error('callback must be a function');
  }

  if (options.root && options.root.nodeType != 1) {
    throw new Error('root must be an Element');
  }

  // Binds and throttles `this._checkForIntersections`.
  this._checkForIntersections = throttle(
      this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);

  // Private properties.
  this._callback = callback;
  this._observationTargets = [];
  this._queuedEntries = [];
  this._rootMarginValues = this._parseRootMargin(options.rootMargin);

  // Public properties.
  this.thresholds = this._initThresholds(options.threshold);
  this.root = options.root || null;
  this.rootMargin = this._rootMarginValues.map(function(margin) {
    return margin.value + margin.unit;
  }).join(' ');
}


/**
 * The minimum interval within which the document will be checked for
 * intersection changes.
 */
IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;


/**
 * The frequency in which the polyfill polls for intersection changes.
 * this can be updated on a per instance basis and must be set prior to
 * calling `observe` on the first target.
 */
IntersectionObserver.prototype.POLL_INTERVAL = null;

/**
 * Use a mutation observer on the root element
 * to detect intersection changes.
 */
IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;


/**
 * Starts observing a target element for intersection changes based on
 * the thresholds values.
 * @param {Element} target The DOM element to observe.
 */
IntersectionObserver.prototype.observe = function(target) {
  var isTargetAlreadyObserved = this._observationTargets.some(function(item) {
    return item.element == target;
  });

  if (isTargetAlreadyObserved) {
    return;
  }

  if (!(target && target.nodeType == 1)) {
    throw new Error('target must be an Element');
  }

  this._registerInstance();
  this._observationTargets.push({element: target, entry: null});
  this._monitorIntersections();
  this._checkForIntersections();
};


/**
 * Stops observing a target element for intersection changes.
 * @param {Element} target The DOM element to observe.
 */
IntersectionObserver.prototype.unobserve = function(target) {
  this._observationTargets =
      this._observationTargets.filter(function(item) {

    return item.element != target;
  });
  if (!this._observationTargets.length) {
    this._unmonitorIntersections();
    this._unregisterInstance();
  }
};


/**
 * Stops observing all target elements for intersection changes.
 */
IntersectionObserver.prototype.disconnect = function() {
  this._observationTargets = [];
  this._unmonitorIntersections();
  this._unregisterInstance();
};


/**
 * Returns any queue entries that have not yet been reported to the
 * callback and clears the queue. This can be used in conjunction with the
 * callback to obtain the absolute most up-to-date intersection information.
 * @return {Array} The currently queued entries.
 */
IntersectionObserver.prototype.takeRecords = function() {
  var records = this._queuedEntries.slice();
  this._queuedEntries = [];
  return records;
};


/**
 * Accepts the threshold value from the user configuration object and
 * returns a sorted array of unique threshold values. If a value is not
 * between 0 and 1 and error is thrown.
 * @private
 * @param {Array|number=} opt_threshold An optional threshold value or
 *     a list of threshold values, defaulting to [0].
 * @return {Array} A sorted list of unique and valid threshold values.
 */
IntersectionObserver.prototype._initThresholds = function(opt_threshold) {
  var threshold = opt_threshold || [0];
  if (!Array.isArray(threshold)) threshold = [threshold];

  return threshold.sort().filter(function(t, i, a) {
    if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {
      throw new Error('threshold must be a number between 0 and 1 inclusively');
    }
    return t !== a[i - 1];
  });
};


/**
 * Accepts the rootMargin value from the user configuration object
 * and returns an array of the four margin values as an object containing
 * the value and unit properties. If any of the values are not properly
 * formatted or use a unit other than px or %, and error is thrown.
 * @private
 * @param {string=} opt_rootMargin An optional rootMargin value,
 *     defaulting to '0px'.
 * @return {Array<Object>} An array of margin objects with the keys
 *     value and unit.
 */
IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {
  var marginString = opt_rootMargin || '0px';
  var margins = marginString.split(/\s+/).map(function(margin) {
    var parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
    if (!parts) {
      throw new Error('rootMargin must be specified in pixels or percent');
    }
    return {value: parseFloat(parts[1]), unit: parts[2]};
  });

  // Handles shorthand.
  margins[1] = margins[1] || margins[0];
  margins[2] = margins[2] || margins[0];
  margins[3] = margins[3] || margins[1];

  return margins;
};


/**
 * Starts polling for intersection changes if the polling is not already
 * happening, and if the page's visibility state is visible.
 * @private
 */
IntersectionObserver.prototype._monitorIntersections = function() {
  if (!this._monitoringIntersections) {
    this._monitoringIntersections = true;

    // If a poll interval is set, use polling instead of listening to
    // resize and scroll events or DOM mutations.
    if (this.POLL_INTERVAL) {
      this._monitoringInterval = setInterval(
          this._checkForIntersections, this.POLL_INTERVAL);
    }
    else {
      addEvent(window, 'resize', this._checkForIntersections, true);
      addEvent(document, 'scroll', this._checkForIntersections, true);

      if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in window) {
        this._domObserver = new MutationObserver(this._checkForIntersections);
        this._domObserver.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      }
    }
  }
};


/**
 * Stops polling for intersection changes.
 * @private
 */
IntersectionObserver.prototype._unmonitorIntersections = function() {
  if (this._monitoringIntersections) {
    this._monitoringIntersections = false;

    clearInterval(this._monitoringInterval);
    this._monitoringInterval = null;

    removeEvent(window, 'resize', this._checkForIntersections, true);
    removeEvent(document, 'scroll', this._checkForIntersections, true);

    if (this._domObserver) {
      this._domObserver.disconnect();
      this._domObserver = null;
    }
  }
};


/**
 * Scans each observation target for intersection changes and adds them
 * to the internal entries queue. If new entries are found, it
 * schedules the callback to be invoked.
 * @private
 */
IntersectionObserver.prototype._checkForIntersections = function() {
  var rootIsInDom = this._rootIsInDom();
  var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();

  this._observationTargets.forEach(function(item) {
    var target = item.element;
    var targetRect = getBoundingClientRect(target);
    var rootContainsTarget = this._rootContainsTarget(target);
    var oldEntry = item.entry;
    var intersectionRect = rootIsInDom && rootContainsTarget &&
        this._computeTargetAndRootIntersection(target, rootRect);

    var newEntry = item.entry = new IntersectionObserverEntry({
      time: now(),
      target: target,
      boundingClientRect: targetRect,
      rootBounds: rootRect,
      intersectionRect: intersectionRect
    });

    if (!oldEntry) {
      this._queuedEntries.push(newEntry);
    } else if (rootIsInDom && rootContainsTarget) {
      // If the new entry intersection ratio has crossed any of the
      // thresholds, add a new entry.
      if (this._hasCrossedThreshold(oldEntry, newEntry)) {
        this._queuedEntries.push(newEntry);
      }
    } else {
      // If the root is not in the DOM or target is not contained within
      // root but the previous entry for this target had an intersection,
      // add a new record indicating removal.
      if (oldEntry && oldEntry.isIntersecting) {
        this._queuedEntries.push(newEntry);
      }
    }
  }, this);

  if (this._queuedEntries.length) {
    this._callback(this.takeRecords(), this);
  }
};


/**
 * Accepts a target and root rect computes the intersection between then
 * following the algorithm in the spec.
 * TODO(philipwalton): at this time clip-path is not considered.
 * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo
 * @param {Element} target The target DOM element
 * @param {Object} rootRect The bounding rect of the root after being
 *     expanded by the rootMargin value.
 * @return {?Object} The final intersection rect object or undefined if no
 *     intersection is found.
 * @private
 */
IntersectionObserver.prototype._computeTargetAndRootIntersection =
    function(target, rootRect) {

  // If the element isn't displayed, an intersection can't happen.
  if (window.getComputedStyle(target).display == 'none') return;

  var targetRect = getBoundingClientRect(target);
  var intersectionRect = targetRect;
  var parent = getParentNode(target);
  var atRoot = false;

  while (!atRoot) {
    var parentRect = null;
    var parentComputedStyle = parent.nodeType == 1 ?
        window.getComputedStyle(parent) : {};

    // If the parent isn't displayed, an intersection can't happen.
    if (parentComputedStyle.display == 'none') return;

    if (parent == this.root || parent == document) {
      atRoot = true;
      parentRect = rootRect;
    } else {
      // If the element has a non-visible overflow, and it's not the <body>
      // or <html> element, update the intersection rect.
      // Note: <body> and <html> cannot be clipped to a rect that's not also
      // the document rect, so no need to compute a new intersection.
      if (parent != document.body &&
          parent != document.documentElement &&
          parentComputedStyle.overflow != 'visible') {
        parentRect = getBoundingClientRect(parent);
      }
    }

    // If either of the above conditionals set a new parentRect,
    // calculate new intersection data.
    if (parentRect) {
      intersectionRect = computeRectIntersection(parentRect, intersectionRect);

      if (!intersectionRect) break;
    }
    parent = getParentNode(parent);
  }
  return intersectionRect;
};


/**
 * Returns the root rect after being expanded by the rootMargin value.
 * @return {Object} The expanded root rect.
 * @private
 */
IntersectionObserver.prototype._getRootRect = function() {
  var rootRect;
  if (this.root) {
    rootRect = getBoundingClientRect(this.root);
  } else {
    // Use <html>/<body> instead of window since scroll bars affect size.
    var html = document.documentElement;
    var body = document.body;
    rootRect = {
      top: 0,
      left: 0,
      right: html.clientWidth || body.clientWidth,
      width: html.clientWidth || body.clientWidth,
      bottom: html.clientHeight || body.clientHeight,
      height: html.clientHeight || body.clientHeight
    };
  }
  return this._expandRectByRootMargin(rootRect);
};


/**
 * Accepts a rect and expands it by the rootMargin value.
 * @param {Object} rect The rect object to expand.
 * @return {Object} The expanded rect.
 * @private
 */
IntersectionObserver.prototype._expandRectByRootMargin = function(rect) {
  var margins = this._rootMarginValues.map(function(margin, i) {
    return margin.unit == 'px' ? margin.value :
        margin.value * (i % 2 ? rect.width : rect.height) / 100;
  });
  var newRect = {
    top: rect.top - margins[0],
    right: rect.right + margins[1],
    bottom: rect.bottom + margins[2],
    left: rect.left - margins[3]
  };
  newRect.width = newRect.right - newRect.left;
  newRect.height = newRect.bottom - newRect.top;

  return newRect;
};


/**
 * Accepts an old and new entry and returns true if at least one of the
 * threshold values has been crossed.
 * @param {?IntersectionObserverEntry} oldEntry The previous entry for a
 *    particular target element or null if no previous entry exists.
 * @param {IntersectionObserverEntry} newEntry The current entry for a
 *    particular target element.
 * @return {boolean} Returns true if a any threshold has been crossed.
 * @private
 */
IntersectionObserver.prototype._hasCrossedThreshold =
    function(oldEntry, newEntry) {

  // To make comparing easier, an entry that has a ratio of 0
  // but does not actually intersect is given a value of -1
  var oldRatio = oldEntry && oldEntry.isIntersecting ?
      oldEntry.intersectionRatio || 0 : -1;
  var newRatio = newEntry.isIntersecting ?
      newEntry.intersectionRatio || 0 : -1;

  // Ignore unchanged ratios
  if (oldRatio === newRatio) return;

  for (var i = 0; i < this.thresholds.length; i++) {
    var threshold = this.thresholds[i];

    // Return true if an entry matches a threshold or if the new ratio
    // and the old ratio are on the opposite sides of a threshold.
    if (threshold == oldRatio || threshold == newRatio ||
        threshold < oldRatio !== threshold < newRatio) {
      return true;
    }
  }
};


/**
 * Returns whether or not the root element is an element and is in the DOM.
 * @return {boolean} True if the root element is an element and is in the DOM.
 * @private
 */
IntersectionObserver.prototype._rootIsInDom = function() {
  return !this.root || containsDeep(document, this.root);
};


/**
 * Returns whether or not the target element is a child of root.
 * @param {Element} target The target element to check.
 * @return {boolean} True if the target element is a child of root.
 * @private
 */
IntersectionObserver.prototype._rootContainsTarget = function(target) {
  return containsDeep(this.root || document, target);
};


/**
 * Adds the instance to the global IntersectionObserver registry if it isn't
 * already present.
 * @private
 */
IntersectionObserver.prototype._registerInstance = function() {
  if (registry.indexOf(this) < 0) {
    registry.push(this);
  }
};


/**
 * Removes the instance from the global IntersectionObserver registry.
 * @private
 */
IntersectionObserver.prototype._unregisterInstance = function() {
  var index = registry.indexOf(this);
  if (index != -1) registry.splice(index, 1);
};


/**
 * Returns the result of the performance.now() method or null in browsers
 * that don't support the API.
 * @return {number} The elapsed time since the page was requested.
 */
function now() {
  return window.performance && performance.now && performance.now();
}


/**
 * Throttles a function and delays its execution, so it's only called at most
 * once within a given time period.
 * @param {Function} fn The function to throttle.
 * @param {number} timeout The amount of time that must pass before the
 *     function can be called again.
 * @return {Function} The throttled function.
 */
function throttle(fn, timeout) {
  var timer = null;
  return function () {
    if (!timer) {
      timer = setTimeout(function() {
        fn();
        timer = null;
      }, timeout);
    }
  };
}


/**
 * Adds an event handler to a DOM node ensuring cross-browser compatibility.
 * @param {Node} node The DOM node to add the event handler to.
 * @param {string} event The event name.
 * @param {Function} fn The event handler to add.
 * @param {boolean} opt_useCapture Optionally adds the even to the capture
 *     phase. Note: this only works in modern browsers.
 */
function addEvent(node, event, fn, opt_useCapture) {
  if (typeof node.addEventListener == 'function') {
    node.addEventListener(event, fn, opt_useCapture || false);
  }
  else if (typeof node.attachEvent == 'function') {
    node.attachEvent('on' + event, fn);
  }
}


/**
 * Removes a previously added event handler from a DOM node.
 * @param {Node} node The DOM node to remove the event handler from.
 * @param {string} event The event name.
 * @param {Function} fn The event handler to remove.
 * @param {boolean} opt_useCapture If the event handler was added with this
 *     flag set to true, it should be set to true here in order to remove it.
 */
function removeEvent(node, event, fn, opt_useCapture) {
  if (typeof node.removeEventListener == 'function') {
    node.removeEventListener(event, fn, opt_useCapture || false);
  }
  else if (typeof node.detatchEvent == 'function') {
    node.detatchEvent('on' + event, fn);
  }
}


/**
 * Returns the intersection between two rect objects.
 * @param {Object} rect1 The first rect.
 * @param {Object} rect2 The second rect.
 * @return {?Object} The intersection rect or undefined if no intersection
 *     is found.
 */
function computeRectIntersection(rect1, rect2) {
  var top = Math.max(rect1.top, rect2.top);
  var bottom = Math.min(rect1.bottom, rect2.bottom);
  var left = Math.max(rect1.left, rect2.left);
  var right = Math.min(rect1.right, rect2.right);
  var width = right - left;
  var height = bottom - top;

  return (width >= 0 && height >= 0) && {
    top: top,
    bottom: bottom,
    left: left,
    right: right,
    width: width,
    height: height
  };
}


/**
 * Shims the native getBoundingClientRect for compatibility with older IE.
 * @param {Element} el The element whose bounding rect to get.
 * @return {Object} The (possibly shimmed) rect of the element.
 */
function getBoundingClientRect(el) {
  var rect;

  try {
    rect = el.getBoundingClientRect();
  } catch (err) {
    // Ignore Windows 7 IE11 "Unspecified error"
    // https://github.com/w3c/IntersectionObserver/pull/205
  }

  if (!rect) return getEmptyRect();

  // Older IE
  if (!(rect.width && rect.height)) {
    rect = {
      top: rect.top,
      right: rect.right,
      bottom: rect.bottom,
      left: rect.left,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top
    };
  }
  return rect;
}


/**
 * Returns an empty rect object. An empty rect is returned when an element
 * is not in the DOM.
 * @return {Object} The empty rect.
 */
function getEmptyRect() {
  return {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    width: 0,
    height: 0
  };
}

/**
 * Checks to see if a parent element contains a child element (including inside
 * shadow DOM).
 * @param {Node} parent The parent element.
 * @param {Node} child The child element.
 * @return {boolean} True if the parent node contains the child node.
 */
function containsDeep(parent, child) {
  var node = child;
  while (node) {
    if (node == parent) return true;

    node = getParentNode(node);
  }
  return false;
}


/**
 * Gets the parent node of an element or its host element if the parent node
 * is a shadow root.
 * @param {Node} node The node whose parent to get.
 * @return {Node|null} The parent node or null if no parent exists.
 */
function getParentNode(node) {
  var parent = node.parentNode;

  if (parent && parent.nodeType == 11 && parent.host) {
    // If the parent is a shadow root, return the host element.
    return parent.host;
  }
  return parent;
}


// Exposes the constructors globally.
window.IntersectionObserver = IntersectionObserver;
window.IntersectionObserverEntry = IntersectionObserverEntry;

}(window, document));


/***/ }),

/***/ "./node_modules/is-arguments/index.js":
/*!********************************************!*\
  !*** ./node_modules/is-arguments/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		$toString(value) !== '[object Array]' &&
		$toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;


/***/ }),

/***/ "./node_modules/is-callable/index.js":
/*!*******************************************!*\
  !*** ./node_modules/is-callable/index.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
	try {
		badArrayLike = Object.defineProperty({}, 'length', {
			get: function () {
				throw isCallableMarker;
			}
		});
		isCallableMarker = {};
		// eslint-disable-next-line no-throw-literal
		reflectApply(function () { throw 42; }, null, badArrayLike);
	} catch (_) {
		if (_ !== isCallableMarker) {
			reflectApply = null;
		}
	}
} else {
	reflectApply = null;
}

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`
/* globals document: false */
var documentDotAll = typeof document === 'object' && typeof document.all === 'undefined' && document.all !== undefined ? document.all : {};

module.exports = reflectApply
	? function isCallable(value) {
		if (value === documentDotAll) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (typeof value === 'function' && !value.prototype) { return true; }
		try {
			reflectApply(value, null, badArrayLike);
		} catch (e) {
			if (e !== isCallableMarker) { return false; }
		}
		return !isES6ClassFn(value);
	}
	: function isCallable(value) {
		if (value === documentDotAll) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (typeof value === 'function' && !value.prototype) { return true; }
		if (hasToStringTag) { return tryFunctionObject(value); }
		if (isES6ClassFn(value)) { return false; }
		var strClass = toStr.call(value);
		return strClass === fnClass || strClass === genClass;
	};


/***/ }),

/***/ "./node_modules/is-date-object/index.js":
/*!**********************************************!*\
  !*** ./node_modules/is-date-object/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateGetDayCall(value) {
	try {
		getDay.call(value);
		return true;
	} catch (e) {
		return false;
	}
};

var toStr = Object.prototype.toString;
var dateClass = '[object Date]';
var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();

module.exports = function isDateObject(value) {
	if (typeof value !== 'object' || value === null) {
		return false;
	}
	return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
};


/***/ }),

/***/ "./node_modules/is-map/index.js":
/*!**************************************!*\
  !*** ./node_modules/is-map/index.js ***!
  \**************************************/
/***/ ((module) => {

"use strict";


var $Map = typeof Map === 'function' && Map.prototype ? Map : null;
var $Set = typeof Set === 'function' && Set.prototype ? Set : null;

var exported;

if (!$Map) {
	// eslint-disable-next-line no-unused-vars
	exported = function isMap(x) {
		// `Map` is not present in this environment.
		return false;
	};
}

var $mapHas = $Map ? Map.prototype.has : null;
var $setHas = $Set ? Set.prototype.has : null;
if (!exported && !$mapHas) {
	// eslint-disable-next-line no-unused-vars
	exported = function isMap(x) {
		// `Map` does not have a `has` method
		return false;
	};
}

module.exports = exported || function isMap(x) {
	if (!x || typeof x !== 'object') {
		return false;
	}
	try {
		$mapHas.call(x);
		if ($setHas) {
			try {
				$setHas.call(x);
			} catch (e) {
				return true;
			}
		}
		return x instanceof $Map; // core-js workaround, pre-v2.5.0
	} catch (e) {}
	return false;
};


/***/ }),

/***/ "./node_modules/is-regex/index.js":
/*!****************************************!*\
  !*** ./node_modules/is-regex/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();
var has;
var $exec;
var isRegexMarker;
var badStringifier;

if (hasToStringTag) {
	has = callBound('Object.prototype.hasOwnProperty');
	$exec = callBound('RegExp.prototype.exec');
	isRegexMarker = {};

	var throwRegexMarker = function () {
		throw isRegexMarker;
	};
	badStringifier = {
		toString: throwRegexMarker,
		valueOf: throwRegexMarker
	};

	if (typeof Symbol.toPrimitive === 'symbol') {
		badStringifier[Symbol.toPrimitive] = throwRegexMarker;
	}
}

var $toString = callBound('Object.prototype.toString');
var gOPD = Object.getOwnPropertyDescriptor;
var regexClass = '[object RegExp]';

module.exports = hasToStringTag
	// eslint-disable-next-line consistent-return
	? function isRegex(value) {
		if (!value || typeof value !== 'object') {
			return false;
		}

		var descriptor = gOPD(value, 'lastIndex');
		var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
		if (!hasLastIndexDataProperty) {
			return false;
		}

		try {
			$exec(value, badStringifier);
		} catch (e) {
			return e === isRegexMarker;
		}
	}
	: function isRegex(value) {
		// In older browsers, typeof regex incorrectly returns 'function'
		if (!value || (typeof value !== 'object' && typeof value !== 'function')) {
			return false;
		}

		return $toString(value) === regexClass;
	};


/***/ }),

/***/ "./node_modules/is-set/index.js":
/*!**************************************!*\
  !*** ./node_modules/is-set/index.js ***!
  \**************************************/
/***/ ((module) => {

"use strict";


var $Map = typeof Map === 'function' && Map.prototype ? Map : null;
var $Set = typeof Set === 'function' && Set.prototype ? Set : null;

var exported;

if (!$Set) {
	// eslint-disable-next-line no-unused-vars
	exported = function isSet(x) {
		// `Set` is not present in this environment.
		return false;
	};
}

var $mapHas = $Map ? Map.prototype.has : null;
var $setHas = $Set ? Set.prototype.has : null;
if (!exported && !$setHas) {
	// eslint-disable-next-line no-unused-vars
	exported = function isSet(x) {
		// `Set` does not have a `has` method
		return false;
	};
}

module.exports = exported || function isSet(x) {
	if (!x || typeof x !== 'object') {
		return false;
	}
	try {
		$setHas.call(x);
		if ($mapHas) {
			try {
				$mapHas.call(x);
			} catch (e) {
				return true;
			}
		}
		return x instanceof $Set; // core-js workaround, pre-v2.5.0
	} catch (e) {}
	return false;
};


/***/ }),

/***/ "./node_modules/is-string/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-string/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var strValue = String.prototype.valueOf;
var tryStringObject = function tryStringObject(value) {
	try {
		strValue.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var strClass = '[object String]';
var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();

module.exports = function isString(value) {
	if (typeof value === 'string') {
		return true;
	}
	if (typeof value !== 'object') {
		return false;
	}
	return hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;
};


/***/ }),

/***/ "./node_modules/is-symbol/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-symbol/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var toStr = Object.prototype.toString;
var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();

if (hasSymbols) {
	var symToStr = Symbol.prototype.toString;
	var symStringRegex = /^Symbol\(.*\)$/;
	var isSymbolObject = function isRealSymbolObject(value) {
		if (typeof value.valueOf() !== 'symbol') {
			return false;
		}
		return symStringRegex.test(symToStr.call(value));
	};

	module.exports = function isSymbol(value) {
		if (typeof value === 'symbol') {
			return true;
		}
		if (toStr.call(value) !== '[object Symbol]') {
			return false;
		}
		try {
			return isSymbolObject(value);
		} catch (e) {
			return false;
		}
	};
} else {

	module.exports = function isSymbol(value) {
		// this environment does not support Symbols.
		return  false && 0;
	};
}


/***/ }),

/***/ "./node_modules/iterate-iterator/index.js":
/*!************************************************!*\
  !*** ./node_modules/iterate-iterator/index.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
module.exports = function iterateIterator(iterator) {
	if (!iterator || typeof iterator.next !== 'function') {
		throw new $TypeError('iterator must be an object with a `next` method');
	}
	if (arguments.length > 1) {
		var callback = arguments[1];
		if (typeof callback !== 'function') {
			throw new $TypeError('`callback`, if provided, must be a function');
		}
	}
	var values = callback || [];
	var result;
	while ((result = iterator.next()) && !result.done) {
		if (callback) {
			callback(result.value); // eslint-disable-line callback-return
		} else {
			values.push(result.value);
		}
	}
	if (!callback) {
		return values;
	}
};


/***/ }),

/***/ "./node_modules/matchmedia-polyfill/matchMedia.addListener.js":
/*!********************************************************************!*\
  !*** ./node_modules/matchmedia-polyfill/matchMedia.addListener.js ***!
  \********************************************************************/
/***/ (() => {

/*! matchMedia() polyfill addListener/removeListener extension. Author & copyright (c) 2012: Scott Jehl. MIT license */
(function(){
    // Bail out for browsers that have addListener support
    if (window.matchMedia && window.matchMedia('all').addListener) {
        return false;
    }

    var localMatchMedia = window.matchMedia,
        hasMediaQueries = localMatchMedia('only all').matches,
        isListening     = false,
        timeoutID       = 0,    // setTimeout for debouncing 'handleChange'
        queries         = [],   // Contains each 'mql' and associated 'listeners' if 'addListener' is used
        handleChange    = function(evt) {
            // Debounce
            clearTimeout(timeoutID);

            timeoutID = setTimeout(function() {
                for (var i = 0, il = queries.length; i < il; i++) {
                    var mql         = queries[i].mql,
                        listeners   = queries[i].listeners || [],
                        matches     = localMatchMedia(mql.media).matches;

                    // Update mql.matches value and call listeners
                    // Fire listeners only if transitioning to or from matched state
                    if (matches !== mql.matches) {
                        mql.matches = matches;

                        for (var j = 0, jl = listeners.length; j < jl; j++) {
                            listeners[j].call(window, mql);
                        }
                    }
                }
            }, 30);
        };

    window.matchMedia = function(media) {
        var mql         = localMatchMedia(media),
            listeners   = [],
            index       = 0;

        mql.addListener = function(listener) {
            // Changes would not occur to css media type so return now (Affects IE <= 8)
            if (!hasMediaQueries) {
                return;
            }

            // Set up 'resize' listener for browsers that support CSS3 media queries (Not for IE <= 8)
            // There should only ever be 1 resize listener running for performance
            if (!isListening) {
                isListening = true;
                window.addEventListener('resize', handleChange, true);
            }

            // Push object only if it has not been pushed already
            if (index === 0) {
                index = queries.push({
                    mql         : mql,
                    listeners   : listeners
                });
            }

            listeners.push(listener);
        };

        mql.removeListener = function(listener) {
            for (var i = 0, il = listeners.length; i < il; i++){
                if (listeners[i] === listener){
                    listeners.splice(i, 1);
                }
            }
        };

        return mql;
    };
}());


/***/ }),

/***/ "./node_modules/matchmedia-polyfill/matchMedia.js":
/*!********************************************************!*\
  !*** ./node_modules/matchmedia-polyfill/matchMedia.js ***!
  \********************************************************/
/***/ (() => {

/*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. MIT license */

window.matchMedia || (window.matchMedia = function() {
    "use strict";

    // For browsers that support matchMedium api such as IE 9 and webkit
    var styleMedia = (window.styleMedia || window.media);

    // For those that don't support matchMedium
    if (!styleMedia) {
        var style       = document.createElement('style'),
            script      = document.getElementsByTagName('script')[0],
            info        = null;

        style.type  = 'text/css';
        style.id    = 'matchmediajs-test';

        if (!script) {
          document.head.appendChild(style);
        } else {
          script.parentNode.insertBefore(style, script);
        }

        // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers
        info = ('getComputedStyle' in window) && window.getComputedStyle(style, null) || style.currentStyle;

        styleMedia = {
            matchMedium: function(media) {
                var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';

                // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers
                if (style.styleSheet) {
                    style.styleSheet.cssText = text;
                } else {
                    style.textContent = text;
                }

                // Test if media query is true or false
                return info.width === '1px';
            }
        };
    }

    return function(media) {
        return {
            matches: styleMedia.matchMedium(media || 'all'),
            media: media || 'all'
        };
    };
}());


/***/ }),

/***/ "./node_modules/object-inspect/index.js":
/*!**********************************************!*\
  !*** ./node_modules/object-inspect/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var match = String.prototype.match;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
var isEnumerable = Object.prototype.propertyIsEnumerable;

var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
    [].__proto__ === Array.prototype // eslint-disable-line no-proto
        ? function (O) {
            return O.__proto__; // eslint-disable-line no-proto
        }
        : null
);

var inspectCustom = (__webpack_require__(/*! ./util.inspect */ "?4f7e").custom);
var inspectSymbol = inspectCustom && isSymbol(inspectCustom) ? inspectCustom : null;
var toStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag !== 'undefined' ? Symbol.toStringTag : null;

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (
        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }

    if (
        has(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) {
        throw new TypeError('options "indent" must be "\\t", an integer > 0, or `null`');
    }

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        return String(obj);
    }
    if (typeof obj === 'bigint') {
        return String(obj) + 'n';
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = seen.slice();
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function') {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + keys.join(', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? String(obj).replace(/^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + String(obj.nodeName).toLowerCase();
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + String(obj.nodeName).toLowerCase() + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return '[]'; }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + xs.join(', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + parts.join(', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function') {
            return obj[inspectSymbol]();
        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        mapForEach.call(obj, function (value, key) {
            mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
        });
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        setForEach.call(obj, function (value) {
            setParts.push(inspect(value, obj));
        });
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? toStr(obj).slice(8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + [].concat(stringTag || [], protoTag || []).join(': ') + '] ' : '');
        if (ys.length === 0) { return tag + '{}'; }
        if (indent) {
            return tag + '{' + indentedJoin(ys, indent) + '}';
        }
        return tag + '{ ' + ys.join(', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return String(s).replace(/"/g, '&quot;');
}

function isArray(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) {
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
        return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}

function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString(str.slice(0, opts.maxStringLength), opts) + trailer;
    }
    // eslint-disable-next-line no-control-regex
    var s = str.replace(/(['\\])/g, '\\$1').replace(/[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + n.toString(16).toUpperCase();
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : entries.join(', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = Array(opts.indent + 1).join(' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: Array(depth + 1).join(baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return ''; }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + xs.join(',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
            symMap['$' + syms[k]] = syms[k];
        }
    }

    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ((/[^\w$]/).test(key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}


/***/ }),

/***/ "./node_modules/object-keys/implementation.js":
/*!****************************************************!*\
  !*** ./node_modules/object-keys/implementation.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = __webpack_require__(/*! ./isArguments */ "./node_modules/object-keys/isArguments.js"); // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;


/***/ }),

/***/ "./node_modules/object-keys/index.js":
/*!*******************************************!*\
  !*** ./node_modules/object-keys/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var slice = Array.prototype.slice;
var isArgs = __webpack_require__(/*! ./isArguments */ "./node_modules/object-keys/isArguments.js");

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : __webpack_require__(/*! ./implementation */ "./node_modules/object-keys/implementation.js");

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;


/***/ }),

/***/ "./node_modules/object-keys/isArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/object-keys/isArguments.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};


/***/ }),

/***/ "./node_modules/object.entries/implementation.js":
/*!*******************************************************!*\
  !*** ./node_modules/object.entries/implementation.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var RequireObjectCoercible = __webpack_require__(/*! es-abstract/2021/RequireObjectCoercible */ "./node_modules/es-abstract/2021/RequireObjectCoercible.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');
var $push = callBound('Array.prototype.push');

module.exports = function entries(O) {
	var obj = RequireObjectCoercible(O);
	var entrys = [];
	for (var key in obj) {
		if ($isEnumerable(obj, key)) { // checks own-ness as well
			$push(entrys, [key, obj[key]]);
		}
	}
	return entrys;
};


/***/ }),

/***/ "./node_modules/object.entries/polyfill.js":
/*!*************************************************!*\
  !*** ./node_modules/object.entries/polyfill.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/object.entries/implementation.js");

module.exports = function getPolyfill() {
	return typeof Object.entries === 'function' ? Object.entries : implementation;
};


/***/ }),

/***/ "./node_modules/object.entries/shim.js":
/*!*********************************************!*\
  !*** ./node_modules/object.entries/shim.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/object.entries/polyfill.js");
var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");

module.exports = function shimEntries() {
	var polyfill = getPolyfill();
	define(Object, { entries: polyfill }, {
		entries: function testEntries() {
			return Object.entries !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ "./node_modules/object.fromentries/auto.js":
/*!*************************************************!*\
  !*** ./node_modules/object.fromentries/auto.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! ./shim */ "./node_modules/object.fromentries/shim.js")();


/***/ }),

/***/ "./node_modules/object.fromentries/implementation.js":
/*!***********************************************************!*\
  !*** ./node_modules/object.fromentries/implementation.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var AddEntriesFromIterable = __webpack_require__(/*! es-abstract/2021/AddEntriesFromIterable */ "./node_modules/es-abstract/2021/AddEntriesFromIterable.js");
var CreateDataPropertyOrThrow = __webpack_require__(/*! es-abstract/2021/CreateDataPropertyOrThrow */ "./node_modules/es-abstract/2021/CreateDataPropertyOrThrow.js");
var RequireObjectCoercible = __webpack_require__(/*! es-abstract/2021/RequireObjectCoercible */ "./node_modules/es-abstract/2021/RequireObjectCoercible.js");
var ToPropertyKey = __webpack_require__(/*! es-abstract/2021/ToPropertyKey */ "./node_modules/es-abstract/2021/ToPropertyKey.js");

var adder = function addDataProperty(key, value) {
	var O = this; // eslint-disable-line no-invalid-this
	var propertyKey = ToPropertyKey(key);
	CreateDataPropertyOrThrow(O, propertyKey, value);
};

module.exports = function fromEntries(iterable) {
	RequireObjectCoercible(iterable);

	return AddEntriesFromIterable({}, iterable, adder);
};


/***/ }),

/***/ "./node_modules/object.fromentries/polyfill.js":
/*!*****************************************************!*\
  !*** ./node_modules/object.fromentries/polyfill.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/object.fromentries/implementation.js");

module.exports = function getPolyfill() {
	return typeof Object.fromEntries === 'function' ? Object.fromEntries : implementation;
};


/***/ }),

/***/ "./node_modules/object.fromentries/shim.js":
/*!*************************************************!*\
  !*** ./node_modules/object.fromentries/shim.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/object.fromentries/polyfill.js");
var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");

module.exports = function shimEntries() {
	var polyfill = getPolyfill();
	define(Object, { fromEntries: polyfill }, {
		fromEntries: function testEntries() {
			return Object.fromEntries !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ "./node_modules/object.getownpropertydescriptors/implementation.js":
/*!*************************************************************************!*\
  !*** ./node_modules/object.getownpropertydescriptors/implementation.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var CreateDataProperty = __webpack_require__(/*! es-abstract/2021/CreateDataProperty */ "./node_modules/es-abstract/2021/CreateDataProperty.js");
var IsCallable = __webpack_require__(/*! es-abstract/2021/IsCallable */ "./node_modules/es-abstract/2021/IsCallable.js");
var RequireObjectCoercible = __webpack_require__(/*! es-abstract/2021/RequireObjectCoercible */ "./node_modules/es-abstract/2021/RequireObjectCoercible.js");
var ToObject = __webpack_require__(/*! es-abstract/2021/ToObject */ "./node_modules/es-abstract/2021/ToObject.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");

var $gOPD = Object.getOwnPropertyDescriptor;
var $getOwnNames = Object.getOwnPropertyNames;
var $getSymbols = Object.getOwnPropertySymbols;
var $concat = callBound('Array.prototype.concat');
var $reduce = callBound('Array.prototype.reduce');
var getAll = $getSymbols ? function (obj) {
	return $concat($getOwnNames(obj), $getSymbols(obj));
} : $getOwnNames;

var isES5 = IsCallable($gOPD) && IsCallable($getOwnNames);

module.exports = function getOwnPropertyDescriptors(value) {
	RequireObjectCoercible(value);
	if (!isES5) {
		throw new TypeError('getOwnPropertyDescriptors requires Object.getOwnPropertyDescriptor');
	}

	var O = ToObject(value);
	return $reduce(
		getAll(O),
		function (acc, key) {
			var descriptor = $gOPD(O, key);
			if (typeof descriptor !== 'undefined') {
				CreateDataProperty(acc, key, descriptor);
			}
			return acc;
		},
		{}
	);
};


/***/ }),

/***/ "./node_modules/object.getownpropertydescriptors/polyfill.js":
/*!*******************************************************************!*\
  !*** ./node_modules/object.getownpropertydescriptors/polyfill.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/object.getownpropertydescriptors/implementation.js");

module.exports = function getPolyfill() {
	return typeof Object.getOwnPropertyDescriptors === 'function' ? Object.getOwnPropertyDescriptors : implementation;
};


/***/ }),

/***/ "./node_modules/object.getownpropertydescriptors/shim.js":
/*!***************************************************************!*\
  !*** ./node_modules/object.getownpropertydescriptors/shim.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/object.getownpropertydescriptors/polyfill.js");
var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");

module.exports = function shimGetOwnPropertyDescriptors() {
	var polyfill = getPolyfill();
	define(
		Object,
		{ getOwnPropertyDescriptors: polyfill },
		{ getOwnPropertyDescriptors: function () { return Object.getOwnPropertyDescriptors !== polyfill; } }
	);
	return polyfill;
};


/***/ }),

/***/ "./node_modules/object.values/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/object.values/implementation.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var RequireObjectCoercible = __webpack_require__(/*! es-abstract/2021/RequireObjectCoercible */ "./node_modules/es-abstract/2021/RequireObjectCoercible.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');
var $push = callBound('Array.prototype.push');

module.exports = function values(O) {
	var obj = RequireObjectCoercible(O);
	var vals = [];
	for (var key in obj) {
		if ($isEnumerable(obj, key)) { // checks own-ness as well
			$push(vals, obj[key]);
		}
	}
	return vals;
};


/***/ }),

/***/ "./node_modules/object.values/polyfill.js":
/*!************************************************!*\
  !*** ./node_modules/object.values/polyfill.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/object.values/implementation.js");

module.exports = function getPolyfill() {
	return typeof Object.values === 'function' ? Object.values : implementation;
};


/***/ }),

/***/ "./node_modules/object.values/shim.js":
/*!********************************************!*\
  !*** ./node_modules/object.values/shim.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/object.values/polyfill.js");
var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");

module.exports = function shimValues() {
	var polyfill = getPolyfill();
	define(Object, { values: polyfill }, {
		values: function testValues() {
			return Object.values !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ "./node_modules/performance-now/lib/performance-now.js":
/*!*************************************************************!*\
  !*** ./node_modules/performance-now/lib/performance-now.js ***!
  \*************************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);

//# sourceMappingURL=performance-now.js.map


/***/ }),

/***/ "./node_modules/promise.allsettled/auto.js":
/*!*************************************************!*\
  !*** ./node_modules/promise.allsettled/auto.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! ./shim */ "./node_modules/promise.allsettled/shim.js")();


/***/ }),

/***/ "./node_modules/promise.allsettled/implementation.js":
/*!***********************************************************!*\
  !*** ./node_modules/promise.allsettled/implementation.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var requirePromise = __webpack_require__(/*! ./requirePromise */ "./node_modules/promise.allsettled/requirePromise.js");

requirePromise();

var PromiseResolve = __webpack_require__(/*! es-abstract/2021/PromiseResolve */ "./node_modules/es-abstract/2021/PromiseResolve.js");
var Type = __webpack_require__(/*! es-abstract/2021/Type */ "./node_modules/es-abstract/2021/Type.js");
var iterate = __webpack_require__(/*! iterate-value */ "./node_modules/iterate-value/index.js");
var map = __webpack_require__(/*! array.prototype.map */ "./node_modules/array.prototype.map/index.js");
var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var callBind = __webpack_require__(/*! call-bind */ "./node_modules/call-bind/index.js");

var all = callBind(GetIntrinsic('%Promise.all%'));
var reject = callBind(GetIntrinsic('%Promise.reject%'));

module.exports = function allSettled(iterable) {
	var C = this;
	if (Type(C) !== 'Object') {
		throw new TypeError('`this` value must be an object');
	}
	var values = iterate(iterable);
	return all(C, map(values, function (item) {
		var onFulfill = function (value) {
			return { status: 'fulfilled', value: value };
		};
		var onReject = function (reason) {
			return { status: 'rejected', reason: reason };
		};
		var itemPromise = PromiseResolve(C, item);
		try {
			return itemPromise.then(onFulfill, onReject);
		} catch (e) {
			return reject(C, e);
		}
	}));
};


/***/ }),

/***/ "./node_modules/promise.allsettled/polyfill.js":
/*!*****************************************************!*\
  !*** ./node_modules/promise.allsettled/polyfill.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var requirePromise = __webpack_require__(/*! ./requirePromise */ "./node_modules/promise.allsettled/requirePromise.js");

var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/promise.allsettled/implementation.js");

module.exports = function getPolyfill() {
	requirePromise();
	return typeof Promise.allSettled === 'function' ? Promise.allSettled : implementation;
};


/***/ }),

/***/ "./node_modules/promise.allsettled/requirePromise.js":
/*!***********************************************************!*\
  !*** ./node_modules/promise.allsettled/requirePromise.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";


module.exports = function requirePromise() {
	if (typeof Promise !== 'function') {
		throw new TypeError('`Promise.allSettled` requires a global `Promise` be available.');
	}
};


/***/ }),

/***/ "./node_modules/promise.allsettled/shim.js":
/*!*************************************************!*\
  !*** ./node_modules/promise.allsettled/shim.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var requirePromise = __webpack_require__(/*! ./requirePromise */ "./node_modules/promise.allsettled/requirePromise.js");

var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/promise.allsettled/polyfill.js");
var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");

module.exports = function shimAllSettled() {
	requirePromise();

	var polyfill = getPolyfill();
	define(Promise, { allSettled: polyfill }, {
		allSettled: function testAllSettled() {
			return Promise.allSettled !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ "./node_modules/promise.prototype.finally/auto.js":
/*!********************************************************!*\
  !*** ./node_modules/promise.prototype.finally/auto.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! ./shim */ "./node_modules/promise.prototype.finally/shim.js")();


/***/ }),

/***/ "./node_modules/promise.prototype.finally/implementation.js":
/*!******************************************************************!*\
  !*** ./node_modules/promise.prototype.finally/implementation.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var requirePromise = __webpack_require__(/*! ./requirePromise */ "./node_modules/promise.prototype.finally/requirePromise.js");

requirePromise();

var IsCallable = __webpack_require__(/*! es-abstract/2021/IsCallable */ "./node_modules/es-abstract/2021/IsCallable.js");
var SpeciesConstructor = __webpack_require__(/*! es-abstract/2021/SpeciesConstructor */ "./node_modules/es-abstract/2021/SpeciesConstructor.js");
var Type = __webpack_require__(/*! es-abstract/2021/Type */ "./node_modules/es-abstract/2021/Type.js");

var promiseResolve = function PromiseResolve(C, value) {
	return new C(function (resolve) {
		resolve(value);
	});
};

var OriginalPromise = Promise;

var createThenFinally = function CreateThenFinally(C, onFinally) {
	return function (value) {
		var result = onFinally();
		var promise = promiseResolve(C, result);
		var valueThunk = function () {
			return value;
		};
		return promise.then(valueThunk);
	};
};

var createCatchFinally = function CreateCatchFinally(C, onFinally) {
	return function (reason) {
		var result = onFinally();
		var promise = promiseResolve(C, result);
		var thrower = function () {
			throw reason;
		};
		return promise.then(thrower);
	};
};

var promiseFinally = function finally_(onFinally) {
	/* eslint no-invalid-this: 0 */

	var promise = this;

	if (Type(promise) !== 'Object') {
		throw new TypeError('receiver is not an Object');
	}

	var C = SpeciesConstructor(promise, OriginalPromise); // may throw

	var thenFinally = onFinally;
	var catchFinally = onFinally;
	if (IsCallable(onFinally)) {
		thenFinally = createThenFinally(C, onFinally);
		catchFinally = createCatchFinally(C, onFinally);
	}

	return promise.then(thenFinally, catchFinally);
};

if (Object.getOwnPropertyDescriptor) {
	var descriptor = Object.getOwnPropertyDescriptor(promiseFinally, 'name');
	if (descriptor && descriptor.configurable) {
		Object.defineProperty(promiseFinally, 'name', { configurable: true, value: 'finally' });
	}
}

module.exports = promiseFinally;


/***/ }),

/***/ "./node_modules/promise.prototype.finally/polyfill.js":
/*!************************************************************!*\
  !*** ./node_modules/promise.prototype.finally/polyfill.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var requirePromise = __webpack_require__(/*! ./requirePromise */ "./node_modules/promise.prototype.finally/requirePromise.js");

var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/promise.prototype.finally/implementation.js");

module.exports = function getPolyfill() {
	requirePromise();
	return typeof Promise.prototype['finally'] === 'function' ? Promise.prototype['finally'] : implementation;
};


/***/ }),

/***/ "./node_modules/promise.prototype.finally/requirePromise.js":
/*!******************************************************************!*\
  !*** ./node_modules/promise.prototype.finally/requirePromise.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function requirePromise() {
	if (typeof Promise !== 'function') {
		throw new TypeError('`Promise.prototype.finally` requires a global `Promise` be available.');
	}
};


/***/ }),

/***/ "./node_modules/promise.prototype.finally/shim.js":
/*!********************************************************!*\
  !*** ./node_modules/promise.prototype.finally/shim.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var requirePromise = __webpack_require__(/*! ./requirePromise */ "./node_modules/promise.prototype.finally/requirePromise.js");

var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/promise.prototype.finally/polyfill.js");
var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");

module.exports = function shimPromiseFinally() {
	requirePromise();

	var polyfill = getPolyfill();
	define(Promise.prototype, { 'finally': polyfill }, {
		'finally': function testFinally() {
			return Promise.prototype['finally'] !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ "./node_modules/raf/index.js":
/*!***********************************!*\
  !*** ./node_modules/raf/index.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var now = __webpack_require__(/*! performance-now */ "./node_modules/performance-now/lib/performance-now.js")
  , root = typeof window === 'undefined' ? __webpack_require__.g : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix]
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix]
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last))
      last = next + _now
      setTimeout(function() {
        var cp = queue.slice(0)
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last)
            } catch(e) {
              setTimeout(function() { throw e }, 0)
            }
          }
        }
      }, Math.round(next))
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    })
    return id
  }

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true
      }
    }
  }
}

module.exports = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
}
module.exports.cancel = function() {
  caf.apply(root, arguments)
}
module.exports.polyfill = function(object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf
  object.cancelAnimationFrame = caf
}


/***/ }),

/***/ "./node_modules/raf/polyfill.js":
/*!**************************************!*\
  !*** ./node_modules/raf/polyfill.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

(__webpack_require__(/*! ./ */ "./node_modules/raf/index.js").polyfill)()


/***/ }),

/***/ "./node_modules/regexp.prototype.flags/implementation.js":
/*!***************************************************************!*\
  !*** ./node_modules/regexp.prototype.flags/implementation.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


var $Object = Object;
var $TypeError = TypeError;

module.exports = function flags() {
	if (this != null && this !== $Object(this)) {
		throw new $TypeError('RegExp.prototype.flags getter called on non-object');
	}
	var result = '';
	if (this.global) {
		result += 'g';
	}
	if (this.ignoreCase) {
		result += 'i';
	}
	if (this.multiline) {
		result += 'm';
	}
	if (this.dotAll) {
		result += 's';
	}
	if (this.unicode) {
		result += 'u';
	}
	if (this.sticky) {
		result += 'y';
	}
	return result;
};


/***/ }),

/***/ "./node_modules/regexp.prototype.flags/index.js":
/*!******************************************************!*\
  !*** ./node_modules/regexp.prototype.flags/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");
var callBind = __webpack_require__(/*! call-bind */ "./node_modules/call-bind/index.js");

var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/regexp.prototype.flags/implementation.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/regexp.prototype.flags/polyfill.js");
var shim = __webpack_require__(/*! ./shim */ "./node_modules/regexp.prototype.flags/shim.js");

var flagsBound = callBind(implementation);

define(flagsBound, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = flagsBound;


/***/ }),

/***/ "./node_modules/regexp.prototype.flags/polyfill.js":
/*!*********************************************************!*\
  !*** ./node_modules/regexp.prototype.flags/polyfill.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/regexp.prototype.flags/implementation.js");

var supportsDescriptors = (__webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js").supportsDescriptors);
var $gOPD = Object.getOwnPropertyDescriptor;
var $TypeError = TypeError;

module.exports = function getPolyfill() {
	if (!supportsDescriptors) {
		throw new $TypeError('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');
	}
	if ((/a/mig).flags === 'gim') {
		var descriptor = $gOPD(RegExp.prototype, 'flags');
		if (descriptor && typeof descriptor.get === 'function' && typeof (/a/).dotAll === 'boolean') {
			return descriptor.get;
		}
	}
	return implementation;
};


/***/ }),

/***/ "./node_modules/regexp.prototype.flags/shim.js":
/*!*****************************************************!*\
  !*** ./node_modules/regexp.prototype.flags/shim.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var supportsDescriptors = (__webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js").supportsDescriptors);
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/regexp.prototype.flags/polyfill.js");
var gOPD = Object.getOwnPropertyDescriptor;
var defineProperty = Object.defineProperty;
var TypeErr = TypeError;
var getProto = Object.getPrototypeOf;
var regex = /a/;

module.exports = function shimFlags() {
	if (!supportsDescriptors || !getProto) {
		throw new TypeErr('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');
	}
	var polyfill = getPolyfill();
	var proto = getProto(regex);
	var descriptor = gOPD(proto, 'flags');
	if (!descriptor || descriptor.get !== polyfill) {
		defineProperty(proto, 'flags', {
			configurable: true,
			enumerable: false,
			get: polyfill
		});
	}
	return polyfill;
};


/***/ }),

/***/ "./node_modules/ric-shim/index.js":
/*!****************************************!*\
  !*** ./node_modules/ric-shim/index.js ***!
  \****************************************/
/***/ ((module) => {

/* globals requestIdleCallback, cancelIdleCallback */
var fallback = function (cb) {
  return setTimeout(function () {
    var start = Date.now()
    cb({
      didTimeout: false,
      timeRemaining: function () {
        return Math.max(0, 50 - (Date.now() - start))
      }
    })
  }, 1)
}

var isSupported = (typeof requestIdleCallback !== 'undefined')

module.exports = isSupported ? requestIdleCallback : fallback
module.exports.cancelIdleCallback = isSupported ? cancelIdleCallback : clearTimeout


/***/ }),

/***/ "./node_modules/shim-keyboard-event-key/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/shim-keyboard-event-key/index.js ***!
  \*******************************************************/
/***/ (() => {

(function() {
  "use strict"

  if (!self.document) return

  var event = KeyboardEvent.prototype
  var desc = Object.getOwnPropertyDescriptor(event, "key")
  if (!desc) return

  var keys = {
    Win: "Meta",
    Scroll: "ScrollLock",
    Spacebar: " ",

    Down: "ArrowDown",
    Left: "ArrowLeft",
    Right: "ArrowRight",
    Up: "ArrowUp",

    Del: "Delete",
    Apps: "ContextMenu",
    Esc: "Escape",

    Multiply: "*",
    Add: "+",
    Subtract: "-",
    Decimal: ".",
    Divide: "/",
  }

  Object.defineProperty(event, "key", {
    get: function() {
      var key = desc.get.call(this)

      return keys.hasOwnProperty(key) ? keys[key] : key
    },
  })
})()


/***/ }),

/***/ "./node_modules/side-channel/index.js":
/*!********************************************!*\
  !*** ./node_modules/side-channel/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
var inspect = __webpack_require__(/*! object-inspect */ "./node_modules/object-inspect/index.js");

var $TypeError = GetIntrinsic('%TypeError%');
var $WeakMap = GetIntrinsic('%WeakMap%', true);
var $Map = GetIntrinsic('%Map%', true);

var $weakMapGet = callBound('WeakMap.prototype.get', true);
var $weakMapSet = callBound('WeakMap.prototype.set', true);
var $weakMapHas = callBound('WeakMap.prototype.has', true);
var $mapGet = callBound('Map.prototype.get', true);
var $mapSet = callBound('Map.prototype.set', true);
var $mapHas = callBound('Map.prototype.has', true);

/*
 * This function traverses the list returning the node corresponding to the
 * given key.
 *
 * That node is also moved to the head of the list, so that if it's accessed
 * again we don't need to traverse the whole list. By doing so, all the recently
 * used nodes can be accessed relatively quickly.
 */
var listGetNode = function (list, key) { // eslint-disable-line consistent-return
	for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
		if (curr.key === key) {
			prev.next = curr.next;
			curr.next = list.next;
			list.next = curr; // eslint-disable-line no-param-reassign
			return curr;
		}
	}
};

var listGet = function (objects, key) {
	var node = listGetNode(objects, key);
	return node && node.value;
};
var listSet = function (objects, key, value) {
	var node = listGetNode(objects, key);
	if (node) {
		node.value = value;
	} else {
		// Prepend the new node to the beginning of the list
		objects.next = { // eslint-disable-line no-param-reassign
			key: key,
			next: objects.next,
			value: value
		};
	}
};
var listHas = function (objects, key) {
	return !!listGetNode(objects, key);
};

module.exports = function getSideChannel() {
	var $wm;
	var $m;
	var $o;
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		get: function (key) { // eslint-disable-line consistent-return
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapGet($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapGet($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listGet($o, key);
				}
			}
		},
		has: function (key) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapHas($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapHas($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listHas($o, key);
				}
			}
			return false;
		},
		set: function (key, value) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if (!$wm) {
					$wm = new $WeakMap();
				}
				$weakMapSet($wm, key, value);
			} else if ($Map) {
				if (!$m) {
					$m = new $Map();
				}
				$mapSet($m, key, value);
			} else {
				if (!$o) {
					/*
					 * Initialize the linked list as an empty node, so that we don't have
					 * to special-case handling of the first node: we can always refer to
					 * it as (previous node).next, instead of something like (list).head
					 */
					$o = { key: {}, next: null };
				}
				listSet($o, key, value);
			}
		}
	};
	return channel;
};


/***/ }),

/***/ "./node_modules/smoothscroll-polyfill/dist/smoothscroll.js":
/*!*****************************************************************!*\
  !*** ./node_modules/smoothscroll-polyfill/dist/smoothscroll.js ***!
  \*****************************************************************/
/***/ ((module) => {

/*
 * smoothscroll polyfill - v0.3.5
 * https://iamdustan.github.io/smoothscroll
 * 2016 (c) Dustan Kasten, Jeremias Menichelli - MIT License
 */

(function(w, d, undefined) {
  'use strict';

  /*
   * aliases
   * w: window global object
   * d: document
   * undefined: undefined
   */

  // polyfill
  function polyfill() {
    // return when scrollBehavior interface is supported
    if ('scrollBehavior' in d.documentElement.style) {
      return;
    }

    /*
     * globals
     */
    var Element = w.HTMLElement || w.Element;
    var SCROLL_TIME = 468;

    /*
     * object gathering original scroll methods
     */
    var original = {
      scroll: w.scroll || w.scrollTo,
      scrollBy: w.scrollBy,
      elScroll: Element.prototype.scroll || scrollElement,
      scrollIntoView: Element.prototype.scrollIntoView
    };

    /*
     * define timing method
     */
    var now = w.performance && w.performance.now
      ? w.performance.now.bind(w.performance) : Date.now;

    /**
     * changes scroll position inside an element
     * @method scrollElement
     * @param {Number} x
     * @param {Number} y
     */
    function scrollElement(x, y) {
      this.scrollLeft = x;
      this.scrollTop = y;
    }

    /**
     * returns result of applying ease math function to a number
     * @method ease
     * @param {Number} k
     * @returns {Number}
     */
    function ease(k) {
      return 0.5 * (1 - Math.cos(Math.PI * k));
    }

    /**
     * indicates if a smooth behavior should be applied
     * @method shouldBailOut
     * @param {Number|Object} x
     * @returns {Boolean}
     */
    function shouldBailOut(x) {
      if (typeof x !== 'object'
            || x === null
            || x.behavior === undefined
            || x.behavior === 'auto'
            || x.behavior === 'instant') {
        // first arg not an object/null
        // or behavior is auto, instant or undefined
        return true;
      }

      if (typeof x === 'object'
            && x.behavior === 'smooth') {
        // first argument is an object and behavior is smooth
        return false;
      }

      // throw error when behavior is not supported
      throw new TypeError('behavior not valid');
    }

    /**
     * finds scrollable parent of an element
     * @method findScrollableParent
     * @param {Node} el
     * @returns {Node} el
     */
    function findScrollableParent(el) {
      var isBody;
      var hasScrollableSpace;
      var hasVisibleOverflow;

      do {
        el = el.parentNode;

        // set condition variables
        isBody = el === d.body;
        hasScrollableSpace =
          el.clientHeight < el.scrollHeight ||
          el.clientWidth < el.scrollWidth;
        hasVisibleOverflow =
          w.getComputedStyle(el, null).overflow === 'visible';
      } while (!isBody && !(hasScrollableSpace && !hasVisibleOverflow));

      isBody = hasScrollableSpace = hasVisibleOverflow = null;

      return el;
    }

    /**
     * self invoked function that, given a context, steps through scrolling
     * @method step
     * @param {Object} context
     */
    function step(context) {
      var time = now();
      var value;
      var currentX;
      var currentY;
      var elapsed = (time - context.startTime) / SCROLL_TIME;

      // avoid elapsed times higher than one
      elapsed = elapsed > 1 ? 1 : elapsed;

      // apply easing to elapsed time
      value = ease(elapsed);

      currentX = context.startX + (context.x - context.startX) * value;
      currentY = context.startY + (context.y - context.startY) * value;

      context.method.call(context.scrollable, currentX, currentY);

      // scroll more if we have not reached our destination
      if (currentX !== context.x || currentY !== context.y) {
        w.requestAnimationFrame(step.bind(w, context));
      }
    }

    /**
     * scrolls window with a smooth behavior
     * @method smoothScroll
     * @param {Object|Node} el
     * @param {Number} x
     * @param {Number} y
     */
    function smoothScroll(el, x, y) {
      var scrollable;
      var startX;
      var startY;
      var method;
      var startTime = now();

      // define scroll context
      if (el === d.body) {
        scrollable = w;
        startX = w.scrollX || w.pageXOffset;
        startY = w.scrollY || w.pageYOffset;
        method = original.scroll;
      } else {
        scrollable = el;
        startX = el.scrollLeft;
        startY = el.scrollTop;
        method = scrollElement;
      }

      // scroll looping over a frame
      step({
        scrollable: scrollable,
        method: method,
        startTime: startTime,
        startX: startX,
        startY: startY,
        x: x,
        y: y
      });
    }

    /*
     * ORIGINAL METHODS OVERRIDES
     */

    // w.scroll and w.scrollTo
    w.scroll = w.scrollTo = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.scroll.call(
          w,
          arguments[0].left || arguments[0],
          arguments[0].top || arguments[1]
        );
        return;
      }

      // LET THE SMOOTHNESS BEGIN!
      smoothScroll.call(
        w,
        d.body,
        ~~arguments[0].left,
        ~~arguments[0].top
      );
    };

    // w.scrollBy
    w.scrollBy = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.scrollBy.call(
          w,
          arguments[0].left || arguments[0],
          arguments[0].top || arguments[1]
        );
        return;
      }

      // LET THE SMOOTHNESS BEGIN!
      smoothScroll.call(
        w,
        d.body,
        ~~arguments[0].left + (w.scrollX || w.pageXOffset),
        ~~arguments[0].top + (w.scrollY || w.pageYOffset)
      );
    };

    // Element.prototype.scroll and Element.prototype.scrollTo
    Element.prototype.scroll = Element.prototype.scrollTo = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.elScroll.call(
            this,
            arguments[0].left || arguments[0],
            arguments[0].top || arguments[1]
        );
        return;
      }

      var left = arguments[0].left;
      var top = arguments[0].top;

      // LET THE SMOOTHNESS BEGIN!
      smoothScroll.call(
          this,
          this,
          typeof left === 'number' ? left : this.scrollLeft,
          typeof top === 'number' ? top : this.scrollTop
      );
    };

    // Element.prototype.scrollBy
    Element.prototype.scrollBy = function() {
      var arg0 = arguments[0];

      if (typeof arg0 === 'object') {
        this.scroll({
          left: arg0.left + this.scrollLeft,
          top: arg0.top + this.scrollTop,
          behavior: arg0.behavior
        });
      } else {
        this.scroll(
          this.scrollLeft + arg0,
          this.scrollTop + arguments[1]
        );
      }
    };

    // Element.prototype.scrollIntoView
    Element.prototype.scrollIntoView = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.scrollIntoView.call(
          this,
          arguments[0] === undefined ? true : arguments[0]
        );
        return;
      }

      // LET THE SMOOTHNESS BEGIN!
      var scrollableParent = findScrollableParent(this);
      var parentRects = scrollableParent.getBoundingClientRect();
      var clientRects = this.getBoundingClientRect();

      if (scrollableParent !== d.body) {
        // reveal element inside parent
        smoothScroll.call(
          this,
          scrollableParent,
          scrollableParent.scrollLeft + clientRects.left - parentRects.left,
          scrollableParent.scrollTop + clientRects.top - parentRects.top
        );
        // reveal parent in viewport
        w.scrollBy({
          left: parentRects.left,
          top: parentRects.top,
          behavior: 'smooth'
        });
      } else {
        // reveal element in viewport
        w.scrollBy({
          left: clientRects.left,
          top: clientRects.top,
          behavior: 'smooth'
        });
      }
    };
  }

  if (true) {
    // commonjs
    module.exports = { polyfill: polyfill };
  } else {}
})(window, document);


/***/ }),

/***/ "./node_modules/string.prototype.matchall/auto.js":
/*!********************************************************!*\
  !*** ./node_modules/string.prototype.matchall/auto.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! ./shim */ "./node_modules/string.prototype.matchall/shim.js")();


/***/ }),

/***/ "./node_modules/string.prototype.matchall/implementation.js":
/*!******************************************************************!*\
  !*** ./node_modules/string.prototype.matchall/implementation.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Call = __webpack_require__(/*! es-abstract/2021/Call */ "./node_modules/es-abstract/2021/Call.js");
var Get = __webpack_require__(/*! es-abstract/2021/Get */ "./node_modules/es-abstract/2021/Get.js");
var GetMethod = __webpack_require__(/*! es-abstract/2021/GetMethod */ "./node_modules/es-abstract/2021/GetMethod.js");
var IsRegExp = __webpack_require__(/*! es-abstract/2021/IsRegExp */ "./node_modules/es-abstract/2021/IsRegExp.js");
var ToString = __webpack_require__(/*! es-abstract/2021/ToString */ "./node_modules/es-abstract/2021/ToString.js");
var RequireObjectCoercible = __webpack_require__(/*! es-abstract/2021/RequireObjectCoercible */ "./node_modules/es-abstract/2021/RequireObjectCoercible.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();
var flagsGetter = __webpack_require__(/*! regexp.prototype.flags */ "./node_modules/regexp.prototype.flags/index.js");

var $indexOf = callBound('String.prototype.indexOf');

var regexpMatchAllPolyfill = __webpack_require__(/*! ./polyfill-regexp-matchall */ "./node_modules/string.prototype.matchall/polyfill-regexp-matchall.js");

var getMatcher = function getMatcher(regexp) { // eslint-disable-line consistent-return
	var matcherPolyfill = regexpMatchAllPolyfill();
	if (hasSymbols && typeof Symbol.matchAll === 'symbol') {
		var matcher = GetMethod(regexp, Symbol.matchAll);
		if (matcher === RegExp.prototype[Symbol.matchAll] && matcher !== matcherPolyfill) {
			return matcherPolyfill;
		}
		return matcher;
	}
	// fallback for pre-Symbol.matchAll environments
	if (IsRegExp(regexp)) {
		return matcherPolyfill;
	}
};

module.exports = function matchAll(regexp) {
	var O = RequireObjectCoercible(this);

	if (typeof regexp !== 'undefined' && regexp !== null) {
		var isRegExp = IsRegExp(regexp);
		if (isRegExp) {
			// workaround for older engines that lack RegExp.prototype.flags
			var flags = 'flags' in regexp ? Get(regexp, 'flags') : flagsGetter(regexp);
			RequireObjectCoercible(flags);
			if ($indexOf(ToString(flags), 'g') < 0) {
				throw new TypeError('matchAll requires a global regular expression');
			}
		}

		var matcher = getMatcher(regexp);
		if (typeof matcher !== 'undefined') {
			return Call(matcher, regexp, [O]);
		}
	}

	var S = ToString(O);
	// var rx = RegExpCreate(regexp, 'g');
	var rx = new RegExp(regexp, 'g');
	return Call(getMatcher(rx), rx, [S]);
};


/***/ }),

/***/ "./node_modules/string.prototype.matchall/polyfill-regexp-matchall.js":
/*!****************************************************************************!*\
  !*** ./node_modules/string.prototype.matchall/polyfill-regexp-matchall.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();
var regexpMatchAll = __webpack_require__(/*! ./regexp-matchall */ "./node_modules/string.prototype.matchall/regexp-matchall.js");

module.exports = function getRegExpMatchAllPolyfill() {
	if (!hasSymbols || typeof Symbol.matchAll !== 'symbol' || typeof RegExp.prototype[Symbol.matchAll] !== 'function') {
		return regexpMatchAll;
	}
	return RegExp.prototype[Symbol.matchAll];
};


/***/ }),

/***/ "./node_modules/string.prototype.matchall/polyfill.js":
/*!************************************************************!*\
  !*** ./node_modules/string.prototype.matchall/polyfill.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/string.prototype.matchall/implementation.js");

module.exports = function getPolyfill() {
	if (String.prototype.matchAll) {
		try {
			''.matchAll(RegExp.prototype);
		} catch (e) {
			return String.prototype.matchAll;
		}
	}
	return implementation;
};


/***/ }),

/***/ "./node_modules/string.prototype.matchall/regexp-matchall.js":
/*!*******************************************************************!*\
  !*** ./node_modules/string.prototype.matchall/regexp-matchall.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// var Construct = require('es-abstract/2021/Construct');
var CreateRegExpStringIterator = __webpack_require__(/*! es-abstract/2021/CreateRegExpStringIterator */ "./node_modules/es-abstract/2021/CreateRegExpStringIterator.js");
var Get = __webpack_require__(/*! es-abstract/2021/Get */ "./node_modules/es-abstract/2021/Get.js");
var Set = __webpack_require__(/*! es-abstract/2021/Set */ "./node_modules/es-abstract/2021/Set.js");
var SpeciesConstructor = __webpack_require__(/*! es-abstract/2021/SpeciesConstructor */ "./node_modules/es-abstract/2021/SpeciesConstructor.js");
var ToLength = __webpack_require__(/*! es-abstract/2021/ToLength */ "./node_modules/es-abstract/2021/ToLength.js");
var ToString = __webpack_require__(/*! es-abstract/2021/ToString */ "./node_modules/es-abstract/2021/ToString.js");
var Type = __webpack_require__(/*! es-abstract/2021/Type */ "./node_modules/es-abstract/2021/Type.js");
var flagsGetter = __webpack_require__(/*! regexp.prototype.flags */ "./node_modules/regexp.prototype.flags/index.js");

var OrigRegExp = RegExp;

var supportsConstructingWithFlags = 'flags' in RegExp.prototype;

var constructRegexWithFlags = function constructRegex(C, R) {
	var matcher;
	// workaround for older engines that lack RegExp.prototype.flags
	var flags = 'flags' in R ? Get(R, 'flags') : ToString(flagsGetter(R));
	if (supportsConstructingWithFlags && typeof flags === 'string') {
		matcher = new C(R, flags);
	} else if (C === OrigRegExp) {
		// workaround for older engines that can not construct a RegExp with flags
		matcher = new C(R.source, flags);
	} else {
		matcher = new C(R, flags);
	}
	return { flags: flags, matcher: matcher };
};

var regexMatchAll = function SymbolMatchAll(string) {
	var R = this;
	if (Type(R) !== 'Object') {
		throw new TypeError('"this" value must be an Object');
	}
	var S = ToString(string);
	var C = SpeciesConstructor(R, OrigRegExp);

	var tmp = constructRegexWithFlags(C, R);
	// var flags = ToString(Get(R, 'flags'));
	var flags = tmp.flags;
	// var matcher = Construct(C, [R, flags]);
	var matcher = tmp.matcher;

	var lastIndex = ToLength(Get(R, 'lastIndex'));
	Set(matcher, 'lastIndex', lastIndex, true);
	var global = flags.indexOf('g') > -1;
	var fullUnicode = flags.indexOf('u') > -1;
	return CreateRegExpStringIterator(matcher, S, global, fullUnicode);
};

var defineP = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;

if (defineP && gOPD) {
	var desc = gOPD(regexMatchAll, 'name');
	if (desc && desc.configurable) {
		defineP(regexMatchAll, 'name', { value: '[Symbol.matchAll]' });
	}
}

module.exports = regexMatchAll;


/***/ }),

/***/ "./node_modules/string.prototype.matchall/shim.js":
/*!********************************************************!*\
  !*** ./node_modules/string.prototype.matchall/shim.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");
var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/string.prototype.matchall/polyfill.js");
var regexpMatchAllPolyfill = __webpack_require__(/*! ./polyfill-regexp-matchall */ "./node_modules/string.prototype.matchall/polyfill-regexp-matchall.js");

var defineP = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;

module.exports = function shimMatchAll() {
	var polyfill = getPolyfill();
	define(
		String.prototype,
		{ matchAll: polyfill },
		{ matchAll: function () { return String.prototype.matchAll !== polyfill; } }
	);
	if (hasSymbols) {
		// eslint-disable-next-line no-restricted-properties
		var symbol = Symbol.matchAll || (Symbol['for'] ? Symbol['for']('Symbol.matchAll') : Symbol('Symbol.matchAll'));
		define(
			Symbol,
			{ matchAll: symbol },
			{ matchAll: function () { return Symbol.matchAll !== symbol; } }
		);

		if (defineP && gOPD) {
			var desc = gOPD(Symbol, symbol);
			if (!desc || desc.configurable) {
				defineP(Symbol, symbol, {
					configurable: false,
					enumerable: false,
					value: symbol,
					writable: false
				});
			}
		}

		var regexpMatchAll = regexpMatchAllPolyfill();
		var func = {};
		func[symbol] = regexpMatchAll;
		var predicate = {};
		predicate[symbol] = function () {
			return RegExp.prototype[symbol] !== regexpMatchAll;
		};
		define(RegExp.prototype, func, predicate);
	}
	return polyfill;
};


/***/ }),

/***/ "./node_modules/string.prototype.padend/implementation.js":
/*!****************************************************************!*\
  !*** ./node_modules/string.prototype.padend/implementation.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ToLength = __webpack_require__(/*! es-abstract/2021/ToLength */ "./node_modules/es-abstract/2021/ToLength.js");
var ToString = __webpack_require__(/*! es-abstract/2021/ToString */ "./node_modules/es-abstract/2021/ToString.js");
var RequireObjectCoercible = __webpack_require__(/*! es-abstract/2021/RequireObjectCoercible */ "./node_modules/es-abstract/2021/RequireObjectCoercible.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");

var $slice = callBound('String.prototype.slice');

module.exports = function padEnd(maxLength) {
	var O = RequireObjectCoercible(this);
	var S = ToString(O);
	var stringLength = ToLength(S.length);
	var fillString;
	if (arguments.length > 1) {
		fillString = arguments[1];
	}
	var filler = typeof fillString === 'undefined' ? '' : ToString(fillString);
	if (filler === '') {
		filler = ' ';
	}
	var intMaxLength = ToLength(maxLength);
	if (intMaxLength <= stringLength) {
		return S;
	}
	var fillLen = intMaxLength - stringLength;
	while (filler.length < fillLen) {
		var fLen = filler.length;
		var remainingCodeUnits = fillLen - fLen;
		filler += fLen > remainingCodeUnits ? $slice(filler, 0, remainingCodeUnits) : filler;
	}

	var truncatedStringFiller = filler.length > fillLen ? $slice(filler, 0, fillLen) : filler;
	return S + truncatedStringFiller;
};


/***/ }),

/***/ "./node_modules/string.prototype.padend/polyfill.js":
/*!**********************************************************!*\
  !*** ./node_modules/string.prototype.padend/polyfill.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/string.prototype.padend/implementation.js");

module.exports = function getPolyfill() {
	return typeof String.prototype.padEnd === 'function' ? String.prototype.padEnd : implementation;
};


/***/ }),

/***/ "./node_modules/string.prototype.padend/shim.js":
/*!******************************************************!*\
  !*** ./node_modules/string.prototype.padend/shim.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/string.prototype.padend/polyfill.js");
var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");

module.exports = function shimPadEnd() {
	var polyfill = getPolyfill();
	define(String.prototype, { padEnd: polyfill }, {
		padEnd: function testPadEnd() {
			return String.prototype.padEnd !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ "./node_modules/string.prototype.padstart/implementation.js":
/*!******************************************************************!*\
  !*** ./node_modules/string.prototype.padstart/implementation.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ToLength = __webpack_require__(/*! es-abstract/2021/ToLength */ "./node_modules/es-abstract/2021/ToLength.js");
var ToString = __webpack_require__(/*! es-abstract/2021/ToString */ "./node_modules/es-abstract/2021/ToString.js");
var RequireObjectCoercible = __webpack_require__(/*! es-abstract/2021/RequireObjectCoercible */ "./node_modules/es-abstract/2021/RequireObjectCoercible.js");

var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
var $slice = callBound('String.prototype.slice');

module.exports = function padStart(maxLength) {
	var O = RequireObjectCoercible(this);
	var S = ToString(O);
	var stringLength = ToLength(S.length);
	var fillString;
	if (arguments.length > 1) {
		fillString = arguments[1];
	}
	var filler = typeof fillString === 'undefined' ? '' : ToString(fillString);
	if (filler === '') {
		filler = ' ';
	}
	var intMaxLength = ToLength(maxLength);
	if (intMaxLength <= stringLength) {
		return S;
	}
	var fillLen = intMaxLength - stringLength;
	while (filler.length < fillLen) {
		var fLen = filler.length;
		var remainingCodeUnits = fillLen - fLen;
		filler += fLen > remainingCodeUnits ? $slice(filler, 0, remainingCodeUnits) : filler;
	}

	var truncatedStringFiller = filler.length > fillLen ? $slice(filler, 0, fillLen) : filler;
	return truncatedStringFiller + S;
};


/***/ }),

/***/ "./node_modules/string.prototype.padstart/polyfill.js":
/*!************************************************************!*\
  !*** ./node_modules/string.prototype.padstart/polyfill.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/string.prototype.padstart/implementation.js");

module.exports = function getPolyfill() {
	return typeof String.prototype.padStart === 'function' ? String.prototype.padStart : implementation;
};


/***/ }),

/***/ "./node_modules/string.prototype.padstart/shim.js":
/*!********************************************************!*\
  !*** ./node_modules/string.prototype.padstart/shim.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/string.prototype.padstart/polyfill.js");
var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");

module.exports = function shimPadStart() {
	var polyfill = getPolyfill();
	define(String.prototype, { padStart: polyfill }, {
		padStart: function testPadStart() {
			return String.prototype.padStart !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ "./cloudyman/client/src/styles.css":
/*!*****************************************!*\
  !*** ./cloudyman/client/src/styles.css ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js!./styles.css */ "./node_modules/css-loader/dist/cjs.js!./cloudyman/client/src/styles.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/the-new-css-reset/css/reset.css":
/*!******************************************************!*\
  !*** ./node_modules/the-new-css-reset/css/reset.css ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _css_loader_dist_cjs_js_reset_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../css-loader/dist/cjs.js!./reset.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/the-new-css-reset/css/reset.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_reset_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_reset_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _css_loader_dist_cjs_js_reset_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _css_loader_dist_cjs_js_reset_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


var stylesInDOM = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };

    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);

  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }

      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };

  return updater;
}

module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();

        stylesInDOM.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


var memo = {};
/* istanbul ignore next  */

function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }

    memo[target] = styleTarget;
  }

  return memo[target];
}
/* istanbul ignore next  */


function insertBySelector(insert, style) {
  var target = getTarget(insert);

  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }

  target.appendChild(style);
}

module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}

module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;

  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}

module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";

  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }

  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }

  var needLayer = typeof obj.layer !== "undefined";

  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }

  css += obj.css;

  if (needLayer) {
    css += "}";
  }

  if (obj.media) {
    css += "}";
  }

  if (obj.supports) {
    css += "}";
  }

  var sourceMap = obj.sourceMap;

  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  options.styleTagTransform(css, styleElement, options.options);
}

function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }

  styleElement.parentNode.removeChild(styleElement);
}
/* istanbul ignore next  */


function domAPI(options) {
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}

module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }

    styleElement.appendChild(document.createTextNode(css));
  }
}

module.exports = styleTagTransform;

/***/ }),

/***/ "./node_modules/symbol.prototype.description/auto.js":
/*!***********************************************************!*\
  !*** ./node_modules/symbol.prototype.description/auto.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! ./shim */ "./node_modules/symbol.prototype.description/shim.js")();


/***/ }),

/***/ "./node_modules/symbol.prototype.description/implementation.js":
/*!*********************************************************************!*\
  !*** ./node_modules/symbol.prototype.description/implementation.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getSymbolDescription = __webpack_require__(/*! get-symbol-description */ "./node_modules/get-symbol-description/index.js");

module.exports = function description() {
	return getSymbolDescription(this);
};


/***/ }),

/***/ "./node_modules/symbol.prototype.description/polyfill.js":
/*!***************************************************************!*\
  !*** ./node_modules/symbol.prototype.description/polyfill.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();

var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/symbol.prototype.description/implementation.js");
var gOPD = Object.getOwnPropertyDescriptor;

module.exports = function descriptionPolyfill() {
	if (!hasSymbols || typeof gOPD !== 'function') {
		return null;
	}

	var desc = gOPD(Symbol.prototype, 'description');
	if (!desc || typeof desc.get !== 'function') {
		return implementation;
	}

	var emptySymbolDesc = desc.get.call(Symbol());
	var emptyDescValid = typeof emptySymbolDesc === 'undefined' || emptySymbolDesc === '';
	if (!emptyDescValid || desc.get.call(Symbol('a')) !== 'a') {
		return implementation;
	}
	return desc.get;
};


/***/ }),

/***/ "./node_modules/symbol.prototype.description/shim.js":
/*!***********************************************************!*\
  !*** ./node_modules/symbol.prototype.description/shim.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();
var polyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/symbol.prototype.description/polyfill.js");
var getInferredName = __webpack_require__(/*! get-symbol-description/getInferredName */ "./node_modules/get-symbol-description/getInferredName.js");

var gOPD = Object.getOwnPropertyDescriptor;
var gOPDs = __webpack_require__(/*! object.getownpropertydescriptors/polyfill */ "./node_modules/object.getownpropertydescriptors/polyfill.js")();
var dP = Object.defineProperty;
var dPs = Object.defineProperties;
var setProto = Object.setPrototypeOf;

var define = function defineGetter(getter) {
	dP(Symbol.prototype, 'description', {
		configurable: true,
		enumerable: false,
		get: getter
	});
};

var shimGlobal = function shimGlobalSymbol(getter) {
	var origSym = Function.apply.bind(Symbol);
	var emptyStrings = Object.create ? Object.create(null) : {};
	var SymNew = function Symbol() {
		var sym = origSym(this, arguments);
		if (arguments.length > 0 && arguments[0] === '') {
			emptyStrings[sym] = true;
		}
		return sym;
	};
	SymNew.prototype = Symbol.prototype;
	setProto(SymNew, Symbol);
	var props = gOPDs(Symbol);
	delete props.length;
	delete props.arguments;
	delete props.caller;
	dPs(SymNew, props);
	Symbol = SymNew; // eslint-disable-line no-native-reassign, no-global-assign

	var boundGetter = Function.call.bind(getter);
	var wrappedGetter = function description() {
		/* eslint no-invalid-this: 0 */
		var symbolDescription = boundGetter(this);
		if (emptyStrings[this]) {
			return '';
		}
		return symbolDescription;
	};
	define(wrappedGetter);
	return wrappedGetter;
};

module.exports = function shimSymbolDescription() {
	if (!hasSymbols) {
		return false;
	}
	var desc = gOPD(Symbol.prototype, 'description');
	var getter = polyfill();
	var isMissing = !desc || typeof desc.get !== 'function';
	var isBroken = !isMissing && (typeof Symbol().description !== 'undefined' || Symbol('').description !== '');
	if (isMissing || isBroken) {
		if (!getInferredName) {
			return shimGlobal(getter);
		}
		define(getter);
	}
	return getter;
};


/***/ }),

/***/ "./node_modules/whatwg-fetch/fetch.js":
/*!********************************************!*\
  !*** ./node_modules/whatwg-fetch/fetch.js ***!
  \********************************************/
/***/ (function() {

(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)

    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var list = this.map[name]
    if (!list) {
      list = []
      this.map[name] = list
    }
    list.push(value)
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    var values = this.map[normalizeName(name)]
    return values ? values[0] : null
  }

  Headers.prototype.getAll = function(name) {
    return this.map[normalizeName(name)] || []
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = [normalizeValue(value)]
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    Object.getOwnPropertyNames(this.map).forEach(function(name) {
      this.map[name].forEach(function(value) {
        callback.call(thisArg, value, name, this)
      }, this)
    }, this)
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    reader.readAsArrayBuffer(blob)
    return fileReaderReady(reader)
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    reader.readAsText(blob)
    return fileReaderReady(reader)
  }

  var support = {
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob()
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  function Body() {
    this.bodyUsed = false


    this._initBody = function(body) {
      this._bodyInit = body
      if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (!body) {
        this._bodyText = ''
      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {
        // Only support ArrayBuffers for POST method.
        // Receiving ArrayBuffers happens via Blobs, instead.
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8')
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type)
        }
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        return this.blob().then(readBlobAsArrayBuffer)
      }

      this.text = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text')
        } else {
          return Promise.resolve(this._bodyText)
        }
      }
    } else {
      this.text = function() {
        var rejected = consumed(this)
        return rejected ? rejected : Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body
    if (Request.prototype.isPrototypeOf(input)) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    } else {
      this.url = input
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body)
  }

  Request.prototype.clone = function() {
    return new Request(this)
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function headers(xhr) {
    var head = new Headers()
    var pairs = (xhr.getAllResponseHeaders() || '').trim().split('\n')
    pairs.forEach(function(header) {
      var split = header.trim().split(':')
      var key = split.shift().trim()
      var value = split.join(':').trim()
      head.append(key, value)
    })
    return head
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this.type = 'default'
    this.status = options.status
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = options.statusText
    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)
    this.url = options.url || ''
    this._initBody(bodyInit)
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers
  self.Request = Request
  self.Response = Response

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request
      if (Request.prototype.isPrototypeOf(input) && !init) {
        request = input
      } else {
        request = new Request(input, init)
      }

      var xhr = new XMLHttpRequest()

      function responseURL() {
        if ('responseURL' in xhr) {
          return xhr.responseURL
        }

        // Avoid security warnings on getResponseHeader when not allowed by CORS
        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
          return xhr.getResponseHeader('X-Request-URL')
        }

        return
      }

      xhr.onload = function() {
        var status = (xhr.status === 1223) ? 204 : xhr.status
        if (status < 100 || status > 599) {
          reject(new TypeError('Network request failed'))
          return
        }
        var options = {
          status: status,
          statusText: xhr.statusText,
          headers: headers(xhr),
          url: responseURL()
        }
        var body = 'response' in xhr ? xhr.response : xhr.responseText
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === 'include') {
        xhr.withCredentials = true
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true
})(typeof self !== 'undefined' ? self : this);


/***/ }),

/***/ "./node_modules/window-location-origin/src/window-location-origin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/window-location-origin/src/window-location-origin.js ***!
  \***************************************************************************/
/***/ (() => {

/* jshint browser:true
 *
 * window-location-origin - version 0.0.1
 * Add support for browsers that don't natively support window.location.origin
 *
 * Authror: Kyle Welsby <kyle@mekyle.com>
 * License: MIT
 */

(function(location){
  'use strict';
  if (!location.origin) {
    var origin = location.protocol + "//" + location.hostname + (location.port && ":" + location.port);
    
    try {
      // Make it non editable
      Object.defineProperty(location, "origin", {
        enumerable: true,
        value: origin
      });
    } catch (e){
      // IE < 8
      location.origin = origin;
    }
  }
})(window.location);


/***/ }),

/***/ "?4f7e":
/*!********************************!*\
  !*** ./util.inspect (ignored) ***!
  \********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "./node_modules/es-abstract/2020/IsArray.js":
/*!**************************************************!*\
  !*** ./node_modules/es-abstract/2020/IsArray.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $Array = GetIntrinsic('%Array%');

// eslint-disable-next-line global-require
var toStr = !$Array.isArray && __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js")('Object.prototype.toString');

// https://ecma-international.org/ecma-262/6.0/#sec-isarray

module.exports = $Array.isArray || function IsArray(argument) {
	return toStr(argument) === '[object Array]';
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/AddEntriesFromIterable.js":
/*!*****************************************************************!*\
  !*** ./node_modules/es-abstract/2021/AddEntriesFromIterable.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var inspect = __webpack_require__(/*! object-inspect */ "./node_modules/object-inspect/index.js");

var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $TypeError = GetIntrinsic('%TypeError%');

var Call = __webpack_require__(/*! ./Call */ "./node_modules/es-abstract/2021/Call.js");
var Get = __webpack_require__(/*! ./Get */ "./node_modules/es-abstract/2021/Get.js");
var GetIterator = __webpack_require__(/*! ./GetIterator */ "./node_modules/es-abstract/2021/GetIterator.js");
var IsCallable = __webpack_require__(/*! ./IsCallable */ "./node_modules/es-abstract/2021/IsCallable.js");
var IteratorClose = __webpack_require__(/*! ./IteratorClose */ "./node_modules/es-abstract/2021/IteratorClose.js");
var IteratorStep = __webpack_require__(/*! ./IteratorStep */ "./node_modules/es-abstract/2021/IteratorStep.js");
var IteratorValue = __webpack_require__(/*! ./IteratorValue */ "./node_modules/es-abstract/2021/IteratorValue.js");
var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");

// https://262.ecma-international.org/10.0//#sec-add-entries-from-iterable

module.exports = function AddEntriesFromIterable(target, iterable, adder) {
	if (!IsCallable(adder)) {
		throw new $TypeError('Assertion failed: `adder` is not callable');
	}
	if (iterable == null) {
		throw new $TypeError('Assertion failed: `iterable` is present, and not nullish');
	}
	var iteratorRecord = GetIterator(iterable);
	while (true) { // eslint-disable-line no-constant-condition
		var next = IteratorStep(iteratorRecord);
		if (!next) {
			return target;
		}
		var nextItem = IteratorValue(next);
		if (Type(nextItem) !== 'Object') {
			var error = new $TypeError('iterator next must return an Object, got ' + inspect(nextItem));
			return IteratorClose(
				iteratorRecord,
				function () { throw error; } // eslint-disable-line no-loop-func
			);
		}
		try {
			var k = Get(nextItem, '0');
			var v = Get(nextItem, '1');
			Call(adder, target, [k, v]);
		} catch (e) {
			return IteratorClose(
				iteratorRecord,
				function () { throw e; }
			);
		}
	}
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/AdvanceStringIndex.js":
/*!*************************************************************!*\
  !*** ./node_modules/es-abstract/2021/AdvanceStringIndex.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var CodePointAt = __webpack_require__(/*! ./CodePointAt */ "./node_modules/es-abstract/2021/CodePointAt.js");
var IsIntegralNumber = __webpack_require__(/*! ./IsIntegralNumber */ "./node_modules/es-abstract/2021/IsIntegralNumber.js");
var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");

var MAX_SAFE_INTEGER = __webpack_require__(/*! ../helpers/maxSafeInteger */ "./node_modules/es-abstract/helpers/maxSafeInteger.js");

var $TypeError = GetIntrinsic('%TypeError%');

// https://ecma-international.org/ecma-262/12.0/#sec-advancestringindex

module.exports = function AdvanceStringIndex(S, index, unicode) {
	if (Type(S) !== 'String') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!IsIntegralNumber(index) || index < 0 || index > MAX_SAFE_INTEGER) {
		throw new $TypeError('Assertion failed: `length` must be an integer >= 0 and <= 2**53');
	}
	if (Type(unicode) !== 'Boolean') {
		throw new $TypeError('Assertion failed: `unicode` must be a Boolean');
	}
	if (!unicode) {
		return index + 1;
	}
	var length = S.length;
	if ((index + 1) >= length) {
		return index + 1;
	}
	var cp = CodePointAt(S, index);
	return index + cp['[[CodeUnitCount]]'];
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/ArrayCreate.js":
/*!******************************************************!*\
  !*** ./node_modules/es-abstract/2021/ArrayCreate.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $ArrayPrototype = GetIntrinsic('%Array.prototype%');
var $RangeError = GetIntrinsic('%RangeError%');
var $SyntaxError = GetIntrinsic('%SyntaxError%');
var $TypeError = GetIntrinsic('%TypeError%');

var IsIntegralNumber = __webpack_require__(/*! ./IsIntegralNumber */ "./node_modules/es-abstract/2021/IsIntegralNumber.js");

var MAX_ARRAY_LENGTH = Math.pow(2, 32) - 1;

var $setProto = GetIntrinsic('%Object.setPrototypeOf%', true) || (
	// eslint-disable-next-line no-proto, no-negated-condition
	[].__proto__ !== $ArrayPrototype
		? null
		: function (O, proto) {
			O.__proto__ = proto; // eslint-disable-line no-proto, no-param-reassign
			return O;
		}
);

// https://www.ecma-international.org/ecma-262/12.0/#sec-arraycreate

module.exports = function ArrayCreate(length) {
	if (!IsIntegralNumber(length) || length < 0) {
		throw new $TypeError('Assertion failed: `length` must be an integer Number >= 0');
	}
	if (length > MAX_ARRAY_LENGTH) {
		throw new $RangeError('length is greater than (2**32 - 1)');
	}
	var proto = arguments.length > 1 ? arguments[1] : $ArrayPrototype;
	var A = []; // steps 3, 5
	if (proto !== $ArrayPrototype) { // step 4
		if (!$setProto) {
			throw new $SyntaxError('ArrayCreate: a `proto` argument that is not `Array.prototype` is not supported in an environment that does not support setting the [[Prototype]]');
		}
		$setProto(A, proto);
	}
	if (length !== 0) { // bypasses the need for step 6
		A.length = length;
	}
	/* step 6, the above as a shortcut for the below
    OrdinaryDefineOwnProperty(A, 'length', {
        '[[Configurable]]': false,
        '[[Enumerable]]': false,
        '[[Value]]': length,
        '[[Writable]]': true
    });
    */
	return A;
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/ArraySpeciesCreate.js":
/*!*************************************************************!*\
  !*** ./node_modules/es-abstract/2021/ArraySpeciesCreate.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = GetIntrinsic('%TypeError%');

var ArrayCreate = __webpack_require__(/*! ./ArrayCreate */ "./node_modules/es-abstract/2021/ArrayCreate.js");
var Get = __webpack_require__(/*! ./Get */ "./node_modules/es-abstract/2021/Get.js");
var IsArray = __webpack_require__(/*! ./IsArray */ "./node_modules/es-abstract/2021/IsArray.js");
var IsConstructor = __webpack_require__(/*! ./IsConstructor */ "./node_modules/es-abstract/2021/IsConstructor.js");
var IsIntegralNumber = __webpack_require__(/*! ./IsIntegralNumber */ "./node_modules/es-abstract/2021/IsIntegralNumber.js");
var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");

// https://ecma-international.org/ecma-262/12.0/#sec-arrayspeciescreate

module.exports = function ArraySpeciesCreate(originalArray, length) {
	if (!IsIntegralNumber(length) || length < 0) {
		throw new $TypeError('Assertion failed: length must be an integer >= 0');
	}

	var isArray = IsArray(originalArray);
	if (!isArray) {
		return ArrayCreate(length);
	}

	var C = Get(originalArray, 'constructor');
	// TODO: figure out how to make a cross-realm normal Array, a same-realm Array
	// if (IsConstructor(C)) {
	// 	if C is another realm's Array, C = undefined
	// 	Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(Array))) === null ?
	// }
	if ($species && Type(C) === 'Object') {
		C = Get(C, $species);
		if (C === null) {
			C = void 0;
		}
	}

	if (typeof C === 'undefined') {
		return ArrayCreate(length);
	}
	if (!IsConstructor(C)) {
		throw new $TypeError('C must be a constructor');
	}
	return new C(length); // Construct(C, length);
};



/***/ }),

/***/ "./node_modules/es-abstract/2021/Call.js":
/*!***********************************************!*\
  !*** ./node_modules/es-abstract/2021/Call.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");

var $TypeError = GetIntrinsic('%TypeError%');

var IsArray = __webpack_require__(/*! ./IsArray */ "./node_modules/es-abstract/2021/IsArray.js");

var $apply = GetIntrinsic('%Reflect.apply%', true) || callBound('%Function.prototype.apply%');

// https://ecma-international.org/ecma-262/6.0/#sec-call

module.exports = function Call(F, V) {
	var argumentsList = arguments.length > 2 ? arguments[2] : [];
	if (!IsArray(argumentsList)) {
		throw new $TypeError('Assertion failed: optional `argumentsList`, if provided, must be a List');
	}
	return $apply(F, V, argumentsList);
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/CodePointAt.js":
/*!******************************************************!*\
  !*** ./node_modules/es-abstract/2021/CodePointAt.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $TypeError = GetIntrinsic('%TypeError%');
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
var isLeadingSurrogate = __webpack_require__(/*! ../helpers/isLeadingSurrogate */ "./node_modules/es-abstract/helpers/isLeadingSurrogate.js");
var isTrailingSurrogate = __webpack_require__(/*! ../helpers/isTrailingSurrogate */ "./node_modules/es-abstract/helpers/isTrailingSurrogate.js");

var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");
var UTF16SurrogatePairToCodePoint = __webpack_require__(/*! ./UTF16SurrogatePairToCodePoint */ "./node_modules/es-abstract/2021/UTF16SurrogatePairToCodePoint.js");

var $charAt = callBound('String.prototype.charAt');
var $charCodeAt = callBound('String.prototype.charCodeAt');

// https://ecma-international.org/ecma-262/12.0/#sec-codepointat

module.exports = function CodePointAt(string, position) {
	if (Type(string) !== 'String') {
		throw new $TypeError('Assertion failed: `string` must be a String');
	}
	var size = string.length;
	if (position < 0 || position >= size) {
		throw new $TypeError('Assertion failed: `position` must be >= 0, and < the length of `string`');
	}
	var first = $charCodeAt(string, position);
	var cp = $charAt(string, position);
	var firstIsLeading = isLeadingSurrogate(first);
	var firstIsTrailing = isTrailingSurrogate(first);
	if (!firstIsLeading && !firstIsTrailing) {
		return {
			'[[CodePoint]]': cp,
			'[[CodeUnitCount]]': 1,
			'[[IsUnpairedSurrogate]]': false
		};
	}
	if (firstIsTrailing || (position + 1 === size)) {
		return {
			'[[CodePoint]]': cp,
			'[[CodeUnitCount]]': 1,
			'[[IsUnpairedSurrogate]]': true
		};
	}
	var second = $charCodeAt(string, position + 1);
	if (!isTrailingSurrogate(second)) {
		return {
			'[[CodePoint]]': cp,
			'[[CodeUnitCount]]': 1,
			'[[IsUnpairedSurrogate]]': true
		};
	}

	return {
		'[[CodePoint]]': UTF16SurrogatePairToCodePoint(first, second),
		'[[CodeUnitCount]]': 2,
		'[[IsUnpairedSurrogate]]': false
	};
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/CreateDataProperty.js":
/*!*************************************************************!*\
  !*** ./node_modules/es-abstract/2021/CreateDataProperty.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $TypeError = GetIntrinsic('%TypeError%');

var DefineOwnProperty = __webpack_require__(/*! ../helpers/DefineOwnProperty */ "./node_modules/es-abstract/helpers/DefineOwnProperty.js");

var FromPropertyDescriptor = __webpack_require__(/*! ./FromPropertyDescriptor */ "./node_modules/es-abstract/2021/FromPropertyDescriptor.js");
var OrdinaryGetOwnProperty = __webpack_require__(/*! ./OrdinaryGetOwnProperty */ "./node_modules/es-abstract/2021/OrdinaryGetOwnProperty.js");
var IsDataDescriptor = __webpack_require__(/*! ./IsDataDescriptor */ "./node_modules/es-abstract/2021/IsDataDescriptor.js");
var IsExtensible = __webpack_require__(/*! ./IsExtensible */ "./node_modules/es-abstract/2021/IsExtensible.js");
var IsPropertyKey = __webpack_require__(/*! ./IsPropertyKey */ "./node_modules/es-abstract/2021/IsPropertyKey.js");
var SameValue = __webpack_require__(/*! ./SameValue */ "./node_modules/es-abstract/2021/SameValue.js");
var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");

// https://ecma-international.org/ecma-262/6.0/#sec-createdataproperty

module.exports = function CreateDataProperty(O, P, V) {
	if (Type(O) !== 'Object') {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true');
	}
	var oldDesc = OrdinaryGetOwnProperty(O, P);
	var extensible = !oldDesc || IsExtensible(O);
	var immutable = oldDesc && (!oldDesc['[[Writable]]'] || !oldDesc['[[Configurable]]']);
	if (immutable || !extensible) {
		return false;
	}
	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		{
			'[[Configurable]]': true,
			'[[Enumerable]]': true,
			'[[Value]]': V,
			'[[Writable]]': true
		}
	);
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/CreateDataPropertyOrThrow.js":
/*!********************************************************************!*\
  !*** ./node_modules/es-abstract/2021/CreateDataPropertyOrThrow.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $TypeError = GetIntrinsic('%TypeError%');

var CreateDataProperty = __webpack_require__(/*! ./CreateDataProperty */ "./node_modules/es-abstract/2021/CreateDataProperty.js");
var IsPropertyKey = __webpack_require__(/*! ./IsPropertyKey */ "./node_modules/es-abstract/2021/IsPropertyKey.js");
var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");

// // https://ecma-international.org/ecma-262/6.0/#sec-createdatapropertyorthrow

module.exports = function CreateDataPropertyOrThrow(O, P, V) {
	if (Type(O) !== 'Object') {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true');
	}
	var success = CreateDataProperty(O, P, V);
	if (!success) {
		throw new $TypeError('unable to create data property');
	}
	return success;
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/CreateIterResultObject.js":
/*!*****************************************************************!*\
  !*** ./node_modules/es-abstract/2021/CreateIterResultObject.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $TypeError = GetIntrinsic('%TypeError%');

var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");

// https://ecma-international.org/ecma-262/6.0/#sec-createiterresultobject

module.exports = function CreateIterResultObject(value, done) {
	if (Type(done) !== 'Boolean') {
		throw new $TypeError('Assertion failed: Type(done) is not Boolean');
	}
	return {
		value: value,
		done: done
	};
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/CreateMethodProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/es-abstract/2021/CreateMethodProperty.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $TypeError = GetIntrinsic('%TypeError%');

var DefineOwnProperty = __webpack_require__(/*! ../helpers/DefineOwnProperty */ "./node_modules/es-abstract/helpers/DefineOwnProperty.js");

var FromPropertyDescriptor = __webpack_require__(/*! ./FromPropertyDescriptor */ "./node_modules/es-abstract/2021/FromPropertyDescriptor.js");
var IsDataDescriptor = __webpack_require__(/*! ./IsDataDescriptor */ "./node_modules/es-abstract/2021/IsDataDescriptor.js");
var IsPropertyKey = __webpack_require__(/*! ./IsPropertyKey */ "./node_modules/es-abstract/2021/IsPropertyKey.js");
var SameValue = __webpack_require__(/*! ./SameValue */ "./node_modules/es-abstract/2021/SameValue.js");
var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");

// https://ecma-international.org/ecma-262/6.0/#sec-createmethodproperty

module.exports = function CreateMethodProperty(O, P, V) {
	if (Type(O) !== 'Object') {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true');
	}

	var newDesc = {
		'[[Configurable]]': true,
		'[[Enumerable]]': false,
		'[[Value]]': V,
		'[[Writable]]': true
	};
	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		newDesc
	);
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/CreateRegExpStringIterator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/es-abstract/2021/CreateRegExpStringIterator.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();

var $TypeError = GetIntrinsic('%TypeError%');
var IteratorPrototype = GetIntrinsic('%IteratorPrototype%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

var AdvanceStringIndex = __webpack_require__(/*! ./AdvanceStringIndex */ "./node_modules/es-abstract/2021/AdvanceStringIndex.js");
var CreateIterResultObject = __webpack_require__(/*! ./CreateIterResultObject */ "./node_modules/es-abstract/2021/CreateIterResultObject.js");
var CreateMethodProperty = __webpack_require__(/*! ./CreateMethodProperty */ "./node_modules/es-abstract/2021/CreateMethodProperty.js");
var Get = __webpack_require__(/*! ./Get */ "./node_modules/es-abstract/2021/Get.js");
var OrdinaryObjectCreate = __webpack_require__(/*! ./OrdinaryObjectCreate */ "./node_modules/es-abstract/2021/OrdinaryObjectCreate.js");
var RegExpExec = __webpack_require__(/*! ./RegExpExec */ "./node_modules/es-abstract/2021/RegExpExec.js");
var Set = __webpack_require__(/*! ./Set */ "./node_modules/es-abstract/2021/Set.js");
var ToLength = __webpack_require__(/*! ./ToLength */ "./node_modules/es-abstract/2021/ToLength.js");
var ToString = __webpack_require__(/*! ./ToString */ "./node_modules/es-abstract/2021/ToString.js");
var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");

var SLOT = __webpack_require__(/*! internal-slot */ "./node_modules/internal-slot/index.js");

var RegExpStringIterator = function RegExpStringIterator(R, S, global, fullUnicode) {
	if (Type(S) !== 'String') {
		throw new $TypeError('`S` must be a string');
	}
	if (Type(global) !== 'Boolean') {
		throw new $TypeError('`global` must be a boolean');
	}
	if (Type(fullUnicode) !== 'Boolean') {
		throw new $TypeError('`fullUnicode` must be a boolean');
	}
	SLOT.set(this, '[[IteratingRegExp]]', R);
	SLOT.set(this, '[[IteratedString]]', S);
	SLOT.set(this, '[[Global]]', global);
	SLOT.set(this, '[[Unicode]]', fullUnicode);
	SLOT.set(this, '[[Done]]', false);
};

if (IteratorPrototype) {
	RegExpStringIterator.prototype = OrdinaryObjectCreate(IteratorPrototype);
}

var RegExpStringIteratorNext = function next() {
	var O = this; // eslint-disable-line no-invalid-this
	if (Type(O) !== 'Object') {
		throw new $TypeError('receiver must be an object');
	}
	if (
		!(O instanceof RegExpStringIterator)
        || !SLOT.has(O, '[[IteratingRegExp]]')
        || !SLOT.has(O, '[[IteratedString]]')
        || !SLOT.has(O, '[[Global]]')
        || !SLOT.has(O, '[[Unicode]]')
        || !SLOT.has(O, '[[Done]]')
	) {
		throw new $TypeError('"this" value must be a RegExpStringIterator instance');
	}
	if (SLOT.get(O, '[[Done]]')) {
		return CreateIterResultObject(undefined, true);
	}
	var R = SLOT.get(O, '[[IteratingRegExp]]');
	var S = SLOT.get(O, '[[IteratedString]]');
	var global = SLOT.get(O, '[[Global]]');
	var fullUnicode = SLOT.get(O, '[[Unicode]]');
	var match = RegExpExec(R, S);
	if (match === null) {
		SLOT.set(O, '[[Done]]', true);
		return CreateIterResultObject(undefined, true);
	}
	if (global) {
		var matchStr = ToString(Get(match, '0'));
		if (matchStr === '') {
			var thisIndex = ToLength(Get(R, 'lastIndex'));
			var nextIndex = AdvanceStringIndex(S, thisIndex, fullUnicode);
			Set(R, 'lastIndex', nextIndex, true);
		}
		return CreateIterResultObject(match, false);
	}
	SLOT.set(O, '[[Done]]', true);
	return CreateIterResultObject(match, false);
};
CreateMethodProperty(RegExpStringIterator.prototype, 'next', RegExpStringIteratorNext);

if (hasSymbols) {
	if (Symbol.toStringTag) {
		if ($defineProperty) {
			$defineProperty(RegExpStringIterator.prototype, Symbol.toStringTag, {
				configurable: true,
				enumerable: false,
				value: 'RegExp String Iterator',
				writable: false
			});
		} else {
			RegExpStringIterator.prototype[Symbol.toStringTag] = 'RegExp String Iterator';
		}
	}

	if (Symbol.iterator && typeof RegExpStringIterator.prototype[Symbol.iterator] !== 'function') {
		var iteratorFn = function SymbolIterator() {
			return this;
		};
		CreateMethodProperty(RegExpStringIterator.prototype, Symbol.iterator, iteratorFn);
	}
}

// https://262.ecma-international.org/11.0/#sec-createregexpstringiterator
module.exports = function CreateRegExpStringIterator(R, S, global, fullUnicode) {
	// assert R.global === global && R.unicode === fullUnicode?
	return new RegExpStringIterator(R, S, global, fullUnicode);
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/DefinePropertyOrThrow.js":
/*!****************************************************************!*\
  !*** ./node_modules/es-abstract/2021/DefinePropertyOrThrow.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $TypeError = GetIntrinsic('%TypeError%');

var isPropertyDescriptor = __webpack_require__(/*! ../helpers/isPropertyDescriptor */ "./node_modules/es-abstract/helpers/isPropertyDescriptor.js");
var DefineOwnProperty = __webpack_require__(/*! ../helpers/DefineOwnProperty */ "./node_modules/es-abstract/helpers/DefineOwnProperty.js");

var FromPropertyDescriptor = __webpack_require__(/*! ./FromPropertyDescriptor */ "./node_modules/es-abstract/2021/FromPropertyDescriptor.js");
var IsAccessorDescriptor = __webpack_require__(/*! ./IsAccessorDescriptor */ "./node_modules/es-abstract/2021/IsAccessorDescriptor.js");
var IsDataDescriptor = __webpack_require__(/*! ./IsDataDescriptor */ "./node_modules/es-abstract/2021/IsDataDescriptor.js");
var IsPropertyKey = __webpack_require__(/*! ./IsPropertyKey */ "./node_modules/es-abstract/2021/IsPropertyKey.js");
var SameValue = __webpack_require__(/*! ./SameValue */ "./node_modules/es-abstract/2021/SameValue.js");
var ToPropertyDescriptor = __webpack_require__(/*! ./ToPropertyDescriptor */ "./node_modules/es-abstract/2021/ToPropertyDescriptor.js");
var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");

// https://ecma-international.org/ecma-262/6.0/#sec-definepropertyorthrow

module.exports = function DefinePropertyOrThrow(O, P, desc) {
	if (Type(O) !== 'Object') {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true');
	}

	var Desc = isPropertyDescriptor({
		Type: Type,
		IsDataDescriptor: IsDataDescriptor,
		IsAccessorDescriptor: IsAccessorDescriptor
	}, desc) ? desc : ToPropertyDescriptor(desc);
	if (!isPropertyDescriptor({
		Type: Type,
		IsDataDescriptor: IsDataDescriptor,
		IsAccessorDescriptor: IsAccessorDescriptor
	}, Desc)) {
		throw new $TypeError('Assertion failed: Desc is not a valid Property Descriptor');
	}

	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		Desc
	);
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/FlattenIntoArray.js":
/*!***********************************************************!*\
  !*** ./node_modules/es-abstract/2021/FlattenIntoArray.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $TypeError = GetIntrinsic('%TypeError%');

var MAX_SAFE_INTEGER = __webpack_require__(/*! ../helpers/maxSafeInteger */ "./node_modules/es-abstract/helpers/maxSafeInteger.js");

var Call = __webpack_require__(/*! ./Call */ "./node_modules/es-abstract/2021/Call.js");
var CreateDataPropertyOrThrow = __webpack_require__(/*! ./CreateDataPropertyOrThrow */ "./node_modules/es-abstract/2021/CreateDataPropertyOrThrow.js");
var Get = __webpack_require__(/*! ./Get */ "./node_modules/es-abstract/2021/Get.js");
var HasProperty = __webpack_require__(/*! ./HasProperty */ "./node_modules/es-abstract/2021/HasProperty.js");
var IsArray = __webpack_require__(/*! ./IsArray */ "./node_modules/es-abstract/2021/IsArray.js");
var LengthOfArrayLike = __webpack_require__(/*! ./LengthOfArrayLike */ "./node_modules/es-abstract/2021/LengthOfArrayLike.js");
var ToString = __webpack_require__(/*! ./ToString */ "./node_modules/es-abstract/2021/ToString.js");

// https://262.ecma-international.org/11.0/#sec-flattenintoarray

// eslint-disable-next-line max-params
module.exports = function FlattenIntoArray(target, source, sourceLen, start, depth) {
	var mapperFunction;
	if (arguments.length > 5) {
		mapperFunction = arguments[5];
	}

	var targetIndex = start;
	var sourceIndex = 0;
	while (sourceIndex < sourceLen) {
		var P = ToString(sourceIndex);
		var exists = HasProperty(source, P);
		if (exists === true) {
			var element = Get(source, P);
			if (typeof mapperFunction !== 'undefined') {
				if (arguments.length <= 6) {
					throw new $TypeError('Assertion failed: thisArg is required when mapperFunction is provided');
				}
				element = Call(mapperFunction, arguments[6], [element, sourceIndex, source]);
			}
			var shouldFlatten = false;
			if (depth > 0) {
				shouldFlatten = IsArray(element);
			}
			if (shouldFlatten) {
				var elementLen = LengthOfArrayLike(element);
				targetIndex = FlattenIntoArray(target, element, elementLen, targetIndex, depth - 1);
			} else {
				if (targetIndex >= MAX_SAFE_INTEGER) {
					throw new $TypeError('index too large');
				}
				CreateDataPropertyOrThrow(target, ToString(targetIndex), element);
				targetIndex += 1;
			}
		}
		sourceIndex += 1;
	}

	return targetIndex;
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/FromPropertyDescriptor.js":
/*!*****************************************************************!*\
  !*** ./node_modules/es-abstract/2021/FromPropertyDescriptor.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var assertRecord = __webpack_require__(/*! ../helpers/assertRecord */ "./node_modules/es-abstract/helpers/assertRecord.js");

var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");

// https://ecma-international.org/ecma-262/6.0/#sec-frompropertydescriptor

module.exports = function FromPropertyDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return Desc;
	}

	assertRecord(Type, 'Property Descriptor', 'Desc', Desc);

	var obj = {};
	if ('[[Value]]' in Desc) {
		obj.value = Desc['[[Value]]'];
	}
	if ('[[Writable]]' in Desc) {
		obj.writable = Desc['[[Writable]]'];
	}
	if ('[[Get]]' in Desc) {
		obj.get = Desc['[[Get]]'];
	}
	if ('[[Set]]' in Desc) {
		obj.set = Desc['[[Set]]'];
	}
	if ('[[Enumerable]]' in Desc) {
		obj.enumerable = Desc['[[Enumerable]]'];
	}
	if ('[[Configurable]]' in Desc) {
		obj.configurable = Desc['[[Configurable]]'];
	}
	return obj;
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/Get.js":
/*!**********************************************!*\
  !*** ./node_modules/es-abstract/2021/Get.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $TypeError = GetIntrinsic('%TypeError%');

var inspect = __webpack_require__(/*! object-inspect */ "./node_modules/object-inspect/index.js");

var IsPropertyKey = __webpack_require__(/*! ./IsPropertyKey */ "./node_modules/es-abstract/2021/IsPropertyKey.js");
var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");

/**
 * 7.3.1 Get (O, P) - https://ecma-international.org/ecma-262/6.0/#sec-get-o-p
 * 1. Assert: Type(O) is Object.
 * 2. Assert: IsPropertyKey(P) is true.
 * 3. Return O.[[Get]](P, O).
 */

module.exports = function Get(O, P) {
	// 7.3.1.1
	if (Type(O) !== 'Object') {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	// 7.3.1.2
	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true, got ' + inspect(P));
	}
	// 7.3.1.3
	return O[P];
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/GetIterator.js":
/*!******************************************************!*\
  !*** ./node_modules/es-abstract/2021/GetIterator.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $TypeError = GetIntrinsic('%TypeError%');
var $asyncIterator = GetIntrinsic('%Symbol.asyncIterator%', true);

var inspect = __webpack_require__(/*! object-inspect */ "./node_modules/object-inspect/index.js");
var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();

var getIteratorMethod = __webpack_require__(/*! ../helpers/getIteratorMethod */ "./node_modules/es-abstract/helpers/getIteratorMethod.js");
var AdvanceStringIndex = __webpack_require__(/*! ./AdvanceStringIndex */ "./node_modules/es-abstract/2021/AdvanceStringIndex.js");
var Call = __webpack_require__(/*! ./Call */ "./node_modules/es-abstract/2021/Call.js");
var GetMethod = __webpack_require__(/*! ./GetMethod */ "./node_modules/es-abstract/2021/GetMethod.js");
var IsArray = __webpack_require__(/*! ./IsArray */ "./node_modules/es-abstract/2021/IsArray.js");
var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");

// https://262.ecma-international.org/9.0/#sec-getiterator
module.exports = function GetIterator(obj, hint, method) {
	var actualHint = hint;
	if (arguments.length < 2) {
		actualHint = 'sync';
	}
	if (actualHint !== 'sync' && actualHint !== 'async') {
		throw new $TypeError("Assertion failed: `hint` must be one of 'sync' or 'async', got " + inspect(hint));
	}

	var actualMethod = method;
	if (arguments.length < 3) {
		if (actualHint === 'async') {
			if (hasSymbols && $asyncIterator) {
				actualMethod = GetMethod(obj, $asyncIterator);
			}
			if (actualMethod === undefined) {
				throw new $TypeError("async from sync iterators aren't currently supported");
			}
		} else {
			actualMethod = getIteratorMethod(
				{
					AdvanceStringIndex: AdvanceStringIndex,
					GetMethod: GetMethod,
					IsArray: IsArray,
					Type: Type
				},
				obj
			);
		}
	}
	var iterator = Call(actualMethod, obj);
	if (Type(iterator) !== 'Object') {
		throw new $TypeError('iterator must return an object');
	}

	return iterator;

	// TODO: This should return an IteratorRecord
	/*
	var nextMethod = GetV(iterator, 'next');
	return {
		'[[Iterator]]': iterator,
		'[[NextMethod]]': nextMethod,
		'[[Done]]': false
	};
	*/
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/GetMethod.js":
/*!****************************************************!*\
  !*** ./node_modules/es-abstract/2021/GetMethod.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $TypeError = GetIntrinsic('%TypeError%');

var GetV = __webpack_require__(/*! ./GetV */ "./node_modules/es-abstract/2021/GetV.js");
var IsCallable = __webpack_require__(/*! ./IsCallable */ "./node_modules/es-abstract/2021/IsCallable.js");
var IsPropertyKey = __webpack_require__(/*! ./IsPropertyKey */ "./node_modules/es-abstract/2021/IsPropertyKey.js");

/**
 * 7.3.9 - https://ecma-international.org/ecma-262/6.0/#sec-getmethod
 * 1. Assert: IsPropertyKey(P) is true.
 * 2. Let func be GetV(O, P).
 * 3. ReturnIfAbrupt(func).
 * 4. If func is either undefined or null, return undefined.
 * 5. If IsCallable(func) is false, throw a TypeError exception.
 * 6. Return func.
 */

module.exports = function GetMethod(O, P) {
	// 7.3.9.1
	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true');
	}

	// 7.3.9.2
	var func = GetV(O, P);

	// 7.3.9.4
	if (func == null) {
		return void 0;
	}

	// 7.3.9.5
	if (!IsCallable(func)) {
		throw new $TypeError(P + 'is not a function');
	}

	// 7.3.9.6
	return func;
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/GetV.js":
/*!***********************************************!*\
  !*** ./node_modules/es-abstract/2021/GetV.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $TypeError = GetIntrinsic('%TypeError%');

var IsPropertyKey = __webpack_require__(/*! ./IsPropertyKey */ "./node_modules/es-abstract/2021/IsPropertyKey.js");
var ToObject = __webpack_require__(/*! ./ToObject */ "./node_modules/es-abstract/2021/ToObject.js");

/**
 * 7.3.2 GetV (V, P)
 * 1. Assert: IsPropertyKey(P) is true.
 * 2. Let O be ToObject(V).
 * 3. ReturnIfAbrupt(O).
 * 4. Return O.[[Get]](P, V).
 */

module.exports = function GetV(V, P) {
	// 7.3.2.1
	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true');
	}

	// 7.3.2.2-3
	var O = ToObject(V);

	// 7.3.2.4
	return O[P];
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/HasProperty.js":
/*!******************************************************!*\
  !*** ./node_modules/es-abstract/2021/HasProperty.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $TypeError = GetIntrinsic('%TypeError%');

var IsPropertyKey = __webpack_require__(/*! ./IsPropertyKey */ "./node_modules/es-abstract/2021/IsPropertyKey.js");
var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");

// https://ecma-international.org/ecma-262/6.0/#sec-hasproperty

module.exports = function HasProperty(O, P) {
	if (Type(O) !== 'Object') {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	return P in O;
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/Invoke.js":
/*!*************************************************!*\
  !*** ./node_modules/es-abstract/2021/Invoke.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $TypeError = GetIntrinsic('%TypeError%');

var Call = __webpack_require__(/*! ./Call */ "./node_modules/es-abstract/2021/Call.js");
var IsArray = __webpack_require__(/*! ./IsArray */ "./node_modules/es-abstract/2021/IsArray.js");
var GetV = __webpack_require__(/*! ./GetV */ "./node_modules/es-abstract/2021/GetV.js");
var IsPropertyKey = __webpack_require__(/*! ./IsPropertyKey */ "./node_modules/es-abstract/2021/IsPropertyKey.js");

// https://ecma-international.org/ecma-262/6.0/#sec-invoke

module.exports = function Invoke(O, P) {
	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	var argumentsList = arguments.length > 2 ? arguments[2] : [];
	if (!IsArray(argumentsList)) {
		throw new $TypeError('Assertion failed: optional `argumentsList`, if provided, must be a List');
	}
	var func = GetV(O, P);
	return Call(func, O, argumentsList);
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/IsAccessorDescriptor.js":
/*!***************************************************************!*\
  !*** ./node_modules/es-abstract/2021/IsAccessorDescriptor.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var has = __webpack_require__(/*! has */ "./node_modules/has/src/index.js");

var assertRecord = __webpack_require__(/*! ../helpers/assertRecord */ "./node_modules/es-abstract/helpers/assertRecord.js");

var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");

// https://ecma-international.org/ecma-262/6.0/#sec-isaccessordescriptor

module.exports = function IsAccessorDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	assertRecord(Type, 'Property Descriptor', 'Desc', Desc);

	if (!has(Desc, '[[Get]]') && !has(Desc, '[[Set]]')) {
		return false;
	}

	return true;
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/IsArray.js":
/*!**************************************************!*\
  !*** ./node_modules/es-abstract/2021/IsArray.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $Array = GetIntrinsic('%Array%');

// eslint-disable-next-line global-require
var toStr = !$Array.isArray && __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js")('Object.prototype.toString');

// https://ecma-international.org/ecma-262/6.0/#sec-isarray

module.exports = $Array.isArray || function IsArray(argument) {
	return toStr(argument) === '[object Array]';
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/IsCallable.js":
/*!*****************************************************!*\
  !*** ./node_modules/es-abstract/2021/IsCallable.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// http://262.ecma-international.org/5.1/#sec-9.11

module.exports = __webpack_require__(/*! is-callable */ "./node_modules/is-callable/index.js");


/***/ }),

/***/ "./node_modules/es-abstract/2021/IsConstructor.js":
/*!********************************************************!*\
  !*** ./node_modules/es-abstract/2021/IsConstructor.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! ../GetIntrinsic.js */ "./node_modules/es-abstract/GetIntrinsic.js");

var $construct = GetIntrinsic('%Reflect.construct%', true);

var DefinePropertyOrThrow = __webpack_require__(/*! ./DefinePropertyOrThrow */ "./node_modules/es-abstract/2021/DefinePropertyOrThrow.js");
try {
	DefinePropertyOrThrow({}, '', { '[[Get]]': function () {} });
} catch (e) {
	// Accessor properties aren't supported
	DefinePropertyOrThrow = null;
}

// https://ecma-international.org/ecma-262/6.0/#sec-isconstructor

if (DefinePropertyOrThrow && $construct) {
	var isConstructorMarker = {};
	var badArrayLike = {};
	DefinePropertyOrThrow(badArrayLike, 'length', {
		'[[Get]]': function () {
			throw isConstructorMarker;
		},
		'[[Enumerable]]': true
	});

	module.exports = function IsConstructor(argument) {
		try {
			// `Reflect.construct` invokes `IsConstructor(target)` before `Get(args, 'length')`:
			$construct(argument, badArrayLike);
		} catch (err) {
			return err === isConstructorMarker;
		}
	};
} else {
	module.exports = function IsConstructor(argument) {
		// unfortunately there's no way to truly check this without try/catch `new argument` in old environments
		return typeof argument === 'function' && !!argument.prototype;
	};
}


/***/ }),

/***/ "./node_modules/es-abstract/2021/IsDataDescriptor.js":
/*!***********************************************************!*\
  !*** ./node_modules/es-abstract/2021/IsDataDescriptor.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var has = __webpack_require__(/*! has */ "./node_modules/has/src/index.js");

var assertRecord = __webpack_require__(/*! ../helpers/assertRecord */ "./node_modules/es-abstract/helpers/assertRecord.js");

var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");

// https://ecma-international.org/ecma-262/6.0/#sec-isdatadescriptor

module.exports = function IsDataDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	assertRecord(Type, 'Property Descriptor', 'Desc', Desc);

	if (!has(Desc, '[[Value]]') && !has(Desc, '[[Writable]]')) {
		return false;
	}

	return true;
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/IsExtensible.js":
/*!*******************************************************!*\
  !*** ./node_modules/es-abstract/2021/IsExtensible.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $Object = GetIntrinsic('%Object%');

var isPrimitive = __webpack_require__(/*! ../helpers/isPrimitive */ "./node_modules/es-abstract/helpers/isPrimitive.js");

var $preventExtensions = $Object.preventExtensions;
var $isExtensible = $Object.isExtensible;

// https://ecma-international.org/ecma-262/6.0/#sec-isextensible-o

module.exports = $preventExtensions
	? function IsExtensible(obj) {
		return !isPrimitive(obj) && $isExtensible(obj);
	}
	: function IsExtensible(obj) {
		return !isPrimitive(obj);
	};


/***/ }),

/***/ "./node_modules/es-abstract/2021/IsIntegralNumber.js":
/*!***********************************************************!*\
  !*** ./node_modules/es-abstract/2021/IsIntegralNumber.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var abs = __webpack_require__(/*! ./abs */ "./node_modules/es-abstract/2021/abs.js");
var floor = __webpack_require__(/*! ./floor */ "./node_modules/es-abstract/2021/floor.js");
var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");

var $isNaN = __webpack_require__(/*! ../helpers/isNaN */ "./node_modules/es-abstract/helpers/isNaN.js");
var $isFinite = __webpack_require__(/*! ../helpers/isFinite */ "./node_modules/es-abstract/helpers/isFinite.js");

// https://tc39.es/ecma262/#sec-isintegralnumber

module.exports = function IsIntegralNumber(argument) {
	if (Type(argument) !== 'Number' || $isNaN(argument) || !$isFinite(argument)) {
		return false;
	}
	var absValue = abs(argument);
	return floor(absValue) === absValue;
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/IsPropertyKey.js":
/*!********************************************************!*\
  !*** ./node_modules/es-abstract/2021/IsPropertyKey.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


// https://ecma-international.org/ecma-262/6.0/#sec-ispropertykey

module.exports = function IsPropertyKey(argument) {
	return typeof argument === 'string' || typeof argument === 'symbol';
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/IsRegExp.js":
/*!***************************************************!*\
  !*** ./node_modules/es-abstract/2021/IsRegExp.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $match = GetIntrinsic('%Symbol.match%', true);

var hasRegExpMatcher = __webpack_require__(/*! is-regex */ "./node_modules/is-regex/index.js");

var ToBoolean = __webpack_require__(/*! ./ToBoolean */ "./node_modules/es-abstract/2021/ToBoolean.js");

// https://ecma-international.org/ecma-262/6.0/#sec-isregexp

module.exports = function IsRegExp(argument) {
	if (!argument || typeof argument !== 'object') {
		return false;
	}
	if ($match) {
		var isRegExp = argument[$match];
		if (typeof isRegExp !== 'undefined') {
			return ToBoolean(isRegExp);
		}
	}
	return hasRegExpMatcher(argument);
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/IteratorClose.js":
/*!********************************************************!*\
  !*** ./node_modules/es-abstract/2021/IteratorClose.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $TypeError = GetIntrinsic('%TypeError%');

var Call = __webpack_require__(/*! ./Call */ "./node_modules/es-abstract/2021/Call.js");
var GetMethod = __webpack_require__(/*! ./GetMethod */ "./node_modules/es-abstract/2021/GetMethod.js");
var IsCallable = __webpack_require__(/*! ./IsCallable */ "./node_modules/es-abstract/2021/IsCallable.js");
var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");

// https://ecma-international.org/ecma-262/6.0/#sec-iteratorclose

module.exports = function IteratorClose(iterator, completion) {
	if (Type(iterator) !== 'Object') {
		throw new $TypeError('Assertion failed: Type(iterator) is not Object');
	}
	if (!IsCallable(completion)) {
		throw new $TypeError('Assertion failed: completion is not a thunk for a Completion Record');
	}
	var completionThunk = completion;

	var iteratorReturn = GetMethod(iterator, 'return');

	if (typeof iteratorReturn === 'undefined') {
		return completionThunk();
	}

	var completionRecord;
	try {
		var innerResult = Call(iteratorReturn, iterator, []);
	} catch (e) {
		// if we hit here, then "e" is the innerResult completion that needs re-throwing

		// if the completion is of type "throw", this will throw.
		completionThunk();
		completionThunk = null; // ensure it's not called twice.

		// if not, then return the innerResult completion
		throw e;
	}
	completionRecord = completionThunk(); // if innerResult worked, then throw if the completion does
	completionThunk = null; // ensure it's not called twice.

	if (Type(innerResult) !== 'Object') {
		throw new $TypeError('iterator .return must return an object');
	}

	return completionRecord;
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/IteratorComplete.js":
/*!***********************************************************!*\
  !*** ./node_modules/es-abstract/2021/IteratorComplete.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $TypeError = GetIntrinsic('%TypeError%');

var Get = __webpack_require__(/*! ./Get */ "./node_modules/es-abstract/2021/Get.js");
var ToBoolean = __webpack_require__(/*! ./ToBoolean */ "./node_modules/es-abstract/2021/ToBoolean.js");
var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");

// https://ecma-international.org/ecma-262/6.0/#sec-iteratorcomplete

module.exports = function IteratorComplete(iterResult) {
	if (Type(iterResult) !== 'Object') {
		throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
	}
	return ToBoolean(Get(iterResult, 'done'));
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/IteratorNext.js":
/*!*******************************************************!*\
  !*** ./node_modules/es-abstract/2021/IteratorNext.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $TypeError = GetIntrinsic('%TypeError%');

var Invoke = __webpack_require__(/*! ./Invoke */ "./node_modules/es-abstract/2021/Invoke.js");
var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");

// https://ecma-international.org/ecma-262/6.0/#sec-iteratornext

module.exports = function IteratorNext(iterator, value) {
	var result = Invoke(iterator, 'next', arguments.length < 2 ? [] : [value]);
	if (Type(result) !== 'Object') {
		throw new $TypeError('iterator next must return an object');
	}
	return result;
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/IteratorStep.js":
/*!*******************************************************!*\
  !*** ./node_modules/es-abstract/2021/IteratorStep.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var IteratorComplete = __webpack_require__(/*! ./IteratorComplete */ "./node_modules/es-abstract/2021/IteratorComplete.js");
var IteratorNext = __webpack_require__(/*! ./IteratorNext */ "./node_modules/es-abstract/2021/IteratorNext.js");

// https://ecma-international.org/ecma-262/6.0/#sec-iteratorstep

module.exports = function IteratorStep(iterator) {
	var result = IteratorNext(iterator);
	var done = IteratorComplete(result);
	return done === true ? false : result;
};



/***/ }),

/***/ "./node_modules/es-abstract/2021/IteratorValue.js":
/*!********************************************************!*\
  !*** ./node_modules/es-abstract/2021/IteratorValue.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $TypeError = GetIntrinsic('%TypeError%');

var Get = __webpack_require__(/*! ./Get */ "./node_modules/es-abstract/2021/Get.js");
var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");

// https://ecma-international.org/ecma-262/6.0/#sec-iteratorvalue

module.exports = function IteratorValue(iterResult) {
	if (Type(iterResult) !== 'Object') {
		throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
	}
	return Get(iterResult, 'value');
};



/***/ }),

/***/ "./node_modules/es-abstract/2021/LengthOfArrayLike.js":
/*!************************************************************!*\
  !*** ./node_modules/es-abstract/2021/LengthOfArrayLike.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $TypeError = GetIntrinsic('%TypeError%');

var Get = __webpack_require__(/*! ./Get */ "./node_modules/es-abstract/2021/Get.js");
var ToLength = __webpack_require__(/*! ./ToLength */ "./node_modules/es-abstract/2021/ToLength.js");
var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");

// https://262.ecma-international.org/11.0/#sec-lengthofarraylike

module.exports = function LengthOfArrayLike(obj) {
	if (Type(obj) !== 'Object') {
		throw new $TypeError('Assertion failed: `obj` must be an Object');
	}
	return ToLength(Get(obj, 'length'));
};

// TODO: use this all over


/***/ }),

/***/ "./node_modules/es-abstract/2021/OrdinaryGetOwnProperty.js":
/*!*****************************************************************!*\
  !*** ./node_modules/es-abstract/2021/OrdinaryGetOwnProperty.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $gOPD = __webpack_require__(/*! ../helpers/getOwnPropertyDescriptor */ "./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js");
var $TypeError = GetIntrinsic('%TypeError%');

var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var has = __webpack_require__(/*! has */ "./node_modules/has/src/index.js");

var IsArray = __webpack_require__(/*! ./IsArray */ "./node_modules/es-abstract/2021/IsArray.js");
var IsPropertyKey = __webpack_require__(/*! ./IsPropertyKey */ "./node_modules/es-abstract/2021/IsPropertyKey.js");
var IsRegExp = __webpack_require__(/*! ./IsRegExp */ "./node_modules/es-abstract/2021/IsRegExp.js");
var ToPropertyDescriptor = __webpack_require__(/*! ./ToPropertyDescriptor */ "./node_modules/es-abstract/2021/ToPropertyDescriptor.js");
var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");

// https://ecma-international.org/ecma-262/6.0/#sec-ordinarygetownproperty

module.exports = function OrdinaryGetOwnProperty(O, P) {
	if (Type(O) !== 'Object') {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (!has(O, P)) {
		return void 0;
	}
	if (!$gOPD) {
		// ES3 / IE 8 fallback
		var arrayLength = IsArray(O) && P === 'length';
		var regexLastIndex = IsRegExp(O) && P === 'lastIndex';
		return {
			'[[Configurable]]': !(arrayLength || regexLastIndex),
			'[[Enumerable]]': $isEnumerable(O, P),
			'[[Value]]': O[P],
			'[[Writable]]': true
		};
	}
	return ToPropertyDescriptor($gOPD(O, P));
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/OrdinaryObjectCreate.js":
/*!***************************************************************!*\
  !*** ./node_modules/es-abstract/2021/OrdinaryObjectCreate.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $ObjectCreate = GetIntrinsic('%Object.create%', true);
var $TypeError = GetIntrinsic('%TypeError%');
var $SyntaxError = GetIntrinsic('%SyntaxError%');

var IsArray = __webpack_require__(/*! ./IsArray */ "./node_modules/es-abstract/2021/IsArray.js");
var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");

var hasProto = !({ __proto__: null } instanceof Object);

// https://262.ecma-international.org/6.0/#sec-objectcreate

module.exports = function OrdinaryObjectCreate(proto) {
	if (proto !== null && Type(proto) !== 'Object') {
		throw new $TypeError('Assertion failed: `proto` must be null or an object');
	}
	var additionalInternalSlotsList = arguments.length < 2 ? [] : arguments[1];
	if (!IsArray(additionalInternalSlotsList)) {
		throw new $TypeError('Assertion failed: `additionalInternalSlotsList` must be an Array');
	}
	// var internalSlotsList = ['[[Prototype]]', '[[Extensible]]'];
	if (additionalInternalSlotsList.length > 0) {
		throw new $SyntaxError('es-abstract does not yet support internal slots');
		// internalSlotsList.push(...additionalInternalSlotsList);
	}
	// var O = MakeBasicObject(internalSlotsList);
	// setProto(O, proto);
	// return O;

	if ($ObjectCreate) {
		return $ObjectCreate(proto);
	}
	if (hasProto) {
		return { __proto__: proto };
	}

	if (proto === null) {
		throw new $SyntaxError('native Object.create support is required to create null objects');
	}
	var T = function T() {};
	T.prototype = proto;
	return new T();
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/PromiseResolve.js":
/*!*********************************************************!*\
  !*** ./node_modules/es-abstract/2021/PromiseResolve.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var callBind = __webpack_require__(/*! call-bind */ "./node_modules/call-bind/index.js");

var $resolve = GetIntrinsic('%Promise.resolve%', true);
var $PromiseResolve = $resolve && callBind($resolve);

// https://262.ecma-international.org/9.0/#sec-promise-resolve

module.exports = function PromiseResolve(C, x) {
	if (!$PromiseResolve) {
		throw new SyntaxError('This environment does not support Promises.');
	}
	return $PromiseResolve(C, x);
};



/***/ }),

/***/ "./node_modules/es-abstract/2021/RegExpExec.js":
/*!*****************************************************!*\
  !*** ./node_modules/es-abstract/2021/RegExpExec.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $TypeError = GetIntrinsic('%TypeError%');

var regexExec = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js")('RegExp.prototype.exec');

var Call = __webpack_require__(/*! ./Call */ "./node_modules/es-abstract/2021/Call.js");
var Get = __webpack_require__(/*! ./Get */ "./node_modules/es-abstract/2021/Get.js");
var IsCallable = __webpack_require__(/*! ./IsCallable */ "./node_modules/es-abstract/2021/IsCallable.js");
var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");

// https://ecma-international.org/ecma-262/6.0/#sec-regexpexec

module.exports = function RegExpExec(R, S) {
	if (Type(R) !== 'Object') {
		throw new $TypeError('Assertion failed: `R` must be an Object');
	}
	if (Type(S) !== 'String') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	var exec = Get(R, 'exec');
	if (IsCallable(exec)) {
		var result = Call(exec, R, [S]);
		if (result === null || Type(result) === 'Object') {
			return result;
		}
		throw new $TypeError('"exec" method must return `null` or an Object');
	}
	return regexExec(R, S);
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/RequireObjectCoercible.js":
/*!*****************************************************************!*\
  !*** ./node_modules/es-abstract/2021/RequireObjectCoercible.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = __webpack_require__(/*! ../5/CheckObjectCoercible */ "./node_modules/es-abstract/5/CheckObjectCoercible.js");


/***/ }),

/***/ "./node_modules/es-abstract/2021/SameValue.js":
/*!****************************************************!*\
  !*** ./node_modules/es-abstract/2021/SameValue.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $isNaN = __webpack_require__(/*! ../helpers/isNaN */ "./node_modules/es-abstract/helpers/isNaN.js");

// http://262.ecma-international.org/5.1/#sec-9.12

module.exports = function SameValue(x, y) {
	if (x === y) { // 0 === -0, but they are not identical.
		if (x === 0) { return 1 / x === 1 / y; }
		return true;
	}
	return $isNaN(x) && $isNaN(y);
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/SameValueZero.js":
/*!********************************************************!*\
  !*** ./node_modules/es-abstract/2021/SameValueZero.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $isNaN = __webpack_require__(/*! ../helpers/isNaN */ "./node_modules/es-abstract/helpers/isNaN.js");

// https://ecma-international.org/ecma-262/6.0/#sec-samevaluezero

module.exports = function SameValueZero(x, y) {
	return (x === y) || ($isNaN(x) && $isNaN(y));
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/Set.js":
/*!**********************************************!*\
  !*** ./node_modules/es-abstract/2021/Set.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $TypeError = GetIntrinsic('%TypeError%');

var IsPropertyKey = __webpack_require__(/*! ./IsPropertyKey */ "./node_modules/es-abstract/2021/IsPropertyKey.js");
var SameValue = __webpack_require__(/*! ./SameValue */ "./node_modules/es-abstract/2021/SameValue.js");
var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");

// IE 9 does not throw in strict mode when writability/configurability/extensibility is violated
var noThrowOnStrictViolation = (function () {
	try {
		delete [].length;
		return true;
	} catch (e) {
		return false;
	}
}());

// https://ecma-international.org/ecma-262/6.0/#sec-set-o-p-v-throw

module.exports = function Set(O, P, V, Throw) {
	if (Type(O) !== 'Object') {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	if (Type(Throw) !== 'Boolean') {
		throw new $TypeError('Assertion failed: `Throw` must be a Boolean');
	}
	if (Throw) {
		O[P] = V; // eslint-disable-line no-param-reassign
		if (noThrowOnStrictViolation && !SameValue(O[P], V)) {
			throw new $TypeError('Attempted to assign to readonly property.');
		}
		return true;
	}
	try {
		O[P] = V; // eslint-disable-line no-param-reassign
		return noThrowOnStrictViolation ? SameValue(O[P], V) : true;
	} catch (e) {
		return false;
	}

};


/***/ }),

/***/ "./node_modules/es-abstract/2021/SpeciesConstructor.js":
/*!*************************************************************!*\
  !*** ./node_modules/es-abstract/2021/SpeciesConstructor.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = GetIntrinsic('%TypeError%');

var IsConstructor = __webpack_require__(/*! ./IsConstructor */ "./node_modules/es-abstract/2021/IsConstructor.js");
var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");

// https://ecma-international.org/ecma-262/6.0/#sec-speciesconstructor

module.exports = function SpeciesConstructor(O, defaultConstructor) {
	if (Type(O) !== 'Object') {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	var C = O.constructor;
	if (typeof C === 'undefined') {
		return defaultConstructor;
	}
	if (Type(C) !== 'Object') {
		throw new $TypeError('O.constructor is not an Object');
	}
	var S = $species ? C[$species] : void 0;
	if (S == null) {
		return defaultConstructor;
	}
	if (IsConstructor(S)) {
		return S;
	}
	throw new $TypeError('no constructor found');
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/ToBoolean.js":
/*!****************************************************!*\
  !*** ./node_modules/es-abstract/2021/ToBoolean.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";


// http://262.ecma-international.org/5.1/#sec-9.2

module.exports = function ToBoolean(value) { return !!value; };


/***/ }),

/***/ "./node_modules/es-abstract/2021/ToIntegerOrInfinity.js":
/*!**************************************************************!*\
  !*** ./node_modules/es-abstract/2021/ToIntegerOrInfinity.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ES5ToInteger = __webpack_require__(/*! ../5/ToInteger */ "./node_modules/es-abstract/5/ToInteger.js");

var ToNumber = __webpack_require__(/*! ./ToNumber */ "./node_modules/es-abstract/2021/ToNumber.js");

// https://www.ecma-international.org/ecma-262/11.0/#sec-tointeger

module.exports = function ToInteger(value) {
	var number = ToNumber(value);
	if (number !== 0) {
		number = ES5ToInteger(number);
	}
	return number === 0 ? 0 : number;
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/ToLength.js":
/*!***************************************************!*\
  !*** ./node_modules/es-abstract/2021/ToLength.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var MAX_SAFE_INTEGER = __webpack_require__(/*! ../helpers/maxSafeInteger */ "./node_modules/es-abstract/helpers/maxSafeInteger.js");

var ToIntegerOrInfinity = __webpack_require__(/*! ./ToIntegerOrInfinity */ "./node_modules/es-abstract/2021/ToIntegerOrInfinity.js");

module.exports = function ToLength(argument) {
	var len = ToIntegerOrInfinity(argument);
	if (len <= 0) { return 0; } // includes converting -0 to +0
	if (len > MAX_SAFE_INTEGER) { return MAX_SAFE_INTEGER; }
	return len;
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/ToNumber.js":
/*!***************************************************!*\
  !*** ./node_modules/es-abstract/2021/ToNumber.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $TypeError = GetIntrinsic('%TypeError%');
var $Number = GetIntrinsic('%Number%');
var $RegExp = GetIntrinsic('%RegExp%');
var $parseInteger = GetIntrinsic('%parseInt%');

var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
var regexTester = __webpack_require__(/*! ../helpers/regexTester */ "./node_modules/es-abstract/helpers/regexTester.js");
var isPrimitive = __webpack_require__(/*! ../helpers/isPrimitive */ "./node_modules/es-abstract/helpers/isPrimitive.js");

var $strSlice = callBound('String.prototype.slice');
var isBinary = regexTester(/^0b[01]+$/i);
var isOctal = regexTester(/^0o[0-7]+$/i);
var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);
var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
var nonWSregex = new $RegExp('[' + nonWS + ']', 'g');
var hasNonWS = regexTester(nonWSregex);

// whitespace from: https://es5.github.io/#x15.5.4.20
// implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324
var ws = [
	'\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003',
	'\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028',
	'\u2029\uFEFF'
].join('');
var trimRegex = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');
var $replace = callBound('String.prototype.replace');
var $trim = function (value) {
	return $replace(value, trimRegex, '');
};

var ToPrimitive = __webpack_require__(/*! ./ToPrimitive */ "./node_modules/es-abstract/2021/ToPrimitive.js");

// https://ecma-international.org/ecma-262/6.0/#sec-tonumber

module.exports = function ToNumber(argument) {
	var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
	if (typeof value === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a number');
	}
	if (typeof value === 'bigint') {
		throw new $TypeError('Conversion from \'BigInt\' to \'number\' is not allowed.');
	}
	if (typeof value === 'string') {
		if (isBinary(value)) {
			return ToNumber($parseInteger($strSlice(value, 2), 2));
		} else if (isOctal(value)) {
			return ToNumber($parseInteger($strSlice(value, 2), 8));
		} else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
			return NaN;
		}
		var trimmed = $trim(value);
		if (trimmed !== value) {
			return ToNumber(trimmed);
		}

	}
	return $Number(value);
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/ToObject.js":
/*!***************************************************!*\
  !*** ./node_modules/es-abstract/2021/ToObject.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $Object = GetIntrinsic('%Object%');

var RequireObjectCoercible = __webpack_require__(/*! ./RequireObjectCoercible */ "./node_modules/es-abstract/2021/RequireObjectCoercible.js");

// https://ecma-international.org/ecma-262/6.0/#sec-toobject

module.exports = function ToObject(value) {
	RequireObjectCoercible(value);
	return $Object(value);
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/ToPrimitive.js":
/*!******************************************************!*\
  !*** ./node_modules/es-abstract/2021/ToPrimitive.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var toPrimitive = __webpack_require__(/*! es-to-primitive/es2015 */ "./node_modules/es-to-primitive/es2015.js");

// https://ecma-international.org/ecma-262/6.0/#sec-toprimitive

module.exports = function ToPrimitive(input) {
	if (arguments.length > 1) {
		return toPrimitive(input, arguments[1]);
	}
	return toPrimitive(input);
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/ToPropertyDescriptor.js":
/*!***************************************************************!*\
  !*** ./node_modules/es-abstract/2021/ToPropertyDescriptor.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var has = __webpack_require__(/*! has */ "./node_modules/has/src/index.js");

var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $TypeError = GetIntrinsic('%TypeError%');

var Type = __webpack_require__(/*! ./Type */ "./node_modules/es-abstract/2021/Type.js");
var ToBoolean = __webpack_require__(/*! ./ToBoolean */ "./node_modules/es-abstract/2021/ToBoolean.js");
var IsCallable = __webpack_require__(/*! ./IsCallable */ "./node_modules/es-abstract/2021/IsCallable.js");

// https://262.ecma-international.org/5.1/#sec-8.10.5

module.exports = function ToPropertyDescriptor(Obj) {
	if (Type(Obj) !== 'Object') {
		throw new $TypeError('ToPropertyDescriptor requires an object');
	}

	var desc = {};
	if (has(Obj, 'enumerable')) {
		desc['[[Enumerable]]'] = ToBoolean(Obj.enumerable);
	}
	if (has(Obj, 'configurable')) {
		desc['[[Configurable]]'] = ToBoolean(Obj.configurable);
	}
	if (has(Obj, 'value')) {
		desc['[[Value]]'] = Obj.value;
	}
	if (has(Obj, 'writable')) {
		desc['[[Writable]]'] = ToBoolean(Obj.writable);
	}
	if (has(Obj, 'get')) {
		var getter = Obj.get;
		if (typeof getter !== 'undefined' && !IsCallable(getter)) {
			throw new $TypeError('getter must be a function');
		}
		desc['[[Get]]'] = getter;
	}
	if (has(Obj, 'set')) {
		var setter = Obj.set;
		if (typeof setter !== 'undefined' && !IsCallable(setter)) {
			throw new $TypeError('setter must be a function');
		}
		desc['[[Set]]'] = setter;
	}

	if ((has(desc, '[[Get]]') || has(desc, '[[Set]]')) && (has(desc, '[[Value]]') || has(desc, '[[Writable]]'))) {
		throw new $TypeError('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');
	}
	return desc;
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/ToPropertyKey.js":
/*!********************************************************!*\
  !*** ./node_modules/es-abstract/2021/ToPropertyKey.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $String = GetIntrinsic('%String%');

var ToPrimitive = __webpack_require__(/*! ./ToPrimitive */ "./node_modules/es-abstract/2021/ToPrimitive.js");
var ToString = __webpack_require__(/*! ./ToString */ "./node_modules/es-abstract/2021/ToString.js");

// https://ecma-international.org/ecma-262/6.0/#sec-topropertykey

module.exports = function ToPropertyKey(argument) {
	var key = ToPrimitive(argument, $String);
	return typeof key === 'symbol' ? key : ToString(key);
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/ToString.js":
/*!***************************************************!*\
  !*** ./node_modules/es-abstract/2021/ToString.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $String = GetIntrinsic('%String%');
var $TypeError = GetIntrinsic('%TypeError%');

// https://ecma-international.org/ecma-262/6.0/#sec-tostring

module.exports = function ToString(argument) {
	if (typeof argument === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a string');
	}
	return $String(argument);
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/ToUint32.js":
/*!***************************************************!*\
  !*** ./node_modules/es-abstract/2021/ToUint32.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ToNumber = __webpack_require__(/*! ./ToNumber */ "./node_modules/es-abstract/2021/ToNumber.js");

// http://262.ecma-international.org/5.1/#sec-9.6

module.exports = function ToUint32(x) {
	return ToNumber(x) >>> 0;
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/Type.js":
/*!***********************************************!*\
  !*** ./node_modules/es-abstract/2021/Type.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ES5Type = __webpack_require__(/*! ../5/Type */ "./node_modules/es-abstract/5/Type.js");

// https://262.ecma-international.org/11.0/#sec-ecmascript-data-types-and-values

module.exports = function Type(x) {
	if (typeof x === 'symbol') {
		return 'Symbol';
	}
	if (typeof x === 'bigint') {
		return 'BigInt';
	}
	return ES5Type(x);
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/UTF16SurrogatePairToCodePoint.js":
/*!************************************************************************!*\
  !*** ./node_modules/es-abstract/2021/UTF16SurrogatePairToCodePoint.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $TypeError = GetIntrinsic('%TypeError%');
var $fromCharCode = GetIntrinsic('%String.fromCharCode%');

var isLeadingSurrogate = __webpack_require__(/*! ../helpers/isLeadingSurrogate */ "./node_modules/es-abstract/helpers/isLeadingSurrogate.js");
var isTrailingSurrogate = __webpack_require__(/*! ../helpers/isTrailingSurrogate */ "./node_modules/es-abstract/helpers/isTrailingSurrogate.js");

// https://tc39.es/ecma262/2020/#sec-utf16decodesurrogatepair

module.exports = function UTF16DecodeSurrogatePair(lead, trail) {
	if (!isLeadingSurrogate(lead) || !isTrailingSurrogate(trail)) {
		throw new $TypeError('Assertion failed: `lead` must be a leading surrogate char code, and `trail` must be a trailing surrogate char code');
	}
	// var cp = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
	return $fromCharCode(lead) + $fromCharCode(trail);
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/abs.js":
/*!**********************************************!*\
  !*** ./node_modules/es-abstract/2021/abs.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $abs = GetIntrinsic('%Math.abs%');

// http://262.ecma-international.org/5.1/#sec-5.2

module.exports = function abs(x) {
	return $abs(x);
};


/***/ }),

/***/ "./node_modules/es-abstract/2021/floor.js":
/*!************************************************!*\
  !*** ./node_modules/es-abstract/2021/floor.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


// var modulo = require('./modulo');
var $floor = Math.floor;

// http://262.ecma-international.org/5.1/#sec-5.2

module.exports = function floor(x) {
	// return x - modulo(x, 1);
	return $floor(x);
};


/***/ }),

/***/ "./node_modules/es-abstract/5/CheckObjectCoercible.js":
/*!************************************************************!*\
  !*** ./node_modules/es-abstract/5/CheckObjectCoercible.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $TypeError = GetIntrinsic('%TypeError%');

// http://262.ecma-international.org/5.1/#sec-9.10

module.exports = function CheckObjectCoercible(value, optMessage) {
	if (value == null) {
		throw new $TypeError(optMessage || ('Cannot call method on ' + value));
	}
	return value;
};


/***/ }),

/***/ "./node_modules/es-abstract/5/ToInteger.js":
/*!*************************************************!*\
  !*** ./node_modules/es-abstract/5/ToInteger.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var abs = __webpack_require__(/*! ./abs */ "./node_modules/es-abstract/5/abs.js");
var floor = __webpack_require__(/*! ./floor */ "./node_modules/es-abstract/5/floor.js");
var ToNumber = __webpack_require__(/*! ./ToNumber */ "./node_modules/es-abstract/5/ToNumber.js");

var $isNaN = __webpack_require__(/*! ../helpers/isNaN */ "./node_modules/es-abstract/helpers/isNaN.js");
var $isFinite = __webpack_require__(/*! ../helpers/isFinite */ "./node_modules/es-abstract/helpers/isFinite.js");
var $sign = __webpack_require__(/*! ../helpers/sign */ "./node_modules/es-abstract/helpers/sign.js");

// http://262.ecma-international.org/5.1/#sec-9.4

module.exports = function ToInteger(value) {
	var number = ToNumber(value);
	if ($isNaN(number)) { return 0; }
	if (number === 0 || !$isFinite(number)) { return number; }
	return $sign(number) * floor(abs(number));
};


/***/ }),

/***/ "./node_modules/es-abstract/5/ToNumber.js":
/*!************************************************!*\
  !*** ./node_modules/es-abstract/5/ToNumber.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ToPrimitive = __webpack_require__(/*! ./ToPrimitive */ "./node_modules/es-abstract/5/ToPrimitive.js");

// http://262.ecma-international.org/5.1/#sec-9.3

module.exports = function ToNumber(value) {
	var prim = ToPrimitive(value, Number);
	if (typeof prim !== 'string') {
		return +prim; // eslint-disable-line no-implicit-coercion
	}

	// eslint-disable-next-line no-control-regex
	var trimmed = prim.replace(/^[ \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u0085]+|[ \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u0085]+$/g, '');
	if ((/^0[ob]|^[+-]0x/).test(trimmed)) {
		return NaN;
	}

	return +trimmed; // eslint-disable-line no-implicit-coercion
};


/***/ }),

/***/ "./node_modules/es-abstract/5/ToPrimitive.js":
/*!***************************************************!*\
  !*** ./node_modules/es-abstract/5/ToPrimitive.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// http://262.ecma-international.org/5.1/#sec-9.1

module.exports = __webpack_require__(/*! es-to-primitive/es5 */ "./node_modules/es-to-primitive/es5.js");


/***/ }),

/***/ "./node_modules/es-abstract/5/Type.js":
/*!********************************************!*\
  !*** ./node_modules/es-abstract/5/Type.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";


// https://262.ecma-international.org/5.1/#sec-8

module.exports = function Type(x) {
	if (x === null) {
		return 'Null';
	}
	if (typeof x === 'undefined') {
		return 'Undefined';
	}
	if (typeof x === 'function' || typeof x === 'object') {
		return 'Object';
	}
	if (typeof x === 'number') {
		return 'Number';
	}
	if (typeof x === 'boolean') {
		return 'Boolean';
	}
	if (typeof x === 'string') {
		return 'String';
	}
};


/***/ }),

/***/ "./node_modules/es-abstract/5/abs.js":
/*!*******************************************!*\
  !*** ./node_modules/es-abstract/5/abs.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $abs = GetIntrinsic('%Math.abs%');

// http://262.ecma-international.org/5.1/#sec-5.2

module.exports = function abs(x) {
	return $abs(x);
};


/***/ }),

/***/ "./node_modules/es-abstract/5/floor.js":
/*!*********************************************!*\
  !*** ./node_modules/es-abstract/5/floor.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


// var modulo = require('./modulo');
var $floor = Math.floor;

// http://262.ecma-international.org/5.1/#sec-5.2

module.exports = function floor(x) {
	// return x - modulo(x, 1);
	return $floor(x);
};


/***/ }),

/***/ "./node_modules/es-abstract/GetIntrinsic.js":
/*!**************************************************!*\
  !*** ./node_modules/es-abstract/GetIntrinsic.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// TODO: remove, semver-major

module.exports = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");


/***/ }),

/***/ "./node_modules/es-abstract/helpers/DefineOwnProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/es-abstract/helpers/DefineOwnProperty.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

// node v0.6 has a bug where array lengths can be Set but not Defined
var hasArrayLengthDefineBug = Object.defineProperty && Object.defineProperty([], 'length', { value: 1 }).length === 0;

// eslint-disable-next-line global-require
var isArray = hasArrayLengthDefineBug && __webpack_require__(/*! ../2020/IsArray */ "./node_modules/es-abstract/2020/IsArray.js"); // this does not depend on any other AOs.

var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

// eslint-disable-next-line max-params
module.exports = function DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, desc) {
	if (!$defineProperty) {
		if (!IsDataDescriptor(desc)) {
			// ES3 does not support getters/setters
			return false;
		}
		if (!desc['[[Configurable]]'] || !desc['[[Writable]]']) {
			return false;
		}

		// fallback for ES3
		if (P in O && $isEnumerable(O, P) !== !!desc['[[Enumerable]]']) {
			// a non-enumerable existing property
			return false;
		}

		// property does not exist at all, or exists but is enumerable
		var V = desc['[[Value]]'];
		// eslint-disable-next-line no-param-reassign
		O[P] = V; // will use [[Define]]
		return SameValue(O[P], V);
	}
	if (
		hasArrayLengthDefineBug
		&& P === 'length'
		&& '[[Value]]' in desc
		&& isArray(O)
		&& O.length !== desc['[[Value]]']
	) {
		// eslint-disable-next-line no-param-reassign
		O.length = desc['[[Value]]'];
		return O.length === desc['[[Value]]'];
	}

	$defineProperty(O, P, FromPropertyDescriptor(desc));
	return true;
};


/***/ }),

/***/ "./node_modules/es-abstract/helpers/assertRecord.js":
/*!**********************************************************!*\
  !*** ./node_modules/es-abstract/helpers/assertRecord.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $TypeError = GetIntrinsic('%TypeError%');
var $SyntaxError = GetIntrinsic('%SyntaxError%');

var has = __webpack_require__(/*! has */ "./node_modules/has/src/index.js");

var predicates = {
	// https://262.ecma-international.org/6.0/#sec-property-descriptor-specification-type
	'Property Descriptor': function isPropertyDescriptor(Type, Desc) {
		if (Type(Desc) !== 'Object') {
			return false;
		}
		var allowed = {
			'[[Configurable]]': true,
			'[[Enumerable]]': true,
			'[[Get]]': true,
			'[[Set]]': true,
			'[[Value]]': true,
			'[[Writable]]': true
		};

		for (var key in Desc) { // eslint-disable-line
			if (has(Desc, key) && !allowed[key]) {
				return false;
			}
		}

		var isData = has(Desc, '[[Value]]');
		var IsAccessor = has(Desc, '[[Get]]') || has(Desc, '[[Set]]');
		if (isData && IsAccessor) {
			throw new $TypeError('Property Descriptors may not be both accessor and data descriptors');
		}
		return true;
	}
};

module.exports = function assertRecord(Type, recordType, argumentName, value) {
	var predicate = predicates[recordType];
	if (typeof predicate !== 'function') {
		throw new $SyntaxError('unknown record type: ' + recordType);
	}
	if (!predicate(Type, value)) {
		throw new $TypeError(argumentName + ' must be a ' + recordType);
	}
};


/***/ }),

/***/ "./node_modules/es-abstract/helpers/getIteratorMethod.js":
/*!***************************************************************!*\
  !*** ./node_modules/es-abstract/helpers/getIteratorMethod.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();
var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");

var $iterator = GetIntrinsic('%Symbol.iterator%', true);
var $stringSlice = callBound('String.prototype.slice');

module.exports = function getIteratorMethod(ES, iterable) {
	var usingIterator;
	if (hasSymbols) {
		usingIterator = ES.GetMethod(iterable, $iterator);
	} else if (ES.IsArray(iterable)) {
		usingIterator = function () {
			var i = -1;
			var arr = this; // eslint-disable-line no-invalid-this
			return {
				next: function () {
					i += 1;
					return {
						done: i >= arr.length,
						value: arr[i]
					};
				}
			};
		};
	} else if (ES.Type(iterable) === 'String') {
		usingIterator = function () {
			var i = 0;
			return {
				next: function () {
					var nextIndex = ES.AdvanceStringIndex(iterable, i, true);
					var value = $stringSlice(iterable, i, nextIndex);
					i = nextIndex;
					return {
						done: nextIndex > iterable.length,
						value: value
					};
				}
			};
		};
	}
	return usingIterator;
};


/***/ }),

/***/ "./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ "./node_modules/es-abstract/helpers/isFinite.js":
/*!******************************************************!*\
  !*** ./node_modules/es-abstract/helpers/isFinite.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


var $isNaN = Number.isNaN || function (a) { return a !== a; };

module.exports = Number.isFinite || function (x) { return typeof x === 'number' && !$isNaN(x) && x !== Infinity && x !== -Infinity; };


/***/ }),

/***/ "./node_modules/es-abstract/helpers/isLeadingSurrogate.js":
/*!****************************************************************!*\
  !*** ./node_modules/es-abstract/helpers/isLeadingSurrogate.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function isLeadingSurrogate(charCode) {
	return typeof charCode === 'number' && charCode >= 0xD800 && charCode <= 0xDBFF;
};


/***/ }),

/***/ "./node_modules/es-abstract/helpers/isNaN.js":
/*!***************************************************!*\
  !*** ./node_modules/es-abstract/helpers/isNaN.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


module.exports = Number.isNaN || function isNaN(a) {
	return a !== a;
};


/***/ }),

/***/ "./node_modules/es-abstract/helpers/isPrimitive.js":
/*!*********************************************************!*\
  !*** ./node_modules/es-abstract/helpers/isPrimitive.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


module.exports = function isPrimitive(value) {
	return value === null || (typeof value !== 'function' && typeof value !== 'object');
};


/***/ }),

/***/ "./node_modules/es-abstract/helpers/isPropertyDescriptor.js":
/*!******************************************************************!*\
  !*** ./node_modules/es-abstract/helpers/isPropertyDescriptor.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var has = __webpack_require__(/*! has */ "./node_modules/has/src/index.js");
var $TypeError = GetIntrinsic('%TypeError%');

module.exports = function IsPropertyDescriptor(ES, Desc) {
	if (ES.Type(Desc) !== 'Object') {
		return false;
	}
	var allowed = {
		'[[Configurable]]': true,
		'[[Enumerable]]': true,
		'[[Get]]': true,
		'[[Set]]': true,
		'[[Value]]': true,
		'[[Writable]]': true
	};

	for (var key in Desc) { // eslint-disable-line no-restricted-syntax
		if (has(Desc, key) && !allowed[key]) {
			return false;
		}
	}

	if (ES.IsDataDescriptor(Desc) && ES.IsAccessorDescriptor(Desc)) {
		throw new $TypeError('Property Descriptors may not be both accessor and data descriptors');
	}
	return true;
};


/***/ }),

/***/ "./node_modules/es-abstract/helpers/isTrailingSurrogate.js":
/*!*****************************************************************!*\
  !*** ./node_modules/es-abstract/helpers/isTrailingSurrogate.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function isTrailingSurrogate(charCode) {
	return typeof charCode === 'number' && charCode >= 0xDC00 && charCode <= 0xDFFF;
};


/***/ }),

/***/ "./node_modules/es-abstract/helpers/maxSafeInteger.js":
/*!************************************************************!*\
  !*** ./node_modules/es-abstract/helpers/maxSafeInteger.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $Math = GetIntrinsic('%Math%');
var $Number = GetIntrinsic('%Number%');

module.exports = $Number.MAX_SAFE_INTEGER || $Math.pow(2, 53) - 1;


/***/ }),

/***/ "./node_modules/es-abstract/helpers/regexTester.js":
/*!*********************************************************!*\
  !*** ./node_modules/es-abstract/helpers/regexTester.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $test = GetIntrinsic('RegExp.prototype.test');

var callBind = __webpack_require__(/*! call-bind */ "./node_modules/call-bind/index.js");

module.exports = function regexTester(regex) {
	return callBind($test, regex);
};


/***/ }),

/***/ "./node_modules/es-abstract/helpers/sign.js":
/*!**************************************************!*\
  !*** ./node_modules/es-abstract/helpers/sign.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";


module.exports = function sign(number) {
	return number >= 0 ? 1 : -1;
};


/***/ }),

/***/ "./node_modules/es-get-iterator/index.js":
/*!***********************************************!*\
  !*** ./node_modules/es-get-iterator/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* eslint global-require: 0 */
// the code is structured this way so that bundlers can
// alias out `has-symbols` to `() => true` or `() => false` if your target
// environments' Symbol capabilities are known, and then use
// dead code elimination on the rest of this module.
//
// Similarly, `isarray` can be aliased to `Array.isArray` if
// available in all target environments.

var isArguments = __webpack_require__(/*! is-arguments */ "./node_modules/is-arguments/index.js");

if (__webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")() || __webpack_require__(/*! has-symbols/shams */ "./node_modules/has-symbols/shams.js")()) {
	var $iterator = Symbol.iterator;
	// Symbol is available natively or shammed
	// natively:
	//  - Chrome >= 38
	//  - Edge 12-14?, Edge >= 15 for sure
	//  - FF >= 36
	//  - Safari >= 9
	//  - node >= 0.12
	module.exports = function getIterator(iterable) {
		// alternatively, `iterable[$iterator]?.()`
		if (iterable != null && typeof iterable[$iterator] !== 'undefined') {
			return iterable[$iterator]();
		}
		if (isArguments(iterable)) {
			// arguments objects lack Symbol.iterator
			// - node 0.12
			return Array.prototype[$iterator].call(iterable);
		}
	};
} else {
	// Symbol is not available, native or shammed
	var isArray = __webpack_require__(/*! isarray */ "./node_modules/es-get-iterator/node_modules/isarray/index.js");
	var isString = __webpack_require__(/*! is-string */ "./node_modules/is-string/index.js");
	var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
	var $Map = GetIntrinsic('%Map%', true);
	var $Set = GetIntrinsic('%Set%', true);
	var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
	var $arrayPush = callBound('Array.prototype.push');
	var $charCodeAt = callBound('String.prototype.charCodeAt');
	var $stringSlice = callBound('String.prototype.slice');

	var advanceStringIndex = function advanceStringIndex(S, index) {
		var length = S.length;
		if ((index + 1) >= length) {
			return index + 1;
		}

		var first = $charCodeAt(S, index);
		if (first < 0xD800 || first > 0xDBFF) {
			return index + 1;
		}

		var second = $charCodeAt(S, index + 1);
		if (second < 0xDC00 || second > 0xDFFF) {
			return index + 1;
		}

		return index + 2;
	};

	var getArrayIterator = function getArrayIterator(arraylike) {
		var i = 0;
		return {
			next: function next() {
				var done = i >= arraylike.length;
				var value;
				if (!done) {
					value = arraylike[i];
					i += 1;
				}
				return {
					done: done,
					value: value
				};
			}
		};
	};

	var getNonCollectionIterator = function getNonCollectionIterator(iterable, noPrimordialCollections) {
		if (isArray(iterable) || isArguments(iterable)) {
			return getArrayIterator(iterable);
		}
		if (isString(iterable)) {
			var i = 0;
			return {
				next: function next() {
					var nextIndex = advanceStringIndex(iterable, i);
					var value = $stringSlice(iterable, i, nextIndex);
					i = nextIndex;
					return {
						done: nextIndex > iterable.length,
						value: value
					};
				}
			};
		}

		// es6-shim and es-shims' es-map use a string "_es6-shim iterator_" property on different iterables, such as MapIterator.
		if (noPrimordialCollections && typeof iterable['_es6-shim iterator_'] !== 'undefined') {
			return iterable['_es6-shim iterator_']();
		}
	};

	if (!$Map && !$Set) {
		// the only language iterables are Array, String, arguments
		// - Safari <= 6.0
		// - Chrome < 38
		// - node < 0.12
		// - FF < 13
		// - IE < 11
		// - Edge < 11

		module.exports = function getIterator(iterable) {
			if (iterable != null) {
				return getNonCollectionIterator(iterable, true);
			}
		};
	} else {
		// either Map or Set are available, but Symbol is not
		// - es6-shim on an ES5 browser
		// - Safari 6.2 (maybe 6.1?)
		// - FF v[13, 36)
		// - IE 11
		// - Edge 11
		// - Safari v[6, 9)

		var isMap = __webpack_require__(/*! is-map */ "./node_modules/is-map/index.js");
		var isSet = __webpack_require__(/*! is-set */ "./node_modules/is-set/index.js");

		// Firefox >= 27, IE 11, Safari 6.2 - 9, Edge 11, es6-shim in older envs, all have forEach
		var $mapForEach = callBound('Map.prototype.forEach', true);
		var $setForEach = callBound('Set.prototype.forEach', true);
		if (typeof process === 'undefined' || !process.versions || !process.versions.node) { // "if is not node"

			// Firefox 17 - 26 has `.iterator()`, whose iterator `.next()` either
			// returns a value, or throws a StopIteration object. These browsers
			// do not have any other mechanism for iteration.
			var $mapIterator = callBound('Map.prototype.iterator', true);
			var $setIterator = callBound('Set.prototype.iterator', true);
			var getStopIterationIterator = function (iterator) {
				var done = false;
				return {
					next: function next() {
						try {
							return {
								done: done,
								value: done ? undefined : iterator.next()
							};
						} catch (e) {
							done = true;
							return {
								done: true,
								value: undefined
							};
						}
					}
				};
			};
		}
		// Firefox 27-35, and some older es6-shim versions, use a string "@@iterator" property
		// this returns a proper iterator object, so we should use it instead of forEach.
		// newer es6-shim versions use a string "_es6-shim iterator_" property.
		var $mapAtAtIterator = callBound('Map.prototype.@@iterator', true) || callBound('Map.prototype._es6-shim iterator_', true);
		var $setAtAtIterator = callBound('Set.prototype.@@iterator', true) || callBound('Set.prototype._es6-shim iterator_', true);

		var getCollectionIterator = function getCollectionIterator(iterable) {
			if (isMap(iterable)) {
				if ($mapIterator) {
					return getStopIterationIterator($mapIterator(iterable));
				}
				if ($mapAtAtIterator) {
					return $mapAtAtIterator(iterable);
				}
				if ($mapForEach) {
					var entries = [];
					$mapForEach(iterable, function (v, k) {
						$arrayPush(entries, [k, v]);
					});
					return getArrayIterator(entries);
				}
			}
			if (isSet(iterable)) {
				if ($setIterator) {
					return getStopIterationIterator($setIterator(iterable));
				}
				if ($setAtAtIterator) {
					return $setAtAtIterator(iterable);
				}
				if ($setForEach) {
					var values = [];
					$setForEach(iterable, function (v) {
						$arrayPush(values, v);
					});
					return getArrayIterator(values);
				}
			}
		};

		module.exports = function getIterator(iterable) {
			return getCollectionIterator(iterable) || getNonCollectionIterator(iterable);
		};
	}
}


/***/ }),

/***/ "./node_modules/iterate-value/index.js":
/*!*********************************************!*\
  !*** ./node_modules/iterate-value/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getIterator = __webpack_require__(/*! es-get-iterator */ "./node_modules/es-get-iterator/index.js");
var $TypeError = TypeError;
var iterate = __webpack_require__(/*! iterate-iterator */ "./node_modules/iterate-iterator/index.js");

module.exports = function iterateValue(iterable) {
	var iterator = getIterator(iterable);
	if (!iterator) {
		throw new $TypeError('non-iterable value provided');
	}
	if (arguments.length > 1) {
		return iterate(iterator, arguments[1]);
	}
	return iterate(iterator);
};


/***/ }),

/***/ "./cloudyman/client/src/content/characters.js":
/*!****************************************************!*\
  !*** ./cloudyman/client/src/content/characters.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const characters = {
  a: {
    sprite: 'ch1',
    msg: 'tell me more'
  },
  b: {
    sprite: 'ch2',
    msg: 'wow dude'
  },
  cloudyman: {
    sprite: 'cloudyman',
    msg: 'its a cloudy night...'
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (characters);

/***/ }),

/***/ "./cloudyman/client/src/content/player.js":
/*!************************************************!*\
  !*** ./cloudyman/client/src/content/player.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _functions_init_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functions/init.js */ "./cloudyman/client/src/functions/init.js");
/* harmony import */ var _talking_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./talking.js */ "./cloudyman/client/src/content/talking.js");



const playerOne = () => {
  const player = _functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].get('playerOne')[0];
  let hasKey = false;
  player.overlaps('key', key => {
    _functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].play('coin');
    _functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].destroy(key);
    hasKey = true;
  });
  player.overlaps('door1', () => {
    if (hasKey) {
      _functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].play('hit');
      _functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].go('two');
    } else {
      (0,_talking_js__WEBPACK_IMPORTED_MODULE_1__.talk)('wherez dey key?');
    }
  });
  let finalDoor = false;
  player.overlaps('finalDoor', () => {
    if (finalDoor) {
      _functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].go('win');
    } else {
      (0,_talking_js__WEBPACK_IMPORTED_MODULE_1__.talk)('did you talk to the Cloudyman?');
    }
  });
  player.overlaps('ch1', ch => {
    _functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].play('aaa');
    (0,_talking_js__WEBPACK_IMPORTED_MODULE_1__.talk)(ch.msg);
  });
  player.overlaps('ch2', ch => {
    _functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].play('haha');
    (0,_talking_js__WEBPACK_IMPORTED_MODULE_1__.talk)(ch.msg);
  });
  player.overlaps('cloudyman', ch => {
    _functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].play('ayy');
    (0,_talking_js__WEBPACK_IMPORTED_MODULE_1__.cloudyTalk)(ch.msg);
    finalDoor = true;
  });
  player.action(() => {
    player.resolve();
  });
  return player;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (playerOne);

/***/ }),

/***/ "./cloudyman/client/src/content/talking.js":
/*!*************************************************!*\
  !*** ./cloudyman/client/src/content/talking.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ifTalking": () => (/* binding */ ifTalking),
/* harmony export */   "talk": () => (/* binding */ talk),
/* harmony export */   "cloudyTalk": () => (/* binding */ cloudyTalk)
/* harmony export */ });
/* harmony import */ var _functions_init_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functions/init.js */ "./cloudyman/client/src/functions/init.js");

let talking = [];
const ifTalking = () => {
  if (talking[0]) {
    for (const t of talking) {
      _functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].destroy(t);
    }

    talking = [];
  }
};
const talk = message => {
  ifTalking();
  talking.push(_functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].add([_functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].text(message, 7, {
    width: 140
  }), _functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].pos(_functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].width() / 2, _functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].height() - 11), _functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].origin('center')]));
};
const cloudyTalk = message => {
  ifTalking();
  talking.push(_functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].add([_functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].text(message), _functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].pos(_functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].width() / 2, 11), _functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].origin('center')]));
};

/***/ }),

/***/ "./cloudyman/client/src/functions/controls.js":
/*!****************************************************!*\
  !*** ./cloudyman/client/src/functions/controls.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _content_player_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../content/player.js */ "./cloudyman/client/src/content/player.js");
/* harmony import */ var _content_talking_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../content/talking.js */ "./cloudyman/client/src/content/talking.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init.js */ "./cloudyman/client/src/functions/init.js");
/* harmony import */ var _zoom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./zoom.js */ "./cloudyman/client/src/functions/zoom.js");





let getMoving = () => {};

let isDown = false;
let direction;
let timer;
let sound = false;

const controls = () => {
  const player = (0,_content_player_js__WEBPACK_IMPORTED_MODULE_0__["default"])();
  const SPEED = 80;
  const directories = {
    left: _init_js__WEBPACK_IMPORTED_MODULE_2__["default"].vec2(-1, 0),
    up: _init_js__WEBPACK_IMPORTED_MODULE_2__["default"].vec2(0, -1),
    right: _init_js__WEBPACK_IMPORTED_MODULE_2__["default"].vec2(1, 0),
    down: _init_js__WEBPACK_IMPORTED_MODULE_2__["default"].vec2(0, 1)
  };
  const directionKeys = Object.keys(directories);

  for (const key of directionKeys) {
    _init_js__WEBPACK_IMPORTED_MODULE_2__["default"].keyPress(key, _content_talking_js__WEBPACK_IMPORTED_MODULE_1__.ifTalking);
    _init_js__WEBPACK_IMPORTED_MODULE_2__["default"].keyDown(key, () => {
      player.move(directories[key].scale(SPEED));
    });
  }

  getMoving = () => {
    (0,_content_talking_js__WEBPACK_IMPORTED_MODULE_1__.ifTalking)();
    timer = setInterval(() => {
      if (isDown) {
        player.move(directories[direction].scale(SPEED));
      }
    }, 15);
  };
};

const playerMove = event => {
  event.preventDefault(); // eslint-disable-next-line no-param-reassign

  event.returnValue = false;

  if (event.type !== 'mouseup' && event.type !== 'touchend' && event.type !== 'touchcancel' && (event.target.id === 'up' || event.target.id === 'right' || event.target.id === 'down' || event.target.id === 'left')) {
    if (event.buttons === 1 || event.buttons === 3 || event.type === 'touchstart' || event.type === 'touchmove') {
      clearInterval(timer);
      isDown = true;
      direction = event.target.id;
      getMoving();
    }
  } else {
    clearInterval(timer);
    isDown = false;
  }
};

const blackScreen = document.querySelector('#blackScreen');
const title = document.querySelector('#title');

const touchStart = () => {
  if (!sound && getComputedStyle(title).opacity === '1') {
    _init_js__WEBPACK_IMPORTED_MODULE_2__["default"].play('coin');
    sound = true;
    document.querySelector('#controls').style.pointerEvents = 'all';
    blackScreen.style.animation = 'fadeOut .4s linear 0s forwards';
    title.style.animation = 'fadeOut .2s linear 0s forwards';
    controls();
  }
};

blackScreen.addEventListener('mousedown', touchStart);
blackScreen.addEventListener('touchstart', touchStart, {
  passive: true
});
title.addEventListener('mousedown', touchStart);
title.addEventListener('touchstart', touchStart, {
  passive: true
});
document.addEventListener('mousedown', playerMove);
document.addEventListener('mouseup', playerMove);
document.addEventListener('mouseover', playerMove);
document.addEventListener('touchstart', playerMove, false, {
  passive: true
});
document.addEventListener('touchend', playerMove, false);
document.addEventListener('touchmove', playerMove, false, {
  passive: true
});
document.addEventListener('touchcancel', playerMove, false);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (controls);

/***/ }),

/***/ "./cloudyman/client/src/functions/init.js":
/*!************************************************!*\
  !*** ./cloudyman/client/src/functions/init.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var kaboom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! kaboom */ "./node_modules/kaboom/dist/kaboom.mjs");

const K = (0,kaboom__WEBPACK_IMPORTED_MODULE_0__["default"])({
  canvas: document.querySelector('#game'),
  clearColor: [0, 0, 0, 1],
  crisp: true,
  fullscreen: false,
  width: 205,
  height: 205,
  scale: 1,
  debug: false,
  global: false,
  plugins: []
});
K.loadRoot('cloudyman/client/public/');
K.loadSprite('ch1', 'assets/sprites/ch1.png');
K.loadSprite('ch2', 'assets/sprites/ch2.png');
K.loadSprite('cloudyman', 'assets/sprites/cloudyman.png');
K.loadSprite('door', 'assets/sprites/door.png');
K.loadSprite('guy', 'assets/sprites/guy.png');
K.loadSprite('key', 'assets/sprites/key.png');
K.loadSprite('steel', 'assets/sprites/steel.png');
K.loadSound('coin', 'assets/sounds/coin.mp3');
K.loadSound('hit', 'assets/sounds/hit.mp3');
K.loadSound('ayy', 'assets/sounds/ayy.mp3');
K.loadSound('mmm', 'assets/sounds/mmm.mp3');
K.loadSound('haha', 'assets/sounds/haha.mp3');
K.loadSound('aaa', 'assets/sounds/aaa.mp3');
K.loadSound('priorities', 'assets/sounds/priorities.mp3');
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (K);

/***/ }),

/***/ "./cloudyman/client/src/functions/zoom.js":
/*!************************************************!*\
  !*** ./cloudyman/client/src/functions/zoom.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
let isZoomed = false;

const zoom = () => {
  if (!isZoomed) {
    document.querySelector('#body').style.justifyContent = 'flex-start';
    document.querySelector('#app').style.justifyContent = 'flex-start';
    document.querySelector('#app').style.height = '190%';
    document.querySelector('#zoom').style.visibility = 'visible';
    document.querySelector('#title').style.transform = 'scale(2.1)';
    document.querySelector('#background').style.maxWidth = 'none';
    isZoomed = true;
  } else {
    document.querySelector('#body').style.justifyContent = 'center';
    document.querySelector('#app').style.justifyContent = 'center';
    document.querySelector('#app').style.height = '100%';
    document.querySelector('#zoom').style.visibility = '';
    document.querySelector('#title').style.transform = 'scale(1)';
    document.querySelector('#background').style.maxWidth = '100%';
    isZoomed = false;
  }
};

document.querySelector('#zoom').addEventListener('click', zoom);

if (document.addEventListener) {
  document.addEventListener('contextmenu', event_ => {
    if (window.getComputedStyle(document.querySelector('#zoom')).visibility === 'visible') {
      zoom();
    }

    event_.preventDefault();
  }, false);
} else {
  document.attachEvent('oncontextmenu', () => {
    if (window.getComputedStyle(document.querySelector('#zoom')).visibility === 'visible') {
      zoom();
    }

    window.event.returnValue = false;
  });
}

/***/ }),

/***/ "./cloudyman/client/src/scenes/one.js":
/*!********************************************!*\
  !*** ./cloudyman/client/src/scenes/one.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _content_characters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../content/characters.js */ "./cloudyman/client/src/content/characters.js");
/* harmony import */ var _functions_init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../functions/init.js */ "./cloudyman/client/src/functions/init.js");



const one = () => {
  const level = ['=======|=======', '=     = =   =$=', '= a   = = a = =', '=     = =   = =', '=             =', '=    ==========', '= b           =', '===========a  =', '=          =  =', '=  ======  =  =', '=  =b   =  =  =', '=  =  = =  =  =', '=  =  = =  =  =', '=     =@=     =', '==============='];
  _functions_init_js__WEBPACK_IMPORTED_MODULE_1__["default"].addLevel(level, {
    width: 11,
    height: 11,
    pos: _functions_init_js__WEBPACK_IMPORTED_MODULE_1__["default"].vec2(20, 20),
    '=': [_functions_init_js__WEBPACK_IMPORTED_MODULE_1__["default"].sprite('steel'), _functions_init_js__WEBPACK_IMPORTED_MODULE_1__["default"].solid()],
    $: [_functions_init_js__WEBPACK_IMPORTED_MODULE_1__["default"].sprite('key'), 'key'],
    '@': [_functions_init_js__WEBPACK_IMPORTED_MODULE_1__["default"].sprite('guy'), 'playerOne'],
    '|': [_functions_init_js__WEBPACK_IMPORTED_MODULE_1__["default"].sprite('door'), _functions_init_js__WEBPACK_IMPORTED_MODULE_1__["default"].solid(), 'door1'],

    any(ch) {
      const char = _content_characters_js__WEBPACK_IMPORTED_MODULE_0__["default"][ch];

      if (char) {
        return [_functions_init_js__WEBPACK_IMPORTED_MODULE_1__["default"].sprite(char.sprite), _functions_init_js__WEBPACK_IMPORTED_MODULE_1__["default"].solid(), char.sprite, {
          msg: char.msg
        }];
      }

      return char;
    }

  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (one);

/***/ }),

/***/ "./cloudyman/client/src/scenes/two.js":
/*!********************************************!*\
  !*** ./cloudyman/client/src/scenes/two.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _content_characters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../content/characters.js */ "./cloudyman/client/src/content/characters.js");
/* harmony import */ var _functions_controls_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../functions/controls.js */ "./cloudyman/client/src/functions/controls.js");
/* harmony import */ var _functions_init_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../functions/init.js */ "./cloudyman/client/src/functions/init.js");
/* eslint-disable sonarjs/no-duplicate-string */




const two = () => {
  const level = ['=======F=======', '=             =', '=             =', '=     !       =', '=             =', '=             =', '=             =', '=             =', '=             =', '=             =', '=             =', '=             =', '=             =', '=      @      =', '==============='];
  _functions_init_js__WEBPACK_IMPORTED_MODULE_2__["default"].addLevel(level, {
    width: 11,
    height: 11,
    pos: _functions_init_js__WEBPACK_IMPORTED_MODULE_2__["default"].vec2(20, 20),
    '=': [_functions_init_js__WEBPACK_IMPORTED_MODULE_2__["default"].sprite('steel'), _functions_init_js__WEBPACK_IMPORTED_MODULE_2__["default"].solid()],
    '@': [_functions_init_js__WEBPACK_IMPORTED_MODULE_2__["default"].sprite('guy'), 'playerOne'],
    '!': [_functions_init_js__WEBPACK_IMPORTED_MODULE_2__["default"].sprite(_content_characters_js__WEBPACK_IMPORTED_MODULE_0__["default"].cloudyman.sprite), _functions_init_js__WEBPACK_IMPORTED_MODULE_2__["default"].solid(), _content_characters_js__WEBPACK_IMPORTED_MODULE_0__["default"].cloudyman.sprite, {
      msg: _content_characters_js__WEBPACK_IMPORTED_MODULE_0__["default"].cloudyman.msg
    }],
    F: [_functions_init_js__WEBPACK_IMPORTED_MODULE_2__["default"].sprite('door'), _functions_init_js__WEBPACK_IMPORTED_MODULE_2__["default"].solid(), 'finalDoor']
  });
  (0,_functions_controls_js__WEBPACK_IMPORTED_MODULE_1__["default"])();
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (two);

/***/ }),

/***/ "./cloudyman/client/src/scenes/win.js":
/*!********************************************!*\
  !*** ./cloudyman/client/src/scenes/win.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _functions_init_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functions/init.js */ "./cloudyman/client/src/functions/init.js");


const win = () => {
  _functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].play('priorities');
  _functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].add([_functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].text('you win!'), _functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].pos(_functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].width() / 2, _functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].height() / 2), _functions_init_js__WEBPACK_IMPORTED_MODULE_0__["default"].origin('center')]);
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (win);

/***/ }),

/***/ "./node_modules/kaboom/dist/kaboom.mjs":
/*!*********************************************!*\
  !*** ./node_modules/kaboom/dist/kaboom.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var Je=Object.defineProperty,Qt=Object.defineProperties;var Jt=Object.getOwnPropertyDescriptors;var et=Object.getOwnPropertySymbols;var en=Object.prototype.hasOwnProperty,tn=Object.prototype.propertyIsEnumerable;var tt=(t,e,o)=>e in t?Je(t,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):t[e]=o,le=(t,e)=>{for(var o in e||(e={}))en.call(e,o)&&tt(t,o,e[o]);if(et)for(var o of et(e))tn.call(e,o)&&tt(t,o,e[o]);return t},we=(t,e)=>Qt(t,Jt(e));var r=(t,e)=>Je(t,"name",{value:e,configurable:!0});var fe=(t,e)=>()=>(t&&(e=t(t=0)),e),nn=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports);function nt(t){return t*Math.PI/180}function rt(t){return t*180/Math.PI}function ae(t,e,o){return e>o?ae(t,o,e):Math.min(Math.max(t,e),o)}function De(t,e,o){return t+(e-t)*o}function ve(t,e,o,i,m){return i+(t-e)/(o-e)*(m-i)}function st(t,e,o,i,m){return ae(ve(t,e,o,i,m),i,m)}function f(...t){if(t.length===0)return f(0,0);if(t.length===1){if(typeof t[0]=="number")return f(t[0],t[0]);if(Re(t[0]))return f(t[0].x,t[0].y);if(Array.isArray(t[0])&&t[0].length===2)return f.apply(null,t[0])}return{x:t[0],y:t[1],clone(){return f(this.x,this.y)},add(...e){let o=f(...e);return f(this.x+o.x,this.y+o.y)},sub(...e){let o=f(...e);return f(this.x-o.x,this.y-o.y)},scale(e){return f(this.x*e,this.y*e)},dist(...e){let o=f(...e);return Math.sqrt((this.x-o.x)*(this.x-o.x)+(this.y-o.y)*(this.y-o.y))},len(){return this.dist(f(0,0))},unit(){return this.scale(1/this.len())},normal(){return f(this.y,-this.x)},dot(...e){let o=f(...e);return f(this.x*o.x,this.y*o.y)},angle(...e){let o=f(...e);return Math.atan2(this.y-o.y,this.x-o.x)},lerp(e,o){return f(De(this.x,e.x,o),De(this.y,e.y,o))},eq(e){return this.x===e.x&&this.y===e.y},str(){return`(${this.x}, ${this.y})`}}}function ot(t){return f(Math.cos(t),Math.sin(t))}function Te(t,e,o){return{x:t,y:e,z:o,xy(){return f(this.x,this.y)}}}function Re(t){return t!==void 0&&t.x!==void 0&&t.y!==void 0}function it(t){return t!==void 0&&t.x!==void 0&&t.y!==void 0&&t.z!==void 0}function ye(t){return t!==void 0&&t.r!==void 0&&t.g!==void 0&&t.b!==void 0&&t.a!==void 0}function at(t){if(t!==void 0&&Array.isArray(t.m)&&t.m.length===16)return t}function Ve(...t){if(t.length===0)return Y();if(t.length===1){if(ye(t[0]))return Y(t[0]);if(Array.isArray(t[0])&&t[0].length===3)return Ve.apply(null,t[0])}return Y(t[0],t[1],t[2],1)}function Y(...t){var e;if(t.length===0)return Y(1,1,1,1);if(t.length===1){if(ye(t[0]))return Y(t[0].r,t[0].g,t[0].b,t[0].a);if(Array.isArray(t[0])&&t[0].length===4)return Y.apply(null,t[0])}return{r:t[0],g:t[1],b:t[2],a:(e=t[3])!=null?e:1,clone(){return Y(this.r,this.g,this.b,this.a)},lighten(o){return Y(this.r+o,this.g+o,this.b+o,this.a)},darken(o){return this.lighten(-o)},invert(){return Y(1-this.r,1-this.g,1-this.b,this.a)},isDark(o=.5){return this.r+this.g+this.b<3*o},isLight(o=.5){return this.r+this.g+this.b>3*o},eq(o){return this.r===o.r&&this.g===o.g&&this.b===o.g&&this.a===o.a}}}function oe(t,e,o,i){return{x:t,y:e,w:o,h:i,clone(){return oe(this.x,this.y,this.w,this.h)},eq(m){return this.x===m.x&&this.y===m.y&&this.w===m.w&&this.h===m.h}}}function ee(t){return{m:t?[...t]:[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],clone(){return ee(this.m)},mult(e){let o=[];for(let i=0;i<4;i++)for(let m=0;m<4;m++)o[i*4+m]=this.m[0*4+m]*e.m[i*4+0]+this.m[1*4+m]*e.m[i*4+1]+this.m[2*4+m]*e.m[i*4+2]+this.m[3*4+m]*e.m[i*4+3];return ee(o)},multVec4(e){return{x:e.x*this.m[0]+e.y*this.m[4]+e.z*this.m[8]+e.w*this.m[12],y:e.x*this.m[1]+e.y*this.m[5]+e.z*this.m[9]+e.w*this.m[13],z:e.x*this.m[2]+e.y*this.m[6]+e.z*this.m[10]+e.w*this.m[14],w:e.x*this.m[3]+e.y*this.m[7]+e.z*this.m[11]+e.w*this.m[15]}},multVec3(e){let o=this.multVec4({x:e.x,y:e.y,z:e.z,w:1});return Te(o.x,o.y,o.z)},multVec2(e){return f(e.x*this.m[0]+e.y*this.m[4]+0*this.m[8]+1*this.m[12],e.x*this.m[1]+e.y*this.m[5]+0*this.m[9]+1*this.m[13])},translate(e){return this.mult(ee([1,0,0,0,0,1,0,0,0,0,1,0,e.x,e.y,0,1]))},scale(e){return this.mult(ee([e.x,0,0,0,0,e.y,0,0,0,0,1,0,0,0,0,1]))},rotateX(e){return this.mult(ee([1,0,0,0,0,Math.cos(e),-Math.sin(e),0,0,Math.sin(e),Math.cos(e),0,0,0,0,1]))},rotateY(e){return this.mult(ee([Math.cos(e),0,-Math.sin(e),0,0,1,0,0,Math.sin(e),0,Math.cos(e),0,0,0,0,1]))},rotateZ(e){return this.mult(ee([Math.cos(e),-Math.sin(e),0,0,Math.sin(e),Math.cos(e),0,0,0,0,1,0,0,0,0,1]))},invert(){let e=[],o=this.m[10]*this.m[15]-this.m[14]*this.m[11],i=this.m[9]*this.m[15]-this.m[13]*this.m[11],m=this.m[9]*this.m[14]-this.m[13]*this.m[10],v=this.m[8]*this.m[15]-this.m[12]*this.m[11],A=this.m[8]*this.m[14]-this.m[12]*this.m[10],R=this.m[8]*this.m[13]-this.m[12]*this.m[9],$=this.m[6]*this.m[15]-this.m[14]*this.m[7],k=this.m[5]*this.m[15]-this.m[13]*this.m[7],I=this.m[5]*this.m[14]-this.m[13]*this.m[6],j=this.m[4]*this.m[15]-this.m[12]*this.m[7],T=this.m[4]*this.m[14]-this.m[12]*this.m[6],w=this.m[5]*this.m[15]-this.m[13]*this.m[7],S=this.m[4]*this.m[13]-this.m[12]*this.m[5],U=this.m[6]*this.m[11]-this.m[10]*this.m[7],B=this.m[5]*this.m[11]-this.m[9]*this.m[7],_=this.m[5]*this.m[10]-this.m[9]*this.m[6],G=this.m[4]*this.m[11]-this.m[8]*this.m[7],y=this.m[4]*this.m[10]-this.m[8]*this.m[6],H=this.m[4]*this.m[9]-this.m[8]*this.m[5];e[0]=this.m[5]*o-this.m[6]*i+this.m[7]*m,e[4]=-(this.m[4]*o-this.m[6]*v+this.m[7]*A),e[8]=this.m[4]*i-this.m[5]*v+this.m[7]*R,e[12]=-(this.m[4]*m-this.m[5]*A+this.m[6]*R),e[1]=-(this.m[1]*o-this.m[2]*i+this.m[3]*m),e[5]=this.m[0]*o-this.m[2]*v+this.m[3]*A,e[9]=-(this.m[0]*i-this.m[1]*v+this.m[3]*R),e[13]=this.m[0]*m-this.m[1]*A+this.m[2]*R,e[2]=this.m[1]*$-this.m[2]*k+this.m[3]*I,e[6]=-(this.m[0]*$-this.m[2]*j+this.m[3]*T),e[10]=this.m[0]*w-this.m[1]*j+this.m[3]*S,e[14]=-(this.m[0]*I-this.m[1]*T+this.m[2]*S),e[3]=-(this.m[1]*U-this.m[2]*B+this.m[3]*_),e[7]=this.m[0]*U-this.m[2]*G+this.m[3]*y,e[11]=-(this.m[0]*B-this.m[1]*G+this.m[3]*H),e[15]=this.m[0]*_-this.m[1]*y+this.m[2]*H;let M=this.m[0]*e[0]+this.m[1]*e[4]+this.m[2]*e[8]+this.m[3]*e[12];for(let q=0;q<4;q++)for(let J=0;J<4;J++)e[q*4+J]*=1/M;return ee(e)}}}function ut(t,e,o){return t+(Math.sin(o)+1)/2*(e-t)}function Xe(t){return{seed:t,gen(...e){if(e.length===0)return this.seed=(rn*this.seed+sn)%ct,this.seed/ct;if(e.length===1){if(typeof e[0]=="number")return this.gen(0,e[0]);if(Re(e[0]))return this.gen(f(0,0),e[0]);if(ye(e[0]))return this.gen(Y(0,0,0,0),e[0])}else if(e.length===2){if(typeof e[0]=="number"&&typeof e[1]=="number")return this.gen()*(e[1]-e[0])+e[0];if(Re(e[0])&&Re(e[1]))return f(this.gen(e[0].x,e[1].x),this.gen(e[0].y,e[1].y));if(ye(e[0])&&ye(e[1]))return Y(this.gen(e[0].r,e[1].r),this.gen(e[0].g,e[1].g),this.gen(e[0].b,e[1].b),this.gen(e[0].a,e[1].a))}}}}function ft(t){dt.seed=t}function Pe(...t){return dt.gen(...t)}function ht(t){return Pe()<=t}function mt(t){return t[Math.floor(Pe(t.length))]}function Ye(t,e){return t.p2.x>=e.p1.x&&t.p1.x<=e.p2.x&&t.p2.y>=e.p1.y&&t.p1.y<=e.p2.y}function lt(t,e){return t.p2.x>e.p1.x&&t.p1.x<e.p2.x&&t.p2.y>e.p1.y&&t.p1.y<e.p2.y}function pt(t,e){return e.x>=t.p1.x&&e.x<=t.p2.x&&e.y>=t.p1.y&&e.y<t.p2.y}var rn,sn,ct,dt,xe=fe(()=>{r(nt,"deg2rad");r(rt,"rad2deg");r(ae,"clamp");r(De,"lerp");r(ve,"map");r(st,"mapc");r(f,"vec2");r(ot,"vec2FromAngle");r(Te,"vec3");r(Re,"isVec2");r(it,"isVec3");r(ye,"isColor");r(at,"isMat4");r(Ve,"rgb");r(Y,"rgba");r(oe,"quad");r(ee,"mat4");r(ut,"wave");rn=1103515245,sn=12345,ct=2147483648,dt=Xe(Date.now());r(Xe,"makeRng");r(ft,"randSeed");r(Pe,"rand");r(ht,"chance");r(mt,"choose");r(Ye,"colRectRect");r(lt,"overlapRectRect");r(pt,"colRectPt")});function $e(t,e){let o=typeof t,i=typeof e;if(o!==i)return!1;if(o==="object"&&i==="object"){let m=Object.keys(t),v=Object.keys(e);if(m.length!==v.length)return!1;for(let A of m){let R=t[A],$=e[A];if(!(typeof R=="function"&&typeof $=="function")&&!$e(R,$))return!1}return!0}return t===e}var bt=fe(()=>{r($e,"deepEq")});function Le(t){switch(t){case"topleft":return f(-1,-1);case"top":return f(0,-1);case"topright":return f(1,-1);case"left":return f(-1,0);case"center":return f(0,0);case"right":return f(1,0);case"botleft":return f(-1,1);case"bot":return f(0,1);case"botright":return f(1,1);default:return t}}function xt(t,e){let o=(()=>{switch(e.texFilter){case"linear":return t.LINEAR;case"nearest":return t.NEAREST;default:return t.NEAREST}})(),i=(()=>{var K;let h=A(We,Ke),x=v(new ImageData(new Uint8ClampedArray([255,255,255,255]),1,1)),b=(K=e.clearColor)!=null?K:Y(0,0,0,1);t.clearColor(b.r,b.g,b.b,b.a),t.enable(t.BLEND),t.blendFuncSeparate(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_SRC_ALPHA);let L=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,L),t.bufferData(t.ARRAY_BUFFER,Ne*4,t.DYNAMIC_DRAW),t.bindBuffer(t.ARRAY_BUFFER,null);let z=t.createBuffer();t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,z),t.bufferData(t.ELEMENT_ARRAY_BUFFER,Ne*2,t.DYNAMIC_DRAW),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null);let V=v(new ImageData(new Uint8ClampedArray([128,128,128,255,190,190,190,255,190,190,190,255,128,128,128,255]),2,2));return{drawCalls:0,lastDrawCalls:0,defProg:h,curProg:h,defTex:x,curTex:x,curUniform:{},vbuf:L,ibuf:z,vqueue:[],iqueue:[],transform:ee(),transformStack:[],clearColor:b,bgTex:V}})();I(),j();function m(h){return Math.log(h)/Math.log(2)%1==0}r(m,"powerOfTwo");function v(h){let x=t.createTexture();t.bindTexture(t.TEXTURE_2D,x),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,h),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,o),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,o);let b=(()=>m(h.width)&&m(h.height)?t.REPEAT:t.CLAMP_TO_EDGE)();return t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,b),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,b),t.bindTexture(t.TEXTURE_2D,null),{width:h.width,height:h.height,bind(){t.bindTexture(t.TEXTURE_2D,x)},unbind(){t.bindTexture(t.TEXTURE_2D,null)}}}r(v,"makeTex");function A(h=We,x=Ke){let b,L=on.replace("{{user}}",h!=null?h:We),z=an.replace("{{user}}",x!=null?x:Ke),V=t.createShader(t.VERTEX_SHADER),K=t.createShader(t.FRAGMENT_SHADER);if(t.shaderSource(V,L),t.shaderSource(K,z),t.compileShader(V),t.compileShader(K),b=t.getShaderInfoLog(V))throw new Error(b);if(b=t.getShaderInfoLog(K))throw new Error(b);let C=t.createProgram();if(t.attachShader(C,V),t.attachShader(C,K),t.bindAttribLocation(C,0,"a_pos"),t.bindAttribLocation(C,1,"a_uv"),t.bindAttribLocation(C,2,"a_color"),t.linkProgram(C),(b=t.getProgramInfoLog(C))&&b!==`
`)throw new Error(b);return{bind(){t.useProgram(C)},unbind(){t.useProgram(null)},bindAttribs(){t.vertexAttribPointer(0,3,t.FLOAT,!1,Ie*4,0),t.enableVertexAttribArray(0),t.vertexAttribPointer(1,2,t.FLOAT,!1,Ie*4,12),t.enableVertexAttribArray(1),t.vertexAttribPointer(2,4,t.FLOAT,!1,Ie*4,20),t.enableVertexAttribArray(2)},send(P){this.bind();for(let X in P){let F=P[X],Z=t.getUniformLocation(C,X);typeof F=="number"?t.uniform1f(Z,F):at(F)?t.uniformMatrix4fv(Z,!1,new Float32Array(F.m)):ye(F)?t.uniform4f(Z,F.r,F.g,F.b,F.a):it(F)?t.uniform3f(Z,F.x,F.y,F.z):Re(F)&&t.uniform2f(Z,F.x,F.y)}this.unbind()}}}r(A,"makeProgram");function R(h,x,b,L){let z=h.width/x,V=h.height/b,K=1/z,C=1/V,P={},X=L.split("").entries();for(let[F,Z]of X)P[Z]=f(F%z*K,Math.floor(F/z)*C);return{tex:h,map:P,qw:K,qh:C}}r(R,"makeFont");function $(h,x,b=i.defTex,L=i.defProg,z={}){b=b!=null?b:i.defTex,L=L!=null?L:i.defProg,(b!==i.curTex||L!==i.curProg||!$e(i.curUniform,z)||i.vqueue.length+h.length*Ie>Ne||i.iqueue.length+x.length>Ne)&&k(),i.curTex=b,i.curProg=L,i.curUniform=z;let V=x.map(C=>C+i.vqueue.length/Ie),K=h.map(C=>{let P=w(i.transform.multVec2(C.pos.xy()));return[P.x,P.y,C.pos.z,C.uv.x,C.uv.y,C.color.r,C.color.g,C.color.b,C.color.a]}).flat();V.forEach(C=>i.iqueue.push(C)),K.forEach(C=>i.vqueue.push(C))}r($,"drawRaw");function k(){!i.curTex||!i.curProg||i.vqueue.length===0||i.iqueue.length===0||(i.curProg.send(i.curUniform),t.bindBuffer(t.ARRAY_BUFFER,i.vbuf),t.bufferSubData(t.ARRAY_BUFFER,0,new Float32Array(i.vqueue)),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,i.ibuf),t.bufferSubData(t.ELEMENT_ARRAY_BUFFER,0,new Uint16Array(i.iqueue)),i.curProg.bind(),i.curProg.bindAttribs(),i.curTex.bind(),t.drawElements(t.TRIANGLES,i.iqueue.length,t.UNSIGNED_SHORT,0),i.curTex.unbind(),i.curProg.unbind(),t.bindBuffer(t.ARRAY_BUFFER,null),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),i.iqueue=[],i.vqueue=[],i.drawCalls++)}r(k,"flush");function I(){t.clear(t.COLOR_BUFFER_BIT),e.clearColor||q({width:he(),height:pe(),quad:oe(0,0,he()*be()/yt,pe()*be()/yt),tex:i.bgTex}),i.drawCalls=0,i.transformStack=[],i.transform=ee()}r(I,"frameStart");function j(){k(),i.lastDrawCalls=i.drawCalls}r(j,"frameEnd");function T(){return i.lastDrawCalls}r(T,"drawCalls");function w(h){return f(h.x/he()*2-1,-h.y/pe()*2+1)}r(w,"toNDC");function S(h){i.transform=h.clone()}r(S,"pushMatrix");function U(h){!h||h.x===0&&h.y===0||(i.transform=i.transform.translate(h))}r(U,"pushTranslate");function B(h){!h||h.x===1&&h.y===1||(i.transform=i.transform.scale(h))}r(B,"pushScale");function _(h){!h||(i.transform=i.transform.rotateX(h))}r(_,"pushRotateX");function G(h){!h||(i.transform=i.transform.rotateY(h))}r(G,"pushRotateY");function y(h){!h||(i.transform=i.transform.rotateZ(h))}r(y,"pushRotateZ");function H(){i.transformStack.push(i.transform.clone())}r(H,"pushTransform");function M(){i.transformStack.length>0&&(i.transform=i.transformStack.pop())}r(M,"popTransform");function q(h={}){var Z,re;let x=h.width||0,b=h.height||0,L=h.pos||f(0,0),V=Le(h.origin||He).dot(f(x,b).scale(-.5)),K=f((Z=h.scale)!=null?Z:1),C=h.rot||0,P=h.quad||oe(0,0,1,1),X=1-((re=h.z)!=null?re:0),F=h.color||Y(1,1,1,1);H(),U(L),B(K),y(C),U(V),$([{pos:Te(-x/2,b/2,X),uv:f(P.x,P.y+P.h),color:F},{pos:Te(-x/2,-b/2,X),uv:f(P.x,P.y),color:F},{pos:Te(x/2,-b/2,X),uv:f(P.x+P.w,P.y),color:F},{pos:Te(x/2,b/2,X),uv:f(P.x+P.w,P.y+P.h),color:F}],[0,1,3,1,2,3],h.tex,h.prog,h.uniform),M()}r(q,"drawQuad");function J(h,x={}){var V;let b=(V=x.quad)!=null?V:oe(0,0,1,1),L=h.width*b.w,z=h.height*b.h;q(we(le({},x),{tex:h,quad:b,width:L,height:z}))}r(J,"drawTexture");function E(h,x,b,L={}){q(we(le({},L),{pos:h,width:x,height:b}))}r(E,"drawRect");function O(h,x,b,L={}){let z=Le(L.origin||He).dot(f(x,b)).scale(.5),V=h.add(f(-x/2,-b/2)).sub(z),K=h.add(f(-x/2,b/2)).sub(z),C=h.add(f(x/2,b/2)).sub(z),P=h.add(f(x/2,-b/2)).sub(z);te(V,K,L),te(K,C,L),te(C,P,L),te(P,V,L)}r(O,"drawRectStroke");function te(h,x,b={}){let L=b.width||1,z=h.dist(x),V=Math.PI/2-h.angle(x);q(we(le({},b),{pos:h.add(x).scale(.5),width:L,height:z,rot:V,origin:"center"}))}r(te,"drawLine");function ne(h,x,b={}){let L=(h+"").split(""),z=x.qw*x.tex.width,V=x.qh*x.tex.height,K=b.size||V,C=f(K/V).dot(f(b.scale||1)),P=C.x*z,X=C.y*V,F=0,Z=X,re=0,ge=[[]];for(let ie of L)(ie===`
`||(b.width?F+P>b.width:!1))&&(Z+=X,F=0,ge.push([])),ie!==`
`&&(ge[ge.length-1].push(ie),F+=P),re=Math.max(re,F);b.width&&(re=b.width);let Fe=[],Ge=f(b.pos||0),se=Le(b.origin||He).scale(.5),me=-se.x*P-(se.x+.5)*(re-P),Ce=-se.y*X-(se.y+.5)*(Z-X);return ge.forEach((ie,Ue)=>{let Me=(re-ie.length*P)*(se.x+.5);ie.forEach((Ae,Be)=>{let _e=x.map[Ae],je=Be*P,qe=Ue*X;_e&&Fe.push({tex:x.tex,quad:oe(_e.x,_e.y,x.qw,x.qh),ch:Ae,pos:f(Ge.x+je+me+Me,Ge.y+qe+Ce),color:b.color,origin:b.origin,scale:C,z:b.z})})}),{width:re,height:Z,chars:Fe}}r(ne,"fmtText");function ue(h,x,b={}){ce(ne(h,x,b))}r(ue,"drawText");function ce(h){for(let x of h.chars)q({tex:x.tex,width:x.tex.width*x.quad.w,height:x.tex.height*x.quad.h,pos:x.pos,scale:x.scale,color:x.color,quad:x.quad,origin:"center",z:x.z})}r(ce,"drawFmtText");function he(){return t.drawingBufferWidth/be()}r(he,"width");function pe(){return t.drawingBufferHeight/be()}r(pe,"height");function be(){var h;return(h=e.scale)!=null?h:1}r(be,"scale");function Ee(){return i.clearColor.clone()}return r(Ee,"clearColor"),{width:he,height:pe,scale:be,makeTex:v,makeProgram:A,makeFont:R,drawTexture:J,drawText:ue,drawFmtText:ce,drawRect:E,drawRectStroke:O,drawLine:te,fmtText:ne,frameStart:I,frameEnd:j,pushTransform:H,popTransform:M,pushMatrix:S,drawCalls:T,clearColor:Ee}}var He,Ie,Ne,yt,on,an,We,Ke,gt=fe(()=>{xe();bt();He="topleft",Ie=9,Ne=65536,yt=64,on=`
attribute vec3 a_pos;
attribute vec2 a_uv;
attribute vec4 a_color;

varying vec3 v_pos;
varying vec2 v_uv;
varying vec4 v_color;

vec4 def_vert() {
	return vec4(a_pos, 1.0);
}

{{user}}

void main() {
	vec4 pos = vert(a_pos, a_uv, a_color);
	v_pos = a_pos;
	v_uv = a_uv;
	v_color = a_color;
	gl_Position = pos;
}
`,an=`
precision mediump float;

varying vec3 v_pos;
varying vec2 v_uv;
varying vec4 v_color;

uniform sampler2D u_tex;

vec4 def_frag() {
	return v_color * texture2D(u_tex, v_uv);
}

{{user}}

void main() {
	gl_FragColor = frag(v_pos, v_uv, v_color, u_tex);
	if (gl_FragColor.a == 0.0) {
		discard;
	}
}
`,We=`
vec4 vert(vec3 pos, vec2 uv, vec4 color) {
	return def_vert();
}
`,Ke=`
vec4 frag(vec3 pos, vec2 uv, vec4 color, sampler2D tex) {
	return def_frag();
}
`;r(Le,"originPt");r(xt,"gfxInit")});function wt(t){return t==="pressed"||t==="rpressed"?"down":t==="released"?"up":t}function vt(t={}){var q,J;let e={canvas:(q=t.canvas)!=null?q:(()=>{var O;let E=document.createElement("canvas");return((O=t.root)!=null?O:document.body).appendChild(E),E})(),keyStates:{},charInputted:[],mouseState:"up",mousePos:f(0,0),time:0,realTime:0,skipTime:!1,dt:0,scale:(J=t.scale)!=null?J:1,isTouch:!1,loopID:null,stopped:!1,fps:0,fpsBuf:[],fpsTimer:0},o={ArrowLeft:"left",ArrowRight:"right",ArrowUp:"up",ArrowDown:"down"," ":"space"},i=["space","left","right","up","down","tab","f1","f2","f3","f4","f5","f6","f7","f8","f9","f10","f11"];t.fullscreen?(e.canvas.width=window.innerWidth,e.canvas.height=window.innerHeight):(e.canvas.width=(t.width||640)*e.scale,e.canvas.height=(t.height||480)*e.scale);let m=["outline: none","cursor: default"];t.crisp&&(m.push("image-rendering: pixelated"),m.push("image-rendering: crisp-edges")),e.canvas.style=m.join(";"),e.canvas.setAttribute("tabindex","0");let v=e.canvas.getContext("webgl",{antialias:!0,depth:!0,stencil:!0,alpha:!0,preserveDrawingBuffer:!0});e.isTouch="ontouchstart"in window||navigator.maxTouchPoints>0||navigator.msMaxTouchPoints>0,e.canvas.addEventListener("mousemove",E=>{e.mousePos=f(E.offsetX,E.offsetY).scale(1/e.scale)}),e.canvas.addEventListener("mousedown",()=>{e.mouseState="pressed"}),e.canvas.addEventListener("mouseup",()=>{e.mouseState="released"}),e.canvas.addEventListener("touchstart",E=>{let O=E.touches[0];e.mousePos=f(O.clientX,O.clientY).scale(1/e.scale),e.mouseState="pressed"}),e.canvas.addEventListener("touchmove",E=>{let O=E.touches[0];e.mousePos=f(O.clientX,O.clientY).scale(1/e.scale)}),e.canvas.addEventListener("keydown",E=>{let O=o[E.key]||E.key.toLowerCase();i.includes(O)&&E.preventDefault(),O.length===1&&e.charInputted.push(O),O==="space"&&e.charInputted.push(" "),E.repeat?e.keyStates[O]="rpressed":e.keyStates[O]="pressed"}),e.canvas.addEventListener("keyup",E=>{let O=o[E.key]||E.key.toLowerCase();e.keyStates[O]="released"}),e.canvas.focus(),document.addEventListener("visibilitychange",()=>{switch(document.visibilityState){case"visible":e.skipTime=!0;break;case"hidden":break}});function A(){return e.mousePos.clone()}r(A,"mousePos");function R(){return e.mouseState==="pressed"}r(R,"mouseClicked");function $(){return e.mouseState==="pressed"||e.mouseState==="down"}r($,"mouseDown");function k(){return e.mouseState==="released"}r(k,"mouseReleased");function I(E){return e.keyStates[E]==="pressed"}r(I,"keyPressed");function j(E){return e.keyStates[E]==="pressed"||e.keyStates[E]==="rpressed"}r(j,"keyPressedRep");function T(E){return e.keyStates[E]==="pressed"||e.keyStates[E]==="rpressed"||e.keyStates[E]==="down"}r(T,"keyDown");function w(E){return e.keyStates[E]==="released"}r(w,"keyReleased");function S(){return[...e.charInputted]}r(S,"charInputted");function U(){return e.dt}r(U,"dt");function B(){return e.time}r(B,"time");function _(){return e.fps}r(_,"fps");function G(){return e.canvas.toDataURL()}r(G,"screenshot");function y(E){return E&&(e.canvas.style.cursor=E!=null?E:"default"),e.canvas.style.cursor}r(y,"cursor");function H(E){let O=r(te=>{let ne=te/1e3,ue=ne-e.realTime;e.realTime=ne,e.skipTime||(e.dt=ue,e.time+=e.dt,e.fpsBuf.push(1/e.dt),e.fpsTimer+=e.dt,e.fpsTimer>=1&&(e.fpsTimer=0,e.fps=Math.round(e.fpsBuf.reduce((ce,he)=>ce+he)/e.fpsBuf.length),e.fpsBuf=[])),e.skipTime=!1,E();for(let ce in e.keyStates)e.keyStates[ce]=wt(e.keyStates[ce]);e.mouseState=wt(e.mouseState),e.charInputted=[],e.stopped||(e.loopID=requestAnimationFrame(O))},"frame");e.loopID=requestAnimationFrame(O)}r(H,"run");function M(){cancelAnimationFrame(e.loopID),e.stopped=!0}return r(M,"quit"),{gl:v,mousePos:A,keyDown:T,keyPressed:I,keyPressedRep:j,keyReleased:w,mouseDown:$,mouseClicked:R,mouseReleased:k,charInputted:S,cursor:y,dt:U,time:B,fps:_,screenshot:G,run:H,quit:M}}var Rt=fe(()=>{xe();r(wt,"processBtnState");r(vt,"appInit")});function Et(){let t=(()=>{let m=new(window.AudioContext||window.webkitAudioContext),v=m.createGain(),A=v;return A.connect(m.destination),{ctx:m,gainNode:v,masterNode:A}})();function e(m){return m!==void 0&&(t.gainNode.gain.value=ae(m,Tt,St)),t.gainNode.gain.value}r(e,"volume");function o(m,v={loop:!1,volume:1,speed:1,detune:0,seek:0}){var w;let A=!1,R=t.ctx.createBufferSource();R.buffer=m,R.loop=!!v.loop;let $=t.ctx.createGain();R.connect($),$.connect(t.masterNode);let k=(w=v.seek)!=null?w:0;R.start(0,k);let I=t.ctx.currentTime-k,j=null,T={stop(){A||(this.pause(),I=t.ctx.currentTime)},play(S){if(!A)return;let U=R;R=t.ctx.createBufferSource(),R.buffer=U.buffer,R.loop=U.loop,R.playbackRate.value=U.playbackRate.value,R.detune&&(R.detune.value=U.detune.value),R.connect($);let B=S!=null?S:this.time();R.start(0,B),I=t.ctx.currentTime-B,A=!1,j=null},pause(){A||(R.stop(),A=!0,j=t.ctx.currentTime)},paused(){return A},stopped(){return A},speed(S){return S!==void 0&&(R.playbackRate.value=ae(S,un,cn)),R.playbackRate.value},detune(S){return R.detune?(S!==void 0&&(R.detune.value=ae(S,dn,fn)),R.detune.value):0},volume(S){return S!==void 0&&($.gain.value=ae(S,Tt,St)),$.gain.value},loop(){R.loop=!0},unloop(){R.loop=!1},duration(){return m.duration},time(){return A?j-I:t.ctx.currentTime-I}};return T.speed(v.speed),T.detune(v.detune),T.volume(v.volume),T}r(o,"play");function i(){return t.ctx}return r(i,"ctx"),{ctx:i,volume:e,play:o}}var Tt,St,un,cn,dn,fn,Ct=fe(()=>{xe();Tt=0,St=3,un=0,cn=3,dn=-1200,fn=1200;r(Et,"audioInit")});var At,_t=fe(()=>{At="data:image/png;base64,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"});function kt(t){let e=new Image;return e.src=t,e.crossOrigin="anonymous",new Promise((o,i)=>{e.onload=()=>{o(e)},e.onerror=()=>{i(`failed to load ${t}`)}})}function Dt(t){return t.startsWith("data:")}function Pt(t,e,o={}){let i={lastLoaderID:0,loadRoot:"",loaders:{},sprites:{},sounds:{},fonts:{},shaders:{}};function m(T){var S;let w=i.lastLoaderID;i.loaders[w]=!1,i.lastLoaderID++,T.catch((S=o.errHandler)!=null?S:console.error).finally(()=>{i.loaders[w]=!0})}r(m,"addLoader");function v(){let T=0,w=0;for(let S in i.loaders)T+=1,i.loaders[S]&&(w+=1);return w/T}r(v,"loadProgress");function A(T){return T&&(i.loadRoot=T),i.loadRoot}r(A,"loadRoot");function R(T,w,S,U,B=mn){let _=new Promise((G,y)=>{let H=Dt(w)?w:i.loadRoot+w;kt(H).then(M=>{let q=t.makeFont(t.makeTex(M),S,U,B);i.fonts[T]=q,G(q)}).catch(y)});return m(_),_}r(R,"loadFont");function $(T,w,S={sliceX:1,sliceY:1,anims:{}}){function U(_,G,y={sliceX:1,sliceY:1,gridWidth:0,gridHeight:0,anims:{}}){let H=[],M=t.makeTex(G),q=y.sliceX||M.width/(y.gridWidth||M.width),J=y.sliceY||M.height/(y.gridHeight||M.height),E=1/q,O=1/J;for(let ne=0;ne<J;ne++)for(let ue=0;ue<q;ue++)H.push(oe(ue*E,ne*O,E,O));let te={tex:M,frames:H,anims:y.anims||{}};return i.sprites[_]=te,te}r(U,"loadRawSprite");let B=new Promise((_,G)=>{if(!w)return G(`expected sprite src for "${T}"`);if(typeof w=="string"){let y=Dt(w)?w:i.loadRoot+w;kt(y).then(H=>{_(U(T,H,S))}).catch(G)}else _(U(T,w,S))});return m(B),B}r($,"loadSprite");function k(T,w,S,U=!1){function B(G,y,H){let M=t.makeProgram(y,H);return i.shaders[G]=M,M}r(B,"loadRawShader");let _=new Promise((G,y)=>{if(!w&&!S)return y("no shader");function H(M){return M?fetch(i.loadRoot+M).then(q=>{if(q.ok)return q.text();throw new Error(`failed to load ${M}`)}).catch(y):new Promise(q=>q(null))}if(r(H,"resolveUrl"),U)Promise.all([H(w),H(S)]).then(([M,q])=>{G(B(T,M,q))}).catch(y);else try{G(B(T,w,S))}catch(M){y(M)}});return m(_),_}r(k,"loadShader");function I(T,w){let S=i.loadRoot+w,U=new Promise((B,_)=>{if(!w)return _(`expected sound src for "${T}"`);typeof w=="string"&&fetch(S).then(G=>{if(G.ok)return G.arrayBuffer();throw new Error(`failed to load ${S}`)}).then(G=>new Promise((y,H)=>{e.ctx().decodeAudioData(G,y,H)})).then(G=>{i.sounds[T]=G,B(G)}).catch(_)});return m(U),U}r(I,"loadSound");function j(){return i.fonts[Se]}return r(j,"defFont"),R(Se,At,8,8),{loadRoot:A,loadSprite:$,loadSound:I,loadFont:R,loadShader:k,loadProgress:v,addLoader:m,defFont:j,sprites:i.sprites,fonts:i.fonts,sounds:i.sounds,shaders:i.shaders}}var mn,Se,It=fe(()=>{xe();_t();mn=" !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~",Se="unscii";r(kt,"loadImg");r(Dt,"isDataUrl");r(Pt,"assetsInit")});function Lt(t,e,o={max:8}){var k;let i=[],m=(k=o.max)!=null?k:8;function v(){i.length>m&&(i=i.slice(0,m));let I=f(0,t.height());i.forEach((j,T)=>{let w=ve(T,0,m,1,.5),S=ve(T,0,m,.8,.2),U=(()=>{switch(j.type){case"info":return Y(1,1,1,w);case"error":return Y(1,0,.5,w)}})(),B=t.fmtText(j.msg,e.defFont(),{pos:I,origin:"botleft",color:U,size:ln/t.scale(),width:t.width()});t.drawRect(I,B.width,B.height,{origin:"botleft",color:Y(0,0,0,S)}),t.drawFmtText(B),I.y-=B.height})}r(v,"draw");function A(I){console.error(I),i.unshift({type:"error",msg:I})}r(A,"error");function R(I){i.unshift({type:"info",msg:I})}r(R,"info");function $(){i=[]}return r($,"clear"),{info:R,error:A,draw:v,clear:$}}var ln,Ft=fe(()=>{xe();ln=16;r(Lt,"loggerInit")});function Gt(t){let e={},o=[],i=null;function m(){return i!==null&&i.readyState===1}r(m,"connected");function v(){let k=new WebSocket(t);return new Promise((I,j)=>{k.onopen=()=>{I(k),i=k;for(let T of o)k.send(T)},k.onerror=()=>{j(`failed to connect to ${t}`)},k.onmessage=T=>{let w=JSON.parse(T.data);if(e[w.type])for(let S of e[w.type])S(w.data,w.id)}})}r(v,"connect");function A(k,I){e[k]||(e[k]=[]),e[k].push(I)}r(A,"recv");function R(k,I){let j=JSON.stringify({type:k,data:I});i?i.send(j):o.push(j)}r(R,"send");function $(){i&&i.close()}return r($,"close"),{connect:v,close:$,connected:m,recv:A,send:R}}var Mt=fe(()=>{r(Gt,"netInit")});var pn=nn((Un,qt)=>{xe();gt();Rt();Ct();It();Ft();Mt();qt.exports=(t={width:640,height:480,scale:1,fullscreen:!1,debug:!1,crisp:!1,canvas:null,connect:null,logMax:8,root:document.body})=>{let e=vt({width:t.width,height:t.height,scale:t.scale,fullscreen:t.fullscreen,crisp:t.crisp,canvas:t.canvas,root:t.root}),o=xt(e.gl,{clearColor:t.clearColor?Y(t.clearColor):void 0,scale:t.scale,texFilter:t.texFilter}),i=Et(),m=Pt(o,i,{errHandler:s=>{v.error(s)}}),v=Lt(o,m,{max:t.logMax}),A=(()=>t.connect?Gt(t.connect):null)();function R(s,n){if(!A)throw new Error("not connected to any websockets");A.recv(s,(a,d)=>{try{n(a,d)}catch(u){v.error(u)}})}r(R,"recv");function $(s,n){if(!A)throw new Error("not connected to any websockets");A.send(s,n)}r($,"send");function k(){return e.dt()*W.timeScale}r(k,"dt");function I(s,n={}){let a=m.sounds[s];if(!a)throw new Error(`sound not found: "${s}"`);return i.play(a,n)}r(I,"play");function j(s){var a;let n=y();return!((a=n.layers[s!=null?s:n.defLayer])==null?void 0:a.noCam)}r(j,"isCamLayer");function T(s){return j(s)?y().cam.mpos:e.mousePos()}r(T,"mousePos");function w(s,n={}){var u;let a=(()=>typeof s=="string"?m.sprites[s]:s)();if(!a)throw new Error(`sprite not found: "${s}"`);let d=a.frames[(u=n.frame)!=null?u:0];o.drawTexture(a.tex,we(le({},n),{quad:d}))}r(w,"drawSprite");function S(s,n={}){var u;let a=(u=n.font)!=null?u:Se,d=m.fonts[a];if(!d)throw new Error(`font not found: ${a}`);o.drawText(s,d,n)}r(S,"drawText");let U=980,B="topleft",_={loaded:!1,scenes:{},curScene:null,nextScene:null};function G(s,n){_.scenes[s]={init:n,initialized:!1,events:{add:[],update:[],draw:[],destroy:[],keyDown:[],keyPress:[],keyPressRep:[],keyRelease:[],mouseClick:[],mouseRelease:[],mouseDown:[],charInput:[]},action:[],render:[],objs:new Map,lastObjID:0,timers:{},lastTimerID:0,cam:{pos:f(o.width()/2,o.height()/2),scale:f(1,1),angle:0,shake:0,mpos:f(0),matrix:ee()},layers:{},defLayer:null,gravity:U,data:{}}}r(G,"scene");function y(){return _.scenes[_.curScene]}r(y,"curScene");function H(){return y().data}r(H,"sceneData");function M(){X("`",()=>{W.showLog=!W.showLog,v.info(`show log: ${W.showLog?"on":"off"}`)}),X("f1",()=>{W.inspect=!W.inspect,v.info(`inspect: ${W.inspect?"on":"off"}`)}),X("f2",()=>{W.clearLog()}),X("f8",()=>{W.paused=!W.paused,v.info(`${W.paused?"paused":"unpaused"}`)}),X("f7",()=>{W.timeScale=ae(W.timeScale-.2,0,2),v.info(`time scale: ${W.timeScale.toFixed(1)}`)}),X("f9",()=>{W.timeScale=ae(W.timeScale+.2,0,2),v.info(`time scale: ${W.timeScale.toFixed(1)}`)}),X("f10",()=>{W.stepFrame(),v.info("stepped frame")})}r(M,"regDebugInputs");function q(s,...n){_.nextScene={name:s,args:[...n]}}r(q,"go");function J(s,...n){E(s),_.curScene=s;let a=_.scenes[s];if(!a)throw new Error(`scene not found: '${s}'`);if(!a.initialized){try{a.init(...n)}catch(d){v.error(d.stack)}t.debug&&M(),a.initialized=!0}}r(J,"goSync");function E(s){if(!_.scenes[s])throw new Error(`scene not found: '${s}'`);G(s,_.scenes[s].init)}r(E,"reload");function O(s,n){let a=y();!a||(s.forEach((d,u)=>{a.layers[d]={alpha:1,order:u+1,noCam:!1}}),n&&(a.defLayer=n))}r(O,"layers");function te(...s){let n=y().cam;return s.length>0&&(n.pos=f(...s)),n.pos.clone()}r(te,"camPos");function ne(...s){let n=y().cam;return s.length>0&&(n.scale=f(...s)),n.scale.clone()}r(ne,"camScale");function ue(s){let n=y().cam;return s!==void 0&&(n.angle=s),n.angle}r(ue,"camRot");function ce(s){let n=y().cam;n.shake=s}r(ce,"camShake");function he(s){let n=y();s.forEach(a=>{n.layers[a]&&(n.layers[a].noCam=!0)})}r(he,"camIgnore");function pe(s){let n={hidden:!1,paused:!1,_tags:[],_id:null,_events:{add:[],update:[],draw:[],destroy:[],inspect:[]},use(u){if(u===void 0)return;let p=typeof u;if(p==="string"){this._tags.push(u);return}if(p!=="object")throw new Error(`invalid comp type: ${p}`);if(Array.isArray(u)){for(let c of u)this.use(c);return}for(let c in u){if(typeof u[c]=="function"){this._events[c]?this._events[c].push(u[c].bind(this)):this[c]=u[c].bind(this);continue}this[c]=u[c]}},exists(){return this._id!==void 0},is(u){if(u==="*")return!0;if(Array.isArray(u)){for(let p of u)if(!this._tags.includes(p))return!1;return!0}return this._tags.includes(u)},on(u,p){this._events[u]||(this._events[u]=[]),this._events[u].push(p)},action(u){this.on("update",u)},trigger(u,...p){if(this._events[u])for(let g of this._events[u])g.call(this,...p);let l=y().events[u];if(l)for(let g of l)this.is(g.tag)&&g.cb(this,...p)},rmTag(u){let p=this._tags.indexOf(u);p>-1&&this._tags.splice(p,1)}};n.use(s);let a=y(),d=a.lastObjID++;a.objs.set(d,n),n._id=d,n.trigger("add");for(let u of a.events.add)n.is(u.tag)&&u.cb(n);return n}r(pe,"add");function be(s){if(!s.exists())return;let n=y();n.objs.delete(s._id);let a=n.lastObjID++;return n.objs.set(a,s),s._id=a,s}r(be,"readd");function Ee(s,n,a){let d=y();d.events[s]||(d.events[s]=[]),d.events[s].push({tag:n,cb:a})}r(Ee,"on");function h(s,n){typeof s=="function"&&n===void 0?y().action.push(s):typeof s=="string"&&Ee("update",s,n)}r(h,"action");function x(s,n){typeof s=="function"&&n===void 0?y().render.push(s):typeof s=="string"&&Ee("update",s,n)}r(x,"render");function b(s,n,a){h(s,d=>{d._checkCollisions(n,u=>{a(d,u)})})}r(b,"collides");function L(s,n,a){h(s,d=>{d._checkOverlaps(n,u=>{a(d,u)})})}r(L,"overlaps");function z(s,n){h(s,a=>{a.isClicked()&&n(a)})}r(z,"clicks");function V(s,n){return new Promise(a=>{let d=y();d.timers[d.lastTimerID++]={time:s,cb:()=>{n&&n(),a()}}})}r(V,"wait");function K(s,n){let a=!1,d=r(()=>{a||(n(),V(s,d))},"newF");return d(),{stop(){a=!0}}}r(K,"loop");function C(s,n,a){if(Array.isArray(n))for(let d of n)C(s,d,a);else y().events[s].push({key:n,cb:a})}r(C,"pushKeyEvent");function P(s,n){C("keyDown",s,n)}r(P,"keyDown");function X(s,n){C("keyPress",s,n)}r(X,"keyPress");function F(s,n){C("keyPressRep",s,n)}r(F,"keyPressRep");function Z(s,n){C("keyRelease",s,n)}r(Z,"keyRelease");function re(s){y().events.charInput.push({cb:s})}r(re,"charInput");function ge(s){y().events.mouseDown.push({cb:s})}r(ge,"mouseDown");function Fe(s){y().events.mouseClick.push({cb:s})}r(Fe,"mouseClick");function Ge(s){y().events.mouseRelease.push({cb:s})}r(Ge,"mouseRelease");function se(s){let n=y(),a=[...n.objs.values()].sort((d,u)=>{var l,g,D,N,Q,de;let p=(D=(g=n.layers[(l=d.layer)!=null?l:n.defLayer])==null?void 0:g.order)!=null?D:0,c=(de=(Q=n.layers[(N=u.layer)!=null?N:n.defLayer])==null?void 0:Q.order)!=null?de:0;return p-c});return s?a.filter(d=>d.is(s)):a}r(se,"get");function me(s,n){typeof s=="function"&&n===void 0?se().forEach(s):typeof s=="string"&&se(s).forEach(n)}r(me,"every");function Ce(s,n){typeof s=="function"&&n===void 0?se().reverse().forEach(s):typeof s=="string"&&se(s).reverse().forEach(n)}r(Ce,"revery");function ie(s){if(!s.exists())return;let n=y();!n||(s.trigger("destroy"),n.objs.delete(s._id),delete s._id)}r(ie,"destroy");function Ue(s){me(s,n=>{ie(n)})}r(Ue,"destroyAll");function Me(s){let n=y();return s!==void 0&&(n.gravity=s),n.gravity}r(Me,"gravity");function Ae(s){let n=y();if(!n)throw new Error(`scene not found: '${_.curScene}'`);let a=s||!W.paused;if(a)for(let c in n.timers){let l=n.timers[c];l.time-=k(),l.time<=0&&(l.cb(),delete n.timers[c])}if(Ce(c=>{!c.paused&&a&&c.trigger("update")}),a)for(let c of n.action)c();let d=f(o.width(),o.height()),u=n.cam,p=ot(Pe(0,Math.PI*2)).scale(u.shake);u.shake=De(u.shake,0,5*k()),u.matrix=ee().translate(d.scale(.5)).scale(u.scale).rotateZ(u.angle).translate(d.scale(-.5)).translate(u.pos.scale(-1).add(d.scale(.5)).add(p)),u.mpos=u.matrix.invert().multVec2(e.mousePos()),me(c=>{c.hidden||(o.pushTransform(),j(c.layer)&&o.pushMatrix(u.matrix),c.trigger("draw"),o.popTransform())});for(let c of n.render)c()}r(Ae,"gameFrame");function Be(){let s=y();for(let n of s.events.charInput)e.charInputted().forEach(n.cb);for(let n of s.events.keyDown)e.keyDown(n.key)&&n.cb();for(let n of s.events.keyPress)e.keyPressed(n.key)&&n.cb();for(let n of s.events.keyPressRep)e.keyPressedRep(n.key)&&n.cb();for(let n of s.events.keyRelease)e.keyReleased(n.key)&&n.cb();for(let n of s.events.mouseDown)e.mouseDown()&&n.cb();for(let n of s.events.mouseClick)e.mouseClicked()&&n.cb();for(let n of s.events.mouseRelease)e.mouseReleased()&&n.cb()}r(Be,"handleEvents");function _e(){var c;let s=y(),n=null,a=m.defFont(),d=Y((c=t.inspectColor)!=null?c:[0,1,1,1]);function u(l,g,D){let N=f(4).scale(1/D),Q=o.fmtText(g,a,{size:12/D,pos:l.add(f(N.x,N.y))});o.drawRect(l,Q.width+N.x*2,Q.height+N.x*2,{color:Y(0,0,0,1)}),o.drawFmtText(Q)}r(u,"drawInspectTxt");function p(l,g){let D=j(l.layer),N=o.scale()*(D?(s.cam.scale.x+s.cam.scale.y)/2:1);D&&(o.pushTransform(),o.pushMatrix(s.cam.matrix)),g(N),D&&o.popTransform()}r(p,"drawObj"),Ce(l=>{!l.area||l.hidden||p(l,g=>{n||l.isHovered()&&(n=l);let D=(n===l?6:2)/g,N=l._worldArea(),Q=N.p2.x-N.p1.x,de=N.p2.y-N.p1.y;o.drawRectStroke(N.p1,Q,de,{width:D,color:d})})}),n&&p(n,l=>{let g=T(n.layer),D=[];for(let N of n._tags)D.push(`"${N}"`);for(let N of n._events.inspect){let Q=N();for(let de in Q)D.push(`${de}: ${Q[de]}`)}u(g,D.join(`
`),l)}),u(f(0),e.fps()+"",o.scale())}r(_e,"drawInspect");function je(s,...n){e.run(()=>{if(o.frameStart(),_.loaded){try{if(!y())throw new Error(`scene not found: '${_.curScene}'`);Be(),Ae(),W.inspect&&_e()}catch(a){v.error(a.stack),e.quit()}W.showLog&&v.draw(),_.nextScene&&(J.apply(null,[_.nextScene.name,..._.nextScene.args]),_.nextScene=null)}else{let a=m.loadProgress();if(a===1)_.loaded=!0,J(s,...n),A&&A.connect().catch(v.error);else{let d=o.width()/2,u=24/o.scale(),p=f(o.width()/2,o.height()/2).sub(f(d/2,u/2));o.drawRect(f(0),o.width(),o.height(),{color:Ve(0,0,0)}),o.drawRectStroke(p,d,u,{width:4/o.scale()}),o.drawRect(p,d*a,u)}}o.frameEnd()})}r(je,"start");function qe(...s){return{pos:f(...s),move(...n){let a=f(...n),d=a.x*k(),u=a.y*k();this.pos.x+=d,this.pos.y+=u},inspect(){return{pos:`(${~~this.pos.x}, ${~~this.pos.y})`}}}}r(qe,"pos");function Ze(...s){return s.length===0?Ze(1):{scale:f(...s),flipX(n){this.scale.x=Math.sign(n)*Math.abs(this.scale.x)},flipY(n){this.scale.y=Math.sign(n)*Math.abs(this.scale.y)}}}r(Ze,"scale");function Ot(s){return{angle:s!=null?s:0}}r(Ot,"rotate");function Vt(...s){return{color:Y(...s)}}r(Vt,"color");function Nt(s){return{origin:s}}r(Nt,"origin");function Ut(s){return{layer:s,inspect(){var a;let n=y();return{layer:(a=this.layer)!=null?a:n.defLayer}}}}r(Ut,"layer");function ze(s,n){var d,u;let a=y();return((d=s.layer)!=null?d:a.defLayer)===((u=n.layer)!=null?u:a.defLayer)}r(ze,"isSameLayer");function Qe(s,n){let a={},d={};return{area:{p1:s,p2:n},areaWidth(){let{p1:u,p2:p}=this._worldArea();return p.x-u.x},areaHeight(){let{p1:u,p2:p}=this._worldArea();return p.y-u.y},isClicked(){return e.mouseClicked()&&this.isHovered()},isHovered(){return this.hasPt(T(this.layer))},isCollided(u){if(!u.area||!ze(this,u))return!1;let p=this._worldArea(),c=u._worldArea();return Ye(p,c)},isOverlapped(u){if(!u.area||!ze(this,u))return!1;let p=this._worldArea(),c=u._worldArea();return lt(p,c)},clicks(u){this.action(()=>{this.isClicked()&&u()})},hovers(u){this.action(()=>{this.isHovered()&&u()})},collides(u,p){this.action(()=>{this._checkCollisions(u,p)})},overlaps(u,p){this.action(()=>{this._checkOverlaps(u,p)})},hasPt(u){let p=this._worldArea();return pt({p1:p.p1,p2:p.p2},u)},resolve(){let u=[];return me(p=>{if(p===this||!p.solid||!p.area||!ze(this,p))return;let c=this._worldArea(),l=p._worldArea();if(!Ye(c,l))return;let g=c.p2.x-l.p1.x,D=l.p2.x-c.p1.x,N=c.p2.y-l.p1.y,Q=l.p2.y-c.p1.y,de=Math.min(g,D,N,Q),Zt=(()=>{switch(de){case g:return this.pos.x-=g,"right";case D:return this.pos.x+=D,"left";case N:return this.pos.y-=N,"bottom";case Q:return this.pos.y+=Q,"top"}})();u.push({obj:p,side:Zt})}),u},_checkCollisions(u,p){me(u,c=>{this!==c&&(a[c._id]||this.isCollided(c)&&(p(c),a[c._id]=c))});for(let c in a){let l=a[c];this.isCollided(l)||delete a[c]}},_checkOverlaps(u,p){me(u,c=>{this!==c&&(d[c._id]||this.isOverlapped(c)&&(p(c),d[c._id]=c))});for(let c in d){let l=d[c];this.isOverlapped(l)||delete d[c]}},_worldArea(){let u=this.area,p=this.pos||f(0),c=this.scale||f(1),l=p.add(u.p1.dot(c)),g=p.add(u.p2.dot(c));return{p1:f(Math.min(l.x,g.x),Math.min(l.y,g.y)),p2:f(Math.max(l.x,g.x),Math.max(l.y,g.y))}}}}r(Qe,"area");function Oe(s,n,a){let d=f(s,n),u=Le(a||B).dot(d).scale(-.5);return Qe(u.sub(d.scale(.5)),u.add(d.scale(.5)))}r(Oe,"getAreaFromSize");function Bt(s,n={}){let a=m.sprites[s];if(!a)throw new Error(`sprite not found: "${s}"`);let d=le({},a.frames[0]);n.quad&&(d.x+=n.quad.x*d.w,d.y+=n.quad.y*d.h,d.w*=n.quad.w,d.h*=n.quad.h);let u=a.tex.width*d.w,p=a.tex.height*d.h,c=null;return{width:u,height:p,animSpeed:n.animSpeed||.1,frame:n.frame||0,quad:n.quad||oe(0,0,1,1),add(){!this.area&&!n.noArea&&this.use(Oe(this.width,this.height,this.origin))},draw(){let l=y(),g=a.frames[this.frame];w(a,{pos:this.pos,scale:this.scale,rot:this.angle,color:this.color,frame:this.frame,origin:this.origin,quad:this.quad,prog:m.shaders[this.shader],uniform:this.uniform})},update(){if(!c)return;let l=a.anims[c.name];c.timer+=k(),c.timer>=this.animSpeed&&(this.frame++,this.frame>l.to&&(c.loop?this.frame=l.from:(this.frame--,this.stop())),c&&(c.timer-=this.animSpeed))},play(l,g=!0){let D=a.anims[l];if(!D)throw new Error(`anim not found: ${l}`);c&&this.stop(),c={name:l,loop:g,timer:0},this.frame=D.from,this.trigger("animPlay",l)},stop(){if(!c)return;let l=c.name;c=null,this.trigger("animEnd",l)},changeSprite(l){if(a=m.sprites[l],!a)throw new Error(`sprite not found: "${l}"`);let g=le({},a.frames[0]);n.quad&&(g.x+=n.quad.x*g.w,g.y+=n.quad.y*g.h,g.w*=n.quad.w,g.h*=n.quad.h),this.width=a.tex.width*g.w,this.height=a.tex.height*g.h,this.area&&!n.noArea&&this.use(Oe(this.width,this.height,this.origin)),c=null,this.frame=0},numFrames(){return a.frames.length},curAnim(){return c==null?void 0:c.name},inspect(){let l={};return c&&(l.curAnim=`"${c.name}"`),l}}}r(Bt,"sprite");function jt(s,n,a={}){return{text:s,textSize:n,font:a.font,width:0,height:0,add(){var d,u,p;if(!this.area&&!a.noArea){let c=y(),l=m.fonts[(d=this.font)!=null?d:Se],g=o.fmtText(this.text+"",l,{pos:this.pos,scale:this.scale,rot:this.angle,size:this.textSize,origin:this.origin,color:this.color,width:a.width});this.width=g.width/(((u=this.scale)==null?void 0:u.x)||1),this.height=g.height/(((p=this.scale)==null?void 0:p.y)||1),this.use(Oe(this.width,this.height,this.origin))}},draw(){var c;let d=y(),u=m.fonts[(c=this.font)!=null?c:Se],p=o.fmtText(this.text+"",u,{pos:this.pos,scale:this.scale,rot:this.angle,size:this.textSize,origin:this.origin,color:this.color,width:a.width});this.width=p.width,this.height=p.height,o.drawFmtText(p)}}}r(jt,"text");function zt(s,n,a={}){return{width:s,height:n,add(){!this.area&&!a.noArea&&this.use(Oe(this.width,this.height,this.origin))},draw(){let d=y();o.drawRect(this.pos,this.width,this.height,{scale:this.scale,rot:this.angle,color:this.color,origin:this.origin,prog:m.shaders[this.shader],uniform:this.uniform})}}}r(zt,"rect");function Xt(){return{solid:!0}}r(Xt,"solid");let Yt=960,$t=480;function Ht(s={}){var p,c;let n=0,a=null,d=null,u=(p=s.maxVel)!=null?p:Yt;return{jumpForce:(c=s.jumpForce)!=null?c:$t,update(){this.move(0,n);let l=this.resolve(),g=!1;if(a&&(!a.exists()||!this.isCollided(a)?(a=null,d=null,g=!0):d&&(this.pos=this.pos.add(a.pos.sub(d)),d=a.pos.clone())),!a){n=Math.min(n+Me()*k(),u);for(let D of l)D.side==="bottom"&&n>0?(a=D.obj,n=0,d=a.pos.clone(),g||this.trigger("grounded",a)):D.side==="top"&&n<0&&(n=0,this.trigger("headbump",D.obj))}},curPlatform(){return a},grounded(){return a!==null},falling(){return n>0},jump(l){a=null,n=-l||-this.jumpForce}}}r(Ht,"body");function Wt(s,n={}){let a=m.shaders[s];return{shader:s,uniform:n}}r(Wt,"shader");let W={paused:!1,inspect:!1,timeScale:1,showLog:!0,fps:e.fps,objCount(){return y().objs.size},stepFrame(){Ae(!0)},drawCalls:o.drawCalls,clearLog:v.clear,log:v.info,error:v.error};function Kt(s,n){let a=[],d=f(n.pos||0),u=0,p={getPos(...c){let l=f(...c);return f(d.x+l.x*n.width,d.y+l.y*n.height)},spawn(c,l){let g=(()=>{if(Array.isArray(c))return c;if(n[c]){if(typeof n[c]=="function")return n[c]();if(Array.isArray(n[c]))return[...n[c]]}else if(n.any)return n.any(c)})();if(!g)return;g.push(qe(d.x+l.x*n.width,d.y+l.y*n.height));let D=pe(g);return a.push(D),D.use({gridPos:l.clone(),setGridPos(N){this.gridPos=N.clone(),this.pos=f(d.x+this.gridPos.x*n.width,d.y+this.gridPos.y*n.height)},moveLeft(){this.setGridPos(this.gridPos.add(f(-1,0)))},moveRight(){this.setGridPos(this.gridPos.add(f(1,0)))},moveUp(){this.setGridPos(this.gridPos.add(f(0,-1)))},moveDown(){this.setGridPos(this.gridPos.add(f(0,1)))}}),D},width(){return u*n.width},height(){return s.length*n.height},destroy(){for(let c of a)ie(c)}};return s.forEach((c,l)=>{let g=c.split("");u=Math.max(g.length,u),g.forEach((D,N)=>{p.spawn(D,f(N,l))})}),p}r(Kt,"addLevel");let ke={start:je,loadRoot:m.loadRoot,loadSprite:m.loadSprite,loadSound:m.loadSound,loadFont:m.loadFont,loadShader:m.loadShader,addLoader:m.addLoader,width:o.width,height:o.height,dt:k,time:e.time,screenshot:e.screenshot,scene:G,go:q,sceneData:H,layers:O,camPos:te,camScale:ne,camRot:ue,camShake:ce,camIgnore:he,gravity:Me,add:pe,readd:be,destroy:ie,destroyAll:Ue,get:se,every:me,revery:Ce,send:$,recv:R,pos:qe,scale:Ze,rotate:Ot,color:Vt,origin:Nt,layer:Ut,area:Qe,sprite:Bt,text:jt,rect:zt,solid:Xt,body:Ht,shader:Wt,on:Ee,action:h,render:x,collides:b,overlaps:L,clicks:z,keyDown:P,keyPress:X,keyPressRep:F,keyRelease:Z,charInput:re,mouseDown:ge,mouseClick:Fe,mouseRelease:Ge,mousePos:T,cursor:e.cursor,keyIsDown:e.keyDown,keyIsPressed:e.keyPressed,keyIsPressedRep:e.keyPressedRep,keyIsReleased:e.keyReleased,mouseIsDown:e.mouseDown,mouseIsClicked:e.mouseClicked,mouseIsReleased:e.mouseReleased,loop:K,wait:V,play:I,volume:i.volume,makeRng:Xe,rand:Pe,randSeed:ft,vec2:f,rgb:Ve,rgba:Y,quad:oe,choose:mt,chance:ht,lerp:De,map:ve,mapc:st,wave:ut,deg2rad:nt,rad2deg:rt,drawSprite:w,drawText:S,drawRect:o.drawRect,drawRectStroke:o.drawRectStroke,drawLine:o.drawLine,debug:W,addLevel:Kt};if(t.plugins)for(let s of t.plugins){let n=s(ke);for(let a in n)ke[a]=n[a]}if(t.global)for(let s in ke)window[s]=ke[s];return ke}});/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (pn());
//# sourceMappingURL=kaboom.mjs.map


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!***************************************!*\
  !*** ./cloudyman/client/src/index.js ***!
  \***************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var airbnb_browser_shims__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! airbnb-browser-shims */ "./node_modules/airbnb-browser-shims/index.js");
/* harmony import */ var the_new_css_reset_css_reset_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! the-new-css-reset/css/reset.css */ "./node_modules/the-new-css-reset/css/reset.css");
/* harmony import */ var _styles_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./styles.css */ "./cloudyman/client/src/styles.css");
/* harmony import */ var _functions_init_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./functions/init.js */ "./cloudyman/client/src/functions/init.js");
/* harmony import */ var _scenes_one_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./scenes/one.js */ "./cloudyman/client/src/scenes/one.js");
/* harmony import */ var _scenes_two_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./scenes/two.js */ "./cloudyman/client/src/scenes/two.js");
/* harmony import */ var _scenes_win_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./scenes/win.js */ "./cloudyman/client/src/scenes/win.js");
/* harmony import */ var _functions_controls_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./functions/controls.js */ "./cloudyman/client/src/functions/controls.js");








_functions_init_js__WEBPACK_IMPORTED_MODULE_3__["default"].scene('one', () => (0,_scenes_one_js__WEBPACK_IMPORTED_MODULE_4__["default"])());
_functions_init_js__WEBPACK_IMPORTED_MODULE_3__["default"].scene('two', () => (0,_scenes_two_js__WEBPACK_IMPORTED_MODULE_5__["default"])());
_functions_init_js__WEBPACK_IMPORTED_MODULE_3__["default"].scene('win', _scenes_win_js__WEBPACK_IMPORTED_MODULE_6__["default"]);
_functions_init_js__WEBPACK_IMPORTED_MODULE_3__["default"].start('one');
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvdWR5bWFuL2NsaWVudC9wdWJsaWMvZGlzdC9jbG91ZHltYW4tYnVuZGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBYTs7QUFFYjs7QUFFQTtBQUNBLG1CQUFPLENBQUMsd0VBQXFCOztBQUU3QjtBQUNBLG1CQUFPLENBQUMscUZBQXFCOztBQUU3QjtBQUNBLG1CQUFPLENBQUMsa0VBQWtCOztBQUUxQixtQkFBTyxDQUFDLDBEQUFjOztBQUV0QjtBQUNBO0FBQ0EsRUFBRSxtQkFBTyxDQUFDLDBFQUFvQjs7QUFFOUI7QUFDQSxFQUFFLG1CQUFPLENBQUMsMEVBQWlCOztBQUUzQjtBQUNBLEVBQUUsd0hBQXlDOztBQUUzQztBQUNBLEVBQUUsbUJBQU8sQ0FBQyw2RUFBcUI7QUFDL0IsRUFBRSxtQkFBTyxDQUFDLGdIQUE0Qzs7QUFFdEQ7QUFDQSxFQUFFLG1CQUFPLENBQUMsbUdBQXdCOztBQUVsQztBQUNBLEVBQUUsbUJBQU8sQ0FBQyw4RkFBNEI7O0FBRXRDLEVBQUUsbUJBQU8sQ0FBQyw0RkFBdUI7O0FBRWpDO0FBQ0EsRUFBRSxtQkFBTyxDQUFDLGdGQUF5QjtBQUNuQzs7QUFFQTtBQUNBLG1CQUFPLENBQUMseUVBQWU7O0FBRXZCLG1CQUFPLENBQUMsb0RBQWM7O0FBRXRCLHFCQUFNLHVCQUF1QixtQkFBTyxDQUFDLGtEQUFVOztBQUUvQyxxQkFBTSxzQkFBc0IscUJBQU07O0FBRWxDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN2RGE7O0FBRWIsbUJBQU8sQ0FBQyx3RUFBd0I7Ozs7Ozs7Ozs7OztBQ0ZuQjs7QUFFYjs7QUFFQSxtQkFBTyxDQUFDLGdFQUFpQjs7QUFFekIsbUJBQU8sQ0FBQywyRUFBZ0I7Ozs7Ozs7Ozs7OztBQ05YOztBQUViLG1CQUFPLENBQUMsa0VBQWM7Ozs7Ozs7Ozs7OztBQ0ZUOztBQUViLG1CQUFPLENBQUMscURBQVU7O0FBRWxCLG1CQUFPLENBQUMsb0ZBQThCOztBQUV0QyxtQkFBTyxDQUFDLGlF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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxrQkFBa0I7QUFDOUQsRUFBRTtBQUNGLENBQUMsb0JBQW9CO0FBQ3JCOzs7Ozs7Ozs7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7Ozs7OztBQzdpQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLElBQTBDO0FBQ2xEO0FBQ0EsUUFBUSxvQ0FBTyxPQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDdkIsTUFBTSxLQUFLLEVBUU47QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTs7QUFFQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUEsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxzQkFBc0I7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSw2REFBNkQ7QUFDN0QsNENBQTRDO0FBQzVDLHNDQUFzQztBQUN0QztBQUNBLGdDQUFnQztBQUNoQztBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZOztBQUV0QjtBQUNB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S0FBSzs7QUFFTDtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEMsMkNBQTJDO0FBQzNDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBLDhDQUE4QztBQUM5QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQ0FBa0MsNEJBQTRCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7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LHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxxQkFBcUI7QUFDckIsc0JBQXNCOztBQUV0QjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLHNCQUFzQixHQUFHOztBQUV2RztBQUNBLDBDQUEwQztBQUMxQyx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFlBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFlBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUVBQWlFLHVDQUF1QztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxRQUFRO0FBQ1IscUJBQXFCO0FBQ3JCO0FBQ0EsdUJBQXVCO0FBQ3ZCLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsWUFBWSxtQkFBbUIsZUFBZTtBQUMzRjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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T0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsd0NBQXdDO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNB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U0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkM7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QztBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsNEJBQTRCO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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RixZQUFZLDJDQUEyQyxhQUFhLDBDQUEwQyxVQUFVLDJDQUEyQyxZQUFZLDJDQUEyQyxJQUFJLFNBQVMsaUJBQWlCLFVBQVUseUJBQXlCLFdBQVcsdUJBQXVCLHlCQUF5QixrQkFBa0IseUNBQXlDLGtCQUFrQixFQUFFLElBQUksaUJBQWlCLFFBQVEsdXBDQUF1cEMscUNBQXFDLFlBQVksMEJBQTBCLDRDQUE0QyxXQUFXLEVBQUUsaUVBQWUsSUFBSSxFQUFDO0FBQ2g2Ujs7Ozs7OztVQ3hEQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3RCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsaUNBQWlDLFdBQVc7V0FDNUM7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQSxDQUFDOzs7OztXQ1BEOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUFsRyxnRUFBQSxDQUFRLEtBQVIsRUFBZSxNQUFNeUYsMERBQUcsRUFBeEI7QUFDQXpGLGdFQUFBLENBQVEsS0FBUixFQUFlLE1BQU1nRywwREFBRyxFQUF4QjtBQUNBaEcsZ0VBQUEsQ0FBUSxLQUFSLEVBQWVrRyxzREFBZjtBQUVBbEcsZ0VBQUEsQ0FBUSxLQUFSLEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2FpcmJuYi1icm93c2VyLXNoaW1zL2Jyb3dzZXItb25seS5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2FpcmJuYi1icm93c2VyLXNoaW1zL2RvY3VtZW50LWNvbnRhaW5zLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvYWlyYm5iLWJyb3dzZXItc2hpbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9haXJibmItanMtc2hpbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9haXJibmItanMtc2hpbXMvdGFyZ2V0L2VzMjAxNS5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2FpcmJuYi1qcy1zaGltcy90YXJnZXQvZXMyMDE2LmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvYWlyYm5iLWpzLXNoaW1zL3RhcmdldC9lczIwMTcuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9haXJibmItanMtc2hpbXMvdGFyZ2V0L2VzMjAxOC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2FpcmJuYi1qcy1zaGltcy90YXJnZXQvZXMyMDE5LmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvYWlyYm5iLWpzLXNoaW1zL3RhcmdldC9lczIwMjAuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9haXJibmItanMtc2hpbXMvdGFyZ2V0L2VzNS5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2FycmF5LWluY2x1ZGVzL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvYXJyYXktaW5jbHVkZXMvcG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9hcnJheS1pbmNsdWRlcy9zaGltLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvYXJyYXkucHJvdG90eXBlLmZsYXQvYXV0by5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2FycmF5LnByb3RvdHlwZS5mbGF0L2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvYXJyYXkucHJvdG90eXBlLmZsYXQvcG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9hcnJheS5wcm90b3R5cGUuZmxhdC9zaGltLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvYXJyYXkucHJvdG90eXBlLmZsYXRtYXAvYXV0by5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2FycmF5LnByb3RvdHlwZS5mbGF0bWFwL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvYXJyYXkucHJvdG90eXBlLmZsYXRtYXAvcG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9hcnJheS5wcm90b3R5cGUuZmxhdG1hcC9zaGltLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvYXJyYXkucHJvdG90eXBlLm1hcC9pbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2FycmF5LnByb3RvdHlwZS5tYXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9hcnJheS5wcm90b3R5cGUubWFwL3BvbHlmaWxsLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvYXJyYXkucHJvdG90eXBlLm1hcC9zaGltLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2NhbGxCb3VuZC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2NsYXNzbGlzdC1wb2x5ZmlsbC9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9jb25zb2xlLXBvbHlmaWxsL2luZGV4LmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9jbG91ZHltYW4vY2xpZW50L3NyYy9zdHlsZXMuY3NzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvdGhlLW5ldy1jc3MtcmVzZXQvY3NzL3Jlc2V0LmNzcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9kZWZpbmUtcHJvcGVydGllcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2RvY3VtZW50LmNvbnRhaW5zL2F1dG8uanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9kb2N1bWVudC5jb250YWlucy9pbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2RvY3VtZW50LmNvbnRhaW5zL3BvbHlmaWxsLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZG9jdW1lbnQuY29udGFpbnMvc2hpbS5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtY2xvc2VzdC9lbGVtZW50LWNsb3Nlc3QuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hcnJheS1tZXRob2QtYm94ZXMtcHJvcGVybHkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1nZXQtaXRlcmF0b3Ivbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy10by1wcmltaXRpdmUvZXMyMDE1LmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZXMtdG8tcHJpbWl0aXZlL2VzNS5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLXRvLXByaW1pdGl2ZS9oZWxwZXJzL2lzUHJpbWl0aXZlLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZXM1LXNoaW0vZXM1LXNoYW0uanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lczUtc2hpbS9lczUtc2hpbS5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzNi1zaGltL2VzNi1zaGltLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZm9jdXMtdmlzaWJsZS9kaXN0L2ZvY3VzLXZpc2libGUuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLnByb3RvdHlwZS5uYW1lL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24ucHJvdG90eXBlLm5hbWUvcG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi5wcm90b3R5cGUubmFtZS9zaGltLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZnVuY3Rpb25zLWhhdmUtbmFtZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9nZXQtaW50cmluc2ljL2luZGV4LmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZ2V0LXN5bWJvbC1kZXNjcmlwdGlvbi9nZXRJbmZlcnJlZE5hbWUuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9nZXQtc3ltYm9sLWRlc2NyaXB0aW9uL2luZGV4LmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZ2xvYmFsdGhpcy9hdXRvLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZ2xvYmFsdGhpcy9pbXBsZW1lbnRhdGlvbi5icm93c2VyLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZ2xvYmFsdGhpcy9wb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2dsb2JhbHRoaXMvc2hpbS5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL2luZGV4LmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9oYXMtdG9zdHJpbmd0YWcvc2hhbXMuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9oYXMvc3JjL2luZGV4LmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvaW1hLWJhYmVsNi1wb2x5ZmlsbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2lucHV0LXBsYWNlaG9sZGVyLXBvbHlmaWxsL2Rpc3QvbWFpbi5taW4uanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9pbnRlcm5hbC1zbG90L2luZGV4LmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvaW50ZXJzZWN0aW9uLW9ic2VydmVyL2ludGVyc2VjdGlvbi1vYnNlcnZlci5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2lzLWFyZ3VtZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2lzLWNhbGxhYmxlL2luZGV4LmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvaXMtZGF0ZS1vYmplY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9pcy1tYXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9pcy1yZWdleC9pbmRleC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2lzLXNldC9pbmRleC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2lzLXN0cmluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2lzLXN5bWJvbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2l0ZXJhdGUtaXRlcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9tYXRjaG1lZGlhLXBvbHlmaWxsL21hdGNoTWVkaWEuYWRkTGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9tYXRjaG1lZGlhLXBvbHlmaWxsL21hdGNoTWVkaWEuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9vYmplY3QtaW5zcGVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL29iamVjdC1rZXlzL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL29iamVjdC5lbnRyaWVzL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvb2JqZWN0LmVudHJpZXMvcG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9vYmplY3QuZW50cmllcy9zaGltLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvb2JqZWN0LmZyb21lbnRyaWVzL2F1dG8uanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9vYmplY3QuZnJvbWVudHJpZXMvaW1wbGVtZW50YXRpb24uanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9vYmplY3QuZnJvbWVudHJpZXMvcG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9vYmplY3QuZnJvbWVudHJpZXMvc2hpbS5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL29iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnMvcG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9ycy9zaGltLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvb2JqZWN0LnZhbHVlcy9pbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL29iamVjdC52YWx1ZXMvcG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9vYmplY3QudmFsdWVzL3NoaW0uanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9wZXJmb3JtYW5jZS1ub3cvbGliL3BlcmZvcm1hbmNlLW5vdy5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL3Byb21pc2UuYWxsc2V0dGxlZC9hdXRvLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvcHJvbWlzZS5hbGxzZXR0bGVkL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvcHJvbWlzZS5hbGxzZXR0bGVkL3BvbHlmaWxsLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvcHJvbWlzZS5hbGxzZXR0bGVkL3JlcXVpcmVQcm9taXNlLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvcHJvbWlzZS5hbGxzZXR0bGVkL3NoaW0uanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9wcm9taXNlLnByb3RvdHlwZS5maW5hbGx5L2F1dG8uanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9wcm9taXNlLnByb3RvdHlwZS5maW5hbGx5L2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvcHJvbWlzZS5wcm90b3R5cGUuZmluYWxseS9wb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL3Byb21pc2UucHJvdG90eXBlLmZpbmFsbHkvcmVxdWlyZVByb21pc2UuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9wcm9taXNlLnByb3RvdHlwZS5maW5hbGx5L3NoaW0uanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9yYWYvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9yYWYvcG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9yZWdleHAucHJvdG90eXBlLmZsYWdzL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvcmVnZXhwLnByb3RvdHlwZS5mbGFncy9pbmRleC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL3JlZ2V4cC5wcm90b3R5cGUuZmxhZ3MvcG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9yZWdleHAucHJvdG90eXBlLmZsYWdzL3NoaW0uanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9yaWMtc2hpbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL3NoaW0ta2V5Ym9hcmQtZXZlbnQta2V5L2luZGV4LmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvc2lkZS1jaGFubmVsL2luZGV4LmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvc21vb3Roc2Nyb2xsLXBvbHlmaWxsL2Rpc3Qvc21vb3Roc2Nyb2xsLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvc3RyaW5nLnByb3RvdHlwZS5tYXRjaGFsbC9hdXRvLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvc3RyaW5nLnByb3RvdHlwZS5tYXRjaGFsbC9pbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL3N0cmluZy5wcm90b3R5cGUubWF0Y2hhbGwvcG9seWZpbGwtcmVnZXhwLW1hdGNoYWxsLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvc3RyaW5nLnByb3RvdHlwZS5tYXRjaGFsbC9wb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL3N0cmluZy5wcm90b3R5cGUubWF0Y2hhbGwvcmVnZXhwLW1hdGNoYWxsLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvc3RyaW5nLnByb3RvdHlwZS5tYXRjaGFsbC9zaGltLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvc3RyaW5nLnByb3RvdHlwZS5wYWRlbmQvaW1wbGVtZW50YXRpb24uanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9zdHJpbmcucHJvdG90eXBlLnBhZGVuZC9wb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL3N0cmluZy5wcm90b3R5cGUucGFkZW5kL3NoaW0uanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9zdHJpbmcucHJvdG90eXBlLnBhZHN0YXJ0L2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvc3RyaW5nLnByb3RvdHlwZS5wYWRzdGFydC9wb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL3N0cmluZy5wcm90b3R5cGUucGFkc3RhcnQvc2hpbS5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vY2xvdWR5bWFuL2NsaWVudC9zcmMvc3R5bGVzLmNzcz8yN2Y2Iiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvdGhlLW5ldy1jc3MtcmVzZXQvY3NzL3Jlc2V0LmNzcz8wMDlmIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9zeW1ib2wucHJvdG90eXBlLmRlc2NyaXB0aW9uL2F1dG8uanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9zeW1ib2wucHJvdG90eXBlLmRlc2NyaXB0aW9uL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvc3ltYm9sLnByb3RvdHlwZS5kZXNjcmlwdGlvbi9wb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL3N5bWJvbC5wcm90b3R5cGUuZGVzY3JpcHRpb24vc2hpbS5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL3doYXR3Zy1mZXRjaC9mZXRjaC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL3dpbmRvdy1sb2NhdGlvbi1vcmlnaW4vc3JjL3dpbmRvdy1sb2NhdGlvbi1vcmlnaW4uanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy9pZ25vcmVkfC9Vc2Vycy9NaWtsL0Ryb3Bib3gvZGV2L2FwcHMvY2xvdWR5LW5pZ2h0cy9ub2RlX21vZHVsZXMvb2JqZWN0LWluc3BlY3R8Li91dGlsLmluc3BlY3QiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIwL0lzQXJyYXkuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL0FkZEVudHJpZXNGcm9tSXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL0FkdmFuY2VTdHJpbmdJbmRleC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvQXJyYXlDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL0FycmF5U3BlY2llc0NyZWF0ZS5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvQ2FsbC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvQ29kZVBvaW50QXQuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL0NyZWF0ZURhdGFQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvQ3JlYXRlRGF0YVByb3BlcnR5T3JUaHJvdy5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvQ3JlYXRlSXRlclJlc3VsdE9iamVjdC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvQ3JlYXRlTWV0aG9kUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL0NyZWF0ZVJlZ0V4cFN0cmluZ0l0ZXJhdG9yLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvMjAyMS9EZWZpbmVQcm9wZXJ0eU9yVGhyb3cuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL0ZsYXR0ZW5JbnRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL0Zyb21Qcm9wZXJ0eURlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL0dldC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvR2V0SXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL0dldE1ldGhvZC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvR2V0Vi5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvSGFzUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL0ludm9rZS5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvSXNBY2Nlc3NvckRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL0lzQXJyYXkuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL0lzQ2FsbGFibGUuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL0lzQ29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL0lzRGF0YURlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL0lzRXh0ZW5zaWJsZS5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvSXNJbnRlZ3JhbE51bWJlci5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvSXNQcm9wZXJ0eUtleS5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvSXNSZWdFeHAuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL0l0ZXJhdG9yQ2xvc2UuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL0l0ZXJhdG9yQ29tcGxldGUuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL0l0ZXJhdG9yTmV4dC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvSXRlcmF0b3JTdGVwLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvMjAyMS9JdGVyYXRvclZhbHVlLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvMjAyMS9MZW5ndGhPZkFycmF5TGlrZS5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvT3JkaW5hcnlHZXRPd25Qcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvT3JkaW5hcnlPYmplY3RDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL1Byb21pc2VSZXNvbHZlLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvMjAyMS9SZWdFeHBFeGVjLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvMjAyMS9SZXF1aXJlT2JqZWN0Q29lcmNpYmxlLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvMjAyMS9TYW1lVmFsdWUuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL1NhbWVWYWx1ZVplcm8uanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL1NldC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvU3BlY2llc0NvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvMjAyMS9Ub0Jvb2xlYW4uanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL1RvSW50ZWdlck9ySW5maW5pdHkuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL1RvTGVuZ3RoLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvMjAyMS9Ub051bWJlci5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvVG9PYmplY3QuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL1RvUHJpbWl0aXZlLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvMjAyMS9Ub1Byb3BlcnR5RGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvVG9Qcm9wZXJ0eUtleS5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvVG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL1RvVWludDMyLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvMjAyMS9UeXBlLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvMjAyMS9VVEYxNlN1cnJvZ2F0ZVBhaXJUb0NvZGVQb2ludC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvYWJzLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvMjAyMS9mbG9vci5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzUvQ2hlY2tPYmplY3RDb2VyY2libGUuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC81L1RvSW50ZWdlci5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzUvVG9OdW1iZXIuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC81L1RvUHJpbWl0aXZlLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvNS9UeXBlLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvNS9hYnMuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC81L2Zsb29yLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvR2V0SW50cmluc2ljLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9EZWZpbmVPd25Qcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvYXNzZXJ0UmVjb3JkLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9nZXRJdGVyYXRvck1ldGhvZC5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9pc0Zpbml0ZS5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvaXNMZWFkaW5nU3Vycm9nYXRlLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9pc05hTi5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvaXNQcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL2lzUHJvcGVydHlEZXNjcmlwdG9yLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9pc1RyYWlsaW5nU3Vycm9nYXRlLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9tYXhTYWZlSW50ZWdlci5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvcmVnZXhUZXN0ZXIuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL3NpZ24uanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9lcy1nZXQtaXRlcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL25vZGVfbW9kdWxlcy9pdGVyYXRlLXZhbHVlL2luZGV4LmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9jbG91ZHltYW4vY2xpZW50L3NyYy9jb250ZW50L2NoYXJhY3RlcnMuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL2Nsb3VkeW1hbi9jbGllbnQvc3JjL2NvbnRlbnQvcGxheWVyLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9jbG91ZHltYW4vY2xpZW50L3NyYy9jb250ZW50L3RhbGtpbmcuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL2Nsb3VkeW1hbi9jbGllbnQvc3JjL2Z1bmN0aW9ucy9jb250cm9scy5qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzLy4vY2xvdWR5bWFuL2NsaWVudC9zcmMvZnVuY3Rpb25zL2luaXQuanMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL2Nsb3VkeW1hbi9jbGllbnQvc3JjL2Z1bmN0aW9ucy96b29tLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9jbG91ZHltYW4vY2xpZW50L3NyYy9zY2VuZXMvb25lLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9jbG91ZHltYW4vY2xpZW50L3NyYy9zY2VuZXMvdHdvLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9jbG91ZHltYW4vY2xpZW50L3NyYy9zY2VuZXMvd2luLmpzIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvLi9ub2RlX21vZHVsZXMva2Fib29tL2Rpc3Qva2Fib29tLm1qcyIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL2Nsb3VkeS1uaWdodHMvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9jbG91ZHktbmlnaHRzL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vY2xvdWR5LW5pZ2h0cy8uL2Nsb3VkeW1hbi9jbGllbnQvc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IGdsb2JhbC1yZXF1aXJlOiAwICovXG5cbi8vIEZpeGVzIHN1cGVyLWNvbnN0cnVjdG9yIGNhbGxzIGluIElFOS8xMFxucmVxdWlyZSgnaW1hLWJhYmVsNi1wb2x5ZmlsbCcpO1xuXG4vLyBkb2N1bWVudC5jb250YWlucyBwb2x5ZmlsbFxucmVxdWlyZSgnLi9kb2N1bWVudC1jb250YWlucycpO1xuXG4vLyBjb25zb2xlLiogcG9seWZpbGwgZm9yIG9sZCBicm93c2Vyc1xucmVxdWlyZSgnY29uc29sZS1wb2x5ZmlsbCcpO1xuXG5yZXF1aXJlKCd3aGF0d2ctZmV0Y2gnKTtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIEVsZW1lbnQuY2xhc3NMaXN0IHBvbHlmaWxsXG4gIHJlcXVpcmUoJ2NsYXNzbGlzdC1wb2x5ZmlsbCcpO1xuXG4gIC8vIEVsZW1lbnQuY2xvc2VzdCBwb2x5ZmlsbFxuICByZXF1aXJlKCdlbGVtZW50LWNsb3Nlc3QnKTtcblxuICAvLyBQb2x5ZmlsbCBmb3Igc21vb3RoIHNjcm9sbGluZyBiZWhhdmlvclxuICByZXF1aXJlKCdzbW9vdGhzY3JvbGwtcG9seWZpbGwnKS5wb2x5ZmlsbCgpO1xuXG4gIC8vIFBvbHlmaWxsIHdpbmRvdy5tYXRjaE1lZGlhIChwcmltYXJpbHkgZm9yIElFOSlcbiAgcmVxdWlyZSgnbWF0Y2htZWRpYS1wb2x5ZmlsbCcpO1xuICByZXF1aXJlKCdtYXRjaG1lZGlhLXBvbHlmaWxsL21hdGNoTWVkaWEuYWRkTGlzdGVuZXInKTtcblxuICAvLyBQb2x5ZmlsbCB3aW5kb3cubG9jYXRpb24ub3JpZ2luIChmb3IgSUUgPCAxMSlcbiAgcmVxdWlyZSgnd2luZG93LWxvY2F0aW9uLW9yaWdpbicpO1xuXG4gIC8vIGZvciA8PSBJRSA5LCBPcGVyYSBtaW5pXG4gIHJlcXVpcmUoJ2lucHV0LXBsYWNlaG9sZGVyLXBvbHlmaWxsJyk7XG5cbiAgcmVxdWlyZSgnaW50ZXJzZWN0aW9uLW9ic2VydmVyJyk7XG5cbiAgLy8gS2V5Ym9hcmRFdmVudC5rZXkgc2hpbVxuICByZXF1aXJlKCdzaGltLWtleWJvYXJkLWV2ZW50LWtleScpO1xufVxuXG4vLyA6Zm9jdXMtdmlzaWJsZSBzaGltXG5yZXF1aXJlKCdmb2N1cy12aXNpYmxlJyk7XG5cbnJlcXVpcmUoJ3JhZi9wb2x5ZmlsbCcpO1xuXG5nbG9iYWwucmVxdWVzdElkbGVDYWxsYmFjayA9IHJlcXVpcmUoJ3JpYy1zaGltJyk7XG5cbmdsb2JhbC5jYW5jZWxJZGxlQ2FsbGJhY2sgPSBnbG9iYWwucmVxdWVzdElkbGVDYWxsYmFjay5jYW5jZWxJZGxlQ2FsbGJhY2s7XG5cbnZhciBoYXNTeW1ib2xzID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG5cbi8qIGdsb2JhbHMgVG91Y2hMaXN0ICovXG5pZiAoaGFzU3ltYm9scyAmJiB0eXBlb2YgVG91Y2hMaXN0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBUb3VjaExpc3QucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gIT09ICdmdW5jdGlvbicpIHtcbiAgVG91Y2hMaXN0LnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gQXJyYXkucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJ2RvY3VtZW50LmNvbnRhaW5zL2F1dG8nKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IGdsb2JhbC1yZXF1aXJlOiAwICovXG5cbnJlcXVpcmUoJ2FpcmJuYi1qcy1zaGltcycpO1xuXG5yZXF1aXJlKCcuL2Jyb3dzZXItb25seScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL3RhcmdldC9lczUnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnZXM2LXNoaW0nKTtcblxucmVxdWlyZSgnZnVuY3Rpb24ucHJvdG90eXBlLm5hbWUvc2hpbScpKCk7XG5cbnJlcXVpcmUoJy4vZXMyMDE2Jyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIEFycmF5I2luY2x1ZGVzIGlzIHN0YWdlIDQsIGluIEVTNy9FUzIwMTZcbnJlcXVpcmUoJ2FycmF5LWluY2x1ZGVzL3NoaW0nKSgpO1xuXG5yZXF1aXJlKCcuL2VzMjAxNycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBPYmplY3QudmFsdWVzL09iamVjdC5lbnRyaWVzIGFyZSBzdGFnZSA0LCBpbiBFUzIwMTdcbnJlcXVpcmUoJ29iamVjdC52YWx1ZXMvc2hpbScpKCk7XG5yZXF1aXJlKCdvYmplY3QuZW50cmllcy9zaGltJykoKTtcblxuLy8gU3RyaW5nI3BhZFN0YXJ0L1N0cmluZyNwYWRFbmQgYXJlIHN0YWdlIDQsIGluIEVTMjAxN1xucmVxdWlyZSgnc3RyaW5nLnByb3RvdHlwZS5wYWRzdGFydC9zaGltJykoKTtcbnJlcXVpcmUoJ3N0cmluZy5wcm90b3R5cGUucGFkZW5kL3NoaW0nKSgpO1xuXG4vLyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyBpcyBzdGFnZSA0LCBpbiBFUzIwMTdcbnJlcXVpcmUoJ29iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzL3NoaW0nKSgpO1xuXG5yZXF1aXJlKCcuL2VzMjAxOCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAodHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgcmVxdWlyZSgncHJvbWlzZS5wcm90b3R5cGUuZmluYWxseS9hdXRvJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ2xvYmFsLXJlcXVpcmVcbn1cblxucmVxdWlyZSgnLi9lczIwMTknKTtcbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnYXJyYXkucHJvdG90eXBlLmZsYXQvYXV0bycpO1xucmVxdWlyZSgnYXJyYXkucHJvdG90eXBlLmZsYXRtYXAvYXV0bycpO1xuXG5yZXF1aXJlKCdzeW1ib2wucHJvdG90eXBlLmRlc2NyaXB0aW9uL2F1dG8nKTtcblxucmVxdWlyZSgnb2JqZWN0LmZyb21lbnRyaWVzL2F1dG8nKTtcblxucmVxdWlyZSgnLi9lczIwMjAnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnc3RyaW5nLnByb3RvdHlwZS5tYXRjaGFsbC9hdXRvJyk7XG5cbnJlcXVpcmUoJ2dsb2JhbHRoaXMvYXV0bycpO1xuXG5yZXF1aXJlKCdwcm9taXNlLmFsbHNldHRsZWQvYXV0bycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCdlczUtc2hpbScpO1xucmVxdWlyZSgnZXM1LXNoaW0vZXM1LXNoYW0nKTtcblxucmVxdWlyZSgnLi9lczIwMTUnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFRvSW50ZWdlck9ySW5maW5pdHkgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL1RvSW50ZWdlck9ySW5maW5pdHknKTtcbnZhciBUb0xlbmd0aCA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMjEvVG9MZW5ndGgnKTtcbnZhciBUb09iamVjdCA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMjEvVG9PYmplY3QnKTtcbnZhciBTYW1lVmFsdWVaZXJvID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvMjAyMS9TYW1lVmFsdWVaZXJvJyk7XG52YXIgJGlzTmFOID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvaGVscGVycy9pc05hTicpO1xudmFyICRpc0Zpbml0ZSA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0L2hlbHBlcnMvaXNGaW5pdGUnKTtcbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xudmFyIGlzU3RyaW5nID0gcmVxdWlyZSgnaXMtc3RyaW5nJyk7XG5cbnZhciAkY2hhckF0ID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLmNoYXJBdCcpO1xudmFyICRpbmRleE9mID0gR2V0SW50cmluc2ljKCclQXJyYXkucHJvdG90eXBlLmluZGV4T2YlJyk7IC8vIFRPRE86IHVzZSBjYWxsQmluZC5hcHBseSB3aXRob3V0IGJyZWFraW5nIElFIDhcbnZhciAkbWF4ID0gR2V0SW50cmluc2ljKCclTWF0aC5tYXglJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoRWxlbWVudCkge1xuXHR2YXIgZnJvbUluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBUb0ludGVnZXJPckluZmluaXR5KGFyZ3VtZW50c1sxXSkgOiAwO1xuXHRpZiAoJGluZGV4T2YgJiYgISRpc05hTihzZWFyY2hFbGVtZW50KSAmJiAkaXNGaW5pdGUoZnJvbUluZGV4KSAmJiB0eXBlb2Ygc2VhcmNoRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRyZXR1cm4gJGluZGV4T2YuYXBwbHkodGhpcywgYXJndW1lbnRzKSA+IC0xO1xuXHR9XG5cblx0dmFyIE8gPSBUb09iamVjdCh0aGlzKTtcblx0dmFyIGxlbmd0aCA9IFRvTGVuZ3RoKE8ubGVuZ3RoKTtcblx0aWYgKGxlbmd0aCA9PT0gMCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHR2YXIgayA9IGZyb21JbmRleCA+PSAwID8gZnJvbUluZGV4IDogJG1heCgwLCBsZW5ndGggKyBmcm9tSW5kZXgpO1xuXHR3aGlsZSAoayA8IGxlbmd0aCkge1xuXHRcdGlmIChTYW1lVmFsdWVaZXJvKHNlYXJjaEVsZW1lbnQsIGlzU3RyaW5nKE8pID8gJGNoYXJBdChPLCBrKSA6IE9ba10pKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0ayArPSAxO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcblx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5pbmNsdWRlcyB8fCBpbXBsZW1lbnRhdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1BcnJheVByb3RvdHlwZUluY2x1ZGVzKCkge1xuXHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRkZWZpbmUoXG5cdFx0QXJyYXkucHJvdG90eXBlLFxuXHRcdHsgaW5jbHVkZXM6IHBvbHlmaWxsIH0sXG5cdFx0eyBpbmNsdWRlczogZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzICE9PSBwb2x5ZmlsbDsgfSB9XG5cdCk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4vc2hpbScpKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBBcnJheVNwZWNpZXNDcmVhdGUgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL0FycmF5U3BlY2llc0NyZWF0ZScpO1xudmFyIEZsYXR0ZW5JbnRvQXJyYXkgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL0ZsYXR0ZW5JbnRvQXJyYXknKTtcbnZhciBHZXQgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL0dldCcpO1xudmFyIFRvSW50ZWdlck9ySW5maW5pdHkgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL1RvSW50ZWdlck9ySW5maW5pdHknKTtcbnZhciBUb0xlbmd0aCA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMjEvVG9MZW5ndGgnKTtcbnZhciBUb09iamVjdCA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMjEvVG9PYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmbGF0KCkge1xuXHR2YXIgTyA9IFRvT2JqZWN0KHRoaXMpO1xuXHR2YXIgc291cmNlTGVuID0gVG9MZW5ndGgoR2V0KE8sICdsZW5ndGgnKSk7XG5cblx0dmFyIGRlcHRoTnVtID0gMTtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0ZGVwdGhOdW0gPSBUb0ludGVnZXJPckluZmluaXR5KGFyZ3VtZW50c1swXSk7XG5cdH1cblxuXHR2YXIgQSA9IEFycmF5U3BlY2llc0NyZWF0ZShPLCAwKTtcblx0RmxhdHRlbkludG9BcnJheShBLCBPLCBzb3VyY2VMZW4sIDAsIGRlcHRoTnVtKTtcblx0cmV0dXJuIEE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XG5cdHJldHVybiBBcnJheS5wcm90b3R5cGUuZmxhdCB8fCBpbXBsZW1lbnRhdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1GbGF0KCkge1xuXHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRkZWZpbmUoXG5cdFx0QXJyYXkucHJvdG90eXBlLFxuXHRcdHsgZmxhdDogcG9seWZpbGwgfSxcblx0XHR7IGZsYXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5mbGF0ICE9PSBwb2x5ZmlsbDsgfSB9XG5cdCk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4vc2hpbScpKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBBcnJheVNwZWNpZXNDcmVhdGUgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL0FycmF5U3BlY2llc0NyZWF0ZScpO1xudmFyIEZsYXR0ZW5JbnRvQXJyYXkgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL0ZsYXR0ZW5JbnRvQXJyYXknKTtcbnZhciBHZXQgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL0dldCcpO1xudmFyIElzQ2FsbGFibGUgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL0lzQ2FsbGFibGUnKTtcbnZhciBUb0xlbmd0aCA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMjEvVG9MZW5ndGgnKTtcbnZhciBUb09iamVjdCA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMjEvVG9PYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmbGF0TWFwKG1hcHBlckZ1bmN0aW9uKSB7XG5cdHZhciBPID0gVG9PYmplY3QodGhpcyk7XG5cdHZhciBzb3VyY2VMZW4gPSBUb0xlbmd0aChHZXQoTywgJ2xlbmd0aCcpKTtcblxuXHRpZiAoIUlzQ2FsbGFibGUobWFwcGVyRnVuY3Rpb24pKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignbWFwcGVyRnVuY3Rpb24gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cdH1cblxuXHR2YXIgVDtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0VCA9IGFyZ3VtZW50c1sxXTtcblx0fVxuXG5cdHZhciBBID0gQXJyYXlTcGVjaWVzQ3JlYXRlKE8sIDApO1xuXHRGbGF0dGVuSW50b0FycmF5KEEsIE8sIHNvdXJjZUxlbiwgMCwgMSwgbWFwcGVyRnVuY3Rpb24sIFQpO1xuXHRyZXR1cm4gQTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcblx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5mbGF0TWFwIHx8IGltcGxlbWVudGF0aW9uO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJyk7XG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbUZsYXRNYXAoKSB7XG5cdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG5cdGRlZmluZShcblx0XHRBcnJheS5wcm90b3R5cGUsXG5cdFx0eyBmbGF0TWFwOiBwb2x5ZmlsbCB9LFxuXHRcdHsgZmxhdE1hcDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZsYXRNYXAgIT09IHBvbHlmaWxsOyB9IH1cblx0KTtcblx0cmV0dXJuIHBvbHlmaWxsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEFycmF5U3BlY2llc0NyZWF0ZSA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMjEvQXJyYXlTcGVjaWVzQ3JlYXRlJyk7XG52YXIgQ2FsbCA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMjEvQ2FsbCcpO1xudmFyIENyZWF0ZURhdGFQcm9wZXJ0eU9yVGhyb3cgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL0NyZWF0ZURhdGFQcm9wZXJ0eU9yVGhyb3cnKTtcbnZhciBHZXQgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL0dldCcpO1xudmFyIEhhc1Byb3BlcnR5ID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvMjAyMS9IYXNQcm9wZXJ0eScpO1xudmFyIElzQ2FsbGFibGUgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL0lzQ2FsbGFibGUnKTtcbnZhciBUb1VpbnQzMiA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMjEvVG9VaW50MzInKTtcbnZhciBUb09iamVjdCA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMjEvVG9PYmplY3QnKTtcbnZhciBUb1N0cmluZyA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMjEvVG9TdHJpbmcnKTtcblxudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyIGlzU3RyaW5nID0gcmVxdWlyZSgnaXMtc3RyaW5nJyk7XG5cbi8vIENoZWNrIGZhaWx1cmUgb2YgYnktaW5kZXggYWNjZXNzIG9mIHN0cmluZyBjaGFyYWN0ZXJzIChJRSA8IDkpIGFuZCBmYWlsdXJlIG9mIGAwIGluIGJveGVkU3RyaW5nYCAoUmhpbm8pXG52YXIgYm94ZWRTdHJpbmcgPSBPYmplY3QoJ2EnKTtcbnZhciBzcGxpdFN0cmluZyA9IGJveGVkU3RyaW5nWzBdICE9PSAnYScgfHwgISgwIGluIGJveGVkU3RyaW5nKTtcblxudmFyIHN0clNwbGl0ID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLnNwbGl0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm4pIHtcblx0dmFyIE8gPSBUb09iamVjdCh0aGlzKTtcblx0dmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyhPKSA/IHN0clNwbGl0KE8sICcnKSA6IE87XG5cdHZhciBsZW4gPSBUb1VpbnQzMihzZWxmLmxlbmd0aCk7XG5cblx0Ly8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cblx0aWYgKCFJc0NhbGxhYmxlKGNhbGxiYWNrZm4pKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLm1hcCBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblx0fVxuXG5cdHZhciBUO1xuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRUID0gYXJndW1lbnRzWzFdO1xuXHR9XG5cblx0dmFyIEEgPSBBcnJheVNwZWNpZXNDcmVhdGUoTywgbGVuKTtcblx0dmFyIGsgPSAwO1xuXHR3aGlsZSAoayA8IGxlbikge1xuXHRcdHZhciBQayA9IFRvU3RyaW5nKGspO1xuXHRcdHZhciBrUHJlc2VudCA9IEhhc1Byb3BlcnR5KE8sIFBrKTtcblx0XHRpZiAoa1ByZXNlbnQpIHtcblx0XHRcdHZhciBrVmFsdWUgPSBHZXQoTywgUGspO1xuXHRcdFx0dmFyIG1hcHBlZFZhbHVlID0gQ2FsbChjYWxsYmFja2ZuLCBULCBba1ZhbHVlLCBrLCBPXSk7XG5cdFx0XHRDcmVhdGVEYXRhUHJvcGVydHlPclRocm93KEEsIFBrLCBtYXBwZWRWYWx1ZSk7XG5cdFx0fVxuXHRcdGsgKz0gMTtcblx0fVxuXG5cdHJldHVybiBBO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJyk7XG52YXIgUmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMjEvUmVxdWlyZU9iamVjdENvZXJjaWJsZScpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xudmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcbnZhciBzaGltID0gcmVxdWlyZSgnLi9zaGltJyk7XG5cbnZhciAkc2xpY2UgPSBjYWxsQm91bmQoJ0FycmF5LnByb3RvdHlwZS5zbGljZScpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbnZhciBib3VuZE1hcFNoaW0gPSBmdW5jdGlvbiBtYXAoYXJyYXksIGNhbGxiYWNrZm4pIHtcblx0UmVxdWlyZU9iamVjdENvZXJjaWJsZShhcnJheSk7XG5cdHJldHVybiBwb2x5ZmlsbC5hcHBseShhcnJheSwgJHNsaWNlKGFyZ3VtZW50cywgMSkpO1xufTtcbmRlZmluZShib3VuZE1hcFNoaW0sIHtcblx0Z2V0UG9seWZpbGw6IGdldFBvbHlmaWxsLFxuXHRpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb24sXG5cdHNoaW06IHNoaW1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJvdW5kTWFwU2hpbTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFycmF5TWV0aG9kQm94ZXNQcm9wZXJseSA9IHJlcXVpcmUoJ2VzLWFycmF5LW1ldGhvZC1ib3hlcy1wcm9wZXJseScpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XG5cdHZhciBtZXRob2QgPSBBcnJheS5wcm90b3R5cGUubWFwO1xuXHRyZXR1cm4gYXJyYXlNZXRob2RCb3hlc1Byb3Blcmx5KG1ldGhvZCkgPyBtZXRob2QgOiBpbXBsZW1lbnRhdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1BcnJheVByb3RvdHlwZU1hcCgpIHtcblx0dmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcblx0ZGVmaW5lKFxuXHRcdEFycmF5LnByb3RvdHlwZSxcblx0XHR7IG1hcDogcG9seWZpbGwgfSxcblx0XHR7IG1hcDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcCAhPT0gcG9seWZpbGw7IH0gfVxuXHQpO1xuXHRyZXR1cm4gcG9seWZpbGw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCcuLycpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQmluZChHZXRJbnRyaW5zaWMoJ1N0cmluZy5wcm90b3R5cGUuaW5kZXhPZicpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQm91bmRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWMgPSBHZXRJbnRyaW5zaWMobmFtZSwgISFhbGxvd01pc3NpbmcpO1xuXHRpZiAodHlwZW9mIGludHJpbnNpYyA9PT0gJ2Z1bmN0aW9uJyAmJiAkaW5kZXhPZihuYW1lLCAnLnByb3RvdHlwZS4nKSA+IC0xKSB7XG5cdFx0cmV0dXJuIGNhbGxCaW5kKGludHJpbnNpYyk7XG5cdH1cblx0cmV0dXJuIGludHJpbnNpYztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRhcHBseSA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSUnKTtcbnZhciAkY2FsbCA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsJScpO1xudmFyICRyZWZsZWN0QXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVSZWZsZWN0LmFwcGx5JScsIHRydWUpIHx8IGJpbmQuY2FsbCgkY2FsbCwgJGFwcGx5KTtcblxudmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnLCB0cnVlKTtcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSk7XG52YXIgJG1heCA9IEdldEludHJpbnNpYygnJU1hdGgubWF4JScpO1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQmluZChvcmlnaW5hbEZ1bmN0aW9uKSB7XG5cdHZhciBmdW5jID0gJHJlZmxlY3RBcHBseShiaW5kLCAkY2FsbCwgYXJndW1lbnRzKTtcblx0aWYgKCRnT1BEICYmICRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdHZhciBkZXNjID0gJGdPUEQoZnVuYywgJ2xlbmd0aCcpO1xuXHRcdGlmIChkZXNjLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0Ly8gb3JpZ2luYWwgbGVuZ3RoLCBwbHVzIHRoZSByZWNlaXZlciwgbWludXMgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIChhZnRlciB0aGUgcmVjZWl2ZXIpXG5cdFx0XHQkZGVmaW5lUHJvcGVydHkoXG5cdFx0XHRcdGZ1bmMsXG5cdFx0XHRcdCdsZW5ndGgnLFxuXHRcdFx0XHR7IHZhbHVlOiAxICsgJG1heCgwLCBvcmlnaW5hbEZ1bmN0aW9uLmxlbmd0aCAtIChhcmd1bWVudHMubGVuZ3RoIC0gMSkpIH1cblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmdW5jO1xufTtcblxudmFyIGFwcGx5QmluZCA9IGZ1bmN0aW9uIGFwcGx5QmluZCgpIHtcblx0cmV0dXJuICRyZWZsZWN0QXBwbHkoYmluZCwgJGFwcGx5LCBhcmd1bWVudHMpO1xufTtcblxuaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHQkZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsICdhcHBseScsIHsgdmFsdWU6IGFwcGx5QmluZCB9KTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzLmFwcGx5ID0gYXBwbHlCaW5kO1xufVxuIiwiLypcbiAqIGNsYXNzTGlzdC5qczogQ3Jvc3MtYnJvd3NlciBmdWxsIGVsZW1lbnQuY2xhc3NMaXN0IGltcGxlbWVudGF0aW9uLlxuICogMS4xLjIwMTcwNDI3XG4gKlxuICogQnkgRWxpIEdyZXksIGh0dHA6Ly9lbGlncmV5LmNvbVxuICogTGljZW5zZTogRGVkaWNhdGVkIHRvIHRoZSBwdWJsaWMgZG9tYWluLlxuICogICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VsaWdyZXkvY2xhc3NMaXN0LmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWRcbiAqL1xuXG4vKmdsb2JhbCBzZWxmLCBkb2N1bWVudCwgRE9NRXhjZXB0aW9uICovXG5cbi8qISBAc291cmNlIGh0dHA6Ly9wdXJsLmVsaWdyZXkuY29tL2dpdGh1Yi9jbGFzc0xpc3QuanMvYmxvYi9tYXN0ZXIvY2xhc3NMaXN0LmpzICovXG5cbmlmIChcImRvY3VtZW50XCIgaW4gd2luZG93LnNlbGYpIHtcblxuLy8gRnVsbCBwb2x5ZmlsbCBmb3IgYnJvd3NlcnMgd2l0aCBubyBjbGFzc0xpc3Qgc3VwcG9ydFxuLy8gSW5jbHVkaW5nIElFIDwgRWRnZSBtaXNzaW5nIFNWR0VsZW1lbnQuY2xhc3NMaXN0XG5pZiAoIShcImNsYXNzTGlzdFwiIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJfXCIpKSBcblx0fHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmICEoXCJjbGFzc0xpc3RcIiBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFwiZ1wiKSkpIHtcblxuKGZ1bmN0aW9uICh2aWV3KSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5pZiAoISgnRWxlbWVudCcgaW4gdmlldykpIHJldHVybjtcblxudmFyXG5cdCAgY2xhc3NMaXN0UHJvcCA9IFwiY2xhc3NMaXN0XCJcblx0LCBwcm90b1Byb3AgPSBcInByb3RvdHlwZVwiXG5cdCwgZWxlbUN0clByb3RvID0gdmlldy5FbGVtZW50W3Byb3RvUHJvcF1cblx0LCBvYmpDdHIgPSBPYmplY3Rcblx0LCBzdHJUcmltID0gU3RyaW5nW3Byb3RvUHJvcF0udHJpbSB8fCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgXCJcIik7XG5cdH1cblx0LCBhcnJJbmRleE9mID0gQXJyYXlbcHJvdG9Qcm9wXS5pbmRleE9mIHx8IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0dmFyXG5cdFx0XHQgIGkgPSAwXG5cdFx0XHQsIGxlbiA9IHRoaXMubGVuZ3RoXG5cdFx0O1xuXHRcdGZvciAoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9XG5cdC8vIFZlbmRvcnM6IHBsZWFzZSBhbGxvdyBjb250ZW50IGNvZGUgdG8gaW5zdGFudGlhdGUgRE9NRXhjZXB0aW9uc1xuXHQsIERPTUV4ID0gZnVuY3Rpb24gKHR5cGUsIG1lc3NhZ2UpIHtcblx0XHR0aGlzLm5hbWUgPSB0eXBlO1xuXHRcdHRoaXMuY29kZSA9IERPTUV4Y2VwdGlvblt0eXBlXTtcblx0XHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXHR9XG5cdCwgY2hlY2tUb2tlbkFuZEdldEluZGV4ID0gZnVuY3Rpb24gKGNsYXNzTGlzdCwgdG9rZW4pIHtcblx0XHRpZiAodG9rZW4gPT09IFwiXCIpIHtcblx0XHRcdHRocm93IG5ldyBET01FeChcblx0XHRcdFx0ICBcIlNZTlRBWF9FUlJcIlxuXHRcdFx0XHQsIFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkXCJcblx0XHRcdCk7XG5cdFx0fVxuXHRcdGlmICgvXFxzLy50ZXN0KHRva2VuKSkge1xuXHRcdFx0dGhyb3cgbmV3IERPTUV4KFxuXHRcdFx0XHQgIFwiSU5WQUxJRF9DSEFSQUNURVJfRVJSXCJcblx0XHRcdFx0LCBcIlN0cmluZyBjb250YWlucyBhbiBpbnZhbGlkIGNoYXJhY3RlclwiXG5cdFx0XHQpO1xuXHRcdH1cblx0XHRyZXR1cm4gYXJySW5kZXhPZi5jYWxsKGNsYXNzTGlzdCwgdG9rZW4pO1xuXHR9XG5cdCwgQ2xhc3NMaXN0ID0gZnVuY3Rpb24gKGVsZW0pIHtcblx0XHR2YXJcblx0XHRcdCAgdHJpbW1lZENsYXNzZXMgPSBzdHJUcmltLmNhbGwoZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKVxuXHRcdFx0LCBjbGFzc2VzID0gdHJpbW1lZENsYXNzZXMgPyB0cmltbWVkQ2xhc3Nlcy5zcGxpdCgvXFxzKy8pIDogW11cblx0XHRcdCwgaSA9IDBcblx0XHRcdCwgbGVuID0gY2xhc3Nlcy5sZW5ndGhcblx0XHQ7XG5cdFx0Zm9yICg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dGhpcy5wdXNoKGNsYXNzZXNbaV0pO1xuXHRcdH1cblx0XHR0aGlzLl91cGRhdGVDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHRoaXMudG9TdHJpbmcoKSk7XG5cdFx0fTtcblx0fVxuXHQsIGNsYXNzTGlzdFByb3RvID0gQ2xhc3NMaXN0W3Byb3RvUHJvcF0gPSBbXVxuXHQsIGNsYXNzTGlzdEdldHRlciA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gbmV3IENsYXNzTGlzdCh0aGlzKTtcblx0fVxuO1xuLy8gTW9zdCBET01FeGNlcHRpb24gaW1wbGVtZW50YXRpb25zIGRvbid0IGFsbG93IGNhbGxpbmcgRE9NRXhjZXB0aW9uJ3MgdG9TdHJpbmcoKVxuLy8gb24gbm9uLURPTUV4Y2VwdGlvbnMuIEVycm9yJ3MgdG9TdHJpbmcoKSBpcyBzdWZmaWNpZW50IGhlcmUuXG5ET01FeFtwcm90b1Byb3BdID0gRXJyb3JbcHJvdG9Qcm9wXTtcbmNsYXNzTGlzdFByb3RvLml0ZW0gPSBmdW5jdGlvbiAoaSkge1xuXHRyZXR1cm4gdGhpc1tpXSB8fCBudWxsO1xufTtcbmNsYXNzTGlzdFByb3RvLmNvbnRhaW5zID0gZnVuY3Rpb24gKHRva2VuKSB7XG5cdHRva2VuICs9IFwiXCI7XG5cdHJldHVybiBjaGVja1Rva2VuQW5kR2V0SW5kZXgodGhpcywgdG9rZW4pICE9PSAtMTtcbn07XG5jbGFzc0xpc3RQcm90by5hZGQgPSBmdW5jdGlvbiAoKSB7XG5cdHZhclxuXHRcdCAgdG9rZW5zID0gYXJndW1lbnRzXG5cdFx0LCBpID0gMFxuXHRcdCwgbCA9IHRva2Vucy5sZW5ndGhcblx0XHQsIHRva2VuXG5cdFx0LCB1cGRhdGVkID0gZmFsc2Vcblx0O1xuXHRkbyB7XG5cdFx0dG9rZW4gPSB0b2tlbnNbaV0gKyBcIlwiO1xuXHRcdGlmIChjaGVja1Rva2VuQW5kR2V0SW5kZXgodGhpcywgdG9rZW4pID09PSAtMSkge1xuXHRcdFx0dGhpcy5wdXNoKHRva2VuKTtcblx0XHRcdHVwZGF0ZWQgPSB0cnVlO1xuXHRcdH1cblx0fVxuXHR3aGlsZSAoKytpIDwgbCk7XG5cblx0aWYgKHVwZGF0ZWQpIHtcblx0XHR0aGlzLl91cGRhdGVDbGFzc05hbWUoKTtcblx0fVxufTtcbmNsYXNzTGlzdFByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0dmFyXG5cdFx0ICB0b2tlbnMgPSBhcmd1bWVudHNcblx0XHQsIGkgPSAwXG5cdFx0LCBsID0gdG9rZW5zLmxlbmd0aFxuXHRcdCwgdG9rZW5cblx0XHQsIHVwZGF0ZWQgPSBmYWxzZVxuXHRcdCwgaW5kZXhcblx0O1xuXHRkbyB7XG5cdFx0dG9rZW4gPSB0b2tlbnNbaV0gKyBcIlwiO1xuXHRcdGluZGV4ID0gY2hlY2tUb2tlbkFuZEdldEluZGV4KHRoaXMsIHRva2VuKTtcblx0XHR3aGlsZSAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHR0aGlzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHR1cGRhdGVkID0gdHJ1ZTtcblx0XHRcdGluZGV4ID0gY2hlY2tUb2tlbkFuZEdldEluZGV4KHRoaXMsIHRva2VuKTtcblx0XHR9XG5cdH1cblx0d2hpbGUgKCsraSA8IGwpO1xuXG5cdGlmICh1cGRhdGVkKSB7XG5cdFx0dGhpcy5fdXBkYXRlQ2xhc3NOYW1lKCk7XG5cdH1cbn07XG5jbGFzc0xpc3RQcm90by50b2dnbGUgPSBmdW5jdGlvbiAodG9rZW4sIGZvcmNlKSB7XG5cdHRva2VuICs9IFwiXCI7XG5cblx0dmFyXG5cdFx0ICByZXN1bHQgPSB0aGlzLmNvbnRhaW5zKHRva2VuKVxuXHRcdCwgbWV0aG9kID0gcmVzdWx0ID9cblx0XHRcdGZvcmNlICE9PSB0cnVlICYmIFwicmVtb3ZlXCJcblx0XHQ6XG5cdFx0XHRmb3JjZSAhPT0gZmFsc2UgJiYgXCJhZGRcIlxuXHQ7XG5cblx0aWYgKG1ldGhvZCkge1xuXHRcdHRoaXNbbWV0aG9kXSh0b2tlbik7XG5cdH1cblxuXHRpZiAoZm9yY2UgPT09IHRydWUgfHwgZm9yY2UgPT09IGZhbHNlKSB7XG5cdFx0cmV0dXJuIGZvcmNlO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiAhcmVzdWx0O1xuXHR9XG59O1xuY2xhc3NMaXN0UHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLmpvaW4oXCIgXCIpO1xufTtcblxuaWYgKG9iakN0ci5kZWZpbmVQcm9wZXJ0eSkge1xuXHR2YXIgY2xhc3NMaXN0UHJvcERlc2MgPSB7XG5cdFx0ICBnZXQ6IGNsYXNzTGlzdEdldHRlclxuXHRcdCwgZW51bWVyYWJsZTogdHJ1ZVxuXHRcdCwgY29uZmlndXJhYmxlOiB0cnVlXG5cdH07XG5cdHRyeSB7XG5cdFx0b2JqQ3RyLmRlZmluZVByb3BlcnR5KGVsZW1DdHJQcm90bywgY2xhc3NMaXN0UHJvcCwgY2xhc3NMaXN0UHJvcERlc2MpO1xuXHR9IGNhdGNoIChleCkgeyAvLyBJRSA4IGRvZXNuJ3Qgc3VwcG9ydCBlbnVtZXJhYmxlOnRydWVcblx0XHQvLyBhZGRpbmcgdW5kZWZpbmVkIHRvIGZpZ2h0IHRoaXMgaXNzdWUgaHR0cHM6Ly9naXRodWIuY29tL2VsaWdyZXkvY2xhc3NMaXN0LmpzL2lzc3Vlcy8zNlxuXHRcdC8vIG1vZGVybmllIElFOC1NU1c3IG1hY2hpbmUgaGFzIElFOCA4LjAuNjAwMS4xODcwMiBhbmQgaXMgYWZmZWN0ZWRcblx0XHRpZiAoZXgubnVtYmVyID09PSB1bmRlZmluZWQgfHwgZXgubnVtYmVyID09PSAtMHg3RkY1RUM1NCkge1xuXHRcdFx0Y2xhc3NMaXN0UHJvcERlc2MuZW51bWVyYWJsZSA9IGZhbHNlO1xuXHRcdFx0b2JqQ3RyLmRlZmluZVByb3BlcnR5KGVsZW1DdHJQcm90bywgY2xhc3NMaXN0UHJvcCwgY2xhc3NMaXN0UHJvcERlc2MpO1xuXHRcdH1cblx0fVxufSBlbHNlIGlmIChvYmpDdHJbcHJvdG9Qcm9wXS5fX2RlZmluZUdldHRlcl9fKSB7XG5cdGVsZW1DdHJQcm90by5fX2RlZmluZUdldHRlcl9fKGNsYXNzTGlzdFByb3AsIGNsYXNzTGlzdEdldHRlcik7XG59XG5cbn0od2luZG93LnNlbGYpKTtcblxufVxuXG4vLyBUaGVyZSBpcyBmdWxsIG9yIHBhcnRpYWwgbmF0aXZlIGNsYXNzTGlzdCBzdXBwb3J0LCBzbyBqdXN0IGNoZWNrIGlmIHdlIG5lZWRcbi8vIHRvIG5vcm1hbGl6ZSB0aGUgYWRkL3JlbW92ZSBhbmQgdG9nZ2xlIEFQSXMuXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHZhciB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJfXCIpO1xuXG5cdHRlc3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJjMVwiLCBcImMyXCIpO1xuXG5cdC8vIFBvbHlmaWxsIGZvciBJRSAxMC8xMSBhbmQgRmlyZWZveCA8MjYsIHdoZXJlIGNsYXNzTGlzdC5hZGQgYW5kXG5cdC8vIGNsYXNzTGlzdC5yZW1vdmUgZXhpc3QgYnV0IHN1cHBvcnQgb25seSBvbmUgYXJndW1lbnQgYXQgYSB0aW1lLlxuXHRpZiAoIXRlc3RFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcImMyXCIpKSB7XG5cdFx0dmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uKG1ldGhvZCkge1xuXHRcdFx0dmFyIG9yaWdpbmFsID0gRE9NVG9rZW5MaXN0LnByb3RvdHlwZVttZXRob2RdO1xuXG5cdFx0XHRET01Ub2tlbkxpc3QucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih0b2tlbikge1xuXHRcdFx0XHR2YXIgaSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHR0b2tlbiA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0XHRvcmlnaW5hbC5jYWxsKHRoaXMsIHRva2VuKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9O1xuXHRcdGNyZWF0ZU1ldGhvZCgnYWRkJyk7XG5cdFx0Y3JlYXRlTWV0aG9kKCdyZW1vdmUnKTtcblx0fVxuXG5cdHRlc3RFbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoXCJjM1wiLCBmYWxzZSk7XG5cblx0Ly8gUG9seWZpbGwgZm9yIElFIDEwIGFuZCBGaXJlZm94IDwyNCwgd2hlcmUgY2xhc3NMaXN0LnRvZ2dsZSBkb2VzIG5vdFxuXHQvLyBzdXBwb3J0IHRoZSBzZWNvbmQgYXJndW1lbnQuXG5cdGlmICh0ZXN0RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJjM1wiKSkge1xuXHRcdHZhciBfdG9nZ2xlID0gRE9NVG9rZW5MaXN0LnByb3RvdHlwZS50b2dnbGU7XG5cblx0XHRET01Ub2tlbkxpc3QucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uKHRva2VuLCBmb3JjZSkge1xuXHRcdFx0aWYgKDEgaW4gYXJndW1lbnRzICYmICF0aGlzLmNvbnRhaW5zKHRva2VuKSA9PT0gIWZvcmNlKSB7XG5cdFx0XHRcdHJldHVybiBmb3JjZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBfdG9nZ2xlLmNhbGwodGhpcywgdG9rZW4pO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0fVxuXG5cdHRlc3RFbGVtZW50ID0gbnVsbDtcbn0oKSk7XG5cbn1cbiIsIi8vIENvbnNvbGUtcG9seWZpbGwuIE1JVCBsaWNlbnNlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9jb25zb2xlLXBvbHlmaWxsXG4vLyBNYWtlIGl0IHNhZmUgdG8gZG8gY29uc29sZS5sb2coKSBhbHdheXMuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgaWYgKCFnbG9iYWwuY29uc29sZSkge1xuICAgIGdsb2JhbC5jb25zb2xlID0ge307XG4gIH1cbiAgdmFyIGNvbiA9IGdsb2JhbC5jb25zb2xlO1xuICB2YXIgcHJvcCwgbWV0aG9kO1xuICB2YXIgZHVtbXkgPSBmdW5jdGlvbigpIHt9O1xuICB2YXIgcHJvcGVydGllcyA9IFsnbWVtb3J5J107XG4gIHZhciBtZXRob2RzID0gKCdhc3NlcnQsY2xlYXIsY291bnQsZGVidWcsZGlyLGRpcnhtbCxlcnJvcixleGNlcHRpb24sZ3JvdXAsJyArXG4gICAgICdncm91cENvbGxhcHNlZCxncm91cEVuZCxpbmZvLGxvZyxtYXJrVGltZWxpbmUscHJvZmlsZSxwcm9maWxlcyxwcm9maWxlRW5kLCcgK1xuICAgICAnc2hvdyx0YWJsZSx0aW1lLHRpbWVFbmQsdGltZWxpbmUsdGltZWxpbmVFbmQsdGltZVN0YW1wLHRyYWNlLHdhcm4nKS5zcGxpdCgnLCcpO1xuICB3aGlsZSAocHJvcCA9IHByb3BlcnRpZXMucG9wKCkpIGlmICghY29uW3Byb3BdKSBjb25bcHJvcF0gPSB7fTtcbiAgd2hpbGUgKG1ldGhvZCA9IG1ldGhvZHMucG9wKCkpIGlmICghY29uW21ldGhvZF0pIGNvblttZXRob2RdID0gZHVtbXk7XG4gIC8vIFVzaW5nIGB0aGlzYCBmb3Igd2ViIHdvcmtlcnMgJiBzdXBwb3J0cyBCcm93c2VyaWZ5IC8gV2VicGFjay5cbn0pKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gdGhpcyA6IHdpbmRvdyk7XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcImh0bWwsXFxuYm9keSB7XFxuICBvdmVyZmxvdy14OiBoaWRkZW47XFxuICBvdmVyZmxvdy15OiBoaWRkZW47XFxufVxcblxcbmh0bWwsXFxuYm9keSxcXG5jYW52YXMsXFxuaW1nLFxcbmgxLFxcbiN0aXRsZSxcXG4jdXAsXFxuI3JpZ2h0LFxcbiNkb3duLFxcbiNsZWZ0LCB7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG59XFxuXFxuYm9keSB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgd2lkdGg6IDEwMHZ3O1xcbiAgaGVpZ2h0OiAxMDB2aDtcXG4gIG1hcmdpbjogMDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBmb250LWZhbWlseTogVmVyZGFuYSwgR2VuZXZhLCBUYWhvbWEsIHNhbnMtc2VyaWY7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzAwMDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG59XFxuXFxuYnV0dG9uIHtcXG4gIHBhZGRpbmc6IDA7XFxuICBmb250LXdlaWdodDogOTAwO1xcbiAgYmFja2dyb3VuZDogbm9uZTtcXG4gIGJvcmRlcjogbm9uZTtcXG59XFxuXFxuI2ZhZGVPdXQge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbiAgei1pbmRleDogMjtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMwMDA7XFxuICBvcGFjaXR5OiAxMDAlO1xcbiAgYW5pbWF0aW9uOiBmYWRlT3V0IDFzIGxpbmVhciAwcyBmb3J3YXJkcztcXG4gIHRvdWNoLWFjdGlvbjogbm9uZTtcXG59XFxuXFxuI2FwcCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuI2dhbWVXcmFwcGVyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBtYXgtd2lkdGg6IDEwMCU7XFxuICBtYXgtaGVpZ2h0OiAxMDAlO1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGFuaW1hdGlvbjogZmFkZUluIDFzIGxpbmVhciAwcyBmb3J3YXJkcztcXG59XFxuXFxuI2JsYWNrU2NyZWVuLFxcbiNnYW1lIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMiU7XFxuICB3aWR0aDogYXV0bztcXG4gIGhlaWdodDogNDklO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7XFxuICBib3JkZXItcmFkaXVzOiA1JTtcXG59XFxuXFxuI2JsYWNrU2NyZWVuIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBtaW4td2lkdGg6IDY4JTtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIHRvdWNoLWFjdGlvbjogbm9uZTtcXG59XFxuXFxuI3RpdGxlIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogNDQlO1xcbiAgei1pbmRleDogMztcXG4gIG1hcmdpbjogMDtcXG4gIGZvbnQtc2l6ZTogMTAwJTtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbiAgb3BhY2l0eTogMCU7XFxuICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgYW5pbWF0aW9uOiBmYWRlSW4gMC4zcyBsaW5lYXIgMS41cyBmb3J3YXJkcztcXG4gIHRvdWNoLWFjdGlvbjogbm9uZTtcXG59XFxuXFxuI2JhY2tncm91bmQge1xcbiAgei1pbmRleDogMTtcXG4gIG1heC13aWR0aDogMTAwJTtcXG4gIG1heC1oZWlnaHQ6IDEwMCU7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbiAgdG91Y2gtYWN0aW9uOiBub25lO1xcbn1cXG5cXG4jY29udHJvbHMge1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblxcbiN1cCxcXG4jcmlnaHQsXFxuI2Rvd24sXFxuI2xlZnQge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDogNTtcXG4gIHdpZHRoOiAxNSU7XFxuICBoZWlnaHQ6IDEwJTtcXG59XFxuXFxuI3JpZ2h0LFxcbiNsZWZ0IHtcXG4gIHRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTtcXG59XFxuXFxuI3VwIHtcXG4gIHRvcDogNTMuNiU7XFxuICBsZWZ0OiAxNi4zJTtcXG59XFxuXFxuI3JpZ2h0IHtcXG4gIHRvcDogNjEuOCU7XFxuICBsZWZ0OiAzMSU7XFxufVxcblxcbiNkb3duIHtcXG4gIHRvcDogNzAlO1xcbiAgbGVmdDogMTYuMyU7XFxufVxcblxcbiNsZWZ0IHtcXG4gIHRvcDogNjEuOCU7XFxuICBsZWZ0OiAxLjUlO1xcbn1cXG5cXG4jem9vbSB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICByaWdodDogLTEwcHg7XFxuICBib3R0b206IC0xMHB4O1xcbiAgei1pbmRleDogNjtcXG4gIHdpZHRoOiAxMDBweDtcXG4gIGhlaWdodDogNTBweDtcXG4gIHBhZGRpbmc6IDEwcHggMjBweCAyMHB4IDEwcHg7XFxuICBmb250LXNpemU6IDE1cHg7XFxuICBjb2xvcjogYmxhY2s7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpO1xcbiAgYm9yZGVyLXJhZGl1czogMTBweDtcXG59XFxuXFxuQG1lZGlhIChtaW4td2lkdGg6IDQwMHB4KSwgKG1pbi1oZWlnaHQ6IDk2MHB4KSB7XFxuICAjdGl0bGUge1xcbiAgICBmb250LXNpemU6IDIwMCU7XFxuICB9XFxuXFxuICAjem9vbSB7XFxuICAgIHZpc2liaWxpdHk6IHZpc2libGU7XFxuICB9XFxufVxcblxcbkBrZXlmcmFtZXMgZmFkZUluIHtcXG4gIGZyb20ge1xcbiAgICBvcGFjaXR5OiAwJTtcXG4gIH1cXG5cXG4gIHRvIHtcXG4gICAgb3BhY2l0eTogMTAwJTtcXG4gIH1cXG59XFxuXFxuQGtleWZyYW1lcyBmYWRlT3V0IHtcXG4gIGZyb20ge1xcbiAgICBvcGFjaXR5OiAxMDAlO1xcbiAgfVxcblxcbiAgdG8ge1xcbiAgICBvcGFjaXR5OiAwJTtcXG4gIH1cXG59XFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vY2xvdWR5bWFuL2NsaWVudC9zcmMvc3R5bGVzLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTs7RUFFRSxrQkFBa0I7RUFDbEIsa0JBQWtCO0FBQ3BCOztBQUVBOzs7Ozs7Ozs7O0VBVUUsaUJBQWlCO0FBQ25COztBQUVBO0VBQ0Usa0JBQWtCO0VBQ2xCLGFBQWE7RUFDYixZQUFZO0VBQ1osYUFBYTtFQUNiLFNBQVM7RUFDVCxnQkFBZ0I7RUFDaEIsZ0RBQWdEO0VBQ2hELHNCQUFzQjtFQUN0QixzQkFBc0I7RUFDdEIsbUJBQW1CO0VBQ25CLHVCQUF1QjtBQUN6Qjs7QUFFQTtFQUNFLFVBQVU7RUFDVixnQkFBZ0I7RUFDaEIsZ0JBQWdCO0VBQ2hCLFlBQVk7QUFDZDs7QUFFQTtFQUNFLGtCQUFrQjtFQUNsQixNQUFNO0VBQ04sVUFBVTtFQUNWLFdBQVc7RUFDWCxZQUFZO0VBQ1osb0JBQW9CO0VBQ3BCLGlCQUFpQjtFQUNqQixzQkFBc0I7RUFDdEIsYUFBYTtFQUNiLHdDQUF3QztFQUN4QyxrQkFBa0I7QUFDcEI7O0FBRUE7RUFDRSxhQUFhO0VBQ2IsV0FBVztFQUNYLFlBQVk7RUFDWixzQkFBc0I7RUFDdEIsMkJBQTJCO0VBQzNCLG1CQUFtQjtBQUNyQjs7QUFFQTtFQUNFLGtCQUFrQjtFQUNsQixhQUFhO0VBQ2IsZUFBZTtFQUNmLGdCQUFnQjtFQUNoQixzQkFBc0I7RUFDdEIsdUJBQXVCO0VBQ3ZCLG1CQUFtQjtFQUNuQix1Q0FBdUM7QUFDekM7O0FBRUE7O0VBRUUsa0JBQWtCO0VBQ2xCLE9BQU87RUFDUCxXQUFXO0VBQ1gsV0FBVztFQUNYLHVCQUF1QjtFQUN2QixpQkFBaUI7QUFDbkI7O0FBRUE7RUFDRSxhQUFhO0VBQ2IsY0FBYztFQUNkLHNCQUFzQjtFQUN0QixpQkFBaUI7RUFDakIsdUJBQXVCO0VBQ3ZCLG1CQUFtQjtFQUNuQixrQkFBa0I7QUFDcEI7O0FBRUE7RUFDRSxrQkFBa0I7RUFDbEIsUUFBUTtFQUNSLFVBQVU7RUFDVixTQUFTO0VBQ1QsZUFBZTtFQUNmLFlBQVk7RUFDWixpQkFBaUI7RUFDakIsV0FBVztFQUNYLG1CQUFtQjtFQUNuQiwyQ0FBMkM7RUFDM0Msa0JBQWtCO0FBQ3BCOztBQUVBO0VBQ0UsVUFBVTtFQUNWLGVBQWU7RUFDZixnQkFBZ0I7RUFDaEIsb0JBQW9CO0VBQ3BCLGlCQUFpQjtFQUNqQixrQkFBa0I7QUFDcEI7O0FBRUE7RUFDRSxvQkFBb0I7QUFDdEI7O0FBRUE7Ozs7RUFJRSxrQkFBa0I7RUFDbEIsVUFBVTtFQUNWLFVBQVU7RUFDVixXQUFXO0FBQ2I7O0FBRUE7O0VBRUUsd0JBQXdCO0FBQzFCOztBQUVBO0VBQ0UsVUFBVTtFQUNWLFdBQVc7QUFDYjs7QUFFQTtFQUNFLFVBQVU7RUFDVixTQUFTO0FBQ1g7O0FBRUE7RUFDRSxRQUFRO0VBQ1IsV0FBVztBQUNiOztBQUVBO0VBQ0UsVUFBVTtFQUNWLFVBQVU7QUFDWjs7QUFFQTtFQUNFLGVBQWU7RUFDZixZQUFZO0VBQ1osYUFBYTtFQUNiLFVBQVU7RUFDVixZQUFZO0VBQ1osWUFBWTtFQUNaLDRCQUE0QjtFQUM1QixlQUFlO0VBQ2YsWUFBWTtFQUNaLG1CQUFtQjtFQUNuQixrQkFBa0I7RUFDbEIsMENBQTBDO0VBQzFDLG1CQUFtQjtBQUNyQjs7QUFFQTtFQUNFO0lBQ0UsZUFBZTtFQUNqQjs7RUFFQTtJQUNFLG1CQUFtQjtFQUNyQjtBQUNGOztBQUVBO0VBQ0U7SUFDRSxXQUFXO0VBQ2I7O0VBRUE7SUFDRSxhQUFhO0VBQ2Y7QUFDRjs7QUFFQTtFQUNFO0lBQ0UsYUFBYTtFQUNmOztFQUVBO0lBQ0UsV0FBVztFQUNiO0FBQ0ZcIixcInNvdXJjZXNDb250ZW50XCI6W1wiaHRtbCxcXG5ib2R5IHtcXG4gIG92ZXJmbG93LXg6IGhpZGRlbjtcXG4gIG92ZXJmbG93LXk6IGhpZGRlbjtcXG59XFxuXFxuaHRtbCxcXG5ib2R5LFxcbmNhbnZhcyxcXG5pbWcsXFxuaDEsXFxuI3RpdGxlLFxcbiN1cCxcXG4jcmlnaHQsXFxuI2Rvd24sXFxuI2xlZnQsIHtcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbn1cXG5cXG5ib2R5IHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICB3aWR0aDogMTAwdnc7XFxuICBoZWlnaHQ6IDEwMHZoO1xcbiAgbWFyZ2luOiAwO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIGZvbnQtZmFtaWx5OiBWZXJkYW5hLCBHZW5ldmEsIFRhaG9tYSwgc2Fucy1zZXJpZjtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDAwO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbn1cXG5cXG5idXR0b24ge1xcbiAgcGFkZGluZzogMDtcXG4gIGZvbnQtd2VpZ2h0OiA5MDA7XFxuICBiYWNrZ3JvdW5kOiBub25lO1xcbiAgYm9yZGVyOiBub25lO1xcbn1cXG5cXG4jZmFkZU91dCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICB6LWluZGV4OiAyO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzAwMDtcXG4gIG9wYWNpdHk6IDEwMCU7XFxuICBhbmltYXRpb246IGZhZGVPdXQgMXMgbGluZWFyIDBzIGZvcndhcmRzO1xcbiAgdG91Y2gtYWN0aW9uOiBub25lO1xcbn1cXG5cXG4jYXBwIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG5cXG4jZ2FtZVdyYXBwZXIge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIG1heC13aWR0aDogMTAwJTtcXG4gIG1heC1oZWlnaHQ6IDEwMCU7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgYW5pbWF0aW9uOiBmYWRlSW4gMXMgbGluZWFyIDBzIGZvcndhcmRzO1xcbn1cXG5cXG4jYmxhY2tTY3JlZW4sXFxuI2dhbWUge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAyJTtcXG4gIHdpZHRoOiBhdXRvO1xcbiAgaGVpZ2h0OiA0OSU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjaztcXG4gIGJvcmRlci1yYWRpdXM6IDUlO1xcbn1cXG5cXG4jYmxhY2tTY3JlZW4ge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIG1pbi13aWR0aDogNjglO1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgdG91Y2gtYWN0aW9uOiBub25lO1xcbn1cXG5cXG4jdGl0bGUge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA0NCU7XFxuICB6LWluZGV4OiAzO1xcbiAgbWFyZ2luOiAwO1xcbiAgZm9udC1zaXplOiAxMDAlO1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICBvcGFjaXR5OiAwJTtcXG4gIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICBhbmltYXRpb246IGZhZGVJbiAwLjNzIGxpbmVhciAxLjVzIGZvcndhcmRzO1xcbiAgdG91Y2gtYWN0aW9uOiBub25lO1xcbn1cXG5cXG4jYmFja2dyb3VuZCB7XFxuICB6LWluZGV4OiAxO1xcbiAgbWF4LXdpZHRoOiAxMDAlO1xcbiAgbWF4LWhlaWdodDogMTAwJTtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICB0b3VjaC1hY3Rpb246IG5vbmU7XFxufVxcblxcbiNjb250cm9scyB7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuXFxuI3VwLFxcbiNyaWdodCxcXG4jZG93bixcXG4jbGVmdCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB6LWluZGV4OiA1O1xcbiAgd2lkdGg6IDE1JTtcXG4gIGhlaWdodDogMTAlO1xcbn1cXG5cXG4jcmlnaHQsXFxuI2xlZnQge1xcbiAgdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpO1xcbn1cXG5cXG4jdXAge1xcbiAgdG9wOiA1My42JTtcXG4gIGxlZnQ6IDE2LjMlO1xcbn1cXG5cXG4jcmlnaHQge1xcbiAgdG9wOiA2MS44JTtcXG4gIGxlZnQ6IDMxJTtcXG59XFxuXFxuI2Rvd24ge1xcbiAgdG9wOiA3MCU7XFxuICBsZWZ0OiAxNi4zJTtcXG59XFxuXFxuI2xlZnQge1xcbiAgdG9wOiA2MS44JTtcXG4gIGxlZnQ6IDEuNSU7XFxufVxcblxcbiN6b29tIHtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHJpZ2h0OiAtMTBweDtcXG4gIGJvdHRvbTogLTEwcHg7XFxuICB6LWluZGV4OiA2O1xcbiAgd2lkdGg6IDEwMHB4O1xcbiAgaGVpZ2h0OiA1MHB4O1xcbiAgcGFkZGluZzogMTBweCAyMHB4IDIwcHggMTBweDtcXG4gIGZvbnQtc2l6ZTogMTVweDtcXG4gIGNvbG9yOiBibGFjaztcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuICB2aXNpYmlsaXR5OiBoaWRkZW47XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSk7XFxuICBib3JkZXItcmFkaXVzOiAxMHB4O1xcbn1cXG5cXG5AbWVkaWEgKG1pbi13aWR0aDogNDAwcHgpLCAobWluLWhlaWdodDogOTYwcHgpIHtcXG4gICN0aXRsZSB7XFxuICAgIGZvbnQtc2l6ZTogMjAwJTtcXG4gIH1cXG5cXG4gICN6b29tIHtcXG4gICAgdmlzaWJpbGl0eTogdmlzaWJsZTtcXG4gIH1cXG59XFxuXFxuQGtleWZyYW1lcyBmYWRlSW4ge1xcbiAgZnJvbSB7XFxuICAgIG9wYWNpdHk6IDAlO1xcbiAgfVxcblxcbiAgdG8ge1xcbiAgICBvcGFjaXR5OiAxMDAlO1xcbiAgfVxcbn1cXG5cXG5Aa2V5ZnJhbWVzIGZhZGVPdXQge1xcbiAgZnJvbSB7XFxuICAgIG9wYWNpdHk6IDEwMCU7XFxuICB9XFxuXFxuICB0byB7XFxuICAgIG9wYWNpdHk6IDAlO1xcbiAgfVxcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLyoqKiBUaGUgbmV3IENTUyBSZXNldCAtIHZlcnNpb24gMS40LjEgKGxhc3QgdXBkYXRlZCAyMy4xMS4yMDIxKSAqKiovXFxuXFxuLypcXG4gICAgUmVtb3ZlIGFsbCB0aGUgc3R5bGVzIG9mIHRoZSBcXFwiVXNlci1BZ2VudC1TdHlsZXNoZWV0XFxcIiwgZXhjZXB0IGZvciB0aGUgJ2Rpc3BsYXknIHByb3BlcnR5XFxuICAgIC0gVGhlIFxcXCJzeW1ib2wgKlxcXCIgcGFydCBpcyB0byBzb2x2ZSBGaXJlZm94IFNWRyBzcHJpdGUgYnVnXFxuICovXFxuKjp3aGVyZSg6bm90KGlmcmFtZSwgY2FudmFzLCBpbWcsIHN2ZywgdmlkZW8pOm5vdChzdmcgKiwgc3ltYm9sICopKSB7XFxuICAgIGFsbDogdW5zZXQ7XFxuICAgIGRpc3BsYXk6IHJldmVydDtcXG59XFxuXFxuLyogUHJlZmVycmVkIGJveC1zaXppbmcgdmFsdWUgKi9cXG4qLFxcbio6OmJlZm9yZSxcXG4qOjphZnRlciB7XFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxufVxcblxcbi8qIFJlbW92ZSBsaXN0IHN0eWxlcyAoYnVsbGV0cy9udW1iZXJzKSAqL1xcbm9sLCB1bCB7XFxuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XFxufVxcblxcbi8qIEZvciBpbWFnZXMgdG8gbm90IGJlIGFibGUgdG8gZXhjZWVkIHRoZWlyIGNvbnRhaW5lciAqL1xcbmltZyB7XFxuICAgIG1heC13aWR0aDogMTAwJTtcXG59XFxuXFxuLyogcmVtb3ZlcyBzcGFjaW5nIGJldHdlZW4gY2VsbHMgaW4gdGFibGVzICovXFxudGFibGUge1xcbiAgICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbn1cXG5cXG4vKiByZXZlcnQgdGhlICd3aGl0ZS1zcGFjZScgcHJvcGVydHkgZm9yIHRleHRhcmVhIGVsZW1lbnRzIG9uIFNhZmFyaSAqL1xcbnRleHRhcmVhIHtcXG4gICAgd2hpdGUtc3BhY2U6IHJldmVydDtcXG59XFxuXFxuLyogcmV2ZXJ0IGZvciBidWcgaW4gQ2hyb21pdW0gYnJvd3NlcnNcXG4gICAtIGZpeCBmb3IgdGhlIGNvbnRlbnQgZWRpdGFibGUgYXR0cmlidXRlIHdpbGwgd29yayBwcm9wZXJseS4gKi9cXG46d2hlcmUoW2NvbnRlbnRlZGl0YWJsZV0pe1xcbiAgICAtbW96LXVzZXItbW9kaWZ5OiByZWFkLXdyaXRlO1xcbiAgICAtd2Via2l0LXVzZXItbW9kaWZ5OiByZWFkLXdyaXRlO1xcbiAgICBvdmVyZmxvdy13cmFwOiBicmVhay13b3JkO1xcbiAgICAtd2Via2l0LWxpbmUtYnJlYWs6IGFmdGVyLXdoaXRlLXNwYWNlO1xcbn1cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9ub2RlX21vZHVsZXMvdGhlLW5ldy1jc3MtcmVzZXQvY3NzL3Jlc2V0LmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSxvRUFBb0U7O0FBRXBFOzs7RUFHRTtBQUNGO0lBQ0ksVUFBVTtJQUNWLGVBQWU7QUFDbkI7O0FBRUEsK0JBQStCO0FBQy9COzs7SUFHSSxzQkFBc0I7QUFDMUI7O0FBRUEseUNBQXlDO0FBQ3pDO0lBQ0ksZ0JBQWdCO0FBQ3BCOztBQUVBLHdEQUF3RDtBQUN4RDtJQUNJLGVBQWU7QUFDbkI7O0FBRUEsNENBQTRDO0FBQzVDO0lBQ0kseUJBQXlCO0FBQzdCOztBQUVBLHNFQUFzRTtBQUN0RTtJQUNJLG1CQUFtQjtBQUN2Qjs7QUFFQTtpRUFDaUU7QUFDakU7SUFDSSw0QkFBNEI7SUFDNUIsK0JBQStCO0lBQy9CLHlCQUF5QjtJQUN6QixxQ0FBcUM7QUFDekNcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLyoqKiBUaGUgbmV3IENTUyBSZXNldCAtIHZlcnNpb24gMS40LjEgKGxhc3QgdXBkYXRlZCAyMy4xMS4yMDIxKSAqKiovXFxuXFxuLypcXG4gICAgUmVtb3ZlIGFsbCB0aGUgc3R5bGVzIG9mIHRoZSBcXFwiVXNlci1BZ2VudC1TdHlsZXNoZWV0XFxcIiwgZXhjZXB0IGZvciB0aGUgJ2Rpc3BsYXknIHByb3BlcnR5XFxuICAgIC0gVGhlIFxcXCJzeW1ib2wgKlxcXCIgcGFydCBpcyB0byBzb2x2ZSBGaXJlZm94IFNWRyBzcHJpdGUgYnVnXFxuICovXFxuKjp3aGVyZSg6bm90KGlmcmFtZSwgY2FudmFzLCBpbWcsIHN2ZywgdmlkZW8pOm5vdChzdmcgKiwgc3ltYm9sICopKSB7XFxuICAgIGFsbDogdW5zZXQ7XFxuICAgIGRpc3BsYXk6IHJldmVydDtcXG59XFxuXFxuLyogUHJlZmVycmVkIGJveC1zaXppbmcgdmFsdWUgKi9cXG4qLFxcbio6OmJlZm9yZSxcXG4qOjphZnRlciB7XFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxufVxcblxcbi8qIFJlbW92ZSBsaXN0IHN0eWxlcyAoYnVsbGV0cy9udW1iZXJzKSAqL1xcbm9sLCB1bCB7XFxuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XFxufVxcblxcbi8qIEZvciBpbWFnZXMgdG8gbm90IGJlIGFibGUgdG8gZXhjZWVkIHRoZWlyIGNvbnRhaW5lciAqL1xcbmltZyB7XFxuICAgIG1heC13aWR0aDogMTAwJTtcXG59XFxuXFxuLyogcmVtb3ZlcyBzcGFjaW5nIGJldHdlZW4gY2VsbHMgaW4gdGFibGVzICovXFxudGFibGUge1xcbiAgICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbn1cXG5cXG4vKiByZXZlcnQgdGhlICd3aGl0ZS1zcGFjZScgcHJvcGVydHkgZm9yIHRleHRhcmVhIGVsZW1lbnRzIG9uIFNhZmFyaSAqL1xcbnRleHRhcmVhIHtcXG4gICAgd2hpdGUtc3BhY2U6IHJldmVydDtcXG59XFxuXFxuLyogcmV2ZXJ0IGZvciBidWcgaW4gQ2hyb21pdW0gYnJvd3NlcnNcXG4gICAtIGZpeCBmb3IgdGhlIGNvbnRlbnQgZWRpdGFibGUgYXR0cmlidXRlIHdpbGwgd29yayBwcm9wZXJseS4gKi9cXG46d2hlcmUoW2NvbnRlbnRlZGl0YWJsZV0pe1xcbiAgICAtbW96LXVzZXItbW9kaWZ5OiByZWFkLXdyaXRlO1xcbiAgICAtd2Via2l0LXVzZXItbW9kaWZ5OiByZWFkLXdyaXRlO1xcbiAgICBvdmVyZmxvdy13cmFwOiBicmVhay13b3JkO1xcbiAgICAtd2Via2l0LWxpbmUtYnJlYWs6IGFmdGVyLXdoaXRlLXNwYWNlO1xcbn1cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IFwiXCI7XG4gICAgICB2YXIgbmVlZExheWVyID0gdHlwZW9mIGl0ZW1bNV0gIT09IFwidW5kZWZpbmVkXCI7XG5cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnRlbnQgKz0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtKTtcblxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gaShtb2R1bGVzLCBtZWRpYSwgZGVkdXBlLCBzdXBwb3J0cywgbGF5ZXIpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIHVuZGVmaW5lZF1dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGlkID0gdGhpc1trXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9rID0gMDsgX2sgPCBtb2R1bGVzLmxlbmd0aDsgX2srKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfa10pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgbGF5ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtWzVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdXBwb3J0cykge1xuICAgICAgICBpZiAoIWl0ZW1bNF0pIHtcbiAgICAgICAgICBpdGVtWzRdID0gXCJcIi5jb25jYXQoc3VwcG9ydHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs0XSA9IHN1cHBvcnRzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXTtcbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoY3NzTWFwcGluZykpKSk7XG4gICAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgXCJcIikuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbihcIlxcblwiKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5cyA9IHJlcXVpcmUoJ29iamVjdC1rZXlzJyk7XG52YXIgaGFzU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbCgnZm9vJykgPT09ICdzeW1ib2wnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGNvbmNhdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQ7XG52YXIgb3JpZ0RlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIChmbikge1xuXHRyZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHRvU3RyLmNhbGwoZm4pID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudmFyIGFyZVByb3BlcnR5RGVzY3JpcHRvcnNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBvYmogPSB7fTtcblx0dHJ5IHtcblx0XHRvcmlnRGVmaW5lUHJvcGVydHkob2JqLCAneCcsIHsgZW51bWVyYWJsZTogZmFsc2UsIHZhbHVlOiBvYmogfSk7XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzLCBuby1yZXN0cmljdGVkLXN5bnRheFxuXHRcdGZvciAodmFyIF8gaW4gb2JqKSB7IC8vIGpzY3M6aWdub3JlIGRpc2FsbG93VW51c2VkVmFyaWFibGVzXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiBvYmoueCA9PT0gb2JqO1xuXHR9IGNhdGNoIChlKSB7IC8qIHRoaXMgaXMgSUUgOC4gKi9cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG52YXIgc3VwcG9ydHNEZXNjcmlwdG9ycyA9IG9yaWdEZWZpbmVQcm9wZXJ0eSAmJiBhcmVQcm9wZXJ0eURlc2NyaXB0b3JzU3VwcG9ydGVkKCk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIHZhbHVlLCBwcmVkaWNhdGUpIHtcblx0aWYgKG5hbWUgaW4gb2JqZWN0ICYmICghaXNGdW5jdGlvbihwcmVkaWNhdGUpIHx8ICFwcmVkaWNhdGUoKSkpIHtcblx0XHRyZXR1cm47XG5cdH1cblx0aWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcblx0XHRvcmlnRGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdHdyaXRhYmxlOiB0cnVlXG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0b2JqZWN0W25hbWVdID0gdmFsdWU7XG5cdH1cbn07XG5cbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iamVjdCwgbWFwKSB7XG5cdHZhciBwcmVkaWNhdGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB7fTtcblx0dmFyIHByb3BzID0ga2V5cyhtYXApO1xuXHRpZiAoaGFzU3ltYm9scykge1xuXHRcdHByb3BzID0gY29uY2F0LmNhbGwocHJvcHMsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobWFwKSk7XG5cdH1cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcHNbaV0sIG1hcFtwcm9wc1tpXV0sIHByZWRpY2F0ZXNbcHJvcHNbaV1dKTtcblx0fVxufTtcblxuZGVmaW5lUHJvcGVydGllcy5zdXBwb3J0c0Rlc2NyaXB0b3JzID0gISFzdXBwb3J0c0Rlc2NyaXB0b3JzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnRpZXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4vc2hpbScpKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29udGFpbnMob3RoZXIpIHtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCBpcyByZXF1aXJlZCcpO1xuXHR9XG5cdGlmICh0eXBlb2Ygb3RoZXIgIT09ICdvYmplY3QnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgMSAo4oCdb3RoZXLigJwpIHRvIE5vZGUuY29udGFpbnMgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlJyk7XG5cdH1cblxuXHR2YXIgbm9kZSA9IG90aGVyO1xuXHRkbyB7XG5cdFx0aWYgKHRoaXMgPT09IG5vZGUpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRpZiAobm9kZSkge1xuXHRcdFx0bm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcblx0XHR9XG5cdH0gd2hpbGUgKG5vZGUpO1xuXG5cdHJldHVybiBmYWxzZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcblx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRpZiAoZG9jdW1lbnQuY29udGFpbnMpIHtcblx0XHRcdHJldHVybiBkb2N1bWVudC5jb250YWlucztcblx0XHR9XG5cdFx0aWYgKGRvY3VtZW50LmJvZHkgJiYgZG9jdW1lbnQuYm9keS5jb250YWlucykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKHR5cGVvZiBkb2N1bWVudC5ib2R5LmNvbnRhaW5zLmNhbGwoZG9jdW1lbnQsICcnKSA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRvY3VtZW50LmJvZHkuY29udGFpbnM7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHsgLyoqLyB9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1Db250YWlucygpIHtcblx0dmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcblx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRkZWZpbmUoXG5cdFx0XHRkb2N1bWVudCxcblx0XHRcdHsgY29udGFpbnM6IHBvbHlmaWxsIH0sXG5cdFx0XHR7IGNvbnRhaW5zOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb2N1bWVudC5jb250YWlucyAhPT0gcG9seWZpbGw7IH0gfVxuXHRcdCk7XG5cdFx0aWYgKHR5cGVvZiBFbGVtZW50ICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0ZGVmaW5lKFxuXHRcdFx0XHRFbGVtZW50LnByb3RvdHlwZSxcblx0XHRcdFx0eyBjb250YWluczogcG9seWZpbGwgfSxcblx0XHRcdFx0eyBjb250YWluczogZnVuY3Rpb24gKCkgeyByZXR1cm4gRWxlbWVudC5wcm90b3R5cGUuY29udGFpbnMgIT09IHBvbHlmaWxsOyB9IH1cblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG4iLCIvLyBlbGVtZW50LWNsb3Nlc3QgfCBDQzAtMS4wIHwgZ2l0aHViLmNvbS9qb25hdGhhbnRuZWFsL2Nsb3Nlc3RcblxuKGZ1bmN0aW9uIChFbGVtZW50UHJvdG8pIHtcblx0aWYgKHR5cGVvZiBFbGVtZW50UHJvdG8ubWF0Y2hlcyAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdEVsZW1lbnRQcm90by5tYXRjaGVzID0gRWxlbWVudFByb3RvLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnRQcm90by5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudFByb3RvLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBmdW5jdGlvbiBtYXRjaGVzKHNlbGVjdG9yKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IHRoaXM7XG5cdFx0XHR2YXIgZWxlbWVudHMgPSAoZWxlbWVudC5kb2N1bWVudCB8fCBlbGVtZW50Lm93bmVyRG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuXHRcdFx0dmFyIGluZGV4ID0gMDtcblxuXHRcdFx0d2hpbGUgKGVsZW1lbnRzW2luZGV4XSAmJiBlbGVtZW50c1tpbmRleF0gIT09IGVsZW1lbnQpIHtcblx0XHRcdFx0KytpbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIEJvb2xlYW4oZWxlbWVudHNbaW5kZXhdKTtcblx0XHR9O1xuXHR9XG5cblx0aWYgKHR5cGVvZiBFbGVtZW50UHJvdG8uY2xvc2VzdCAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdEVsZW1lbnRQcm90by5jbG9zZXN0ID0gZnVuY3Rpb24gY2xvc2VzdChzZWxlY3Rvcikge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSB0aGlzO1xuXG5cdFx0XHR3aGlsZSAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlID09PSAxKSB7XG5cdFx0XHRcdGlmIChlbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHR9XG59KSh3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwcm9wZXJseUJveGVkKG1ldGhvZCkge1xuXHQvLyBDaGVjayBub2RlIDAuNi4yMSBidWcgd2hlcmUgdGhpcmQgcGFyYW1ldGVyIGlzIG5vdCBib3hlZFxuXHR2YXIgcHJvcGVybHlCb3hlc05vblN0cmljdCA9IHRydWU7XG5cdHZhciBwcm9wZXJseUJveGVzU3RyaWN0ID0gdHJ1ZTtcblx0dmFyIHRocmV3RXhjZXB0aW9uID0gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zXG5cdFx0XHRtZXRob2QuY2FsbCgnZicsIGZ1bmN0aW9uIChfLCBfXywgTykge1xuXHRcdFx0XHRpZiAodHlwZW9mIE8gIT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0cHJvcGVybHlCb3hlc05vblN0cmljdCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0bWV0aG9kLmNhbGwoXG5cdFx0XHRcdFtudWxsXSxcblx0XHRcdFx0ZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdCd1c2Ugc3RyaWN0JztcblxuXHRcdFx0XHRcdHByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0eXBlb2YgdGhpcyA9PT0gJ3N0cmluZyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW52YWxpZC10aGlzXG5cdFx0XHRcdH0sXG5cdFx0XHRcdCd4J1xuXHRcdFx0KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHR0aHJld0V4Y2VwdGlvbiA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAhdGhyZXdFeGNlcHRpb24gJiYgcHJvcGVybHlCb3hlc05vblN0cmljdCAmJiBwcm9wZXJseUJveGVzU3RyaWN0O1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc1N5bWJvbHMgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnO1xuXG52YXIgaXNQcmltaXRpdmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNQcmltaXRpdmUnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnaXMtY2FsbGFibGUnKTtcbnZhciBpc0RhdGUgPSByZXF1aXJlKCdpcy1kYXRlLW9iamVjdCcpO1xudmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnaXMtc3ltYm9sJyk7XG5cbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlID0gZnVuY3Rpb24gT3JkaW5hcnlUb1ByaW1pdGl2ZShPLCBoaW50KSB7XG5cdGlmICh0eXBlb2YgTyA9PT0gJ3VuZGVmaW5lZCcgfHwgTyA9PT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIG1ldGhvZCBvbiAnICsgTyk7XG5cdH1cblx0aWYgKHR5cGVvZiBoaW50ICE9PSAnc3RyaW5nJyB8fCAoaGludCAhPT0gJ251bWJlcicgJiYgaGludCAhPT0gJ3N0cmluZycpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignaGludCBtdXN0IGJlIFwic3RyaW5nXCIgb3IgXCJudW1iZXJcIicpO1xuXHR9XG5cdHZhciBtZXRob2ROYW1lcyA9IGhpbnQgPT09ICdzdHJpbmcnID8gWyd0b1N0cmluZycsICd2YWx1ZU9mJ10gOiBbJ3ZhbHVlT2YnLCAndG9TdHJpbmcnXTtcblx0dmFyIG1ldGhvZCwgcmVzdWx0LCBpO1xuXHRmb3IgKGkgPSAwOyBpIDwgbWV0aG9kTmFtZXMubGVuZ3RoOyArK2kpIHtcblx0XHRtZXRob2QgPSBPW21ldGhvZE5hbWVzW2ldXTtcblx0XHRpZiAoaXNDYWxsYWJsZShtZXRob2QpKSB7XG5cdFx0XHRyZXN1bHQgPSBtZXRob2QuY2FsbChPKTtcblx0XHRcdGlmIChpc1ByaW1pdGl2ZShyZXN1bHQpKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHRocm93IG5ldyBUeXBlRXJyb3IoJ05vIGRlZmF1bHQgdmFsdWUnKTtcbn07XG5cbnZhciBHZXRNZXRob2QgPSBmdW5jdGlvbiBHZXRNZXRob2QoTywgUCkge1xuXHR2YXIgZnVuYyA9IE9bUF07XG5cdGlmIChmdW5jICE9PSBudWxsICYmIHR5cGVvZiBmdW5jICE9PSAndW5kZWZpbmVkJykge1xuXHRcdGlmICghaXNDYWxsYWJsZShmdW5jKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihmdW5jICsgJyByZXR1cm5lZCBmb3IgcHJvcGVydHkgJyArIFAgKyAnIG9mIG9iamVjdCAnICsgTyArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZ1bmM7XG5cdH1cblx0cmV0dXJuIHZvaWQgMDtcbn07XG5cbi8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b3ByaW1pdGl2ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBUb1ByaW1pdGl2ZShpbnB1dCkge1xuXHRpZiAoaXNQcmltaXRpdmUoaW5wdXQpKSB7XG5cdFx0cmV0dXJuIGlucHV0O1xuXHR9XG5cdHZhciBoaW50ID0gJ2RlZmF1bHQnO1xuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRpZiAoYXJndW1lbnRzWzFdID09PSBTdHJpbmcpIHtcblx0XHRcdGhpbnQgPSAnc3RyaW5nJztcblx0XHR9IGVsc2UgaWYgKGFyZ3VtZW50c1sxXSA9PT0gTnVtYmVyKSB7XG5cdFx0XHRoaW50ID0gJ251bWJlcic7XG5cdFx0fVxuXHR9XG5cblx0dmFyIGV4b3RpY1RvUHJpbTtcblx0aWYgKGhhc1N5bWJvbHMpIHtcblx0XHRpZiAoU3ltYm9sLnRvUHJpbWl0aXZlKSB7XG5cdFx0XHRleG90aWNUb1ByaW0gPSBHZXRNZXRob2QoaW5wdXQsIFN5bWJvbC50b1ByaW1pdGl2ZSk7XG5cdFx0fSBlbHNlIGlmIChpc1N5bWJvbChpbnB1dCkpIHtcblx0XHRcdGV4b3RpY1RvUHJpbSA9IFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZjtcblx0XHR9XG5cdH1cblx0aWYgKHR5cGVvZiBleG90aWNUb1ByaW0gIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0dmFyIHJlc3VsdCA9IGV4b3RpY1RvUHJpbS5jYWxsKGlucHV0LCBoaW50KTtcblx0XHRpZiAoaXNQcmltaXRpdmUocmVzdWx0KSkge1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcigndW5hYmxlIHRvIGNvbnZlcnQgZXhvdGljIG9iamVjdCB0byBwcmltaXRpdmUnKTtcblx0fVxuXHRpZiAoaGludCA9PT0gJ2RlZmF1bHQnICYmIChpc0RhdGUoaW5wdXQpIHx8IGlzU3ltYm9sKGlucHV0KSkpIHtcblx0XHRoaW50ID0gJ3N0cmluZyc7XG5cdH1cblx0cmV0dXJuIG9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIGhpbnQgPT09ICdkZWZhdWx0JyA/ICdudW1iZXInIDogaGludCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG52YXIgaXNQcmltaXRpdmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNQcmltaXRpdmUnKTtcblxudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCdpcy1jYWxsYWJsZScpO1xuXG4vLyBodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy04LjEyLjhcbnZhciBFUzVpbnRlcm5hbFNsb3RzID0ge1xuXHQnW1tEZWZhdWx0VmFsdWVdXSc6IGZ1bmN0aW9uIChPKSB7XG5cdFx0dmFyIGFjdHVhbEhpbnQ7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRhY3R1YWxIaW50ID0gYXJndW1lbnRzWzFdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhY3R1YWxIaW50ID0gdG9TdHIuY2FsbChPKSA9PT0gJ1tvYmplY3QgRGF0ZV0nID8gU3RyaW5nIDogTnVtYmVyO1xuXHRcdH1cblxuXHRcdGlmIChhY3R1YWxIaW50ID09PSBTdHJpbmcgfHwgYWN0dWFsSGludCA9PT0gTnVtYmVyKSB7XG5cdFx0XHR2YXIgbWV0aG9kcyA9IGFjdHVhbEhpbnQgPT09IFN0cmluZyA/IFsndG9TdHJpbmcnLCAndmFsdWVPZiddIDogWyd2YWx1ZU9mJywgJ3RvU3RyaW5nJ107XG5cdFx0XHR2YXIgdmFsdWUsIGk7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbWV0aG9kcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRpZiAoaXNDYWxsYWJsZShPW21ldGhvZHNbaV1dKSkge1xuXHRcdFx0XHRcdHZhbHVlID0gT1ttZXRob2RzW2ldXSgpO1xuXHRcdFx0XHRcdGlmIChpc1ByaW1pdGl2ZSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ05vIGRlZmF1bHQgdmFsdWUnKTtcblx0XHR9XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBbW0RlZmF1bHRWYWx1ZV1dIGhpbnQgc3VwcGxpZWQnKTtcblx0fVxufTtcblxuLy8gaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtOS4xXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvUHJpbWl0aXZlKGlucHV0KSB7XG5cdGlmIChpc1ByaW1pdGl2ZShpbnB1dCkpIHtcblx0XHRyZXR1cm4gaW5wdXQ7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0cmV0dXJuIEVTNWludGVybmFsU2xvdHNbJ1tbRGVmYXVsdFZhbHVlXV0nXShpbnB1dCwgYXJndW1lbnRzWzFdKTtcblx0fVxuXHRyZXR1cm4gRVM1aW50ZXJuYWxTbG90c1snW1tEZWZhdWx0VmFsdWVdXSddKGlucHV0KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlID09PSBudWxsIHx8ICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jyk7XG59O1xuIiwiLyohXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cbiAqIEBsaWNlbnNlIGVzNS1zaGltIENvcHlyaWdodCAyMDA5LTIwMjAgYnkgY29udHJpYnV0b3JzLCBNSVQgTGljZW5zZVxuICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKi9cblxuLy8gdmltOiB0cz00IHN0cz00IHN3PTQgZXhwYW5kdGFiXG5cbi8vIEFkZCBzZW1pY29sb24gdG8gcHJldmVudCBJSUZFIGZyb20gYmVpbmcgcGFzc2VkIGFzIGFyZ3VtZW50IHRvIGNvbmNhdGVuYXRlZCBjb2RlLlxuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV4dHJhLXNlbWlcblxuLy8gVU1EIChVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24pXG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3VtZGpzL3VtZC9ibG9iL21hc3Rlci90ZW1wbGF0ZXMvcmV0dXJuRXhwb3J0cy5qc1xuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyogZ2xvYmFsIGRlZmluZSAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgICAgIC8vIGxpa2UgTm9kZS5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcbiAgICAgICAgcm9vdC5yZXR1cm5FeHBvcnRzID0gZmFjdG9yeSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgY2FsbCA9IEZ1bmN0aW9uLmNhbGw7XG4gICAgdmFyIHByb3RvdHlwZU9mT2JqZWN0ID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgICB2YXIgb3ducyA9IGNhbGwuYmluZChwcm90b3R5cGVPZk9iamVjdC5oYXNPd25Qcm9wZXJ0eSk7XG4gICAgdmFyIGlzRW51bWVyYWJsZSA9IGNhbGwuYmluZChwcm90b3R5cGVPZk9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZSk7XG4gICAgdmFyIHRvU3RyID0gY2FsbC5iaW5kKHByb3RvdHlwZU9mT2JqZWN0LnRvU3RyaW5nKTtcblxuICAgIC8vIElmIEpTIGVuZ2luZSBzdXBwb3J0cyBhY2Nlc3NvcnMgY3JlYXRpbmcgc2hvcnRjdXRzLlxuICAgIHZhciBkZWZpbmVHZXR0ZXI7XG4gICAgdmFyIGRlZmluZVNldHRlcjtcbiAgICB2YXIgbG9va3VwR2V0dGVyO1xuICAgIHZhciBsb29rdXBTZXR0ZXI7XG4gICAgdmFyIHN1cHBvcnRzQWNjZXNzb3JzID0gb3ducyhwcm90b3R5cGVPZk9iamVjdCwgJ19fZGVmaW5lR2V0dGVyX18nKTtcbiAgICBpZiAoc3VwcG9ydHNBY2Nlc3NvcnMpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZXJzY29yZS1kYW5nbGUsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllcyAqL1xuICAgICAgICBkZWZpbmVHZXR0ZXIgPSBjYWxsLmJpbmQocHJvdG90eXBlT2ZPYmplY3QuX19kZWZpbmVHZXR0ZXJfXyk7XG4gICAgICAgIGRlZmluZVNldHRlciA9IGNhbGwuYmluZChwcm90b3R5cGVPZk9iamVjdC5fX2RlZmluZVNldHRlcl9fKTtcbiAgICAgICAgbG9va3VwR2V0dGVyID0gY2FsbC5iaW5kKHByb3RvdHlwZU9mT2JqZWN0Ll9fbG9va3VwR2V0dGVyX18pO1xuICAgICAgICBsb29rdXBTZXR0ZXIgPSBjYWxsLmJpbmQocHJvdG90eXBlT2ZPYmplY3QuX19sb29rdXBTZXR0ZXJfXyk7XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5kZXJzY29yZS1kYW5nbGUsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllcyAqL1xuICAgIH1cblxuICAgIHZhciBpc1ByaW1pdGl2ZSA9IGZ1bmN0aW9uIGlzUHJpbWl0aXZlKG8pIHtcbiAgICAgICAgcmV0dXJuIG8gPT0gbnVsbCB8fCAodHlwZW9mIG8gIT09ICdvYmplY3QnICYmIHR5cGVvZiBvICE9PSAnZnVuY3Rpb24nKTtcbiAgICB9O1xuXG4gICAgLy8gRVM1IDE1LjIuMy4yXG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjJcbiAgICBpZiAoIU9iamVjdC5nZXRQcm90b3R5cGVPZikge1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzI2lzc3VlLzJcbiAgICAgICAgLy8gaHR0cDovL2Vqb2huLm9yZy9ibG9nL29iamVjdGdldHByb3RvdHlwZW9mL1xuICAgICAgICAvLyByZWNvbW1lbmRlZCBieSBmc2NoYWVmZXIgb24gZ2l0aHViXG4gICAgICAgIC8vXG4gICAgICAgIC8vIHN1cmUsIGFuZCB3ZWJyZWZsZWN0aW9uIHNheXMgXl9eXG4gICAgICAgIC8vIC4uLiB0aGlzIHdpbGwgbmVyZXZlciBwb3NzaWJseSByZXR1cm4gbnVsbFxuICAgICAgICAvLyAuLi4gT3BlcmEgTWluaSBicmVha3MgaGVyZSB3aXRoIGluZmluaXRlIGxvb3BzXG4gICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZiA9IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKG9iamVjdCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvXG4gICAgICAgICAgICB2YXIgcHJvdG8gPSBvYmplY3QuX19wcm90b19fO1xuICAgICAgICAgICAgaWYgKHByb3RvIHx8IHByb3RvID09IG51bGwpIHsgLy8gYHVuZGVmaW5lZGAgaXMgZm9yIHByZS1wcm90byBicm93c2Vyc1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm90bztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9TdHIob2JqZWN0LmNvbnN0cnVjdG9yKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3QuY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG90eXBlT2ZPYmplY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb3JyZWN0bHkgcmV0dXJuIG51bGwgZm9yIE9iamVjdHMgY3JlYXRlZCB3aXRoIGBPYmplY3QuY3JlYXRlKG51bGwpYFxuICAgICAgICAgICAgLy8gKHNoYW1tZWQgb3IgbmF0aXZlKSBvciBgeyBfX3Byb3RvX186IG51bGx9YC4gIEFsc28gcmV0dXJucyBudWxsIGZvclxuICAgICAgICAgICAgLy8gY3Jvc3MtcmVhbG0gb2JqZWN0cyBvbiBicm93c2VycyB0aGF0IGxhY2sgYF9fcHJvdG9fX2Agc3VwcG9ydCAobGlrZVxuICAgICAgICAgICAgLy8gSUUgPDExKSwgYnV0IHRoYXQncyB0aGUgYmVzdCB3ZSBjYW4gZG8uXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEVTNSAxNS4yLjMuM1xuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy4zXG5cbiAgICAvLyBjaGVjayB3aGV0aGVyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciB3b3JrcyBpZiBpdCdzIGdpdmVuLiBPdGhlcndpc2UsIHNoaW0gcGFydGlhbGx5LlxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgdmFyIGRvZXNHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JXb3JrID0gZnVuY3Rpb24gZG9lc0dldE93blByb3BlcnR5RGVzY3JpcHRvcldvcmsob2JqZWN0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5zZW50aW5lbCA9IDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsICdzZW50aW5lbCcpLnZhbHVlID09PSAwO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yV29ya3NPbk9iamVjdCA9IGRvZXNHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JXb3JrKHt9KTtcbiAgICAgICAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcldvcmtzT25Eb20gPSB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICB8fCBkb2VzR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yV29yayhkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgICAgIGlmICghZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yV29ya3NPbkRvbSB8fCAhZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yV29ya3NPbk9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvckZhbGxiYWNrID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciB8fCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JGYWxsYmFjaykge1xuICAgICAgICB2YXIgRVJSX05PTl9PQkpFQ1QgPSAnT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciBjYWxsZWQgb24gYSBub24tb2JqZWN0OiAnO1xuXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgaWYgKGlzUHJpbWl0aXZlKG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUl9OT05fT0JKRUNUICsgb2JqZWN0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbWFrZSBhIHZhbGlhbnQgYXR0ZW1wdCB0byB1c2UgdGhlIHJlYWwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXG4gICAgICAgICAgICAvLyBmb3IgSTgncyBET00gZWxlbWVudHMuXG4gICAgICAgICAgICBpZiAoZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yRmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yRmFsbGJhY2suY2FsbChPYmplY3QsIG9iamVjdCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdGhlIHNoaW0gaWYgdGhlIHJlYWwgb25lIGRvZXNuJ3Qgd29ya1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3I7XG5cbiAgICAgICAgICAgIC8vIElmIG9iamVjdCBkb2VzIG5vdCBvd25zIHByb3BlcnR5IHJldHVybiB1bmRlZmluZWQgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICBpZiAoIW93bnMob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgb2JqZWN0IGhhcyBhIHByb3BlcnR5IHRoZW4gaXQncyBmb3Igc3VyZSBgY29uZmlndXJhYmxlYCwgYW5kXG4gICAgICAgICAgICAvLyBwcm9iYWJseSBgZW51bWVyYWJsZWAuIERldGVjdCBlbnVtZXJhYmlsaXR5IHRob3VnaC5cbiAgICAgICAgICAgIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogaXNFbnVtZXJhYmxlKG9iamVjdCwgcHJvcGVydHkpLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gSWYgSlMgZW5naW5lIHN1cHBvcnRzIGFjY2Vzc29yIHByb3BlcnRpZXMgdGhlbiBwcm9wZXJ0eSBtYXkgYmUgYVxuICAgICAgICAgICAgLy8gZ2V0dGVyIG9yIHNldHRlci5cbiAgICAgICAgICAgIGlmIChzdXBwb3J0c0FjY2Vzc29ycykge1xuICAgICAgICAgICAgICAgIC8vIFVuZm9ydHVuYXRlbHkgYF9fbG9va3VwR2V0dGVyX19gIHdpbGwgcmV0dXJuIGEgZ2V0dGVyIGV2ZW5cbiAgICAgICAgICAgICAgICAvLyBpZiBvYmplY3QgaGFzIG93biBub24gZ2V0dGVyIHByb3BlcnR5IGFsb25nIHdpdGggYSBzYW1lIG5hbWVkXG4gICAgICAgICAgICAgICAgLy8gaW5oZXJpdGVkIGdldHRlci4gVG8gYXZvaWQgbWlzYmVoYXZpb3Igd2UgdGVtcG9yYXJ5IHJlbW92ZVxuICAgICAgICAgICAgICAgIC8vIGBfX3Byb3RvX19gIHNvIHRoYXQgYF9fbG9va3VwR2V0dGVyX19gIHdpbGwgcmV0dXJuIGdldHRlciBvbmx5XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQncyBvd25lZCBieSBhbiBvYmplY3QuXG4gICAgICAgICAgICAgICAgdmFyIHByb3RvdHlwZSA9IG9iamVjdC5fX3Byb3RvX187XG4gICAgICAgICAgICAgICAgdmFyIG5vdFByb3RvdHlwZU9mT2JqZWN0ID0gb2JqZWN0ICE9PSBwcm90b3R5cGVPZk9iamVjdDtcbiAgICAgICAgICAgICAgICAvLyBhdm9pZCByZWN1cnNpb24gcHJvYmxlbSwgYnJlYWtpbmcgaW4gT3BlcmEgTWluaSB3aGVuXG4gICAgICAgICAgICAgICAgLy8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAndG9TdHJpbmcnKVxuICAgICAgICAgICAgICAgIC8vIG9yIGFueSBvdGhlciBPYmplY3QucHJvdG90eXBlIGFjY2Vzc29yXG4gICAgICAgICAgICAgICAgaWYgKG5vdFByb3RvdHlwZU9mT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGVPZk9iamVjdDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBnZXR0ZXIgPSBsb29rdXBHZXR0ZXIob2JqZWN0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgdmFyIHNldHRlciA9IGxvb2t1cFNldHRlcihvYmplY3QsIHByb3BlcnR5KTtcblxuICAgICAgICAgICAgICAgIGlmIChub3RQcm90b3R5cGVPZk9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmNlIHdlIGhhdmUgZ2V0dGVyIGFuZCBzZXR0ZXIgd2UgY2FuIHB1dCB2YWx1ZXMgYmFjay5cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChnZXR0ZXIgfHwgc2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IuZ2V0ID0gZ2V0dGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3Iuc2V0ID0gc2V0dGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGl0IHdhcyBhY2Nlc3NvciBwcm9wZXJ0eSB3ZSdyZSBkb25lIGFuZCByZXR1cm4gaGVyZVxuICAgICAgICAgICAgICAgICAgICAvLyBpbiBvcmRlciB0byBhdm9pZCBhZGRpbmcgYHZhbHVlYCB0byB0aGUgZGVzY3JpcHRvci5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB3ZSBnb3QgdGhpcyBmYXIgd2Uga25vdyB0aGF0IG9iamVjdCBoYXMgYW4gb3duIHByb3BlcnR5IHRoYXQgaXNcbiAgICAgICAgICAgIC8vIG5vdCBhbiBhY2Nlc3NvciBzbyB3ZSBzZXQgaXQgYXMgYSB2YWx1ZSBhbmQgcmV0dXJuIGRlc2NyaXB0b3IuXG4gICAgICAgICAgICBkZXNjcmlwdG9yLnZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICAgIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgICAgIH07XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbiAgICB9XG5cbiAgICAvLyBFUzUgMTUuMi4zLjRcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4yLjMuNFxuICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMpIHtcbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRVM1IDE1LjIuMy41XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjVcbiAgICBpZiAoIU9iamVjdC5jcmVhdGUpIHtcblxuICAgICAgICAvLyBDb250cmlidXRlZCBieSBCcmFuZG9uIEJlbnZpZSwgT2N0b2JlciwgMjAxMlxuICAgICAgICB2YXIgY3JlYXRlRW1wdHk7XG4gICAgICAgIHZhciBzdXBwb3J0c1Byb3RvID0gISh7IF9fcHJvdG9fXzogbnVsbCB9IGluc3RhbmNlb2YgT2JqZWN0KTtcbiAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBwcm9kdWNlcyBmYWxzZSBwb3NpdGl2ZXNcbiAgICAgICAgLy8gaW4gT3BlcmEgTWluaSA9PiBub3QgYSByZWxpYWJsZSBjaGVja1xuICAgICAgICAvLyBPYmplY3QucHJvdG90eXBlLl9fcHJvdG9fXyA9PT0gbnVsbFxuXG4gICAgICAgIC8vIENoZWNrIGZvciBkb2N1bWVudC5kb21haW4gYW5kIGFjdGl2ZSB4IHN1cHBvcnRcbiAgICAgICAgLy8gTm8gbmVlZCB0byB1c2UgYWN0aXZlIHggYXBwcm9hY2ggd2hlbiBkb2N1bWVudC5kb21haW4gaXMgbm90IHNldFxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xNTBcbiAgICAgICAgLy8gdmFyaWF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9raXRjYW1icmlkZ2UvZXM1LXNoaW0vY29tbWl0LzRmNzM4YWMwNjYzNDZcbiAgICAgICAgLyogZ2xvYmFsIEFjdGl2ZVhPYmplY3QgKi9cbiAgICAgICAgdmFyIHNob3VsZFVzZUFjdGl2ZVggPSBmdW5jdGlvbiBzaG91bGRVc2VBY3RpdmVYKCkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIGVhcmx5IGlmIGRvY3VtZW50LmRvbWFpbiBub3Qgc2V0XG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50LmRvbWFpbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFuZXcgQWN0aXZlWE9iamVjdCgnaHRtbGZpbGUnKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUaGlzIHN1cHBvcnRzIElFOCB3aGVuIGRvY3VtZW50LmRvbWFpbiBpcyB1c2VkXG4gICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzE1MFxuICAgICAgICAvLyB2YXJpYXRpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL2tpdGNhbWJyaWRnZS9lczUtc2hpbS9jb21taXQvNGY3MzhhYzA2NjM0NlxuICAgICAgICB2YXIgZ2V0RW1wdHlWaWFBY3RpdmVYID0gZnVuY3Rpb24gZ2V0RW1wdHlWaWFBY3RpdmVYKCkge1xuICAgICAgICAgICAgdmFyIGVtcHR5O1xuICAgICAgICAgICAgdmFyIHhEb2M7XG5cbiAgICAgICAgICAgIHhEb2MgPSBuZXcgQWN0aXZlWE9iamVjdCgnaHRtbGZpbGUnKTtcblxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9ICdzY3JpcHQnO1xuICAgICAgICAgICAgeERvYy53cml0ZSgnPCcgKyBzY3JpcHQgKyAnPjwvJyArIHNjcmlwdCArICc+Jyk7XG4gICAgICAgICAgICB4RG9jLmNsb3NlKCk7XG5cbiAgICAgICAgICAgIGVtcHR5ID0geERvYy5wYXJlbnRXaW5kb3cuT2JqZWN0LnByb3RvdHlwZTtcbiAgICAgICAgICAgIHhEb2MgPSBudWxsO1xuXG4gICAgICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVGhlIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uIHVzaW5nIGFuIGlmcmFtZVxuICAgICAgICAvLyBiZWZvcmUgdGhlIGFjdGl2ZXggYXBwcm9hY2ggd2FzIGFkZGVkXG4gICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzE1MFxuICAgICAgICB2YXIgZ2V0RW1wdHlWaWFJRnJhbWUgPSBmdW5jdGlvbiBnZXRFbXB0eVZpYUlGcmFtZSgpIHtcbiAgICAgICAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgIHZhciBlbXB0eTtcblxuICAgICAgICAgICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zY3JpcHQtdXJsXG4gICAgICAgICAgICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JztcblxuICAgICAgICAgICAgZW1wdHkgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3QucHJvdG90eXBlO1xuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICAgICAgICBpZnJhbWUgPSBudWxsO1xuXG4gICAgICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyogZ2xvYmFsIGRvY3VtZW50ICovXG4gICAgICAgIGlmIChzdXBwb3J0c1Byb3RvIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNyZWF0ZUVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IF9fcHJvdG9fXzogbnVsbCB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEluIG9sZCBJRSBfX3Byb3RvX18gY2FuJ3QgYmUgdXNlZCB0byBtYW51YWxseSBzZXQgYG51bGxgLCBub3IgZG9lc1xuICAgICAgICAgICAgLy8gYW55IG90aGVyIG1ldGhvZCBleGlzdCB0byBtYWtlIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gbm90aGluZyxcbiAgICAgICAgICAgIC8vIGFzaWRlIGZyb20gT2JqZWN0LnByb3RvdHlwZSBpdHNlbGYuIEluc3RlYWQsIGNyZWF0ZSBhIG5ldyBnbG9iYWxcbiAgICAgICAgICAgIC8vIG9iamVjdCBhbmQgKnN0ZWFsKiBpdHMgT2JqZWN0LnByb3RvdHlwZSBhbmQgc3RyaXAgaXQgYmFyZS4gVGhpcyBpc1xuICAgICAgICAgICAgLy8gdXNlZCBhcyB0aGUgcHJvdG90eXBlIHRvIGNyZWF0ZSBudWxsYXJ5IG9iamVjdHMuXG4gICAgICAgICAgICBjcmVhdGVFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggYXBwcm9hY2ggdG8gdXNlXG4gICAgICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMTUwXG4gICAgICAgICAgICAgICAgdmFyIGVtcHR5ID0gc2hvdWxkVXNlQWN0aXZlWCgpID8gZ2V0RW1wdHlWaWFBY3RpdmVYKCkgOiBnZXRFbXB0eVZpYUlGcmFtZSgpO1xuXG4gICAgICAgICAgICAgICAgZGVsZXRlIGVtcHR5LmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbXB0eS5oYXNPd25Qcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICBkZWxldGUgZW1wdHkucHJvcGVydHlJc0VudW1lcmFibGU7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVtcHR5LmlzUHJvdG90eXBlT2Y7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVtcHR5LnRvTG9jYWxlU3RyaW5nO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbXB0eS50b1N0cmluZztcbiAgICAgICAgICAgICAgICBkZWxldGUgZW1wdHkudmFsdWVPZjtcblxuICAgICAgICAgICAgICAgIHZhciBFbXB0eSA9IGZ1bmN0aW9uIEVtcHR5KCkge307XG4gICAgICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gZW1wdHk7XG4gICAgICAgICAgICAgICAgLy8gc2hvcnQtY2lyY3VpdCBmdXR1cmUgY2FsbHNcbiAgICAgICAgICAgICAgICBjcmVhdGVFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XG5cbiAgICAgICAgICAgIHZhciBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgVHlwZSA9IGZ1bmN0aW9uIFR5cGUoKSB7fTsgLy8gQW4gZW1wdHkgY29uc3RydWN0b3IuXG5cbiAgICAgICAgICAgIGlmIChwcm90b3R5cGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBjcmVhdGVFbXB0eSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShwcm90b3R5cGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBgcGFyZW50YCBjYW4gYmUgYG51bGxgXG4gICAgICAgICAgICAgICAgLy8gT1IgKmFueSogYGluc3RhbmNlb2YgT2JqZWN0YCAgKE9iamVjdHxGdW5jdGlvbnxBcnJheXxSZWdFeHB8ZXRjKVxuICAgICAgICAgICAgICAgIC8vIFVzZSBgdHlwZW9mYCB0aG8sIGIvYyBpbiBvbGQgSUUsIERPTSBlbGVtZW50cyBhcmUgbm90IGBpbnN0YW5jZW9mIE9iamVjdGBcbiAgICAgICAgICAgICAgICAvLyBsaWtlIHRoZXkgYXJlIGluIG1vZGVybiBicm93c2Vycy4gVXNpbmcgYE9iamVjdC5jcmVhdGVgIG9uIERPTSBlbGVtZW50c1xuICAgICAgICAgICAgICAgIC8vIGlzLi4uZXJyLi4ucHJvYmFibHkgaW5hcHByb3ByaWF0ZSwgYnV0IHRoZSBuYXRpdmUgdmVyc2lvbiBhbGxvd3MgZm9yIGl0LlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdCBwcm90b3R5cGUgbWF5IG9ubHkgYmUgYW4gT2JqZWN0IG9yIG51bGwnKTsgLy8gc2FtZSBtc2cgYXMgQ2hyb21lXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFR5cGUucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUeXBlKCk7XG4gICAgICAgICAgICAgICAgLy8gSUUgaGFzIG5vIGJ1aWx0LWluIGltcGxlbWVudGF0aW9uIG9mIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgXG4gICAgICAgICAgICAgICAgLy8gbmVpdGhlciBgX19wcm90b19fYCwgYnV0IHRoaXMgbWFudWFsbHkgc2V0dGluZyBgX19wcm90b19fYCB3aWxsXG4gICAgICAgICAgICAgICAgLy8gZ3VhcmFudGVlIHRoYXQgYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgd2lsbCB3b3JrIGFzIGV4cGVjdGVkIHdpdGhcbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIGNyZWF0ZWQgdXNpbmcgYE9iamVjdC5jcmVhdGVgXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvXG4gICAgICAgICAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG9iamVjdCwgcHJvcGVydGllcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRVM1IDE1LjIuMy42XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjZcblxuICAgIC8vIFBhdGNoIGZvciBXZWJLaXQgYW5kIElFOCBzdGFuZGFyZCBtb2RlXG4gICAgLy8gRGVzaWduZWQgYnkgaGF4IDxoYXguZ2l0aHViLmNvbT5cbiAgICAvLyByZWxhdGVkIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzI2lzc3VlLzVcbiAgICAvLyBJRTggUmVmZXJlbmNlOlxuICAgIC8vICAgICBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZGQyODI5MDAuYXNweFxuICAgIC8vICAgICBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZGQyMjk5MTYuYXNweFxuICAgIC8vIFdlYktpdCBCdWdzOlxuICAgIC8vICAgICBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MzY0MjNcblxuICAgIHZhciBkb2VzRGVmaW5lUHJvcGVydHlXb3JrID0gZnVuY3Rpb24gZG9lc0RlZmluZVByb3BlcnR5V29yayhvYmplY3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdzZW50aW5lbCcsIHt9KTtcbiAgICAgICAgICAgIHJldHVybiAnc2VudGluZWwnIGluIG9iamVjdDtcbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gY2hlY2sgd2hldGhlciBkZWZpbmVQcm9wZXJ0eSB3b3JrcyBpZiBpdCdzIGdpdmVuLiBPdGhlcndpc2UsXG4gICAgLy8gc2hpbSBwYXJ0aWFsbHkuXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICB2YXIgZGVmaW5lUHJvcGVydHlXb3Jrc09uT2JqZWN0ID0gZG9lc0RlZmluZVByb3BlcnR5V29yayh7fSk7XG4gICAgICAgIHZhciBkZWZpbmVQcm9wZXJ0eVdvcmtzT25Eb20gPSB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICB8fCBkb2VzRGVmaW5lUHJvcGVydHlXb3JrKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICAgICAgaWYgKCFkZWZpbmVQcm9wZXJ0eVdvcmtzT25PYmplY3QgfHwgIWRlZmluZVByb3BlcnR5V29ya3NPbkRvbSkge1xuICAgICAgICAgICAgdmFyIGRlZmluZVByb3BlcnR5RmFsbGJhY2sgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksXG4gICAgICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllc0ZhbGxiYWNrID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIU9iamVjdC5kZWZpbmVQcm9wZXJ0eSB8fCBkZWZpbmVQcm9wZXJ0eUZhbGxiYWNrKSB7XG4gICAgICAgIHZhciBFUlJfTk9OX09CSkVDVF9ERVNDUklQVE9SID0gJ1Byb3BlcnR5IGRlc2NyaXB0aW9uIG11c3QgYmUgYW4gb2JqZWN0OiAnO1xuICAgICAgICB2YXIgRVJSX05PTl9PQkpFQ1RfVEFSR0VUID0gJ09iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxsZWQgb24gbm9uLW9iamVjdDogJztcbiAgICAgICAgdmFyIEVSUl9BQ0NFU1NPUlNfTk9UX1NVUFBPUlRFRCA9ICdnZXR0ZXJzICYgc2V0dGVycyBjYW4gbm90IGJlIGRlZmluZWQgb24gdGhpcyBqYXZhc2NyaXB0IGVuZ2luZSc7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgaWYgKGlzUHJpbWl0aXZlKG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUl9OT05fT0JKRUNUX1RBUkdFVCArIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNQcmltaXRpdmUoZGVzY3JpcHRvcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUl9OT05fT0JKRUNUX0RFU0NSSVBUT1IgKyBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1ha2UgYSB2YWxpYW50IGF0dGVtcHQgdG8gdXNlIHRoZSByZWFsIGRlZmluZVByb3BlcnR5XG4gICAgICAgICAgICAvLyBmb3IgSTgncyBET00gZWxlbWVudHMuXG4gICAgICAgICAgICBpZiAoZGVmaW5lUHJvcGVydHlGYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eUZhbGxiYWNrLmNhbGwoT2JqZWN0LCBvYmplY3QsIHByb3BlcnR5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRoZSBzaGltIGlmIHRoZSByZWFsIG9uZSBkb2Vzbid0IHdvcmtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGl0J3MgYSBkYXRhIHByb3BlcnR5LlxuICAgICAgICAgICAgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgICAgIC8vIGZhaWwgc2lsZW50bHkgaWYgJ3dyaXRhYmxlJywgJ2VudW1lcmFibGUnLCBvciAnY29uZmlndXJhYmxlJ1xuICAgICAgICAgICAgICAgIC8vIGFyZSByZXF1ZXN0ZWQgYnV0IG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIC8vIGFsdGVybmF0ZSBhcHByb2FjaDpcbiAgICAgICAgICAgICAgICBpZiAoIC8vIGNhbid0IGltcGxlbWVudCB0aGVzZSBmZWF0dXJlczsgYWxsb3cgZmFsc2UgYnV0IG5vdCB0cnVlXG4gICAgICAgICAgICAgICAgICAgICgnd3JpdGFibGUnIGluIGRlc2NyaXB0b3IgJiYgIWRlc2NyaXB0b3Iud3JpdGFibGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICgnZW51bWVyYWJsZScgaW4gZGVzY3JpcHRvciAmJiAhZGVzY3JpcHRvci5lbnVtZXJhYmxlKSB8fFxuICAgICAgICAgICAgICAgICAgICAoJ2NvbmZpZ3VyYWJsZScgaW4gZGVzY3JpcHRvciAmJiAhZGVzY3JpcHRvci5jb25maWd1cmFibGUpXG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAnVGhpcyBpbXBsZW1lbnRhdGlvbiBvZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgZG9lcyBub3Qgc3VwcG9ydCBjb25maWd1cmFibGUsIGVudW1lcmFibGUsIG9yIHdyaXRhYmxlLidcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRzQWNjZXNzb3JzICYmIChsb29rdXBHZXR0ZXIob2JqZWN0LCBwcm9wZXJ0eSkgfHwgbG9va3VwU2V0dGVyKG9iamVjdCwgcHJvcGVydHkpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBcyBhY2Nlc3NvcnMgYXJlIHN1cHBvcnRlZCBvbmx5IG9uIGVuZ2luZXMgaW1wbGVtZW50aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGBfX3Byb3RvX19gIHdlIGNhbiBzYWZlbHkgb3ZlcnJpZGUgYF9fcHJvdG9fX2Agd2hpbGUgZGVmaW5pbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBwcm9wZXJ0eSB0byBtYWtlIHN1cmUgdGhhdCB3ZSBkb24ndCBoaXQgYW4gaW5oZXJpdGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGFjY2Vzc29yLlxuICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90bywgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3RvdHlwZSA9IG9iamVjdC5fX3Byb3RvX187XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGVPZk9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRpbmcgYSBwcm9wZXJ0eSBhbnl3YXkgc2luY2UgZ2V0dGVyIC8gc2V0dGVyIG1heSBiZVxuICAgICAgICAgICAgICAgICAgICAvLyBkZWZpbmVkIG9uIG9iamVjdCBpdHNlbGYuXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RbcHJvcGVydHldID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0dGluZyBvcmlnaW5hbCBgX19wcm90b19fYCBiYWNrIG5vdy5cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90bywgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RbcHJvcGVydHldID0gZGVzY3JpcHRvci52YWx1ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhc0dldHRlciA9ICdnZXQnIGluIGRlc2NyaXB0b3I7XG4gICAgICAgICAgICAgICAgdmFyIGhhc1NldHRlciA9ICdzZXQnIGluIGRlc2NyaXB0b3I7XG4gICAgICAgICAgICAgICAgaWYgKCFzdXBwb3J0c0FjY2Vzc29ycyAmJiAoaGFzR2V0dGVyIHx8IGhhc1NldHRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJfQUNDRVNTT1JTX05PVF9TVVBQT1JURUQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBnb3QgdGhhdCBmYXIgdGhlbiBnZXR0ZXJzIGFuZCBzZXR0ZXJzIGNhbiBiZSBkZWZpbmVkICEhXG4gICAgICAgICAgICAgICAgaWYgKGhhc0dldHRlcikge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVHZXR0ZXIob2JqZWN0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvci5nZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzU2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVNldHRlcihvYmplY3QsIHByb3BlcnR5LCBkZXNjcmlwdG9yLnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBFUzUgMTUuMi4zLjdcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4yLjMuN1xuICAgIGlmICghT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgfHwgZGVmaW5lUHJvcGVydGllc0ZhbGxiYWNrKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhvYmplY3QsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIC8vIG1ha2UgYSB2YWxpYW50IGF0dGVtcHQgdG8gdXNlIHRoZSByZWFsIGRlZmluZVByb3BlcnRpZXNcbiAgICAgICAgICAgIGlmIChkZWZpbmVQcm9wZXJ0aWVzRmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmaW5lUHJvcGVydGllc0ZhbGxiYWNrLmNhbGwoT2JqZWN0LCBvYmplY3QsIHByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdGhlIHNoaW0gaWYgdGhlIHJlYWwgb25lIGRvZXNuJ3Qgd29ya1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmtleXMocHJvcGVydGllcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkgIT09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBwcm9wZXJ0aWVzW3Byb3BlcnR5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEVTNSAxNS4yLjMuOFxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy44XG4gICAgaWYgKCFPYmplY3Quc2VhbCkge1xuICAgICAgICBPYmplY3Quc2VhbCA9IGZ1bmN0aW9uIHNlYWwob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KG9iamVjdCkgIT09IG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5zZWFsIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBPYmplY3RzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhpcyBpcyBtaXNsZWFkaW5nIGFuZCBicmVha3MgZmVhdHVyZS1kZXRlY3Rpb24sIGJ1dFxuICAgICAgICAgICAgLy8gYWxsb3dzIFwic2VjdXJhYmxlXCIgY29kZSB0byBcImdyYWNlZnVsbHlcIiBkZWdyYWRlIHRvIHdvcmtpbmdcbiAgICAgICAgICAgIC8vIGJ1dCBpbnNlY3VyZSBjb2RlLlxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBFUzUgMTUuMi4zLjlcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4yLjMuOVxuICAgIGlmICghT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICBPYmplY3QuZnJlZXplID0gZnVuY3Rpb24gZnJlZXplKG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKE9iamVjdChvYmplY3QpICE9PSBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuZnJlZXplIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBPYmplY3RzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhpcyBpcyBtaXNsZWFkaW5nIGFuZCBicmVha3MgZmVhdHVyZS1kZXRlY3Rpb24sIGJ1dFxuICAgICAgICAgICAgLy8gYWxsb3dzIFwic2VjdXJhYmxlXCIgY29kZSB0byBcImdyYWNlZnVsbHlcIiBkZWdyYWRlIHRvIHdvcmtpbmdcbiAgICAgICAgICAgIC8vIGJ1dCBpbnNlY3VyZSBjb2RlLlxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBkZXRlY3QgYSBSaGlubyBidWcgYW5kIHBhdGNoIGl0XG4gICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShmdW5jdGlvbiAoKSB7fSk7XG4gICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUgPSAoZnVuY3Rpb24gKGZyZWV6ZU9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGZyZWV6ZShvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZnJlZXplT2JqZWN0KG9iamVjdCk7XG5cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0oT2JqZWN0LmZyZWV6ZSkpO1xuICAgIH1cblxuICAgIC8vIEVTNSAxNS4yLjMuMTBcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4yLjMuMTBcbiAgICBpZiAoIU9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucykge1xuICAgICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnMgPSBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyhvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qob2JqZWN0KSAhPT0gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBPYmplY3RzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhpcyBpcyBtaXNsZWFkaW5nIGFuZCBicmVha3MgZmVhdHVyZS1kZXRlY3Rpb24sIGJ1dFxuICAgICAgICAgICAgLy8gYWxsb3dzIFwic2VjdXJhYmxlXCIgY29kZSB0byBcImdyYWNlZnVsbHlcIiBkZWdyYWRlIHRvIHdvcmtpbmdcbiAgICAgICAgICAgIC8vIGJ1dCBpbnNlY3VyZSBjb2RlLlxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBFUzUgMTUuMi4zLjExXG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjExXG4gICAgaWYgKCFPYmplY3QuaXNTZWFsZWQpIHtcbiAgICAgICAgT2JqZWN0LmlzU2VhbGVkID0gZnVuY3Rpb24gaXNTZWFsZWQob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KG9iamVjdCkgIT09IG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5pc1NlYWxlZCBjYW4gb25seSBiZSBjYWxsZWQgb24gT2JqZWN0cy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBFUzUgMTUuMi4zLjEyXG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjEyXG4gICAgaWYgKCFPYmplY3QuaXNGcm96ZW4pIHtcbiAgICAgICAgT2JqZWN0LmlzRnJvemVuID0gZnVuY3Rpb24gaXNGcm96ZW4ob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KG9iamVjdCkgIT09IG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5pc0Zyb3plbiBjYW4gb25seSBiZSBjYWxsZWQgb24gT2JqZWN0cy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBFUzUgMTUuMi4zLjEzXG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjEzXG4gICAgaWYgKCFPYmplY3QuaXNFeHRlbnNpYmxlKSB7XG4gICAgICAgIE9iamVjdC5pc0V4dGVuc2libGUgPSBmdW5jdGlvbiBpc0V4dGVuc2libGUob2JqZWN0KSB7XG4gICAgICAgICAgICAvLyAxLiBJZiBUeXBlKE8pIGlzIG5vdCBPYmplY3QgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICAgICAgICAgICAgaWYgKE9iamVjdChvYmplY3QpICE9PSBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuaXNFeHRlbnNpYmxlIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBPYmplY3RzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMi4gUmV0dXJuIHRoZSBCb29sZWFuIHZhbHVlIG9mIHRoZSBbW0V4dGVuc2libGVdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBPLlxuICAgICAgICAgICAgdmFyIG5hbWUgPSAnJztcbiAgICAgICAgICAgIHdoaWxlIChvd25zKG9iamVjdCwgbmFtZSkpIHtcbiAgICAgICAgICAgICAgICBuYW1lICs9ICc/JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iamVjdFtuYW1lXSA9IHRydWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IG93bnMob2JqZWN0LCBuYW1lKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmplY3RbbmFtZV07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbn0pKTtcbiIsIi8qIVxuICogaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltXG4gKiBAbGljZW5zZSBlczUtc2hpbSBDb3B5cmlnaHQgMjAwOS0yMDIwIGJ5IGNvbnRyaWJ1dG9ycywgTUlUIExpY2Vuc2VcbiAqIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICovXG5cbi8vIHZpbTogdHM9NCBzdHM9NCBzdz00IGV4cGFuZHRhYlxuXG4vLyBBZGQgc2VtaWNvbG9uIHRvIHByZXZlbnQgSUlGRSBmcm9tIGJlaW5nIHBhc3NlZCBhcyBhcmd1bWVudCB0byBjb25jYXRlbmF0ZWQgY29kZS5cbjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1leHRyYS1zZW1pXG5cbi8vIFVNRCAoVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uKVxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91bWRqcy91bWQvYmxvYi9tYXN0ZXIvdGVtcGxhdGVzL3JldHVybkV4cG9ydHMuanNcbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qIGdsb2JhbCBkZWZpbmUgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuICAgICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgICAgICAvLyBsaWtlIE5vZGUuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG4gICAgICAgIHJvb3QucmV0dXJuRXhwb3J0cyA9IGZhY3RvcnkoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEJyaW5ncyBhbiBlbnZpcm9ubWVudCBhcyBjbG9zZSB0byBFQ01BU2NyaXB0IDUgY29tcGxpYW5jZVxuICAgICAqIGFzIGlzIHBvc3NpYmxlIHdpdGggdGhlIGZhY2lsaXRpZXMgb2YgZXJzdHdoaWxlIGVuZ2luZXMuXG4gICAgICpcbiAgICAgKiBBbm5vdGF0ZWQgRVM1OiBodHRwOi8vZXM1LmdpdGh1Yi5jb20vIChzcGVjaWZpYyBsaW5rcyBiZWxvdylcbiAgICAgKiBFUzUgU3BlYzogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL3B1YmxpY2F0aW9ucy9maWxlcy9FQ01BLVNUL0VjbWEtMjYyLnBkZlxuICAgICAqIFJlcXVpcmVkIHJlYWRpbmc6IGh0dHA6Ly9qYXZhc2NyaXB0d2VibG9nLndvcmRwcmVzcy5jb20vMjAxMS8xMi8wNS9leHRlbmRpbmctamF2YXNjcmlwdC1uYXRpdmVzL1xuICAgICAqL1xuXG4gICAgLy8gU2hvcnRjdXQgdG8gYW4gb2Z0ZW4gYWNjZXNzZWQgcHJvcGVydGllcywgaW4gb3JkZXIgdG8gYXZvaWQgbXVsdGlwbGVcbiAgICAvLyBkZXJlZmVyZW5jZSB0aGF0IGNvc3RzIHVuaXZlcnNhbGx5LiBUaGlzIGFsc28gaG9sZHMgYSByZWZlcmVuY2UgdG8ga25vd24tZ29vZFxuICAgIC8vIGZ1bmN0aW9ucy5cbiAgICB2YXIgJEFycmF5ID0gQXJyYXk7XG4gICAgdmFyIEFycmF5UHJvdG90eXBlID0gJEFycmF5LnByb3RvdHlwZTtcbiAgICB2YXIgJE9iamVjdCA9IE9iamVjdDtcbiAgICB2YXIgT2JqZWN0UHJvdG90eXBlID0gJE9iamVjdC5wcm90b3R5cGU7XG4gICAgdmFyICRGdW5jdGlvbiA9IEZ1bmN0aW9uO1xuICAgIHZhciBGdW5jdGlvblByb3RvdHlwZSA9ICRGdW5jdGlvbi5wcm90b3R5cGU7XG4gICAgdmFyICRTdHJpbmcgPSBTdHJpbmc7XG4gICAgdmFyIFN0cmluZ1Byb3RvdHlwZSA9ICRTdHJpbmcucHJvdG90eXBlO1xuICAgIHZhciAkTnVtYmVyID0gTnVtYmVyO1xuICAgIHZhciBOdW1iZXJQcm90b3R5cGUgPSAkTnVtYmVyLnByb3RvdHlwZTtcbiAgICB2YXIgYXJyYXlfc2xpY2UgPSBBcnJheVByb3RvdHlwZS5zbGljZTtcbiAgICB2YXIgYXJyYXlfc3BsaWNlID0gQXJyYXlQcm90b3R5cGUuc3BsaWNlO1xuICAgIHZhciBhcnJheV9wdXNoID0gQXJyYXlQcm90b3R5cGUucHVzaDtcbiAgICB2YXIgYXJyYXlfdW5zaGlmdCA9IEFycmF5UHJvdG90eXBlLnVuc2hpZnQ7XG4gICAgdmFyIGFycmF5X2NvbmNhdCA9IEFycmF5UHJvdG90eXBlLmNvbmNhdDtcbiAgICB2YXIgYXJyYXlfam9pbiA9IEFycmF5UHJvdG90eXBlLmpvaW47XG4gICAgdmFyIGNhbGwgPSBGdW5jdGlvblByb3RvdHlwZS5jYWxsO1xuICAgIHZhciBhcHBseSA9IEZ1bmN0aW9uUHJvdG90eXBlLmFwcGx5O1xuICAgIHZhciBtYXggPSBNYXRoLm1heDtcbiAgICB2YXIgbWluID0gTWF0aC5taW47XG4gICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICB2YXIgYWJzID0gTWF0aC5hYnM7XG4gICAgdmFyIHBvdyA9IE1hdGgucG93O1xuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG4gICAgdmFyIGxvZyA9IE1hdGgubG9nO1xuICAgIHZhciBMT0cxMEUgPSBNYXRoLkxPRzEwRTtcbiAgICB2YXIgbG9nMTAgPSBNYXRoLmxvZzEwIHx8IGZ1bmN0aW9uIGxvZzEwKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBsb2codmFsdWUpICogTE9HMTBFO1xuICAgIH07XG5cbiAgICAvLyBIYXZpbmcgYSB0b1N0cmluZyBsb2NhbCB2YXJpYWJsZSBuYW1lIGJyZWFrcyBpbiBPcGVyYSBzbyB1c2UgdG9fc3RyaW5nLlxuICAgIHZhciB0b19zdHJpbmcgPSBPYmplY3RQcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBvbmUtdmFyLWRlY2xhcmF0aW9uLXBlci1saW5lLCBuby1yZWRlY2xhcmUsIG1heC1zdGF0ZW1lbnRzLXBlci1saW5lICovXG4gICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJztcbiAgICB2YXIgaXNDYWxsYWJsZTsgLyogaW5saW5lZCBmcm9tIGh0dHBzOi8vbnBtanMuY29tL2lzLWNhbGxhYmxlICovIHZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLCBjb25zdHJ1Y3RvclJlZ2V4ID0gL15cXHMqY2xhc3MgLywgaXNFUzZDbGFzc0ZuID0gZnVuY3Rpb24gaXNFUzZDbGFzc0ZuKHZhbHVlKSB7IHRyeSB7IHZhciBmblN0ciA9IGZuVG9TdHIuY2FsbCh2YWx1ZSk7IHZhciBzaW5nbGVTdHJpcHBlZCA9IGZuU3RyLnJlcGxhY2UoL1xcL1xcLy4qXFxuL2csICcnKTsgdmFyIG11bHRpU3RyaXBwZWQgPSBzaW5nbGVTdHJpcHBlZC5yZXBsYWNlKC9cXC9cXCpbLlxcc1xcU10qXFwqXFwvL2csICcnKTsgdmFyIHNwYWNlU3RyaXBwZWQgPSBtdWx0aVN0cmlwcGVkLnJlcGxhY2UoL1xcbi9tZywgJyAnKS5yZXBsYWNlKC8gezJ9L2csICcgJyk7IHJldHVybiBjb25zdHJ1Y3RvclJlZ2V4LnRlc3Qoc3BhY2VTdHJpcHBlZCk7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyAvKiBub3QgYSBmdW5jdGlvbiAqLyB9IH0sIHRyeUZ1bmN0aW9uT2JqZWN0ID0gZnVuY3Rpb24gdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpIHsgdHJ5IHsgaWYgKGlzRVM2Q2xhc3NGbih2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9IGZuVG9TdHIuY2FsbCh2YWx1ZSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9LCBmbkNsYXNzID0gJ1tvYmplY3QgRnVuY3Rpb25dJywgZ2VuQ2xhc3MgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLCBpc0NhbGxhYmxlID0gZnVuY3Rpb24gaXNDYWxsYWJsZSh2YWx1ZSkgeyBpZiAoIXZhbHVlKSB7IHJldHVybiBmYWxzZTsgfSBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9IGlmIChoYXNUb1N0cmluZ1RhZykgeyByZXR1cm4gdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpOyB9IGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfSB2YXIgc3RyQ2xhc3MgPSB0b19zdHJpbmcuY2FsbCh2YWx1ZSk7IHJldHVybiBzdHJDbGFzcyA9PT0gZm5DbGFzcyB8fCBzdHJDbGFzcyA9PT0gZ2VuQ2xhc3M7IH07XG5cbiAgICB2YXIgaXNSZWdleDsgLyogaW5saW5lZCBmcm9tIGh0dHBzOi8vbnBtanMuY29tL2lzLXJlZ2V4ICovIHZhciByZWdleEV4ZWMgPSBSZWdFeHAucHJvdG90eXBlLmV4ZWMsIHRyeVJlZ2V4RXhlYyA9IGZ1bmN0aW9uIHRyeVJlZ2V4RXhlYyh2YWx1ZSkgeyB0cnkgeyByZWdleEV4ZWMuY2FsbCh2YWx1ZSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9LCByZWdleENsYXNzID0gJ1tvYmplY3QgUmVnRXhwXSc7IGlzUmVnZXggPSBmdW5jdGlvbiBpc1JlZ2V4KHZhbHVlKSB7IGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfSByZXR1cm4gaGFzVG9TdHJpbmdUYWcgPyB0cnlSZWdleEV4ZWModmFsdWUpIDogdG9fc3RyaW5nLmNhbGwodmFsdWUpID09PSByZWdleENsYXNzOyB9O1xuICAgIHZhciBpc1N0cmluZzsgLyogaW5saW5lZCBmcm9tIGh0dHBzOi8vbnBtanMuY29tL2lzLXN0cmluZyAqLyB2YXIgc3RyVmFsdWUgPSBTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YsIHRyeVN0cmluZ09iamVjdCA9IGZ1bmN0aW9uIHRyeVN0cmluZ09iamVjdCh2YWx1ZSkgeyB0cnkgeyBzdHJWYWx1ZS5jYWxsKHZhbHVlKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH0sIHN0cmluZ0NsYXNzID0gJ1tvYmplY3QgU3RyaW5nXSc7IGlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHsgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIHRydWU7IH0gaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9IHJldHVybiBoYXNUb1N0cmluZ1RhZyA/IHRyeVN0cmluZ09iamVjdCh2YWx1ZSkgOiB0b19zdHJpbmcuY2FsbCh2YWx1ZSkgPT09IHN0cmluZ0NsYXNzOyB9O1xuICAgIC8qIGVzbGludC1lbmFibGUgb25lLXZhci1kZWNsYXJhdGlvbi1wZXItbGluZSwgbm8tcmVkZWNsYXJlLCBtYXgtc3RhdGVtZW50cy1wZXItbGluZSAqL1xuXG4gICAgLyogaW5saW5lZCBmcm9tIGh0dHA6Ly9ucG1qcy5jb20vZGVmaW5lLXByb3BlcnRpZXMgKi9cbiAgICB2YXIgc3VwcG9ydHNEZXNjcmlwdG9ycyA9ICRPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgICAgICRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCAneCcsIHsgZW51bWVyYWJsZTogZmFsc2UsIHZhbHVlOiBvYmogfSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGUtbG9vcCwgbWF4LXN0YXRlbWVudHMtcGVyLWxpbmVcbiAgICAgICAgICAgIGZvciAodmFyIF8gaW4gb2JqKSB7IHJldHVybiBmYWxzZTsgfSAvLyBqc2NzOmlnbm9yZSBkaXNhbGxvd1VudXNlZFZhcmlhYmxlc1xuICAgICAgICAgICAgcmV0dXJuIG9iai54ID09PSBvYmo7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgLyogdGhpcyBpcyBFUzMgKi9cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0oKSk7XG4gICAgdmFyIGRlZmluZVByb3BlcnRpZXMgPSAoZnVuY3Rpb24gKGhhcykge1xuICAgICAgICAvLyBEZWZpbmUgY29uZmlndXJhYmxlLCB3cml0YWJsZSwgYW5kIG5vbi1lbnVtZXJhYmxlIHByb3BzXG4gICAgICAgIC8vIGlmIHRoZXkgZG9uJ3QgZXhpc3QuXG4gICAgICAgIHZhciBkZWZpbmVQcm9wZXJ0eTtcbiAgICAgICAgaWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcbiAgICAgICAgICAgIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgbWV0aG9kLCBmb3JjZUFzc2lnbikge1xuICAgICAgICAgICAgICAgIGlmICghZm9yY2VBc3NpZ24gJiYgKG5hbWUgaW4gb2JqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWV0aG9kXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBtZXRob2QsIGZvcmNlQXNzaWduKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiAobmFtZSBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqZWN0W25hbWVdID0gbWV0aG9kOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKG9iamVjdCwgbWFwLCBmb3JjZUFzc2lnbikge1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBtYXApIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzLmNhbGwobWFwLCBuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIG1hcFtuYW1lXSwgZm9yY2VBc3NpZ24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KE9iamVjdFByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSkpO1xuXG4gICAgLy9cbiAgICAvLyBVdGlsXG4gICAgLy8gPT09PT09XG4gICAgLy9cblxuICAgIC8qIHJlcGxhY2VhYmxlIHdpdGggaHR0cHM6Ly9ucG1qcy5jb20vcGFja2FnZS9lcy1hYnN0cmFjdCAvaGVscGVycy9pc1ByaW1pdGl2ZSAqL1xuICAgIHZhciBpc1ByaW1pdGl2ZSA9IGZ1bmN0aW9uIGlzUHJpbWl0aXZlKGlucHV0KSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIGlucHV0O1xuICAgICAgICByZXR1cm4gaW5wdXQgPT09IG51bGwgfHwgKHR5cGUgIT09ICdvYmplY3QnICYmIHR5cGUgIT09ICdmdW5jdGlvbicpO1xuICAgIH07XG5cbiAgICB2YXIgaXNBY3R1YWxOYU4gPSAkTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIGlzQWN0dWFsTmFOKHgpIHtcbiAgICAgICAgcmV0dXJuIHggIT09IHg7XG4gICAgfTtcblxuICAgIHZhciBFUyA9IHtcbiAgICAgICAgLy8gRVM1IDkuNFxuICAgICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3g5LjRcbiAgICAgICAgLy8gaHR0cDovL2pzcGVyZi5jb20vdG8taW50ZWdlclxuICAgICAgICAvKiByZXBsYWNlYWJsZSB3aXRoIGh0dHBzOi8vbnBtanMuY29tL3BhY2thZ2UvZXMtYWJzdHJhY3QgRVM1LlRvSW50ZWdlciAqL1xuICAgICAgICBUb0ludGVnZXI6IGZ1bmN0aW9uIFRvSW50ZWdlcihudW0pIHtcbiAgICAgICAgICAgIHZhciBuID0gK251bTtcbiAgICAgICAgICAgIGlmIChpc0FjdHVhbE5hTihuKSkge1xuICAgICAgICAgICAgICAgIG4gPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuICE9PSAwICYmIG4gIT09ICgxIC8gMCkgJiYgbiAhPT0gLSgxIC8gMCkpIHtcbiAgICAgICAgICAgICAgICBuID0gKG4gPiAwIHx8IC0xKSAqIGZsb29yKGFicyhuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKiByZXBsYWNlYWJsZSB3aXRoIGh0dHBzOi8vbnBtanMuY29tL3BhY2thZ2UvZXMtYWJzdHJhY3QgRVM1LlRvUHJpbWl0aXZlICovXG4gICAgICAgIFRvUHJpbWl0aXZlOiBmdW5jdGlvbiBUb1ByaW1pdGl2ZShpbnB1dCkge1xuICAgICAgICAgICAgdmFyIHZhbCwgdmFsdWVPZiwgdG9TdHI7XG4gICAgICAgICAgICBpZiAoaXNQcmltaXRpdmUoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVPZiA9IGlucHV0LnZhbHVlT2Y7XG4gICAgICAgICAgICBpZiAoaXNDYWxsYWJsZSh2YWx1ZU9mKSkge1xuICAgICAgICAgICAgICAgIHZhbCA9IHZhbHVlT2YuY2FsbChpbnB1dCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJpbWl0aXZlKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b1N0ciA9IGlucHV0LnRvU3RyaW5nO1xuICAgICAgICAgICAgaWYgKGlzQ2FsbGFibGUodG9TdHIpKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gdG9TdHIuY2FsbChpbnB1dCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJpbWl0aXZlKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRVM1IDkuOVxuICAgICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3g5LjlcbiAgICAgICAgLyogcmVwbGFjZWFibGUgd2l0aCBodHRwczovL25wbWpzLmNvbS9wYWNrYWdlL2VzLWFic3RyYWN0IEVTNS5Ub09iamVjdCAqL1xuICAgICAgICBUb09iamVjdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIGlmIChvID09IG51bGwpIHsgLy8gdGhpcyBtYXRjaGVzIGJvdGggbnVsbCBhbmQgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgXCIgKyBvICsgJyB0byBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkT2JqZWN0KG8pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qIHJlcGxhY2VhYmxlIHdpdGggaHR0cHM6Ly9ucG1qcy5jb20vcGFja2FnZS9lcy1hYnN0cmFjdCBFUzUuVG9VaW50MzIgKi9cbiAgICAgICAgVG9VaW50MzI6IGZ1bmN0aW9uIFRvVWludDMyKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4ID4+PiAwO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vXG4gICAgLy8gRnVuY3Rpb25cbiAgICAvLyA9PT09PT09PVxuICAgIC8vXG5cbiAgICAvLyBFUy01IDE1LjMuNC41XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMy40LjVcblxuICAgIHZhciBFbXB0eSA9IGZ1bmN0aW9uIEVtcHR5KCkge307XG5cbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEZ1bmN0aW9uUHJvdG90eXBlLCB7XG4gICAgICAgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQodGhhdCkgeyAvLyAubGVuZ3RoIGlzIDFcbiAgICAgICAgICAgIC8vIDEuIExldCBUYXJnZXQgYmUgdGhlIHRoaXMgdmFsdWUuXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICAgICAgICAgIC8vIDIuIElmIElzQ2FsbGFibGUoVGFyZ2V0KSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICAgICAgICAgICAgaWYgKCFpc0NhbGxhYmxlKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICcgKyB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMy4gTGV0IEEgYmUgYSBuZXcgKHBvc3NpYmx5IGVtcHR5KSBpbnRlcm5hbCBsaXN0IG9mIGFsbCBvZiB0aGVcbiAgICAgICAgICAgIC8vICAgYXJndW1lbnQgdmFsdWVzIHByb3ZpZGVkIGFmdGVyIHRoaXNBcmcgKGFyZzEsIGFyZzIgZXRjKSwgaW4gb3JkZXIuXG4gICAgICAgICAgICAvLyBYWFggc2xpY2VkQXJncyB3aWxsIHN0YW5kIGluIGZvciBcIkFcIiBpZiB1c2VkXG4gICAgICAgICAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsgLy8gZm9yIG5vcm1hbCBjYWxsXG4gICAgICAgICAgICAvLyA0LiBMZXQgRiBiZSBhIG5ldyBuYXRpdmUgRUNNQVNjcmlwdCBvYmplY3QuXG4gICAgICAgICAgICAvLyAxMS4gU2V0IHRoZSBbW1Byb3RvdHlwZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgdG8gdGhlIHN0YW5kYXJkXG4gICAgICAgICAgICAvLyAgIGJ1aWx0LWluIEZ1bmN0aW9uIHByb3RvdHlwZSBvYmplY3QgYXMgc3BlY2lmaWVkIGluIDE1LjMuMy4xLlxuICAgICAgICAgICAgLy8gMTIuIFNldCB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgICAgIC8vICAgMTUuMy40LjUuMS5cbiAgICAgICAgICAgIC8vIDEzLiBTZXQgdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgICAgIC8vICAgMTUuMy40LjUuMi5cbiAgICAgICAgICAgIC8vIDE0LiBTZXQgdGhlIFtbSGFzSW5zdGFuY2VdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAgICAgLy8gICAxNS4zLjQuNS4zLlxuICAgICAgICAgICAgdmFyIGJvdW5kO1xuICAgICAgICAgICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMiBbW0NvbnN0cnVjdF1dXG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgbWV0aG9kIG9mIGEgZnVuY3Rpb24gb2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICAvLyBGIHRoYXQgd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIGJpbmQgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYVxuICAgICAgICAgICAgICAgICAgICAvLyBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmcgc3RlcHMgYXJlIHRha2VuOlxuICAgICAgICAgICAgICAgICAgICAvLyAxLiBMZXQgdGFyZ2V0IGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tUYXJnZXRGdW5jdGlvbl1dXG4gICAgICAgICAgICAgICAgICAgIC8vICAgaW50ZXJuYWwgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgICAgIC8vIDIuIElmIHRhcmdldCBoYXMgbm8gW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2QsIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gICBUeXBlRXJyb3IgZXhjZXB0aW9uIGlzIHRocm93bi5cbiAgICAgICAgICAgICAgICAgICAgLy8gMy4gTGV0IGJvdW5kQXJncyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRBcmdzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAgICAgLy8gNC4gTGV0IGFyZ3MgYmUgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gICBsaXN0IGJvdW5kQXJncyBpbiB0aGUgc2FtZSBvcmRlciBmb2xsb3dlZCBieSB0aGUgc2FtZVxuICAgICAgICAgICAgICAgICAgICAvLyAgIHZhbHVlcyBhcyB0aGUgbGlzdCBFeHRyYUFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAgICAgICAgICAgIC8vIDUuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gICBtZXRob2Qgb2YgdGFyZ2V0IHByb3ZpZGluZyBhcmdzIGFzIHRoZSBhcmd1bWVudHMuXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGFwcGx5LmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlfY29uY2F0LmNhbGwoYXJncywgYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoJE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMSBbW0NhbGxdXVxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZCBvZiBhIGZ1bmN0aW9uIG9iamVjdCwgRixcbiAgICAgICAgICAgICAgICAvLyB3aGljaCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgYmluZCBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhXG4gICAgICAgICAgICAgICAgLy8gdGhpcyB2YWx1ZSBhbmQgYSBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICAgICAgICAvLyBzdGVwcyBhcmUgdGFrZW46XG4gICAgICAgICAgICAgICAgLy8gMS4gTGV0IGJvdW5kQXJncyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRBcmdzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDIuIExldCBib3VuZFRoaXMgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kVGhpc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyAzLiBMZXQgdGFyZ2V0IGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tUYXJnZXRGdW5jdGlvbl1dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyA0LiBMZXQgYXJncyBiZSBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZVxuICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAvLyAgIHZhbHVlcyBhcyB0aGUgbGlzdCBFeHRyYUFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAgICAgICAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gICBvZiB0YXJnZXQgcHJvdmlkaW5nIGJvdW5kVGhpcyBhcyB0aGUgdGhpcyB2YWx1ZSBhbmRcbiAgICAgICAgICAgICAgICAvLyAgIHByb3ZpZGluZyBhcmdzIGFzIHRoZSBhcmd1bWVudHMuXG5cbiAgICAgICAgICAgICAgICAvLyBlcXVpdjogdGFyZ2V0LmNhbGwodGhpcywgLi4uYm91bmRBcmdzLCAuLi5hcmdzKVxuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseS5jYWxsKFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgICAgIGFycmF5X2NvbmNhdC5jYWxsKGFyZ3MsIGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyAxNS4gSWYgdGhlIFtbQ2xhc3NdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBUYXJnZXQgaXMgXCJGdW5jdGlvblwiLCB0aGVuXG4gICAgICAgICAgICAvLyAgICAgYS4gTGV0IEwgYmUgdGhlIGxlbmd0aCBwcm9wZXJ0eSBvZiBUYXJnZXQgbWludXMgdGhlIGxlbmd0aCBvZiBBLlxuICAgICAgICAgICAgLy8gICAgIGIuIFNldCB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIGVpdGhlciAwIG9yIEwsIHdoaWNoZXZlciBpc1xuICAgICAgICAgICAgLy8gICAgICAgbGFyZ2VyLlxuICAgICAgICAgICAgLy8gMTYuIEVsc2Ugc2V0IHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gMC5cblxuICAgICAgICAgICAgdmFyIGJvdW5kTGVuZ3RoID0gbWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIC8vIDE3LiBTZXQgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byB0aGUgdmFsdWVzXG4gICAgICAgICAgICAvLyAgIHNwZWNpZmllZCBpbiAxNS4zLjUuMS5cbiAgICAgICAgICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFycmF5X3B1c2guY2FsbChib3VuZEFyZ3MsICckJyArIGkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBYWFggQnVpbGQgYSBkeW5hbWljIGZ1bmN0aW9uIHdpdGggZGVzaXJlZCBhbW91bnQgb2YgYXJndW1lbnRzIGlzIHRoZSBvbmx5XG4gICAgICAgICAgICAvLyB3YXkgdG8gc2V0IHRoZSBsZW5ndGggcHJvcGVydHkgb2YgYSBmdW5jdGlvbi5cbiAgICAgICAgICAgIC8vIEluIGVudmlyb25tZW50cyB3aGVyZSBDb250ZW50IFNlY3VyaXR5IFBvbGljaWVzIGVuYWJsZWQgKENocm9tZSBleHRlbnNpb25zLFxuICAgICAgICAgICAgLy8gZm9yIGV4LikgYWxsIHVzZSBvZiBldmFsIG9yIEZ1bmN0aW9uIGNvc3RydWN0b3IgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgIC8vIEhvd2V2ZXIgaW4gYWxsIG9mIHRoZXNlIGVudmlyb25tZW50cyBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBleGlzdHNcbiAgICAgICAgICAgIC8vIGFuZCBzbyB0aGlzIGNvZGUgd2lsbCBuZXZlciBiZSBleGVjdXRlZC5cbiAgICAgICAgICAgIGJvdW5kID0gJEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgYXJyYXlfam9pbi5jYWxsKGJvdW5kQXJncywgJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0nKShiaW5kZXIpO1xuXG4gICAgICAgICAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgICAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG4gICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgZGFuZ2xpbmcgcmVmZXJlbmNlcy5cbiAgICAgICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICAvLyAxOC4gU2V0IHRoZSBbW0V4dGVuc2libGVdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIHRvIHRydWUuXG5cbiAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgIC8vIDE5LiBMZXQgdGhyb3dlciBiZSB0aGUgW1tUaHJvd1R5cGVFcnJvcl1dIGZ1bmN0aW9uIE9iamVjdCAoMTMuMi4zKS5cbiAgICAgICAgICAgIC8vIDIwLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxuICAgICAgICAgICAgLy8gICBhcmd1bWVudHMgXCJjYWxsZXJcIiwgUHJvcGVydHlEZXNjcmlwdG9yIHtbW0dldF1dOiB0aHJvd2VyLCBbW1NldF1dOlxuICAgICAgICAgICAgLy8gICB0aHJvd2VyLCBbW0VudW1lcmFibGVdXTogZmFsc2UsIFtbQ29uZmlndXJhYmxlXV06IGZhbHNlfSwgYW5kXG4gICAgICAgICAgICAvLyAgIGZhbHNlLlxuICAgICAgICAgICAgLy8gMjEuIENhbGwgdGhlIFtbRGVmaW5lT3duUHJvcGVydHldXSBpbnRlcm5hbCBtZXRob2Qgb2YgRiB3aXRoXG4gICAgICAgICAgICAvLyAgIGFyZ3VtZW50cyBcImFyZ3VtZW50c1wiLCBQcm9wZXJ0eURlc2NyaXB0b3Ige1tbR2V0XV06IHRocm93ZXIsXG4gICAgICAgICAgICAvLyAgIFtbU2V0XV06IHRocm93ZXIsIFtbRW51bWVyYWJsZV1dOiBmYWxzZSwgW1tDb25maWd1cmFibGVdXTogZmFsc2V9LFxuICAgICAgICAgICAgLy8gICBhbmQgZmFsc2UuXG5cbiAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgIC8vIE5PVEUgRnVuY3Rpb24gb2JqZWN0cyBjcmVhdGVkIHVzaW5nIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGRvIG5vdFxuICAgICAgICAgICAgLy8gaGF2ZSBhIHByb3RvdHlwZSBwcm9wZXJ0eSBvciB0aGUgW1tDb2RlXV0sIFtbRm9ybWFsUGFyYW1ldGVyc11dLCBhbmRcbiAgICAgICAgICAgIC8vIFtbU2NvcGVdXSBpbnRlcm5hbCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgLy8gWFhYIGNhbid0IGRlbGV0ZSBwcm90b3R5cGUgaW4gcHVyZS1qcy5cblxuICAgICAgICAgICAgLy8gMjIuIFJldHVybiBGLlxuICAgICAgICAgICAgcmV0dXJuIGJvdW5kO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBfUGxlYXNlIG5vdGU6IFNob3J0Y3V0cyBhcmUgZGVmaW5lZCBhZnRlciBgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRgIGFzIHdlXG4gICAgLy8gdXNlIGl0IGluIGRlZmluaW5nIHNob3J0Y3V0cy5cbiAgICB2YXIgb3ducyA9IGNhbGwuYmluZChPYmplY3RQcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuICAgIHZhciB0b1N0ciA9IGNhbGwuYmluZChPYmplY3RQcm90b3R5cGUudG9TdHJpbmcpO1xuICAgIHZhciBhcnJheVNsaWNlID0gY2FsbC5iaW5kKGFycmF5X3NsaWNlKTtcbiAgICB2YXIgYXJyYXlTbGljZUFwcGx5ID0gYXBwbHkuYmluZChhcnJheV9zbGljZSk7XG4gICAgLyogZ2xvYmFscyBkb2N1bWVudCAqL1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICdvYmplY3QnICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXJyYXlTbGljZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2hpbGROb2Rlcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHZhciBvcmlnQXJyYXlTbGljZSA9IGFycmF5U2xpY2U7XG4gICAgICAgICAgICB2YXIgb3JpZ0FycmF5U2xpY2VBcHBseSA9IGFycmF5U2xpY2VBcHBseTtcbiAgICAgICAgICAgIGFycmF5U2xpY2UgPSBmdW5jdGlvbiBhcnJheVNsaWNlSUUoYXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGFyci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcltpXSA9IGFycltpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdBcnJheVNsaWNlQXBwbHkociwgb3JpZ0FycmF5U2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXJyYXlTbGljZUFwcGx5ID0gZnVuY3Rpb24gYXJyYXlTbGljZUFwcGx5SUUoYXJyLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdBcnJheVNsaWNlQXBwbHkoYXJyYXlTbGljZShhcnIpLCBhcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHN0clNsaWNlID0gY2FsbC5iaW5kKFN0cmluZ1Byb3RvdHlwZS5zbGljZSk7XG4gICAgdmFyIHN0clNwbGl0ID0gY2FsbC5iaW5kKFN0cmluZ1Byb3RvdHlwZS5zcGxpdCk7XG4gICAgdmFyIHN0ckluZGV4T2YgPSBjYWxsLmJpbmQoU3RyaW5nUHJvdG90eXBlLmluZGV4T2YpO1xuICAgIHZhciBwdXNoQ2FsbCA9IGNhbGwuYmluZChhcnJheV9wdXNoKTtcbiAgICB2YXIgaXNFbnVtID0gY2FsbC5iaW5kKE9iamVjdFByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSk7XG4gICAgdmFyIGFycmF5U29ydCA9IGNhbGwuYmluZChBcnJheVByb3RvdHlwZS5zb3J0KTtcblxuICAgIC8vXG4gICAgLy8gQXJyYXlcbiAgICAvLyA9PT09PVxuICAgIC8vXG5cbiAgICB2YXIgaXNBcnJheSA9ICRBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgICAgIHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH07XG5cbiAgICAvLyBFUzUgMTUuNC40LjEyXG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjEzXG4gICAgLy8gUmV0dXJuIGxlbithcmdDb3VudC5cbiAgICAvLyBbYnVnZml4LCBpZWx0OF1cbiAgICAvLyBJRSA8IDggYnVnOiBbXS51bnNoaWZ0KDApID09PSB1bmRlZmluZWQgYnV0IHNob3VsZCBiZSBcIjFcIlxuICAgIHZhciBoYXNVbnNoaWZ0UmV0dXJuVmFsdWVCdWcgPSBbXS51bnNoaWZ0KDApICE9PSAxO1xuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgdW5zaGlmdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYXJyYXlfdW5zaGlmdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfSwgaGFzVW5zaGlmdFJldHVyblZhbHVlQnVnKTtcblxuICAgIC8vIEVTNSAxNS40LjMuMlxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuMy4yXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaXNBcnJheVxuICAgIGRlZmluZVByb3BlcnRpZXMoJEFycmF5LCB7IGlzQXJyYXk6IGlzQXJyYXkgfSk7XG5cbiAgICAvLyBUaGUgSXNDYWxsYWJsZSgpIGNoZWNrIGluIHRoZSBBcnJheSBmdW5jdGlvbnNcbiAgICAvLyBoYXMgYmVlbiByZXBsYWNlZCB3aXRoIGEgc3RyaWN0IGNoZWNrIG9uIHRoZVxuICAgIC8vIGludGVybmFsIGNsYXNzIG9mIHRoZSBvYmplY3QgdG8gdHJhcCBjYXNlcyB3aGVyZVxuICAgIC8vIHRoZSBwcm92aWRlZCBmdW5jdGlvbiB3YXMgYWN0dWFsbHkgYSByZWd1bGFyXG4gICAgLy8gZXhwcmVzc2lvbiBsaXRlcmFsLCB3aGljaCBpbiBWOCBhbmRcbiAgICAvLyBKYXZhU2NyaXB0Q29yZSBpcyBhIHR5cGVvZiBcImZ1bmN0aW9uXCIuICBPbmx5IGluXG4gICAgLy8gVjggYXJlIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFscyBwZXJtaXR0ZWQgYXNcbiAgICAvLyByZWR1Y2UgcGFyYW1ldGVycywgc28gaXQgaXMgZGVzaXJhYmxlIGluIHRoZVxuICAgIC8vIGdlbmVyYWwgY2FzZSBmb3IgdGhlIHNoaW0gdG8gbWF0Y2ggdGhlIG1vcmVcbiAgICAvLyBzdHJpY3QgYW5kIGNvbW1vbiBiZWhhdmlvciBvZiByZWplY3RpbmcgcmVndWxhclxuICAgIC8vIGV4cHJlc3Npb25zLlxuXG4gICAgLy8gRVM1IDE1LjQuNC4xOFxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xOFxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL2FycmF5L2ZvckVhY2hcblxuICAgIC8vIENoZWNrIGZhaWx1cmUgb2YgYnktaW5kZXggYWNjZXNzIG9mIHN0cmluZyBjaGFyYWN0ZXJzIChJRSA8IDkpXG4gICAgLy8gYW5kIGZhaWx1cmUgb2YgYDAgaW4gYm94ZWRTdHJpbmdgIChSaGlubylcbiAgICB2YXIgYm94ZWRTdHJpbmcgPSAkT2JqZWN0KCdhJyk7XG4gICAgdmFyIHNwbGl0U3RyaW5nID0gYm94ZWRTdHJpbmdbMF0gIT09ICdhJyB8fCAhKDAgaW4gYm94ZWRTdHJpbmcpO1xuXG4gICAgdmFyIHByb3Blcmx5Qm94ZXNDb250ZXh0ID0gZnVuY3Rpb24gcHJvcGVybHlCb3hlZChtZXRob2QpIHtcbiAgICAgICAgLy8gQ2hlY2sgbm9kZSAwLjYuMjEgYnVnIHdoZXJlIHRoaXJkIHBhcmFtZXRlciBpcyBub3QgYm94ZWRcbiAgICAgICAgdmFyIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgPSB0cnVlO1xuICAgICAgICB2YXIgcHJvcGVybHlCb3hlc1N0cmljdCA9IHRydWU7XG4gICAgICAgIHZhciB0aHJld0V4Y2VwdGlvbiA9IGZhbHNlO1xuICAgICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG1ldGhvZC5jYWxsKCdmb28nLCBmdW5jdGlvbiAoXywgX18sIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVybHlCb3hlc05vblN0cmljdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBtZXRob2QuY2FsbChbMV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgICAgICAgICAgIHByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0eXBlb2YgdGhpcyA9PT0gJ3N0cmluZyc7XG4gICAgICAgICAgICAgICAgfSwgJ3gnKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJld0V4Y2VwdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICEhbWV0aG9kICYmICF0aHJld0V4Y2VwdGlvbiAmJiBwcm9wZXJseUJveGVzTm9uU3RyaWN0ICYmIHByb3Blcmx5Qm94ZXNTdHJpY3Q7XG4gICAgfTtcblxuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuLyosIHRoaXNBcmcqLykge1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IG9iamVjdDtcbiAgICAgICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIFQ7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBUID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICAgICAgaWYgKCFpc0NhbGxhYmxlKGNhbGxiYWNrZm4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLmZvckVhY2ggY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEludm9rZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBjYWxsLCBwYXNzaW5nIGFyZ3VtZW50czpcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udGV4dCwgcHJvcGVydHkgdmFsdWUsIHByb3BlcnR5IGtleSwgdGhpc0FyZyBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBUID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tmbihzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tmbi5jYWxsKFQsIHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCAhcHJvcGVybHlCb3hlc0NvbnRleHQoQXJyYXlQcm90b3R5cGUuZm9yRWFjaCkpO1xuXG4gICAgLy8gRVM1IDE1LjQuNC4xOVxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xOVxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NvcmVfSmF2YVNjcmlwdF8xLjVfUmVmZXJlbmNlL09iamVjdHMvQXJyYXkvbWFwXG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgICAgICBtYXA6IGZ1bmN0aW9uIG1hcChjYWxsYmFja2ZuLyosIHRoaXNBcmcqLykge1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IG9iamVjdDtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBFUy5Ub1VpbnQzMihzZWxmLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gJEFycmF5KGxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgVDtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIFQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgICAgICBpZiAoIWlzQ2FsbGFibGUoY2FsbGJhY2tmbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUubWFwIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIFQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBjYWxsYmFja2ZuKHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBjYWxsYmFja2ZuLmNhbGwoVCwgc2VsZltpXSwgaSwgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9LCAhcHJvcGVybHlCb3hlc0NvbnRleHQoQXJyYXlQcm90b3R5cGUubWFwKSk7XG5cbiAgICAvLyBFUzUgMTUuNC40LjIwXG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjIwXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vQ29yZV9KYXZhU2NyaXB0XzEuNV9SZWZlcmVuY2UvT2JqZWN0cy9BcnJheS9maWx0ZXJcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4vKiwgdGhpc0FyZyovKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogb2JqZWN0O1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgIHZhciBUO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgVCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgICAgIGlmICghaXNDYWxsYWJsZShjYWxsYmFja2ZuKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5maWx0ZXIgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gc2VsZltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBUID09PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrZm4odmFsdWUsIGksIG9iamVjdCkgOiBjYWxsYmFja2ZuLmNhbGwoVCwgdmFsdWUsIGksIG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hDYWxsKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH0sICFwcm9wZXJseUJveGVzQ29udGV4dChBcnJheVByb3RvdHlwZS5maWx0ZXIpKTtcblxuICAgIC8vIEVTNSAxNS40LjQuMTZcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTZcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9ldmVyeVxuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4vKiwgdGhpc0FyZyovKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogb2JqZWN0O1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBUO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgVCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgICAgIGlmICghaXNDYWxsYWJsZShjYWxsYmFja2ZuKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5ldmVyeSBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHNlbGYgJiYgISh0eXBlb2YgVCA9PT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFja2ZuKHNlbGZbaV0sIGksIG9iamVjdCkgOiBjYWxsYmFja2ZuLmNhbGwoVCwgc2VsZltpXSwgaSwgb2JqZWN0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSwgIXByb3Blcmx5Qm94ZXNDb250ZXh0KEFycmF5UHJvdG90eXBlLmV2ZXJ5KSk7XG5cbiAgICAvLyBFUzUgMTUuNC40LjE3XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE3XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29tZVxuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuLyosIHRoaXNBcmcgKi8pIHtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIFQ7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBUID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICAgICAgaWYgKCFpc0NhbGxhYmxlKGNhbGxiYWNrZm4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLnNvbWUgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSBpbiBzZWxmICYmICh0eXBlb2YgVCA9PT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFja2ZuKHNlbGZbaV0sIGksIG9iamVjdCkgOiBjYWxsYmFja2ZuLmNhbGwoVCwgc2VsZltpXSwgaSwgb2JqZWN0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSwgIXByb3Blcmx5Qm94ZXNDb250ZXh0KEFycmF5UHJvdG90eXBlLnNvbWUpKTtcblxuICAgIC8vIEVTNSAxNS40LjQuMjFcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMjFcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9Db3JlX0phdmFTY3JpcHRfMS41X1JlZmVyZW5jZS9PYmplY3RzL0FycmF5L3JlZHVjZVxuICAgIHZhciByZWR1Y2VDb2VyY2VzVG9PYmplY3QgPSBmYWxzZTtcbiAgICBpZiAoQXJyYXlQcm90b3R5cGUucmVkdWNlKSB7XG4gICAgICAgIHJlZHVjZUNvZXJjZXNUb09iamVjdCA9IHR5cGVvZiBBcnJheVByb3RvdHlwZS5yZWR1Y2UuY2FsbCgnZXM1JywgZnVuY3Rpb24gKF8sIF9fLCBfX18sIGxpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICB9KSA9PT0gJ29iamVjdCc7XG4gICAgfVxuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbi8qLCBpbml0aWFsVmFsdWUqLykge1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IG9iamVjdDtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBFUy5Ub1VpbnQzMihzZWxmLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgICAgICBpZiAoIWlzQ2FsbGFibGUoY2FsbGJhY2tmbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUucmVkdWNlIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBubyB2YWx1ZSB0byByZXR1cm4gaWYgbm8gaW5pdGlhbCB2YWx1ZSBhbmQgYW4gZW1wdHkgYXJyYXlcbiAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDAgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc2VsZltpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBhcnJheSBjb250YWlucyBubyB2YWx1ZXMsIG5vIGluaXRpYWwgdmFsdWUgdG8gcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIGlmICgrK2kgPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2tmbihyZXN1bHQsIHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfSwgIXJlZHVjZUNvZXJjZXNUb09iamVjdCk7XG5cbiAgICAvLyBFUzUgMTUuNC40LjIyXG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjIyXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vQ29yZV9KYXZhU2NyaXB0XzEuNV9SZWZlcmVuY2UvT2JqZWN0cy9BcnJheS9yZWR1Y2VSaWdodFxuICAgIHZhciByZWR1Y2VSaWdodENvZXJjZXNUb09iamVjdCA9IGZhbHNlO1xuICAgIGlmIChBcnJheVByb3RvdHlwZS5yZWR1Y2VSaWdodCkge1xuICAgICAgICByZWR1Y2VSaWdodENvZXJjZXNUb09iamVjdCA9IHR5cGVvZiBBcnJheVByb3RvdHlwZS5yZWR1Y2VSaWdodC5jYWxsKCdlczUnLCBmdW5jdGlvbiAoXywgX18sIF9fXywgbGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICAgIH0pID09PSAnb2JqZWN0JztcbiAgICB9XG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgICAgICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmbi8qLCBpbml0aWFsKi8pIHtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuXG4gICAgICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICAgICAgaWYgKCFpc0NhbGxhYmxlKGNhbGxiYWNrZm4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0IGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBubyB2YWx1ZSB0byByZXR1cm4gaWYgbm8gaW5pdGlhbCB2YWx1ZSwgZW1wdHkgYXJyYXlcbiAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDAgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlZHVjZVJpZ2h0IG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgdmFyIGkgPSBsZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBzZWxmW2ktLV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGFycmF5IGNvbnRhaW5zIG5vIHZhbHVlcywgbm8gaW5pdGlhbCB2YWx1ZSB0byByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgaWYgKC0taSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlZHVjZVJpZ2h0IG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrZm4ocmVzdWx0LCBzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKGktLSk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9LCAhcmVkdWNlUmlnaHRDb2VyY2VzVG9PYmplY3QpO1xuXG4gICAgLy8gRVM1IDE1LjQuNC4xNFxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xNFxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2ZcbiAgICB2YXIgaGFzRmlyZWZveDJJbmRleE9mQnVnID0gQXJyYXlQcm90b3R5cGUuaW5kZXhPZiAmJiBbMCwgMV0uaW5kZXhPZigxLCAyKSAhPT0gLTE7XG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgICAgICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQvKiwgZnJvbUluZGV4ICovKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuXG4gICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBpID0gRVMuVG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGhhbmRsZSBuZWdhdGl2ZSBpbmRpY2VzXG4gICAgICAgICAgICBpID0gaSA+PSAwID8gaSA6IG1heCgwLCBsZW5ndGggKyBpKTtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSBpbiBzZWxmICYmIHNlbGZbaV0gPT09IHNlYXJjaEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfSwgaGFzRmlyZWZveDJJbmRleE9mQnVnKTtcblxuICAgIC8vIEVTNSAxNS40LjQuMTVcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTVcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9sYXN0SW5kZXhPZlxuICAgIHZhciBoYXNGaXJlZm94Mkxhc3RJbmRleE9mQnVnID0gQXJyYXlQcm90b3R5cGUubGFzdEluZGV4T2YgJiYgWzAsIDFdLmxhc3RJbmRleE9mKDAsIC0zKSAhPT0gLTE7XG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgICAgICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudC8qLCBmcm9tSW5kZXggKi8pIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBFUy5Ub1VpbnQzMihzZWxmLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaSA9IGxlbmd0aCAtIDE7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBpID0gbWluKGksIEVTLlRvSW50ZWdlcihhcmd1bWVudHNbMV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhhbmRsZSBuZWdhdGl2ZSBpbmRpY2VzXG4gICAgICAgICAgICBpID0gaSA+PSAwID8gaSA6IGxlbmd0aCAtIGFicyhpKTtcbiAgICAgICAgICAgIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHNlbGYgJiYgc2VhcmNoRWxlbWVudCA9PT0gc2VsZltpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9LCBoYXNGaXJlZm94Mkxhc3RJbmRleE9mQnVnKTtcblxuICAgIC8vIEVTNSAxNS40LjQuMTJcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTJcbiAgICB2YXIgc3BsaWNlTm9vcFJldHVybnNFbXB0eUFycmF5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSBbMSwgMl07XG4gICAgICAgIHZhciByZXN1bHQgPSBhLnNwbGljZSgpO1xuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IDIgJiYgaXNBcnJheShyZXN1bHQpICYmIHJlc3VsdC5sZW5ndGggPT09IDA7XG4gICAgfSgpKTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIC8vIFNhZmFyaSA1LjAgYnVnIHdoZXJlIC5zcGxpY2UoKSByZXR1cm5zIHVuZGVmaW5lZFxuICAgICAgICBzcGxpY2U6IGZ1bmN0aW9uIHNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFycmF5X3NwbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIH1cbiAgICB9LCAhc3BsaWNlTm9vcFJldHVybnNFbXB0eUFycmF5KTtcblxuICAgIHZhciBzcGxpY2VXb3Jrc1dpdGhFbXB0eU9iamVjdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgQXJyYXlQcm90b3R5cGUuc3BsaWNlLmNhbGwob2JqLCAwLCAwLCAxKTtcbiAgICAgICAgcmV0dXJuIG9iai5sZW5ndGggPT09IDE7XG4gICAgfSgpKTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIHNwbGljZTogZnVuY3Rpb24gc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbWF4KEVTLlRvSW50ZWdlcih0aGlzLmxlbmd0aCksIDApO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHR5cGVvZiBkZWxldGVDb3VudCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBhcmdzID0gYXJyYXlTbGljZShhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaENhbGwoYXJncywgdGhpcy5sZW5ndGggLSBzdGFydCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1sxXSA9IEVTLlRvSW50ZWdlcihkZWxldGVDb3VudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFycmF5X3NwbGljZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH0sICFzcGxpY2VXb3Jrc1dpdGhFbXB0eU9iamVjdCk7XG4gICAgdmFyIHNwbGljZVdvcmtzV2l0aExhcmdlU3BhcnNlQXJyYXlzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMjk1XG4gICAgICAgIC8vIFNhZmFyaSA3LzggYnJlYWtzIHdpdGggc3BhcnNlIGFycmF5cyBvZiBzaXplIDFlNSBvciBncmVhdGVyXG4gICAgICAgIHZhciBhcnIgPSBuZXcgJEFycmF5KDFlNSk7XG4gICAgICAgIC8vIG5vdGU6IHRoZSBpbmRleCBNVVNUIGJlIDggb3IgbGFyZ2VyIG9yIHRoZSB0ZXN0IHdpbGwgZmFsc2UgcGFzc1xuICAgICAgICBhcnJbOF0gPSAneCc7XG4gICAgICAgIGFyci5zcGxpY2UoMSwgMSk7XG4gICAgICAgIC8vIG5vdGU6IHRoaXMgdGVzdCBtdXN0IGJlIGRlZmluZWQgKmFmdGVyKiB0aGUgaW5kZXhPZiBzaGltXG4gICAgICAgIC8vIHBlciBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzMxM1xuICAgICAgICByZXR1cm4gYXJyLmluZGV4T2YoJ3gnKSA9PT0gNztcbiAgICB9KCkpO1xuICAgIHZhciBzcGxpY2VXb3Jrc1dpdGhTbWFsbFNwYXJzZUFycmF5cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFBlciBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzI5NVxuICAgICAgICAvLyBPcGVyYSAxMi4xNSBicmVha3Mgb24gdGhpcywgbm8gaWRlYSB3aHkuXG4gICAgICAgIHZhciBuID0gMjU2O1xuICAgICAgICB2YXIgYXJyID0gW107XG4gICAgICAgIGFycltuXSA9ICdhJztcbiAgICAgICAgYXJyLnNwbGljZShuICsgMSwgMCwgJ2InKTtcbiAgICAgICAgcmV0dXJuIGFycltuXSA9PT0gJ2EnO1xuICAgIH0oKSk7XG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgICAgICBzcGxpY2U6IGZ1bmN0aW9uIHNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpIHtcbiAgICAgICAgICAgIHZhciBPID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgQSA9IFtdO1xuICAgICAgICAgICAgdmFyIGxlbiA9IEVTLlRvVWludDMyKE8ubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZVN0YXJ0ID0gRVMuVG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBhY3R1YWxTdGFydCA9IHJlbGF0aXZlU3RhcnQgPCAwID8gbWF4KChsZW4gKyByZWxhdGl2ZVN0YXJ0KSwgMCkgOiBtaW4ocmVsYXRpdmVTdGFydCwgbGVuKTtcbiAgICAgICAgICAgIHZhciBhY3R1YWxEZWxldGVDb3VudCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICA6IGFyZ3VtZW50cy5sZW5ndGggPT09IDFcbiAgICAgICAgICAgICAgICAgICAgPyBsZW4gLSBhY3R1YWxTdGFydFxuICAgICAgICAgICAgICAgICAgICA6IG1pbihtYXgoRVMuVG9JbnRlZ2VyKGRlbGV0ZUNvdW50KSwgMCksIGxlbiAtIGFjdHVhbFN0YXJ0KTtcblxuICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgdmFyIGZyb207XG4gICAgICAgICAgICB3aGlsZSAoayA8IGFjdHVhbERlbGV0ZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgZnJvbSA9ICRTdHJpbmcoYWN0dWFsU3RhcnQgKyBrKTtcbiAgICAgICAgICAgICAgICBpZiAob3ducyhPLCBmcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICBBW2tdID0gT1tmcm9tXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgayArPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBhcnJheVNsaWNlKGFyZ3VtZW50cywgMik7XG4gICAgICAgICAgICB2YXIgaXRlbUNvdW50ID0gaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHRvO1xuICAgICAgICAgICAgaWYgKGl0ZW1Db3VudCA8IGFjdHVhbERlbGV0ZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgayA9IGFjdHVhbFN0YXJ0O1xuICAgICAgICAgICAgICAgIHZhciBtYXhLID0gbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGsgPCBtYXhLKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSAkU3RyaW5nKGsgKyBhY3R1YWxEZWxldGVDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIHRvID0gJFN0cmluZyhrICsgaXRlbUNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG93bnMoTywgZnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9bdG9dID0gT1tmcm9tXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBPW3RvXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBrICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGsgPSBsZW47XG4gICAgICAgICAgICAgICAgdmFyIG1pbksgPSBsZW4gLSBhY3R1YWxEZWxldGVDb3VudCArIGl0ZW1Db3VudDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoayA+IG1pbkspIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIE9bayAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBrIC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtQ291bnQgPiBhY3R1YWxEZWxldGVDb3VudCkge1xuICAgICAgICAgICAgICAgIGsgPSBsZW4gLSBhY3R1YWxEZWxldGVDb3VudDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoayA+IGFjdHVhbFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSAkU3RyaW5nKGsgKyBhY3R1YWxEZWxldGVDb3VudCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB0byA9ICRTdHJpbmcoayArIGl0ZW1Db3VudCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3ducyhPLCBmcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT1t0b10gPSBPW2Zyb21dO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIE9bdG9dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGsgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrID0gYWN0dWFsU3RhcnQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgT1trXSA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgICAgIGsgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE8ubGVuZ3RoID0gbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQgKyBpdGVtQ291bnQ7XG5cbiAgICAgICAgICAgIHJldHVybiBBO1xuICAgICAgICB9XG4gICAgfSwgIXNwbGljZVdvcmtzV2l0aExhcmdlU3BhcnNlQXJyYXlzIHx8ICFzcGxpY2VXb3Jrc1dpdGhTbWFsbFNwYXJzZUFycmF5cyk7XG5cbiAgICB2YXIgb3JpZ2luYWxKb2luID0gQXJyYXlQcm90b3R5cGUuam9pbjtcbiAgICB2YXIgaGFzU3RyaW5nSm9pbkJ1ZztcbiAgICB0cnkge1xuICAgICAgICBoYXNTdHJpbmdKb2luQnVnID0gQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbCgnMTIzJywgJywnKSAhPT0gJzEsMiwzJztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhc1N0cmluZ0pvaW5CdWcgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaGFzU3RyaW5nSm9pbkJ1Zykge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgICAgICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIHZhciBzZXAgPSB0eXBlb2Ygc2VwYXJhdG9yID09PSAndW5kZWZpbmVkJyA/ICcsJyA6IHNlcGFyYXRvcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxKb2luLmNhbGwoaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiB0aGlzLCBzZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYXNTdHJpbmdKb2luQnVnKTtcbiAgICB9XG5cbiAgICB2YXIgaGFzSm9pblVuZGVmaW5lZEJ1ZyA9IFsxLCAyXS5qb2luKHVuZGVmaW5lZCkgIT09ICcxLDInO1xuICAgIGlmIChoYXNKb2luVW5kZWZpbmVkQnVnKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgICAgIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcCA9IHR5cGVvZiBzZXBhcmF0b3IgPT09ICd1bmRlZmluZWQnID8gJywnIDogc2VwYXJhdG9yO1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEpvaW4uY2FsbCh0aGlzLCBzZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYXNKb2luVW5kZWZpbmVkQnVnKTtcbiAgICB9XG5cbiAgICB2YXIgcHVzaFNoaW0gPSBmdW5jdGlvbiBwdXNoKGl0ZW0pIHtcbiAgICAgICAgdmFyIE8gPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIG4gPSBFUy5Ub1VpbnQzMihPLmxlbmd0aCk7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBPW24gKyBpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBPLmxlbmd0aCA9IG4gKyBpO1xuICAgICAgICByZXR1cm4gbiArIGk7XG4gICAgfTtcblxuICAgIHZhciBwdXNoSXNOb3RHZW5lcmljID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICB2YXIgcmVzdWx0ID0gQXJyYXkucHJvdG90eXBlLnB1c2guY2FsbChvYmosIHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQgIT09IDEgfHwgb2JqLmxlbmd0aCAhPT0gMSB8fCB0eXBlb2Ygb2JqWzBdICE9PSAndW5kZWZpbmVkJyB8fCAhb3ducyhvYmosIDApO1xuICAgIH0oKSk7XG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgICAgICBwdXNoOiBmdW5jdGlvbiBwdXNoKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5X3B1c2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwdXNoU2hpbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfSwgcHVzaElzTm90R2VuZXJpYyk7XG5cbiAgICAvLyBUaGlzIGZpeGVzIGEgdmVyeSB3ZWlyZCBidWcgaW4gT3BlcmEgMTAuNiB3aGVuIHB1c2hpbmcgYHVuZGVmaW5lZFxuICAgIHZhciBwdXNoVW5kZWZpbmVkSXNXZWlyZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGFyci5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQgIT09IDEgfHwgYXJyLmxlbmd0aCAhPT0gMSB8fCB0eXBlb2YgYXJyWzBdICE9PSAndW5kZWZpbmVkJyB8fCAhb3ducyhhcnIsIDApO1xuICAgIH0oKSk7XG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwgeyBwdXNoOiBwdXNoU2hpbSB9LCBwdXNoVW5kZWZpbmVkSXNXZWlyZCk7XG5cbiAgICAvLyBFUzUgMTUuMi4zLjE0XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS40LjQuMTBcbiAgICAvLyBGaXggYm94ZWQgc3RyaW5nIGJ1Z1xuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgc2xpY2U6IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgYXJyID0gaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5U2xpY2VBcHBseShhcnIsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9LCBzcGxpdFN0cmluZyk7XG5cbiAgICB2YXIgc29ydElnbm9yZXNOb25GdW5jdGlvbnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgWzEsIDJdLnNvcnQobnVsbCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgWzEsIDJdLnNvcnQoe30pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSgpKTtcbiAgICB2YXIgc29ydFRocm93c09uUmVnZXggPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB0aGlzIGlzIGEgcHJvYmxlbSBpbiBGaXJlZm94IDQsIGluIHdoaWNoIGB0eXBlb2YgL2EvID09PSAnZnVuY3Rpb24nYFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgWzEsIDJdLnNvcnQoL2EvKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSgpKTtcbiAgICB2YXIgc29ydElnbm9yZXNVbmRlZmluZWQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBhcHBsaWVzIGluIElFIDgsIGZvciBvbmUuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBbMSwgMl0uc29ydCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KCkpO1xuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlRm4pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29tcGFyZUZuID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheVNvcnQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzQ2FsbGFibGUoY29tcGFyZUZuKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5zb3J0IGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFycmF5U29ydCh0aGlzLCBjb21wYXJlRm4pO1xuICAgICAgICB9XG4gICAgfSwgc29ydElnbm9yZXNOb25GdW5jdGlvbnMgfHwgIXNvcnRJZ25vcmVzVW5kZWZpbmVkIHx8ICFzb3J0VGhyb3dzT25SZWdleCk7XG5cbiAgICAvL1xuICAgIC8vIE9iamVjdFxuICAgIC8vID09PT09PVxuICAgIC8vXG5cbiAgICAvLyBFUzUgMTUuMi4zLjE0XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjE0XG5cbiAgICAvLyBodHRwOi8vd2hhdHRoZWhlYWRzYWlkLmNvbS8yMDEwLzEwL2Etc2FmZXItb2JqZWN0LWtleXMtY29tcGF0aWJpbGl0eS1pbXBsZW1lbnRhdGlvblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBxdW90ZS1wcm9wc1xuICAgIHZhciBoYXNEb250RW51bUJ1ZyA9ICFpc0VudW0oeyAndG9TdHJpbmcnOiBudWxsIH0sICd0b1N0cmluZycpOyAvLyBqc2NzOmlnbm9yZSBkaXNhbGxvd1F1b3RlZEtleXNJbk9iamVjdHNcbiAgICB2YXIgaGFzUHJvdG9FbnVtQnVnID0gaXNFbnVtKGZ1bmN0aW9uICgpIHt9LCAncHJvdG90eXBlJyk7XG4gICAgdmFyIGhhc1N0cmluZ0VudW1CdWcgPSAhb3ducygneCcsICcwJyk7XG4gICAgdmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuICAgICAgICByZXR1cm4gY3RvciAmJiBjdG9yLnByb3RvdHlwZSA9PT0gbztcbiAgICB9O1xuICAgIHZhciBleGNsdWRlZEtleXMgPSB7XG4gICAgICAgICRhcHBsaWNhdGlvbkNhY2hlOiB0cnVlLFxuICAgICAgICAkY29uc29sZTogdHJ1ZSxcbiAgICAgICAgJGV4dGVybmFsOiB0cnVlLFxuICAgICAgICAkZnJhbWU6IHRydWUsXG4gICAgICAgICRmcmFtZUVsZW1lbnQ6IHRydWUsXG4gICAgICAgICRmcmFtZXM6IHRydWUsXG4gICAgICAgICRpbm5lckhlaWdodDogdHJ1ZSxcbiAgICAgICAgJGlubmVyV2lkdGg6IHRydWUsXG4gICAgICAgICRvbm1vemZ1bGxzY3JlZW5jaGFuZ2U6IHRydWUsXG4gICAgICAgICRvbm1vemZ1bGxzY3JlZW5lcnJvcjogdHJ1ZSxcbiAgICAgICAgJG91dGVySGVpZ2h0OiB0cnVlLFxuICAgICAgICAkb3V0ZXJXaWR0aDogdHJ1ZSxcbiAgICAgICAgJHBhZ2VYT2Zmc2V0OiB0cnVlLFxuICAgICAgICAkcGFnZVlPZmZzZXQ6IHRydWUsXG4gICAgICAgICRwYXJlbnQ6IHRydWUsXG4gICAgICAgICRzY3JvbGxMZWZ0OiB0cnVlLFxuICAgICAgICAkc2Nyb2xsVG9wOiB0cnVlLFxuICAgICAgICAkc2Nyb2xsWDogdHJ1ZSxcbiAgICAgICAgJHNjcm9sbFk6IHRydWUsXG4gICAgICAgICRzZWxmOiB0cnVlLFxuICAgICAgICAkd2Via2l0SW5kZXhlZERCOiB0cnVlLFxuICAgICAgICAkd2Via2l0U3RvcmFnZUluZm86IHRydWUsXG4gICAgICAgICR3aW5kb3c6IHRydWUsXG5cbiAgICAgICAgJHdpZHRoOiB0cnVlLFxuICAgICAgICAkaGVpZ2h0OiB0cnVlLFxuICAgICAgICAkdG9wOiB0cnVlLFxuICAgICAgICAkbG9jYWxTdG9yYWdlOiB0cnVlXG4gICAgfTtcbiAgICB2YXIgaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyogZ2xvYmFscyB3aW5kb3cgKi9cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgayBpbiB3aW5kb3cpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFleGNsdWRlZEtleXNbJyQnICsga10gJiYgb3ducyh3aW5kb3csIGspICYmIHdpbmRvd1trXSAhPT0gbnVsbCAmJiB0eXBlb2Ygd2luZG93W2tdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSh3aW5kb3dba10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSgpKTtcbiAgICB2YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1Zykge1xuICAgICAgICAgICAgcmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvYmplY3QpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBkb250RW51bXMgPSBbXG4gICAgICAgICd0b1N0cmluZycsXG4gICAgICAgICd0b0xvY2FsZVN0cmluZycsXG4gICAgICAgICd2YWx1ZU9mJyxcbiAgICAgICAgJ2hhc093blByb3BlcnR5JyxcbiAgICAgICAgJ2lzUHJvdG90eXBlT2YnLFxuICAgICAgICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAgICAgICAnY29uc3RydWN0b3InXG4gICAgXTtcbiAgICB2YXIgZG9udEVudW1zTGVuZ3RoID0gZG9udEVudW1zLmxlbmd0aDtcblxuICAgIC8vIHRha2VuIGRpcmVjdGx5IGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9pcy1hcmd1bWVudHMvYmxvYi9tYXN0ZXIvaW5kZXguanNcbiAgICAvLyBjYW4gYmUgcmVwbGFjZWQgd2l0aCByZXF1aXJlKCdpcy1hcmd1bWVudHMnKSBpZiB3ZSBldmVyIHVzZSBhIGJ1aWxkIHByb2Nlc3MgaW5zdGVhZFxuICAgIHZhciBpc1N0YW5kYXJkQXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG4gICAgfTtcbiAgICB2YXIgaXNMZWdhY3lBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT09IG51bGxcbiAgICAgICAgICAgICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInXG4gICAgICAgICAgICAmJiB2YWx1ZS5sZW5ndGggPj0gMFxuICAgICAgICAgICAgJiYgIWlzQXJyYXkodmFsdWUpXG4gICAgICAgICAgICAmJiBpc0NhbGxhYmxlKHZhbHVlLmNhbGxlZSk7XG4gICAgfTtcbiAgICB2YXIgaXNBcmd1bWVudHMgPSBpc1N0YW5kYXJkQXJndW1lbnRzKGFyZ3VtZW50cykgPyBpc1N0YW5kYXJkQXJndW1lbnRzIDogaXNMZWdhY3lBcmd1bWVudHM7XG5cbiAgICBkZWZpbmVQcm9wZXJ0aWVzKCRPYmplY3QsIHtcbiAgICAgICAga2V5czogZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBpc0ZuID0gaXNDYWxsYWJsZShvYmplY3QpO1xuICAgICAgICAgICAgdmFyIGlzQXJncyA9IGlzQXJndW1lbnRzKG9iamVjdCk7XG4gICAgICAgICAgICB2YXIgaXNPYmplY3QgPSBvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCc7XG4gICAgICAgICAgICB2YXIgaXNTdHIgPSBpc09iamVjdCAmJiBpc1N0cmluZyhvYmplY3QpO1xuXG4gICAgICAgICAgICBpZiAoIWlzT2JqZWN0ICYmICFpc0ZuICYmICFpc0FyZ3MpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gYSBub24tb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0aGVLZXlzID0gW107XG4gICAgICAgICAgICB2YXIgc2tpcFByb3RvID0gaGFzUHJvdG9FbnVtQnVnICYmIGlzRm47XG4gICAgICAgICAgICBpZiAoKGlzU3RyICYmIGhhc1N0cmluZ0VudW1CdWcpIHx8IGlzQXJncykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2hDYWxsKHRoZUtleXMsICRTdHJpbmcoaSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpc0FyZ3MpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShza2lwUHJvdG8gJiYgbmFtZSA9PT0gJ3Byb3RvdHlwZScpICYmIG93bnMob2JqZWN0LCBuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaENhbGwodGhlS2V5cywgJFN0cmluZyhuYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYXNEb250RW51bUJ1Zykge1xuICAgICAgICAgICAgICAgIHZhciBza2lwQ29uc3RydWN0b3IgPSBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kob2JqZWN0KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbnRFbnVtc0xlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb250RW51bSA9IGRvbnRFbnVtc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoc2tpcENvbnN0cnVjdG9yICYmIGRvbnRFbnVtID09PSAnY29uc3RydWN0b3InKSAmJiBvd25zKG9iamVjdCwgZG9udEVudW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoQ2FsbCh0aGVLZXlzLCBkb250RW51bSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhlS2V5cztcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIGtleXNXb3Jrc1dpdGhBcmd1bWVudHMgPSAkT2JqZWN0LmtleXMgJiYgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gU2FmYXJpIDUuMCBidWdcbiAgICAgICAgcmV0dXJuICRPYmplY3Qua2V5cyhhcmd1bWVudHMpLmxlbmd0aCA9PT0gMjtcbiAgICB9KDEsIDIpKTtcbiAgICB2YXIga2V5c0hhc0FyZ3VtZW50c0xlbmd0aEJ1ZyA9ICRPYmplY3Qua2V5cyAmJiAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJnS2V5cyA9ICRPYmplY3Qua2V5cyhhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCAhPT0gMSB8fCBhcmdLZXlzLmxlbmd0aCAhPT0gMSB8fCBhcmdLZXlzWzBdICE9PSAxO1xuICAgIH0oMSkpO1xuICAgIHZhciBvcmlnaW5hbEtleXMgPSAkT2JqZWN0LmtleXM7XG4gICAgZGVmaW5lUHJvcGVydGllcygkT2JqZWN0LCB7XG4gICAgICAgIGtleXM6IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoaXNBcmd1bWVudHMob2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEtleXMoYXJyYXlTbGljZShvYmplY3QpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEtleXMob2JqZWN0KTtcblxuICAgICAgICB9XG4gICAgfSwgIWtleXNXb3Jrc1dpdGhBcmd1bWVudHMgfHwga2V5c0hhc0FyZ3VtZW50c0xlbmd0aEJ1Zyk7XG5cbiAgICAvL1xuICAgIC8vIERhdGVcbiAgICAvLyA9PT09XG4gICAgLy9cblxuICAgIHZhciBoYXNOZWdhdGl2ZU1vbnRoWWVhckJ1ZyA9IG5ldyBEYXRlKC0zNTA5ODI3MzI5NjAwMjkyKS5nZXRVVENNb250aCgpICE9PSAwO1xuICAgIHZhciBhTmVnYXRpdmVUZXN0RGF0ZSA9IG5ldyBEYXRlKC0xNTA5ODQyMjg5NjAwMjkyKTtcbiAgICB2YXIgYVBvc2l0aXZlVGVzdERhdGUgPSBuZXcgRGF0ZSgxNDQ5NjYyNDAwMDAwKTtcbiAgICB2YXIgaGFzVG9VVENTdHJpbmdGb3JtYXRCdWcgPSBhTmVnYXRpdmVUZXN0RGF0ZS50b1VUQ1N0cmluZygpICE9PSAnTW9uLCAwMSBKYW4gLTQ1ODc1IDExOjU5OjU5IEdNVCc7XG4gICAgdmFyIGhhc1RvRGF0ZVN0cmluZ0Zvcm1hdEJ1ZztcbiAgICB2YXIgaGFzVG9TdHJpbmdGb3JtYXRCdWc7XG4gICAgdmFyIHRpbWVab25lT2Zmc2V0ID0gYU5lZ2F0aXZlVGVzdERhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICBpZiAodGltZVpvbmVPZmZzZXQgPCAtNzIwKSB7XG4gICAgICAgIGhhc1RvRGF0ZVN0cmluZ0Zvcm1hdEJ1ZyA9IGFOZWdhdGl2ZVRlc3REYXRlLnRvRGF0ZVN0cmluZygpICE9PSAnVHVlIEphbiAwMiAtNDU4NzUnO1xuICAgICAgICBoYXNUb1N0cmluZ0Zvcm1hdEJ1ZyA9ICEoL15UaHUgRGVjIDEwIDIwMTUgXFxkXFxkOlxcZFxcZDpcXGRcXGQgR01UWy0rXVxcZFxcZFxcZFxcZCg/OiB8JCkvKS50ZXN0KFN0cmluZyhhUG9zaXRpdmVUZXN0RGF0ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc1RvRGF0ZVN0cmluZ0Zvcm1hdEJ1ZyA9IGFOZWdhdGl2ZVRlc3REYXRlLnRvRGF0ZVN0cmluZygpICE9PSAnTW9uIEphbiAwMSAtNDU4NzUnO1xuICAgICAgICBoYXNUb1N0cmluZ0Zvcm1hdEJ1ZyA9ICEoL15XZWQgRGVjIDA5IDIwMTUgXFxkXFxkOlxcZFxcZDpcXGRcXGQgR01UWy0rXVxcZFxcZFxcZFxcZCg/OiB8JCkvKS50ZXN0KFN0cmluZyhhUG9zaXRpdmVUZXN0RGF0ZSkpO1xuICAgIH1cblxuICAgIHZhciBvcmlnaW5hbEdldEZ1bGxZZWFyID0gY2FsbC5iaW5kKERhdGUucHJvdG90eXBlLmdldEZ1bGxZZWFyKTtcbiAgICB2YXIgb3JpZ2luYWxHZXRNb250aCA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRNb250aCk7XG4gICAgdmFyIG9yaWdpbmFsR2V0RGF0ZSA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXREYXRlKTtcbiAgICB2YXIgb3JpZ2luYWxHZXRVVENGdWxsWWVhciA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRVVENGdWxsWWVhcik7XG4gICAgdmFyIG9yaWdpbmFsR2V0VVRDTW9udGggPSBjYWxsLmJpbmQoRGF0ZS5wcm90b3R5cGUuZ2V0VVRDTW9udGgpO1xuICAgIHZhciBvcmlnaW5hbEdldFVUQ0RhdGUgPSBjYWxsLmJpbmQoRGF0ZS5wcm90b3R5cGUuZ2V0VVRDRGF0ZSk7XG4gICAgdmFyIG9yaWdpbmFsR2V0VVRDRGF5ID0gY2FsbC5iaW5kKERhdGUucHJvdG90eXBlLmdldFVUQ0RheSk7XG4gICAgdmFyIG9yaWdpbmFsR2V0VVRDSG91cnMgPSBjYWxsLmJpbmQoRGF0ZS5wcm90b3R5cGUuZ2V0VVRDSG91cnMpO1xuICAgIHZhciBvcmlnaW5hbEdldFVUQ01pbnV0ZXMgPSBjYWxsLmJpbmQoRGF0ZS5wcm90b3R5cGUuZ2V0VVRDTWludXRlcyk7XG4gICAgdmFyIG9yaWdpbmFsR2V0VVRDU2Vjb25kcyA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRVVENTZWNvbmRzKTtcbiAgICB2YXIgb3JpZ2luYWxHZXRVVENNaWxsaXNlY29uZHMgPSBjYWxsLmJpbmQoRGF0ZS5wcm90b3R5cGUuZ2V0VVRDTWlsbGlzZWNvbmRzKTtcbiAgICB2YXIgZGF5TmFtZSA9IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J107XG4gICAgdmFyIG1vbnRoTmFtZSA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXTtcbiAgICB2YXIgZGF5c0luTW9udGggPSBmdW5jdGlvbiBkYXlzSW5Nb250aChtb250aCwgeWVhcikge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxHZXREYXRlKG5ldyBEYXRlKHllYXIsIG1vbnRoLCAwKSk7XG4gICAgfTtcblxuICAgIGRlZmluZVByb3BlcnRpZXMoRGF0ZS5wcm90b3R5cGUsIHtcbiAgICAgICAgZ2V0RnVsbFllYXI6IGZ1bmN0aW9uIGdldEZ1bGxZZWFyKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzIHx8ICEodGhpcyBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBub3QgYSBEYXRlIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB5ZWFyID0gb3JpZ2luYWxHZXRGdWxsWWVhcih0aGlzKTtcbiAgICAgICAgICAgIGlmICh5ZWFyIDwgMCAmJiBvcmlnaW5hbEdldE1vbnRoKHRoaXMpID4gMTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWVhciArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWVhcjtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TW9udGg6IGZ1bmN0aW9uIGdldE1vbnRoKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzIHx8ICEodGhpcyBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBub3QgYSBEYXRlIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB5ZWFyID0gb3JpZ2luYWxHZXRGdWxsWWVhcih0aGlzKTtcbiAgICAgICAgICAgIHZhciBtb250aCA9IG9yaWdpbmFsR2V0TW9udGgodGhpcyk7XG4gICAgICAgICAgICBpZiAoeWVhciA8IDAgJiYgbW9udGggPiAxMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoO1xuICAgICAgICB9LFxuICAgICAgICBnZXREYXRlOiBmdW5jdGlvbiBnZXREYXRlKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzIHx8ICEodGhpcyBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBub3QgYSBEYXRlIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB5ZWFyID0gb3JpZ2luYWxHZXRGdWxsWWVhcih0aGlzKTtcbiAgICAgICAgICAgIHZhciBtb250aCA9IG9yaWdpbmFsR2V0TW9udGgodGhpcyk7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG9yaWdpbmFsR2V0RGF0ZSh0aGlzKTtcbiAgICAgICAgICAgIGlmICh5ZWFyIDwgMCAmJiBtb250aCA+IDExKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vbnRoID09PSAxMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGRheXMgPSBkYXlzSW5Nb250aCgwLCB5ZWFyICsgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChkYXlzIC0gZGF0ZSkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFVUQ0Z1bGxZZWFyOiBmdW5jdGlvbiBnZXRVVENGdWxsWWVhcigpIHtcbiAgICAgICAgICAgIGlmICghdGhpcyB8fCAhKHRoaXMgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RoaXMgaXMgbm90IGEgRGF0ZSBvYmplY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgeWVhciA9IG9yaWdpbmFsR2V0VVRDRnVsbFllYXIodGhpcyk7XG4gICAgICAgICAgICBpZiAoeWVhciA8IDAgJiYgb3JpZ2luYWxHZXRVVENNb250aCh0aGlzKSA+IDExKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHllYXIgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHllYXI7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFVUQ01vbnRoOiBmdW5jdGlvbiBnZXRVVENNb250aCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcyB8fCAhKHRoaXMgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RoaXMgaXMgbm90IGEgRGF0ZSBvYmplY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgeWVhciA9IG9yaWdpbmFsR2V0VVRDRnVsbFllYXIodGhpcyk7XG4gICAgICAgICAgICB2YXIgbW9udGggPSBvcmlnaW5hbEdldFVUQ01vbnRoKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHllYXIgPCAwICYmIG1vbnRoID4gMTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb250aDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VVRDRGF0ZTogZnVuY3Rpb24gZ2V0VVRDRGF0ZSgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcyB8fCAhKHRoaXMgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RoaXMgaXMgbm90IGEgRGF0ZSBvYmplY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgeWVhciA9IG9yaWdpbmFsR2V0VVRDRnVsbFllYXIodGhpcyk7XG4gICAgICAgICAgICB2YXIgbW9udGggPSBvcmlnaW5hbEdldFVUQ01vbnRoKHRoaXMpO1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBvcmlnaW5hbEdldFVUQ0RhdGUodGhpcyk7XG4gICAgICAgICAgICBpZiAoeWVhciA8IDAgJiYgbW9udGggPiAxMSkge1xuICAgICAgICAgICAgICAgIGlmIChtb250aCA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkYXlzID0gZGF5c0luTW9udGgoMCwgeWVhciArIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoZGF5cyAtIGRhdGUpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICB9XG4gICAgfSwgaGFzTmVnYXRpdmVNb250aFllYXJCdWcpO1xuXG4gICAgZGVmaW5lUHJvcGVydGllcyhEYXRlLnByb3RvdHlwZSwge1xuICAgICAgICB0b1VUQ1N0cmluZzogZnVuY3Rpb24gdG9VVENTdHJpbmcoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMgfHwgISh0aGlzIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aGlzIGlzIG5vdCBhIERhdGUgb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRheSA9IG9yaWdpbmFsR2V0VVRDRGF5KHRoaXMpO1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBvcmlnaW5hbEdldFVUQ0RhdGUodGhpcyk7XG4gICAgICAgICAgICB2YXIgbW9udGggPSBvcmlnaW5hbEdldFVUQ01vbnRoKHRoaXMpO1xuICAgICAgICAgICAgdmFyIHllYXIgPSBvcmlnaW5hbEdldFVUQ0Z1bGxZZWFyKHRoaXMpO1xuICAgICAgICAgICAgdmFyIGhvdXIgPSBvcmlnaW5hbEdldFVUQ0hvdXJzKHRoaXMpO1xuICAgICAgICAgICAgdmFyIG1pbnV0ZSA9IG9yaWdpbmFsR2V0VVRDTWludXRlcyh0aGlzKTtcbiAgICAgICAgICAgIHZhciBzZWNvbmQgPSBvcmlnaW5hbEdldFVUQ1NlY29uZHModGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gZGF5TmFtZVtkYXldICsgJywgJ1xuICAgICAgICAgICAgICAgICsgKGRhdGUgPCAxMCA/ICcwJyArIGRhdGUgOiBkYXRlKSArICcgJ1xuICAgICAgICAgICAgICAgICsgbW9udGhOYW1lW21vbnRoXSArICcgJ1xuICAgICAgICAgICAgICAgICsgeWVhciArICcgJ1xuICAgICAgICAgICAgICAgICsgKGhvdXIgPCAxMCA/ICcwJyArIGhvdXIgOiBob3VyKSArICc6J1xuICAgICAgICAgICAgICAgICsgKG1pbnV0ZSA8IDEwID8gJzAnICsgbWludXRlIDogbWludXRlKSArICc6J1xuICAgICAgICAgICAgICAgICsgKHNlY29uZCA8IDEwID8gJzAnICsgc2Vjb25kIDogc2Vjb25kKSArICcgR01UJztcbiAgICAgICAgfVxuICAgIH0sIGhhc05lZ2F0aXZlTW9udGhZZWFyQnVnIHx8IGhhc1RvVVRDU3RyaW5nRm9ybWF0QnVnKTtcblxuICAgIC8vIE9wZXJhIDEyIGhhcyBgLGBcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKERhdGUucHJvdG90eXBlLCB7XG4gICAgICAgIHRvRGF0ZVN0cmluZzogZnVuY3Rpb24gdG9EYXRlU3RyaW5nKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzIHx8ICEodGhpcyBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBub3QgYSBEYXRlIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkYXkgPSB0aGlzLmdldERheSgpO1xuICAgICAgICAgICAgdmFyIGRhdGUgPSB0aGlzLmdldERhdGUoKTtcbiAgICAgICAgICAgIHZhciBtb250aCA9IHRoaXMuZ2V0TW9udGgoKTtcbiAgICAgICAgICAgIHZhciB5ZWFyID0gdGhpcy5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgcmV0dXJuIGRheU5hbWVbZGF5XSArICcgJ1xuICAgICAgICAgICAgICAgICsgbW9udGhOYW1lW21vbnRoXSArICcgJ1xuICAgICAgICAgICAgICAgICsgKGRhdGUgPCAxMCA/ICcwJyArIGRhdGUgOiBkYXRlKSArICcgJ1xuICAgICAgICAgICAgICAgICsgeWVhcjtcbiAgICAgICAgfVxuICAgIH0sIGhhc05lZ2F0aXZlTW9udGhZZWFyQnVnIHx8IGhhc1RvRGF0ZVN0cmluZ0Zvcm1hdEJ1Zyk7XG5cbiAgICAvLyBjYW4ndCB1c2UgZGVmaW5lUHJvcGVydGllcyBoZXJlIGJlY2F1c2Ugb2YgdG9TdHJpbmcgZW51bWVyYXRpb24gaXNzdWUgaW4gSUUgPD0gOFxuICAgIGlmIChoYXNOZWdhdGl2ZU1vbnRoWWVhckJ1ZyB8fCBoYXNUb1N0cmluZ0Zvcm1hdEJ1Zykge1xuICAgICAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzIHx8ICEodGhpcyBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBub3QgYSBEYXRlIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkYXkgPSB0aGlzLmdldERheSgpO1xuICAgICAgICAgICAgdmFyIGRhdGUgPSB0aGlzLmdldERhdGUoKTtcbiAgICAgICAgICAgIHZhciBtb250aCA9IHRoaXMuZ2V0TW9udGgoKTtcbiAgICAgICAgICAgIHZhciB5ZWFyID0gdGhpcy5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgdmFyIGhvdXIgPSB0aGlzLmdldEhvdXJzKCk7XG4gICAgICAgICAgICB2YXIgbWludXRlID0gdGhpcy5nZXRNaW51dGVzKCk7XG4gICAgICAgICAgICB2YXIgc2Vjb25kID0gdGhpcy5nZXRTZWNvbmRzKCk7XG4gICAgICAgICAgICB2YXIgdGltZXpvbmVPZmZzZXQgPSB0aGlzLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICAgICAgICB2YXIgaG91cnNPZmZzZXQgPSBmbG9vcihhYnModGltZXpvbmVPZmZzZXQpIC8gNjApO1xuICAgICAgICAgICAgdmFyIG1pbnV0ZXNPZmZzZXQgPSBmbG9vcihhYnModGltZXpvbmVPZmZzZXQpICUgNjApO1xuICAgICAgICAgICAgcmV0dXJuIGRheU5hbWVbZGF5XSArICcgJ1xuICAgICAgICAgICAgICAgICsgbW9udGhOYW1lW21vbnRoXSArICcgJ1xuICAgICAgICAgICAgICAgICsgKGRhdGUgPCAxMCA/ICcwJyArIGRhdGUgOiBkYXRlKSArICcgJ1xuICAgICAgICAgICAgICAgICsgeWVhciArICcgJ1xuICAgICAgICAgICAgICAgICsgKGhvdXIgPCAxMCA/ICcwJyArIGhvdXIgOiBob3VyKSArICc6J1xuICAgICAgICAgICAgICAgICsgKG1pbnV0ZSA8IDEwID8gJzAnICsgbWludXRlIDogbWludXRlKSArICc6J1xuICAgICAgICAgICAgICAgICsgKHNlY29uZCA8IDEwID8gJzAnICsgc2Vjb25kIDogc2Vjb25kKSArICcgR01UJ1xuICAgICAgICAgICAgICAgICsgKHRpbWV6b25lT2Zmc2V0ID4gMCA/ICctJyA6ICcrJylcbiAgICAgICAgICAgICAgICArIChob3Vyc09mZnNldCA8IDEwID8gJzAnICsgaG91cnNPZmZzZXQgOiBob3Vyc09mZnNldClcbiAgICAgICAgICAgICAgICArIChtaW51dGVzT2Zmc2V0IDwgMTAgPyAnMCcgKyBtaW51dGVzT2Zmc2V0IDogbWludXRlc09mZnNldCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG4gICAgICAgICAgICAkT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGUucHJvdG90eXBlLCAndG9TdHJpbmcnLCB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVTNSAxNS45LjUuNDNcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS45LjUuNDNcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBTdHJpbmcgdmFsdWUgcmVwcmVzZW50IHRoZSBpbnN0YW5jZSBpbiB0aW1lXG4gICAgLy8gcmVwcmVzZW50ZWQgYnkgdGhpcyBEYXRlIG9iamVjdC4gVGhlIGZvcm1hdCBvZiB0aGUgU3RyaW5nIGlzIHRoZSBEYXRlIFRpbWVcbiAgICAvLyBzdHJpbmcgZm9ybWF0IGRlZmluZWQgaW4gMTUuOS4xLjE1LiBBbGwgZmllbGRzIGFyZSBwcmVzZW50IGluIHRoZSBTdHJpbmcuXG4gICAgLy8gVGhlIHRpbWUgem9uZSBpcyBhbHdheXMgVVRDLCBkZW5vdGVkIGJ5IHRoZSBzdWZmaXggWi4gSWYgdGhlIHRpbWUgdmFsdWUgb2ZcbiAgICAvLyB0aGlzIG9iamVjdCBpcyBub3QgYSBmaW5pdGUgTnVtYmVyIGEgUmFuZ2VFcnJvciBleGNlcHRpb24gaXMgdGhyb3duLlxuICAgIHZhciBuZWdhdGl2ZURhdGUgPSAtNjIxOTg3NTUyMDAwMDA7XG4gICAgdmFyIG5lZ2F0aXZlWWVhclN0cmluZyA9ICctMDAwMDAxJztcbiAgICB2YXIgaGFzTmVnYXRpdmVEYXRlQnVnID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgJiYgbmV3IERhdGUobmVnYXRpdmVEYXRlKS50b0lTT1N0cmluZygpLmluZGV4T2YobmVnYXRpdmVZZWFyU3RyaW5nKSA9PT0gLTE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbWF4LWxlblxuICAgIHZhciBoYXNTYWZhcmk1MURhdGVCdWcgPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyAmJiBuZXcgRGF0ZSgtMSkudG9JU09TdHJpbmcoKSAhPT0gJzE5NjktMTItMzFUMjM6NTk6NTkuOTk5Wic7XG5cbiAgICB2YXIgZ2V0VGltZSA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRUaW1lKTtcblxuICAgIGRlZmluZVByb3BlcnRpZXMoRGF0ZS5wcm90b3R5cGUsIHtcbiAgICAgICAgdG9JU09TdHJpbmc6IGZ1bmN0aW9uIHRvSVNPU3RyaW5nKCkge1xuICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZSh0aGlzKSB8fCAhaXNGaW5pdGUoZ2V0VGltZSh0aGlzKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBBZG9wZSBQaG90b3Nob3AgcmVxdWlyZXMgdGhlIHNlY29uZCBjaGVjay5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgY2FsbGVkIG9uIG5vbi1maW5pdGUgdmFsdWUuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB5ZWFyID0gb3JpZ2luYWxHZXRVVENGdWxsWWVhcih0aGlzKTtcblxuICAgICAgICAgICAgdmFyIG1vbnRoID0gb3JpZ2luYWxHZXRVVENNb250aCh0aGlzKTtcbiAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzExMVxuICAgICAgICAgICAgeWVhciArPSBmbG9vcihtb250aCAvIDEyKTtcbiAgICAgICAgICAgIG1vbnRoID0gKChtb250aCAlIDEyKSArIDEyKSAlIDEyO1xuXG4gICAgICAgICAgICAvLyB0aGUgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQgaXMgc3BlY2lmaWVkIGluIDE1LjkuMS4xNS5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgbW9udGggKyAxLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsR2V0VVRDRGF0ZSh0aGlzKSxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEdldFVUQ0hvdXJzKHRoaXMpLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsR2V0VVRDTWludXRlcyh0aGlzKSxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEdldFVUQ1NlY29uZHModGhpcylcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB5ZWFyID0gKFxuICAgICAgICAgICAgICAgICh5ZWFyIDwgMCA/ICctJyA6ICh5ZWFyID4gOTk5OSA/ICcrJyA6ICcnKSlcbiAgICAgICAgICAgICAgICArIHN0clNsaWNlKCcwMDAwMCcgKyBhYnMoeWVhciksICgwIDw9IHllYXIgJiYgeWVhciA8PSA5OTk5KSA/IC00IDogLTYpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIC8vIHBhZCBtb250aHMsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kcyB0byBoYXZlIHR3byBkaWdpdHMuXG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gc3RyU2xpY2UoJzAwJyArIHJlc3VsdFtpXSwgLTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcGFkIG1pbGxpc2Vjb25kcyB0byBoYXZlIHRocmVlIGRpZ2l0cy5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgeWVhciArICctJyArIGFycmF5U2xpY2UocmVzdWx0LCAwLCAyKS5qb2luKCctJylcbiAgICAgICAgICAgICAgICArICdUJyArIGFycmF5U2xpY2UocmVzdWx0LCAyKS5qb2luKCc6JykgKyAnLidcbiAgICAgICAgICAgICAgICArIHN0clNsaWNlKCcwMDAnICsgb3JpZ2luYWxHZXRVVENNaWxsaXNlY29uZHModGhpcyksIC0zKSArICdaJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0sIGhhc05lZ2F0aXZlRGF0ZUJ1ZyB8fCBoYXNTYWZhcmk1MURhdGVCdWcpO1xuXG4gICAgLy8gRVM1IDE1LjkuNS40NFxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjkuNS40NFxuICAgIC8vIFRoaXMgZnVuY3Rpb24gcHJvdmlkZXMgYSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBEYXRlIG9iamVjdCBmb3IgdXNlIGJ5XG4gICAgLy8gSlNPTi5zdHJpbmdpZnkgKDE1LjEyLjMpLlxuICAgIHZhciBkYXRlVG9KU09OSXNTdXBwb3J0ZWQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIERhdGUucHJvdG90eXBlLnRvSlNPTlxuICAgICAgICAgICAgICAgICYmIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcbiAgICAgICAgICAgICAgICAmJiBuZXcgRGF0ZShuZWdhdGl2ZURhdGUpLnRvSlNPTigpLmluZGV4T2YobmVnYXRpdmVZZWFyU3RyaW5nKSAhPT0gLTFcbiAgICAgICAgICAgICAgICAmJiBEYXRlLnByb3RvdHlwZS50b0pTT04uY2FsbCh7IC8vIGdlbmVyaWNcbiAgICAgICAgICAgICAgICAgICAgdG9JU09TdHJpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSgpKTtcbiAgICBpZiAoIWRhdGVUb0pTT05Jc1N1cHBvcnRlZCkge1xuICAgICAgICBEYXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oa2V5KSB7XG4gICAgICAgICAgICAvLyBXaGVuIHRoZSB0b0pTT04gbWV0aG9kIGlzIGNhbGxlZCB3aXRoIGFyZ3VtZW50IGtleSwgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgICAgLy8gc3RlcHMgYXJlIHRha2VuOlxuXG4gICAgICAgICAgICAvLyAxLiAgTGV0IE8gYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIFRvT2JqZWN0LCBnaXZpbmcgaXQgdGhlIHRoaXNcbiAgICAgICAgICAgIC8vIHZhbHVlIGFzIGl0cyBhcmd1bWVudC5cbiAgICAgICAgICAgIC8vIDIuIExldCB0diBiZSBFUy5Ub1ByaW1pdGl2ZShPLCBoaW50IE51bWJlcikuXG4gICAgICAgICAgICB2YXIgTyA9ICRPYmplY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgdHYgPSBFUy5Ub1ByaW1pdGl2ZShPKTtcbiAgICAgICAgICAgIC8vIDMuIElmIHR2IGlzIGEgTnVtYmVyIGFuZCBpcyBub3QgZmluaXRlLCByZXR1cm4gbnVsbC5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHYgPT09ICdudW1iZXInICYmICFpc0Zpbml0ZSh0dikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDQuIExldCB0b0lTTyBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFtbR2V0XV0gaW50ZXJuYWwgbWV0aG9kIG9mXG4gICAgICAgICAgICAvLyBPIHdpdGggYXJndW1lbnQgXCJ0b0lTT1N0cmluZ1wiLlxuICAgICAgICAgICAgdmFyIHRvSVNPID0gTy50b0lTT1N0cmluZztcbiAgICAgICAgICAgIC8vIDUuIElmIElzQ2FsbGFibGUodG9JU08pIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgICAgICAgICBpZiAoIWlzQ2FsbGFibGUodG9JU08pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndG9JU09TdHJpbmcgcHJvcGVydHkgaXMgbm90IGNhbGxhYmxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA2LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2Qgb2ZcbiAgICAgICAgICAgIC8vICB0b0lTTyB3aXRoIE8gYXMgdGhlIHRoaXMgdmFsdWUgYW5kIGFuIGVtcHR5IGFyZ3VtZW50IGxpc3QuXG4gICAgICAgICAgICByZXR1cm4gdG9JU08uY2FsbChPKTtcblxuICAgICAgICAgICAgLy8gTk9URSAxIFRoZSBhcmd1bWVudCBpcyBpZ25vcmVkLlxuXG4gICAgICAgICAgICAvLyBOT1RFIDIgVGhlIHRvSlNPTiBmdW5jdGlvbiBpcyBpbnRlbnRpb25hbGx5IGdlbmVyaWM7IGl0IGRvZXMgbm90XG4gICAgICAgICAgICAvLyByZXF1aXJlIHRoYXQgaXRzIHRoaXMgdmFsdWUgYmUgYSBEYXRlIG9iamVjdC4gVGhlcmVmb3JlLCBpdCBjYW4gYmVcbiAgICAgICAgICAgIC8vIHRyYW5zZmVycmVkIHRvIG90aGVyIGtpbmRzIG9mIG9iamVjdHMgZm9yIHVzZSBhcyBhIG1ldGhvZC4gSG93ZXZlcixcbiAgICAgICAgICAgIC8vIGl0IGRvZXMgcmVxdWlyZSB0aGF0IGFueSBzdWNoIG9iamVjdCBoYXZlIGEgdG9JU09TdHJpbmcgbWV0aG9kLiBBblxuICAgICAgICAgICAgLy8gb2JqZWN0IGlzIGZyZWUgdG8gdXNlIHRoZSBhcmd1bWVudCBrZXkgdG8gZmlsdGVyIGl0c1xuICAgICAgICAgICAgLy8gc3RyaW5naWZpY2F0aW9uLlxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEVTNSAxNS45LjQuMlxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjkuNC4yXG4gICAgLy8gYmFzZWQgb24gd29yayBzaGFyZWQgYnkgRGFuaWVsIEZyaWVzZW4gKGRhbnRtYW4pXG4gICAgLy8gaHR0cDovL2dpc3QuZ2l0aHViLmNvbS8zMDMyNDlcbiAgICB2YXIgc3VwcG9ydHNFeHRlbmRlZFllYXJzID0gRGF0ZS5wYXJzZSgnKzAzMzY1OC0wOS0yN1QwMTo0Njo0MC4wMDBaJykgPT09IDFlMTU7XG4gICAgdmFyIGFjY2VwdHNJbnZhbGlkRGF0ZXMgPSAhaXNOYU4oRGF0ZS5wYXJzZSgnMjAxMi0wNC0wNFQyNDowMDowMC41MDBaJykpIHx8ICFpc05hTihEYXRlLnBhcnNlKCcyMDEyLTExLTMxVDIzOjU5OjU5LjAwMFonKSkgfHwgIWlzTmFOKERhdGUucGFyc2UoJzIwMTItMTItMzFUMjM6NTk6NjAuMDAwWicpKTtcbiAgICB2YXIgZG9lc05vdFBhcnNlWTJLTmV3WWVhciA9IGlzTmFOKERhdGUucGFyc2UoJzIwMDAtMDEtMDFUMDA6MDA6MDAuMDAwWicpKTtcbiAgICBpZiAoZG9lc05vdFBhcnNlWTJLTmV3WWVhciB8fCBhY2NlcHRzSW52YWxpZERhdGVzIHx8ICFzdXBwb3J0c0V4dGVuZGVkWWVhcnMpIHtcbiAgICAgICAgLy8gWFhYIGdsb2JhbCBhc3NpZ25tZW50IHdvbid0IHdvcmsgaW4gZW1iZWRkaW5ncyB0aGF0IHVzZVxuICAgICAgICAvLyBhbiBhbHRlcm5hdGUgb2JqZWN0IGZvciB0aGUgY29udGV4dC5cbiAgICAgICAgdmFyIG1heFNhZmVVbnNpZ25lZDMyQml0ID0gcG93KDIsIDMxKSAtIDE7XG4gICAgICAgIHZhciBoYXNTYWZhcmlTaWduZWRJbnRCdWcgPSBpc0FjdHVhbE5hTihuZXcgRGF0ZSgxOTcwLCAwLCAxLCAwLCAwLCAwLCBtYXhTYWZlVW5zaWduZWQzMkJpdCArIDEpLmdldFRpbWUoKSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbXBsaWNpdC1nbG9iYWxzLCBuby1nbG9iYWwtYXNzaWduXG4gICAgICAgIERhdGUgPSAoZnVuY3Rpb24gKE5hdGl2ZURhdGUpIHtcbiAgICAgICAgICAgIC8vIERhdGUubGVuZ3RoID09PSA3XG4gICAgICAgICAgICB2YXIgRGF0ZVNoaW0gPSBmdW5jdGlvbiBEYXRlKFksIE0sIEQsIGgsIG0sIHMsIG1zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBOYXRpdmVEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWNvbmRzID0gcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pbGxpcyA9IG1zO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzU2FmYXJpU2lnbmVkSW50QnVnICYmIGxlbmd0aCA+PSA3ICYmIG1zID4gbWF4U2FmZVVuc2lnbmVkMzJCaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdvcmsgYXJvdW5kIGEgU2FmYXJpIDgvOSBidWcgd2hlcmUgaXQgdHJlYXRzIHRoZSBzZWNvbmRzIGFzIHNpZ25lZFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1zVG9TaGlmdCA9IGZsb29yKG1zIC8gbWF4U2FmZVVuc2lnbmVkMzJCaXQpICogbWF4U2FmZVVuc2lnbmVkMzJCaXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc1RvU2hpZnQgPSBmbG9vcihtc1RvU2hpZnQgLyAxZTMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyArPSBzVG9TaGlmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbGxpcyAtPSBzVG9TaGlmdCAqIDFlMztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkYXRlID0gbGVuZ3RoID09PSAxICYmICRTdHJpbmcoWSkgPT09IFkgLy8gaXNTdHJpbmcoWSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGV4cGxpY2l0bHkgcGFzcyBpdCB0aHJvdWdoIHBhcnNlOlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXcgTmF0aXZlRGF0ZShEYXRlU2hpbS5wYXJzZShZKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gbWFudWFsbHkgbWFrZSBjYWxscyBkZXBlbmRpbmcgb24gYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxlbmd0aCBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGxlbmd0aCA+PSA3ID8gbmV3IE5hdGl2ZURhdGUoWSwgTSwgRCwgaCwgbSwgc2Vjb25kcywgbWlsbGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbGVuZ3RoID49IDYgPyBuZXcgTmF0aXZlRGF0ZShZLCBNLCBELCBoLCBtLCBzZWNvbmRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGxlbmd0aCA+PSA1ID8gbmV3IE5hdGl2ZURhdGUoWSwgTSwgRCwgaCwgbSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbGVuZ3RoID49IDQgPyBuZXcgTmF0aXZlRGF0ZShZLCBNLCBELCBoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbGVuZ3RoID49IDMgPyBuZXcgTmF0aXZlRGF0ZShZLCBNLCBEKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGxlbmd0aCA+PSAyID8gbmV3IE5hdGl2ZURhdGUoWSwgTSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbGVuZ3RoID49IDEgPyBuZXcgTmF0aXZlRGF0ZShZIGluc3RhbmNlb2YgTmF0aXZlRGF0ZSA/ICtZIDogWSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG5ldyBOYXRpdmVEYXRlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IE5hdGl2ZURhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ByaW1pdGl2ZShkYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG1peHVwcyB3aXRoIHVuZml4ZWQgRGF0ZSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllcyhkYXRlLCB7IGNvbnN0cnVjdG9yOiBEYXRlU2hpbSB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyAxNS45LjEuMTUgRGF0ZSBUaW1lIFN0cmluZyBGb3JtYXQuXG4gICAgICAgICAgICB2YXIgaXNvRGF0ZUV4cHJlc3Npb24gPSBuZXcgUmVnRXhwKCdeJ1xuICAgICAgICAgICAgICAgICsgJyhcXFxcZHs0fXxbKy1dXFxcXGR7Nn0pJyAvLyBmb3VyLWRpZ2l0IHllYXIgY2FwdHVyZSBvciBzaWduICsgNi1kaWdpdCBleHRlbmRlZCB5ZWFyXG4gICAgICAgICAgICAgICAgKyAnKD86LShcXFxcZHsyfSknIC8vIG9wdGlvbmFsIG1vbnRoIGNhcHR1cmVcbiAgICAgICAgICAgICAgICArICcoPzotKFxcXFxkezJ9KScgLy8gb3B0aW9uYWwgZGF5IGNhcHR1cmVcbiAgICAgICAgICAgICAgICArICcoPzonIC8vIGNhcHR1cmUgaG91cnM6bWludXRlczpzZWNvbmRzLm1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgICAgICAgICArICdUKFxcXFxkezJ9KScgLy8gaG91cnMgY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICArICc6KFxcXFxkezJ9KScgLy8gbWludXRlcyBjYXB0dXJlXG4gICAgICAgICAgICAgICAgICAgICsgJyg/OicgLy8gb3B0aW9uYWwgOnNlY29uZHMubWlsbGlzZWNvbmRzXG4gICAgICAgICAgICAgICAgICAgICAgICArICc6KFxcXFxkezJ9KScgLy8gc2Vjb25kcyBjYXB0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICArICcoPzooXFxcXC5cXFxcZHsxLH0pKT8nIC8vIG1pbGxpc2Vjb25kcyBjYXB0dXJlXG4gICAgICAgICAgICAgICAgICAgICsgJyk/J1xuICAgICAgICAgICAgICAgICsgJygnIC8vIGNhcHR1cmUgVVRDIG9mZnNldCBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgKyAnWnwnIC8vIFVUQyBjYXB0dXJlXG4gICAgICAgICAgICAgICAgICAgICsgJyg/OicgLy8gb2Zmc2V0IHNwZWNpZmllciArLy1ob3VyczptaW51dGVzXG4gICAgICAgICAgICAgICAgICAgICAgICArICcoWy0rXSknIC8vIHNpZ24gY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAnKFxcXFxkezJ9KScgLy8gaG91cnMgb2Zmc2V0IGNhcHR1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJzooXFxcXGR7Mn0pJyAvLyBtaW51dGVzIG9mZnNldCBjYXB0dXJlXG4gICAgICAgICAgICAgICAgICAgICsgJyknXG4gICAgICAgICAgICAgICAgKyAnKT8pPyk/KT8nXG4gICAgICAgICAgICArICckJyk7XG5cbiAgICAgICAgICAgIHZhciBtb250aHMgPSBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzQsIDM2NV07XG5cbiAgICAgICAgICAgIHZhciBkYXlGcm9tTW9udGggPSBmdW5jdGlvbiBkYXlGcm9tTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IG1vbnRoID4gMSA/IDEgOiAwO1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoc1ttb250aF1cbiAgICAgICAgICAgICAgICAgICAgKyBmbG9vcigoeWVhciAtIDE5NjkgKyB0KSAvIDQpXG4gICAgICAgICAgICAgICAgICAgIC0gZmxvb3IoKHllYXIgLSAxOTAxICsgdCkgLyAxMDApXG4gICAgICAgICAgICAgICAgICAgICsgZmxvb3IoKHllYXIgLSAxNjAxICsgdCkgLyA0MDApXG4gICAgICAgICAgICAgICAgICAgICsgKDM2NSAqICh5ZWFyIC0gMTk3MCkpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciB0b1VUQyA9IGZ1bmN0aW9uIHRvVVRDKHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIG1zID0gdDtcbiAgICAgICAgICAgICAgICBpZiAoaGFzU2FmYXJpU2lnbmVkSW50QnVnICYmIG1zID4gbWF4U2FmZVVuc2lnbmVkMzJCaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd29yayBhcm91bmQgYSBTYWZhcmkgOC85IGJ1ZyB3aGVyZSBpdCB0cmVhdHMgdGhlIHNlY29uZHMgYXMgc2lnbmVkXG4gICAgICAgICAgICAgICAgICAgIHZhciBtc1RvU2hpZnQgPSBmbG9vcihtcyAvIG1heFNhZmVVbnNpZ25lZDMyQml0KSAqIG1heFNhZmVVbnNpZ25lZDMyQml0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc1RvU2hpZnQgPSBmbG9vcihtc1RvU2hpZnQgLyAxZTMpO1xuICAgICAgICAgICAgICAgICAgICBzICs9IHNUb1NoaWZ0O1xuICAgICAgICAgICAgICAgICAgICBtcyAtPSBzVG9TaGlmdCAqIDFlMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICROdW1iZXIobmV3IE5hdGl2ZURhdGUoMTk3MCwgMCwgMSwgMCwgMCwgcywgbXMpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIENvcHkgYW55IGN1c3RvbSBtZXRob2RzIGEgM3JkIHBhcnR5IGxpYnJhcnkgbWF5IGhhdmUgYWRkZWRcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBOYXRpdmVEYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG93bnMoTmF0aXZlRGF0ZSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBEYXRlU2hpbVtrZXldID0gTmF0aXZlRGF0ZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29weSBcIm5hdGl2ZVwiIG1ldGhvZHMgZXhwbGljaXRseTsgdGhleSBtYXkgYmUgbm9uLWVudW1lcmFibGVcbiAgICAgICAgICAgIGRlZmluZVByb3BlcnRpZXMoRGF0ZVNoaW0sIHtcbiAgICAgICAgICAgICAgICBub3c6IE5hdGl2ZURhdGUubm93LFxuICAgICAgICAgICAgICAgIFVUQzogTmF0aXZlRGF0ZS5VVENcbiAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgRGF0ZVNoaW0ucHJvdG90eXBlID0gTmF0aXZlRGF0ZS5wcm90b3R5cGU7XG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKERhdGVTaGltLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogRGF0ZVNoaW0gfSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIFVwZ3JhZGUgRGF0ZS5wYXJzZSB0byBoYW5kbGUgc2ltcGxpZmllZCBJU08gODYwMSBzdHJpbmdzXG4gICAgICAgICAgICB2YXIgcGFyc2VTaGltID0gZnVuY3Rpb24gcGFyc2Uoc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gaXNvRGF0ZUV4cHJlc3Npb24uZXhlYyhzdHJpbmcpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwYXJzZSBtb250aHMsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICAgICAgICAgIC8vIHByb3ZpZGUgZGVmYXVsdCB2YWx1ZXMgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgICAgIC8vIHBhcnNlIHRoZSBVVEMgb2Zmc2V0IGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICB2YXIgeWVhciA9ICROdW1iZXIobWF0Y2hbMV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9udGggPSAkTnVtYmVyKG1hdGNoWzJdIHx8IDEpIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRheSA9ICROdW1iZXIobWF0Y2hbM10gfHwgMSkgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG91ciA9ICROdW1iZXIobWF0Y2hbNF0gfHwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW51dGUgPSAkTnVtYmVyKG1hdGNoWzVdIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kID0gJE51bWJlcihtYXRjaFs2XSB8fCAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kID0gZmxvb3IoJE51bWJlcihtYXRjaFs3XSB8fCAwKSAqIDEwMDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aW1lIHpvbmUgaXMgbWlzc2VkLCBsb2NhbCBvZmZzZXQgc2hvdWxkIGJlIHVzZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIChFUyA1LjEgYnVnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vYnVncy5lY21hc2NyaXB0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTEyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0xvY2FsVGltZSA9IEJvb2xlYW4obWF0Y2hbNF0gJiYgIW1hdGNoWzhdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25PZmZzZXQgPSBtYXRjaFs5XSA9PT0gJy0nID8gMSA6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG91ck9mZnNldCA9ICROdW1iZXIobWF0Y2hbMTBdIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWludXRlT2Zmc2V0ID0gJE51bWJlcihtYXRjaFsxMV0gfHwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNNaW51dGVzT3JTZWNvbmRzT3JNaWxsaXNlY29uZHMgPSBtaW51dGUgPiAwIHx8IHNlY29uZCA+IDAgfHwgbWlsbGlzZWNvbmQgPiAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBob3VyIDwgKGhhc01pbnV0ZXNPclNlY29uZHNPck1pbGxpc2Vjb25kcyA/IDI0IDogMjUpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBtaW51dGUgPCA2MCAmJiBzZWNvbmQgPCA2MCAmJiBtaWxsaXNlY29uZCA8IDEwMDBcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIG1vbnRoID4gLTEgJiYgbW9udGggPCAxMiAmJiBob3VyT2Zmc2V0IDwgMjRcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIG1pbnV0ZU9mZnNldCA8IDYwIC8vIGRldGVjdCBpbnZhbGlkIG9mZnNldHNcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIGRheSA+IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBkYXkgPCAoZGF5RnJvbU1vbnRoKHllYXIsIG1vbnRoICsgMSkgLSBkYXlGcm9tTW9udGgoeWVhciwgbW9udGgpKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGRheUZyb21Nb250aCh5ZWFyLCBtb250aCkgKyBkYXkpICogMjQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBob3VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAoaG91ck9mZnNldCAqIHNpZ25PZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICApICogNjA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgocmVzdWx0ICsgbWludXRlICsgKG1pbnV0ZU9mZnNldCAqIHNpZ25PZmZzZXQpKSAqIDYwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgc2Vjb25kXG4gICAgICAgICAgICAgICAgICAgICAgICApICogMTAwMCkgKyBtaWxsaXNlY29uZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0xvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRvVVRDKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLTguNjRlMTUgPD0gcmVzdWx0ICYmIHJlc3VsdCA8PSA4LjY0ZTE1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gTmF0aXZlRGF0ZS5wYXJzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlZmluZVByb3BlcnRpZXMoRGF0ZVNoaW0sIHsgcGFyc2U6IHBhcnNlU2hpbSB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIERhdGVTaGltO1xuICAgICAgICB9KERhdGUpKTtcbiAgICB9XG5cbiAgICAvLyBFUzUgMTUuOS40LjRcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS45LjQuNFxuICAgIGlmICghRGF0ZS5ub3cpIHtcbiAgICAgICAgRGF0ZS5ub3cgPSBmdW5jdGlvbiBub3coKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBOdW1iZXJcbiAgICAvLyA9PT09PT1cbiAgICAvL1xuXG4gICAgLy8gRVM1LjEgMTUuNy40LjVcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS43LjQuNVxuICAgIHZhciBoYXNUb0ZpeGVkQnVncyA9IE51bWJlclByb3RvdHlwZS50b0ZpeGVkICYmIChcbiAgICAgICAgKDAuMDAwMDgpLnRvRml4ZWQoMykgIT09ICcwLjAwMCdcbiAgICAgICAgfHwgKDAuOSkudG9GaXhlZCgwKSAhPT0gJzEnXG4gICAgICAgIHx8ICgxLjI1NSkudG9GaXhlZCgyKSAhPT0gJzEuMjUnXG4gICAgICAgIHx8ICgxMDAwMDAwMDAwMDAwMDAwMTI4KS50b0ZpeGVkKDApICE9PSAnMTAwMDAwMDAwMDAwMDAwMDEyOCdcbiAgICApO1xuXG4gICAgdmFyIHRvRml4ZWRIZWxwZXJzID0ge1xuICAgICAgICBiYXNlOiAxZTcsXG4gICAgICAgIHNpemU6IDYsXG4gICAgICAgIGRhdGE6IFswLCAwLCAwLCAwLCAwLCAwXSxcbiAgICAgICAgbXVsdGlwbHk6IGZ1bmN0aW9uIG11bHRpcGx5KG4sIGMpIHtcbiAgICAgICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgICAgICB2YXIgYzIgPSBjO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IHRvRml4ZWRIZWxwZXJzLnNpemUpIHtcbiAgICAgICAgICAgICAgICBjMiArPSBuICogdG9GaXhlZEhlbHBlcnMuZGF0YVtpXTtcbiAgICAgICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5kYXRhW2ldID0gYzIgJSB0b0ZpeGVkSGVscGVycy5iYXNlO1xuICAgICAgICAgICAgICAgIGMyID0gZmxvb3IoYzIgLyB0b0ZpeGVkSGVscGVycy5iYXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGl2aWRlOiBmdW5jdGlvbiBkaXZpZGUobikge1xuICAgICAgICAgICAgdmFyIGkgPSB0b0ZpeGVkSGVscGVycy5zaXplO1xuICAgICAgICAgICAgdmFyIGMgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgYyArPSB0b0ZpeGVkSGVscGVycy5kYXRhW2ldO1xuICAgICAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLmRhdGFbaV0gPSBmbG9vcihjIC8gbik7XG4gICAgICAgICAgICAgICAgYyA9IChjICUgbikgKiB0b0ZpeGVkSGVscGVycy5iYXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBudW1Ub1N0cmluZzogZnVuY3Rpb24gbnVtVG9TdHJpbmcoKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHRvRml4ZWRIZWxwZXJzLnNpemU7XG4gICAgICAgICAgICB2YXIgcyA9ICcnO1xuICAgICAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHMgIT09ICcnIHx8IGkgPT09IDAgfHwgdG9GaXhlZEhlbHBlcnMuZGF0YVtpXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9ICRTdHJpbmcodG9GaXhlZEhlbHBlcnMuZGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IHQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzICs9IHN0clNsaWNlKCcwMDAwMDAwJywgMCwgNyAtIHQubGVuZ3RoKSArIHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfSxcbiAgICAgICAgcG93OiBmdW5jdGlvbiBwb3coeCwgbiwgYWNjKSB7XG4gICAgICAgICAgICByZXR1cm4gKG4gPT09IDAgPyBhY2MgOiAobiAlIDIgPT09IDEgPyBwb3coeCwgbiAtIDEsIGFjYyAqIHgpIDogcG93KHggKiB4LCBuIC8gMiwgYWNjKSkpO1xuICAgICAgICB9LFxuICAgICAgICBsb2c6IGZ1bmN0aW9uIGxvZyh4KSB7XG4gICAgICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgICAgICB2YXIgeDIgPSB4O1xuICAgICAgICAgICAgd2hpbGUgKHgyID49IDQwOTYpIHtcbiAgICAgICAgICAgICAgICBuICs9IDEyO1xuICAgICAgICAgICAgICAgIHgyIC89IDQwOTY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoeDIgPj0gMikge1xuICAgICAgICAgICAgICAgIG4gKz0gMTtcbiAgICAgICAgICAgICAgICB4MiAvPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHRvRml4ZWRTaGltID0gZnVuY3Rpb24gdG9GaXhlZChmcmFjdGlvbkRpZ2l0cykge1xuICAgICAgICB2YXIgZiwgeCwgcywgbSwgZSwgeiwgaiwgaztcblxuICAgICAgICAvLyBUZXN0IGZvciBOYU4gYW5kIHJvdW5kIGZyYWN0aW9uRGlnaXRzIGRvd25cbiAgICAgICAgZiA9ICROdW1iZXIoZnJhY3Rpb25EaWdpdHMpO1xuICAgICAgICBmID0gaXNBY3R1YWxOYU4oZikgPyAwIDogZmxvb3IoZik7XG5cbiAgICAgICAgaWYgKGYgPCAwIHx8IGYgPiAyMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ051bWJlci50b0ZpeGVkIGNhbGxlZCB3aXRoIGludmFsaWQgbnVtYmVyIG9mIGRlY2ltYWxzJyk7XG4gICAgICAgIH1cblxuICAgICAgICB4ID0gJE51bWJlcih0aGlzKTtcblxuICAgICAgICBpZiAoaXNBY3R1YWxOYU4oeCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnTmFOJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0IGlzIHRvbyBiaWcgb3Igc21hbGwsIHJldHVybiB0aGUgc3RyaW5nIHZhbHVlIG9mIHRoZSBudW1iZXJcbiAgICAgICAgaWYgKHggPD0gLTFlMjEgfHwgeCA+PSAxZTIxKSB7XG4gICAgICAgICAgICByZXR1cm4gJFN0cmluZyh4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHMgPSAnJztcblxuICAgICAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgICAgIHMgPSAnLSc7XG4gICAgICAgICAgICB4ID0gLXg7XG4gICAgICAgIH1cblxuICAgICAgICBtID0gJzAnO1xuXG4gICAgICAgIGlmICh4ID4gMWUtMjEpIHtcbiAgICAgICAgICAgIC8vIDFlLTIxIDwgeCA8IDFlMjFcbiAgICAgICAgICAgIC8vIC03MCA8IGxvZzIoeCkgPCA3MFxuICAgICAgICAgICAgZSA9IHRvRml4ZWRIZWxwZXJzLmxvZyh4ICogdG9GaXhlZEhlbHBlcnMucG93KDIsIDY5LCAxKSkgLSA2OTtcbiAgICAgICAgICAgIHogPSAoZSA8IDAgPyB4ICogdG9GaXhlZEhlbHBlcnMucG93KDIsIC1lLCAxKSA6IHggLyB0b0ZpeGVkSGVscGVycy5wb3coMiwgZSwgMSkpO1xuICAgICAgICAgICAgeiAqPSAweDEwMDAwMDAwMDAwMDAwOyAvLyBwb3coMiwgNTIpO1xuICAgICAgICAgICAgZSA9IDUyIC0gZTtcblxuICAgICAgICAgICAgLy8gLTE4IDwgZSA8IDEyMlxuICAgICAgICAgICAgLy8geCA9IHogLyAyIF4gZVxuICAgICAgICAgICAgaWYgKGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMubXVsdGlwbHkoMCwgeik7XG4gICAgICAgICAgICAgICAgaiA9IGY7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoaiA+PSA3KSB7XG4gICAgICAgICAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLm11bHRpcGx5KDFlNywgMCk7XG4gICAgICAgICAgICAgICAgICAgIGogLT0gNztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5tdWx0aXBseSh0b0ZpeGVkSGVscGVycy5wb3coMTAsIGosIDEpLCAwKTtcbiAgICAgICAgICAgICAgICBqID0gZSAtIDE7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoaiA+PSAyMykge1xuICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5kaXZpZGUoMSA8PCAyMyk7XG4gICAgICAgICAgICAgICAgICAgIGogLT0gMjM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMuZGl2aWRlKDEgPDwgaik7XG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMubXVsdGlwbHkoMSwgMSk7XG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMuZGl2aWRlKDIpO1xuICAgICAgICAgICAgICAgIG0gPSB0b0ZpeGVkSGVscGVycy5udW1Ub1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5tdWx0aXBseSgwLCB6KTtcbiAgICAgICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5tdWx0aXBseSgxIDw8ICgtZSksIDApO1xuICAgICAgICAgICAgICAgIG0gPSB0b0ZpeGVkSGVscGVycy5udW1Ub1N0cmluZygpICsgc3RyU2xpY2UoJzAuMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCAyLCAyICsgZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZiA+IDApIHtcbiAgICAgICAgICAgIGsgPSBtLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKGsgPD0gZikge1xuICAgICAgICAgICAgICAgIG0gPSBzICsgc3RyU2xpY2UoJzAuMDAwMDAwMDAwMDAwMDAwMDAwMCcsIDAsIGYgLSBrICsgMikgKyBtO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtID0gcyArIHN0clNsaWNlKG0sIDAsIGsgLSBmKSArICcuJyArIHN0clNsaWNlKG0sIGsgLSBmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG0gPSBzICsgbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH07XG4gICAgZGVmaW5lUHJvcGVydGllcyhOdW1iZXJQcm90b3R5cGUsIHsgdG9GaXhlZDogdG9GaXhlZFNoaW0gfSwgaGFzVG9GaXhlZEJ1Z3MpO1xuXG4gICAgdmFyIGhhc1RvRXhwb25lbnRpYWxSb3VuZGluZ0J1ZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gKC02LjllLTExKS50b0V4cG9uZW50aWFsKDQpICE9PSAnLTYuOTAwMGUtMTEnO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KCkpO1xuICAgIHZhciB0b0V4cG9uZW50aWFsQWxsb3dzSW5maW5pdGVEaWdpdHMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgKDEpLnRvRXhwb25lbnRpYWwoSW5maW5pdHkpO1xuICAgICAgICAgICAgKDEpLnRvRXhwb25lbnRpYWwoLUluZmluaXR5KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KCkpO1xuICAgIHZhciBvcmlnaW5hbFRvRXhwb25lbnRpYWwgPSBjYWxsLmJpbmQoTnVtYmVyUHJvdG90eXBlLnRvRXhwb25lbnRpYWwpO1xuICAgIHZhciBudW1iZXJUb1N0cmluZyA9IGNhbGwuYmluZChOdW1iZXJQcm90b3R5cGUudG9TdHJpbmcpO1xuICAgIGRlZmluZVByb3BlcnRpZXMoTnVtYmVyUHJvdG90eXBlLCB7XG4gICAgICAgIHRvRXhwb25lbnRpYWw6IGZ1bmN0aW9uIHRvRXhwb25lbnRpYWwoZnJhY3Rpb25EaWdpdHMpIHtcbiAgICAgICAgICAgIC8vIDE6IExldCB4IGJlIHRoaXMgTnVtYmVyIHZhbHVlLlxuICAgICAgICAgICAgdmFyIHggPSAkTnVtYmVyKHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGZyYWN0aW9uRGlnaXRzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFRvRXhwb25lbnRpYWwoeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZiA9IEVTLlRvSW50ZWdlcihmcmFjdGlvbkRpZ2l0cyk7XG4gICAgICAgICAgICBpZiAoaXNBY3R1YWxOYU4oeCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ05hTic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmIDwgMCB8fCBmID4gMjApIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgcHJvYmFibHkgaGF2ZSB0aHJvd24gYWxyZWFkeVxuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFRvRXhwb25lbnRpYWwoeCwgZik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG9ubHkgY2FzZXMgbGVmdCBhcmUgYSBmaW5pdGUgcmVjZWl2ZXIgKyBpbi1yYW5nZSBmcmFjdGlvbkRpZ2l0c1xuXG4gICAgICAgICAgICAvLyBpbXBsZW1lbnRhdGlvbiBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vU2hlZXRKU0Rldi8xMTAwYWQ1NmI5Zjg1NmM5NTI5OWVkMGUwNjhlZWEwOFxuXG4gICAgICAgICAgICAvLyA0OiBMZXQgcyBiZSB0aGUgZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICB2YXIgcyA9ICcnO1xuXG4gICAgICAgICAgICAvLyA1OiBJZiB4IDwgMFxuICAgICAgICAgICAgaWYgKHggPCAwKSB7XG4gICAgICAgICAgICAgICAgcyA9ICctJztcbiAgICAgICAgICAgICAgICB4ID0gLXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIDY6IElmIHggPSArSW5maW5pdHlcbiAgICAgICAgICAgIGlmICh4ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzICsgJ0luZmluaXR5JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gNzogSWYgZnJhY3Rpb25EaWdpdHMgaXMgbm90IHVuZGVmaW5lZCBhbmQgKGYgPCAwIG9yIGYgPiAyMCksIHRocm93IGEgUmFuZ2VFcnJvciBleGNlcHRpb24uXG4gICAgICAgICAgICBpZiAodHlwZW9mIGZyYWN0aW9uRGlnaXRzICE9PSAndW5kZWZpbmVkJyAmJiAoZiA8IDAgfHwgZiA+IDIwKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdGcmFjdGlvbiBkaWdpdHMgJyArIGZyYWN0aW9uRGlnaXRzICsgJyBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG0gPSAnJztcbiAgICAgICAgICAgIHZhciBlID0gMDtcbiAgICAgICAgICAgIHZhciBjID0gJyc7XG4gICAgICAgICAgICB2YXIgZCA9ICcnO1xuXG4gICAgICAgICAgICAvLyA4OiBJZiB4ID0gMCB0aGVuXG4gICAgICAgICAgICBpZiAoeCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGUgPSAwO1xuICAgICAgICAgICAgICAgIGYgPSAwO1xuICAgICAgICAgICAgICAgIG0gPSAnMCc7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyA5OiBFbHNlLCB4ICE9IDBcbiAgICAgICAgICAgICAgICB2YXIgTCA9IGxvZzEwKHgpO1xuICAgICAgICAgICAgICAgIGUgPSBmbG9vcihMKTsgLy8gMTAgKiogZSA8PSB4IGFuZCB4IDwgMTAgKiogKGUrMSlcbiAgICAgICAgICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmcmFjdGlvbkRpZ2l0cyAhPT0gJ3VuZGVmaW5lZCcpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZWdhdGVkLWNvbmRpdGlvblxuICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IHBvdygxMCwgZSAtIGYpOyAvLyB4IC8gMTAgKiogKGYrMSkgPCB3IGFuZCB3IDw9IHggLyAxMCAqKiBmXG4gICAgICAgICAgICAgICAgICAgIG4gPSByb3VuZCh4IC8gdyk7IC8vIDEwICoqIGYgPD0gbiBhbmQgbiA8IDEwICoqIChmKzEpXG4gICAgICAgICAgICAgICAgICAgIGlmICgyICogeCA+PSAoKCgyICogbikgKyAxKSAqIHcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuICs9IDE7IC8vIHBpY2sgbGFyZ2VyIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gPj0gcG93KDEwLCBmICsgMSkpIHsgLy8gMTBlLTEgPSAxZTBcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gLz0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICBlICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmID0gMTY7IC8vIHN0YXJ0IGZyb20gTWF0aC5jZWlsKE1hdGgubG9nMTAoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpKSBhbmQgbG9vcCBkb3duXG4gICAgICAgICAgICAgICAgICAgIHZhciBndWVzc19uID0gcm91bmQocG93KDEwLCBMIC0gZSArIGYpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldF9mID0gZjtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGYtLSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGd1ZXNzX24gPSByb3VuZChwb3coMTAsIEwgLSBlICsgZikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFicygoZ3Vlc3NfbiAqIHBvdygxMCwgZSAtIGYpKSAtIHgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPD0gYWJzKChuICogcG93KDEwLCBlIC0gdGFyZ2V0X2YpKSAtIHgpXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRfZiA9IGY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IGd1ZXNzX247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbSA9IG51bWJlclRvU3RyaW5nKG4sIDEwKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZyYWN0aW9uRGlnaXRzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyU2xpY2UobSwgLTEpID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBzdHJTbGljZShtLCAwLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIDEwOiBJZiBmICE9IDAsIHRoZW5cbiAgICAgICAgICAgIGlmIChmICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgbSA9IHN0clNsaWNlKG0sIDAsIDEpICsgJy4nICsgc3RyU2xpY2UobSwgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIDExOiBJZiBlID0gMCwgdGhlblxuICAgICAgICAgICAgaWYgKGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjID0gJysnO1xuICAgICAgICAgICAgICAgIGQgPSAnMCc7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyAxMjogRWxzZVxuICAgICAgICAgICAgICAgIGMgPSBlID4gMCA/ICcrJyA6ICctJztcbiAgICAgICAgICAgICAgICBkID0gbnVtYmVyVG9TdHJpbmcoYWJzKGUpLCAxMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIDEzOiBMZXQgbSBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGUgZm91ciBTdHJpbmdzIG0sIFwiZVwiLCBjLCBhbmQgZC5cbiAgICAgICAgICAgIG0gKz0gJ2UnICsgYyArIGQ7XG5cbiAgICAgICAgICAgIC8vIDE0OiBSZXR1cm4gdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlIFN0cmluZ3MgcyBhbmQgbS5cbiAgICAgICAgICAgIHJldHVybiBzICsgbTtcbiAgICAgICAgfVxuICAgIH0sIGhhc1RvRXhwb25lbnRpYWxSb3VuZGluZ0J1ZyB8fCB0b0V4cG9uZW50aWFsQWxsb3dzSW5maW5pdGVEaWdpdHMpO1xuXG4gICAgdmFyIGhhc1RvUHJlY2lzaW9uVW5kZWZpbmVkQnVnID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAxLjAudG9QcmVjaXNpb24odW5kZWZpbmVkKSA9PT0gJzEnO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0oKSk7XG4gICAgdmFyIG9yaWdpbmFsVG9QcmVjaXNpb24gPSBjYWxsLmJpbmQoTnVtYmVyUHJvdG90eXBlLnRvUHJlY2lzaW9uKTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKE51bWJlclByb3RvdHlwZSwge1xuICAgICAgICB0b1ByZWNpc2lvbjogZnVuY3Rpb24gdG9QcmVjaXNpb24ocHJlY2lzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHByZWNpc2lvbiA9PT0gJ3VuZGVmaW5lZCcgPyBvcmlnaW5hbFRvUHJlY2lzaW9uKHRoaXMpIDogb3JpZ2luYWxUb1ByZWNpc2lvbih0aGlzLCBwcmVjaXNpb24pO1xuICAgICAgICB9XG4gICAgfSwgaGFzVG9QcmVjaXNpb25VbmRlZmluZWRCdWcpO1xuXG4gICAgLy9cbiAgICAvLyBTdHJpbmdcbiAgICAvLyA9PT09PT1cbiAgICAvL1xuXG4gICAgLy8gRVM1IDE1LjUuNC4xNFxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjUuNC4xNFxuXG4gICAgLy8gW2J1Z2ZpeCwgSUUgbHQgOSwgZmlyZWZveCA0LCBLb25xdWVyb3IsIE9wZXJhLCBvYnNjdXJlIGJyb3dzZXJzXVxuICAgIC8vIE1hbnkgYnJvd3NlcnMgZG8gbm90IHNwbGl0IHByb3Blcmx5IHdpdGggcmVndWxhciBleHByZXNzaW9ucyBvciB0aGV5XG4gICAgLy8gZG8gbm90IHBlcmZvcm0gdGhlIHNwbGl0IGNvcnJlY3RseSB1bmRlciBvYnNjdXJlIGNvbmRpdGlvbnMuXG4gICAgLy8gU2VlIGh0dHA6Ly9ibG9nLnN0ZXZlbmxldml0aGFuLmNvbS9hcmNoaXZlcy9jcm9zcy1icm93c2VyLXNwbGl0XG4gICAgLy8gSSd2ZSB0ZXN0ZWQgaW4gbWFueSBicm93c2VycyBhbmQgdGhpcyBzZWVtcyB0byBjb3ZlciB0aGUgZGV2aWFudCBvbmVzOlxuICAgIC8vICAgICdhYicuc3BsaXQoLyg/OmFiKSovKSBzaG91bGQgYmUgW1wiXCIsIFwiXCJdLCBub3QgW1wiXCJdXG4gICAgLy8gICAgJy4nLnNwbGl0KC8oLj8pKC4/KS8pIHNob3VsZCBiZSBbXCJcIiwgXCIuXCIsIFwiXCIsIFwiXCJdLCBub3QgW1wiXCIsIFwiXCJdXG4gICAgLy8gICAgJ3Rlc3N0Jy5zcGxpdCgvKHMpKi8pIHNob3VsZCBiZSBbXCJ0XCIsIHVuZGVmaW5lZCwgXCJlXCIsIFwic1wiLCBcInRcIl0sIG5vdFxuICAgIC8vICAgICAgIFt1bmRlZmluZWQsIFwidFwiLCB1bmRlZmluZWQsIFwiZVwiLCAuLi5dXG4gICAgLy8gICAgJycuc3BsaXQoLy4/Lykgc2hvdWxkIGJlIFtdLCBub3QgW1wiXCJdXG4gICAgLy8gICAgJy4nLnNwbGl0KC8oKSgpLykgc2hvdWxkIGJlIFtcIi5cIl0sIG5vdCBbXCJcIiwgXCJcIiwgXCIuXCJdXG5cbiAgICBpZiAoXG4gICAgICAgICdhYicuc3BsaXQoLyg/OmFiKSovKS5sZW5ndGggIT09IDJcbiAgICAgICAgfHwgJy4nLnNwbGl0KC8oLj8pKC4/KS8pLmxlbmd0aCAhPT0gNFxuICAgICAgICB8fCAndGVzc3QnLnNwbGl0KC8ocykqLylbMV0gPT09ICd0J1xuICAgICAgICB8fCAndGVzdCcuc3BsaXQoLyg/OikvLCAtMSkubGVuZ3RoICE9PSA0XG4gICAgICAgIHx8ICcnLnNwbGl0KC8uPy8pLmxlbmd0aFxuICAgICAgICB8fCAnLicuc3BsaXQoLygpKCkvKS5sZW5ndGggPiAxXG4gICAgKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29tcGxpYW50RXhlY05wY2cgPSB0eXBlb2YgKC8oKT8/LykuZXhlYygnJylbMV0gPT09ICd1bmRlZmluZWQnOyAvLyBOUENHOiBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cFxuICAgICAgICAgICAgdmFyIG1heFNhZmUzMkJpdEludCA9IHBvdygyLCAzMikgLSAxO1xuXG4gICAgICAgICAgICBTdHJpbmdQcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0cmluZyA9IFN0cmluZyh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNlcGFyYXRvciA9PT0gJ3VuZGVmaW5lZCcgJiYgbGltaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICAgICAgICAgICAgaWYgKCFpc1JlZ2V4KHNlcGFyYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0clNwbGl0KHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyAnaScgOiAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIChzZXBhcmF0b3IubXVsdGlsaW5lID8gJ20nIDogJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAoc2VwYXJhdG9yLnVuaWNvZGUgPyAndScgOiAnJykgLy8gaW4gRVM2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAoc2VwYXJhdG9yLnN0aWNreSA/ICd5JyA6ICcnKSwgLy8gRmlyZWZveCAzKyBhbmQgRVM2XG4gICAgICAgICAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSAwLFxuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3IyLCBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBzZXBhcmF0b3JDb3B5ID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoJ14nICsgc2VwYXJhdG9yQ29weS5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogVmFsdWVzIGZvciBgbGltaXRgLCBwZXIgdGhlIHNwZWM6XG4gICAgICAgICAgICAgICAgICogSWYgdW5kZWZpbmVkOiA0Mjk0OTY3Mjk1IC8vIG1heFNhZmUzMkJpdEludFxuICAgICAgICAgICAgICAgICAqIElmIDAsIEluZmluaXR5LCBvciBOYU46IDBcbiAgICAgICAgICAgICAgICAgKiBJZiBwb3NpdGl2ZSBudW1iZXI6IGxpbWl0ID0gZmxvb3IobGltaXQpOyBpZiAobGltaXQgPiA0Mjk0OTY3Mjk1KSBsaW1pdCAtPSA0Mjk0OTY3Mjk2O1xuICAgICAgICAgICAgICAgICAqIElmIG5lZ2F0aXZlIG51bWJlcjogNDI5NDk2NzI5NiAtIGZsb29yKGFicyhsaW1pdCkpXG4gICAgICAgICAgICAgICAgICogSWYgb3RoZXI6IFR5cGUtY29udmVydCwgdGhlbiB1c2UgdGhlIGFib3ZlIHJ1bGVzXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIHNwbGl0TGltaXQgPSB0eXBlb2YgbGltaXQgPT09ICd1bmRlZmluZWQnID8gbWF4U2FmZTMyQml0SW50IDogRVMuVG9VaW50MzIobGltaXQpO1xuICAgICAgICAgICAgICAgIG1hdGNoID0gc2VwYXJhdG9yQ29weS5leGVjKHN0cmluZyk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGBzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoQ2FsbChvdXRwdXQsIHN0clNsaWNlKHN0cmluZywgbGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFswXS5yZXBsYWNlKHNlcGFyYXRvcjIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFtpXSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheV9wdXNoLmFwcGx5KG91dHB1dCwgYXJyYXlTbGljZShtYXRjaCwgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBzcGxpdExpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcGFyYXRvckNvcHkubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yQ29weS5sYXN0SW5kZXgrKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gc2VwYXJhdG9yQ29weS5leGVjKHN0cmluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3JDb3B5LnRlc3QoJycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoQ2FsbChvdXRwdXQsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2hDYWxsKG91dHB1dCwgc3RyU2xpY2Uoc3RyaW5nLCBsYXN0TGFzdEluZGV4KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQubGVuZ3RoID4gc3BsaXRMaW1pdCA/IGFycmF5U2xpY2Uob3V0cHV0LCAwLCBzcGxpdExpbWl0KSA6IG91dHB1dDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0oKSk7XG5cbiAgICAvLyBbYnVnZml4LCBjaHJvbWVdXG4gICAgLy8gSWYgc2VwYXJhdG9yIGlzIHVuZGVmaW5lZCwgdGhlbiB0aGUgcmVzdWx0IGFycmF5IGNvbnRhaW5zIGp1c3Qgb25lIFN0cmluZyxcbiAgICAvLyB3aGljaCBpcyB0aGUgdGhpcyB2YWx1ZSAoY29udmVydGVkIHRvIGEgU3RyaW5nKS4gSWYgbGltaXQgaXMgbm90IHVuZGVmaW5lZCxcbiAgICAvLyB0aGVuIHRoZSBvdXRwdXQgYXJyYXkgaXMgdHJ1bmNhdGVkIHNvIHRoYXQgaXQgY29udGFpbnMgbm8gbW9yZSB0aGFuIGxpbWl0XG4gICAgLy8gZWxlbWVudHMuXG4gICAgLy8gXCIwXCIuc3BsaXQodW5kZWZpbmVkLCAwKSAtPiBbXVxuICAgIH0gZWxzZSBpZiAoJzAnLnNwbGl0KHZvaWQgMCwgMCkubGVuZ3RoKSB7XG4gICAgICAgIFN0cmluZ1Byb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VwYXJhdG9yID09PSAndW5kZWZpbmVkJyAmJiBsaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHJTcGxpdCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgc3RyX3JlcGxhY2UgPSBTdHJpbmdQcm90b3R5cGUucmVwbGFjZTtcbiAgICB2YXIgcmVwbGFjZVJlcG9ydHNHcm91cHNDb3JyZWN0bHkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ3JvdXBzID0gW107XG4gICAgICAgICd4Jy5yZXBsYWNlKC94KC4pPy9nLCBmdW5jdGlvbiAobWF0Y2gsIGdyb3VwKSB7XG4gICAgICAgICAgICBwdXNoQ2FsbChncm91cHMsIGdyb3VwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBncm91cHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBncm91cHNbMF0gPT09ICd1bmRlZmluZWQnO1xuICAgIH0oKSk7XG5cbiAgICBpZiAoIXJlcGxhY2VSZXBvcnRzR3JvdXBzQ29ycmVjdGx5KSB7XG4gICAgICAgIFN0cmluZ1Byb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgaXNGbiA9IGlzQ2FsbGFibGUocmVwbGFjZVZhbHVlKTtcbiAgICAgICAgICAgIHZhciBoYXNDYXB0dXJpbmdHcm91cHMgPSBpc1JlZ2V4KHNlYXJjaFZhbHVlKSAmJiAoL1xcKVsqP10vKS50ZXN0KHNlYXJjaFZhbHVlLnNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoIWlzRm4gfHwgIWhhc0NhcHR1cmluZ0dyb3Vwcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJfcmVwbGFjZS5jYWxsKHRoaXMsIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHdyYXBwZWRSZXBsYWNlVmFsdWUgPSBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxMYXN0SW5kZXggPSBzZWFyY2hWYWx1ZS5sYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgc2VhcmNoVmFsdWUubGFzdEluZGV4ID0gMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gc2VhcmNoVmFsdWUuZXhlYyhtYXRjaCkgfHwgW107XG4gICAgICAgICAgICAgICAgc2VhcmNoVmFsdWUubGFzdEluZGV4ID0gb3JpZ2luYWxMYXN0SW5kZXg7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBwdXNoQ2FsbChhcmdzLCBhcmd1bWVudHNbbGVuZ3RoIC0gMl0sIGFyZ3VtZW50c1tsZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VWYWx1ZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gc3RyX3JlcGxhY2UuY2FsbCh0aGlzLCBzZWFyY2hWYWx1ZSwgd3JhcHBlZFJlcGxhY2VWYWx1ZSk7XG5cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiwgM3JkIEIuMi4zXG4gICAgLy8gTm90IGFuIEVDTUFTY3JpcHQgc3RhbmRhcmQsIGFsdGhvdWdoIEVDTUFTY3JpcHQgM3JkIEVkaXRpb24gaGFzIGFcbiAgICAvLyBub24tbm9ybWF0aXZlIHNlY3Rpb24gc3VnZ2VzdGluZyB1bmlmb3JtIHNlbWFudGljcyBhbmQgaXQgc2hvdWxkIGJlXG4gICAgLy8gbm9ybWFsaXplZCBhY3Jvc3MgYWxsIGJyb3dzZXJzXG4gICAgLy8gW2J1Z2ZpeCwgSUUgbHQgOV0gSUUgPCA5IHN1YnN0cigpIHdpdGggbmVnYXRpdmUgdmFsdWUgbm90IHdvcmtpbmcgaW4gSUVcbiAgICB2YXIgc3RyaW5nX3N1YnN0ciA9IFN0cmluZ1Byb3RvdHlwZS5zdWJzdHI7XG4gICAgdmFyIGhhc05lZ2F0aXZlU3Vic3RyQnVnID0gJycuc3Vic3RyICYmICcwYicuc3Vic3RyKC0xKSAhPT0gJ2InO1xuICAgIGRlZmluZVByb3BlcnRpZXMoU3RyaW5nUHJvdG90eXBlLCB7XG4gICAgICAgIHN1YnN0cjogZnVuY3Rpb24gc3Vic3RyKHN0YXJ0LCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBub3JtYWxpemVkU3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkU3RhcnQgPSBtYXgodGhpcy5sZW5ndGggKyBzdGFydCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nX3N1YnN0ci5jYWxsKHRoaXMsIG5vcm1hbGl6ZWRTdGFydCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH0sIGhhc05lZ2F0aXZlU3Vic3RyQnVnKTtcblxuICAgIC8vIEVTNSAxNS41LjQuMjBcbiAgICAvLyB3aGl0ZXNwYWNlIGZyb206IGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuNS40LjIwXG4gICAgdmFyIHdzID0gJ1xceDA5XFx4MEFcXHgwQlxceDBDXFx4MERcXHgyMFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzJ1xuICAgICAgICArICdcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOCdcbiAgICAgICAgKyAnXFx1MjAyOVxcdUZFRkYnO1xuICAgIHZhciB6ZXJvV2lkdGggPSAnXFx1MjAwYic7XG4gICAgdmFyIHdzUmVnZXhDaGFycyA9ICdbJyArIHdzICsgJ10nO1xuICAgIHZhciB0cmltQmVnaW5SZWdleHAgPSBuZXcgUmVnRXhwKCdeJyArIHdzUmVnZXhDaGFycyArIHdzUmVnZXhDaGFycyArICcqJyk7XG4gICAgdmFyIHRyaW1FbmRSZWdleHAgPSBuZXcgUmVnRXhwKHdzUmVnZXhDaGFycyArIHdzUmVnZXhDaGFycyArICcqJCcpO1xuICAgIHZhciBoYXNUcmltV2hpdGVzcGFjZUJ1ZyA9IFN0cmluZ1Byb3RvdHlwZS50cmltICYmICh3cy50cmltKCkgfHwgIXplcm9XaWR0aC50cmltKCkpO1xuICAgIGRlZmluZVByb3BlcnRpZXMoU3RyaW5nUHJvdG90eXBlLCB7XG4gICAgICAgIC8vIGh0dHA6Ly9ibG9nLnN0ZXZlbmxldml0aGFuLmNvbS9hcmNoaXZlcy9mYXN0ZXItdHJpbS1qYXZhc2NyaXB0XG4gICAgICAgIC8vIGh0dHA6Ly9wZXJmZWN0aW9ua2lsbHMuY29tL3doaXRlc3BhY2UtZGV2aWF0aW9ucy9cbiAgICAgICAgdHJpbTogZnVuY3Rpb24gdHJpbSgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcyA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IFwiICsgdGhpcyArICcgdG8gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJFN0cmluZyh0aGlzKS5yZXBsYWNlKHRyaW1CZWdpblJlZ2V4cCwgJycpLnJlcGxhY2UodHJpbUVuZFJlZ2V4cCwgJycpO1xuICAgICAgICB9XG4gICAgfSwgaGFzVHJpbVdoaXRlc3BhY2VCdWcpO1xuICAgIHZhciB0cmltID0gY2FsbC5iaW5kKFN0cmluZy5wcm90b3R5cGUudHJpbSk7XG5cbiAgICB2YXIgaGFzTGFzdEluZGV4QnVnID0gU3RyaW5nUHJvdG90eXBlLmxhc3RJbmRleE9mICYmICdhYmPjgYLjgYQnLmxhc3RJbmRleE9mKCfjgYLjgYQnLCAyKSAhPT0gLTE7XG4gICAgZGVmaW5lUHJvcGVydGllcyhTdHJpbmdQcm90b3R5cGUsIHtcbiAgICAgICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaFN0cmluZykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzID09PSAndW5kZWZpbmVkJyB8fCB0aGlzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgXCIgKyB0aGlzICsgJyB0byBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBTID0gJFN0cmluZyh0aGlzKTtcbiAgICAgICAgICAgIHZhciBzZWFyY2hTdHIgPSAkU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gICAgICAgICAgICB2YXIgbnVtUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyAkTnVtYmVyKGFyZ3VtZW50c1sxXSkgOiBOYU47XG4gICAgICAgICAgICB2YXIgcG9zID0gaXNBY3R1YWxOYU4obnVtUG9zKSA/IEluZmluaXR5IDogRVMuVG9JbnRlZ2VyKG51bVBvcyk7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBtaW4obWF4KHBvcywgMCksIFMubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBzZWFyY2hMZW4gPSBzZWFyY2hTdHIubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGsgPSBzdGFydCArIHNlYXJjaExlbjtcbiAgICAgICAgICAgIHdoaWxlIChrID4gMCkge1xuICAgICAgICAgICAgICAgIGsgPSBtYXgoMCwgayAtIHNlYXJjaExlbik7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gc3RySW5kZXhPZihzdHJTbGljZShTLCBrLCBzdGFydCArIHNlYXJjaExlbiksIHNlYXJjaFN0cik7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gayArIGluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH0sIGhhc0xhc3RJbmRleEJ1Zyk7XG5cbiAgICB2YXIgb3JpZ2luYWxMYXN0SW5kZXhPZiA9IFN0cmluZ1Byb3RvdHlwZS5sYXN0SW5kZXhPZjtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKFN0cmluZ1Byb3RvdHlwZSwge1xuICAgICAgICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoU3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxMYXN0SW5kZXhPZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfSwgU3RyaW5nUHJvdG90eXBlLmxhc3RJbmRleE9mLmxlbmd0aCAhPT0gMSk7XG5cbiAgICB2YXIgaGV4UmVnZXggPSAvXlstK10/MFt4WF0vO1xuXG4gICAgLy8gRVMtNSAxNS4xLjIuMlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByYWRpeFxuICAgIGlmIChwYXJzZUludCh3cyArICcwOCcpICE9PSA4IHx8IHBhcnNlSW50KHdzICsgJzB4MTYnKSAhPT0gMjIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWdsb2JhbC1hc3NpZ24sIG5vLWltcGxpY2l0LWdsb2JhbHNcbiAgICAgICAgcGFyc2VJbnQgPSAoZnVuY3Rpb24gKG9yaWdQYXJzZUludCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHBhcnNlSW50KHN0ciwgcmFkaXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RyaW5nID0gdHJpbShTdHJpbmcoc3RyKSk7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRlZFJhZGl4ID0gJE51bWJlcihyYWRpeCkgfHwgKGhleFJlZ2V4LnRlc3Qoc3RyaW5nKSA/IDE2IDogMTApO1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnUGFyc2VJbnQoc3RyaW5nLCBkZWZhdWx0ZWRSYWRpeCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KHBhcnNlSW50KSk7XG4gICAgfVxuICAgIC8vIEVkZ2UgMTUtMThcbiAgICB2YXIgcGFyc2VJbnRGYWlsc1RvVGhyb3dPbkJveGVkU3ltYm9scyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByYWRpeFxuICAgICAgICAgICAgcGFyc2VJbnQoT2JqZWN0KFN5bWJvbC5pdGVyYXRvcikpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgLyoqLyB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByYWRpeFxuICAgICAgICAgICAgcGFyc2VJbnQoU3ltYm9sLml0ZXJhdG9yKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7IC8qKi8gfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KCkpO1xuICAgIGlmIChwYXJzZUludEZhaWxzVG9UaHJvd09uQm94ZWRTeW1ib2xzKSB7XG4gICAgICAgIHZhciBzeW1ib2xWYWx1ZU9mID0gU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZ2xvYmFsLWFzc2lnbiwgbm8taW1wbGljaXQtZ2xvYmFsc1xuICAgICAgICBwYXJzZUludCA9IChmdW5jdGlvbiAob3JpZ1BhcnNlSW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gcGFyc2VJbnQoc3RyLCByYWRpeCkge1xuICAgICAgICAgICAgICAgIHZhciBpc1N5bSA9IHR5cGVvZiBzdHIgPT09ICdzeW1ib2wnO1xuICAgICAgICAgICAgICAgIGlmICghaXNTeW0gJiYgc3RyICYmIHR5cGVvZiBzdHIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xWYWx1ZU9mLmNhbGwoc3RyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3ltID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyAvKiovIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU3ltKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBTeW1ib2xzIGluIG5vZGUgOC4zLzguNFxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW1wbGljaXQtY29lcmNpb24sIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgICAgICAgICAgICAgICAgICAnJyArIHN0cjsgLy8ganNjczppZ25vcmUgZGlzYWxsb3dJbXBsaWNpdFR5cGVDb252ZXJzaW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzdHJpbmcgPSB0cmltKFN0cmluZyhzdHIpKTtcbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdGVkUmFkaXggPSAkTnVtYmVyKHJhZGl4KSB8fCAoaGV4UmVnZXgudGVzdChzdHJpbmcpID8gMTYgOiAxMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdQYXJzZUludChzdHJpbmcsIGRlZmF1bHRlZFJhZGl4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0ocGFyc2VJbnQpKTtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL2VzNS5naXRodWIuaW8vI3gxNS4xLjIuM1xuICAgIGlmICgxIC8gcGFyc2VGbG9hdCgnLTAnKSAhPT0gLUluZmluaXR5KSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1nbG9iYWwtYXNzaWduLCBuby1pbXBsaWNpdC1nbG9iYWxzLCBuby1uYXRpdmUtcmVhc3NpZ25cbiAgICAgICAgcGFyc2VGbG9hdCA9IChmdW5jdGlvbiAob3JpZ1BhcnNlRmxvYXQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBwYXJzZUZsb2F0KHN0cmluZykge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dFN0cmluZyA9IHRyaW0oU3RyaW5nKHN0cmluZykpO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBvcmlnUGFyc2VGbG9hdChpbnB1dFN0cmluZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gMCAmJiBzdHJTbGljZShpbnB1dFN0cmluZywgMCwgMSkgPT09ICctJyA/IC0wIDogcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfShwYXJzZUZsb2F0KSk7XG4gICAgfVxuXG4gICAgaWYgKFN0cmluZyhuZXcgUmFuZ2VFcnJvcigndGVzdCcpKSAhPT0gJ1JhbmdlRXJyb3I6IHRlc3QnKSB7XG4gICAgICAgIHZhciBlcnJvclRvU3RyaW5nU2hpbSA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzID09PSAndW5kZWZpbmVkJyB8fCB0aGlzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgXCIgKyB0aGlzICsgJyB0byBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSAnRXJyb3InO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gJFN0cmluZyhuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtc2cgPSB0aGlzLm1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1zZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBtc2cgPSAnJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1zZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBtc2cgPSAkU3RyaW5nKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtc2cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuYW1lICsgJzogJyArIG1zZztcbiAgICAgICAgfTtcbiAgICAgICAgLy8gY2FuJ3QgdXNlIGRlZmluZVByb3BlcnRpZXMgaGVyZSBiZWNhdXNlIG9mIHRvU3RyaW5nIGVudW1lcmF0aW9uIGlzc3VlIGluIElFIDw9IDhcbiAgICAgICAgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZXJyb3JUb1N0cmluZ1NoaW07XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcbiAgICAgICAgdmFyIGVuc3VyZU5vbkVudW1lcmFibGUgPSBmdW5jdGlvbiAob2JqLCBwcm9wKSB7XG4gICAgICAgICAgICBpZiAoaXNFbnVtKG9iaiwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVzYy5jb25maWd1cmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzYy5lbnVtZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIGRlc2MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZW5zdXJlTm9uRW51bWVyYWJsZShFcnJvci5wcm90b3R5cGUsICdtZXNzYWdlJyk7XG4gICAgICAgIGlmIChFcnJvci5wcm90b3R5cGUubWVzc2FnZSAhPT0gJycpIHtcbiAgICAgICAgICAgIEVycm9yLnByb3RvdHlwZS5tZXNzYWdlID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlTm9uRW51bWVyYWJsZShFcnJvci5wcm90b3R5cGUsICduYW1lJyk7XG4gICAgfVxuXG4gICAgaWYgKFN0cmluZygvYS9taWcpICE9PSAnL2EvZ2ltJykge1xuICAgICAgICB2YXIgcmVnZXhUb1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgdmFyIHN0ciA9ICcvJyArIHRoaXMuc291cmNlICsgJy8nO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2xvYmFsKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9ICdnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlnbm9yZUNhc2UpIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gJ2knO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubXVsdGlsaW5lKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9ICdtJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGNhbid0IHVzZSBkZWZpbmVQcm9wZXJ0aWVzIGhlcmUgYmVjYXVzZSBvZiB0b1N0cmluZyBlbnVtZXJhdGlvbiBpc3N1ZSBpbiBJRSA8PSA4XG4gICAgICAgIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcgPSByZWdleFRvU3RyaW5nO1xuICAgIH1cbn0pKTtcbiIsIi8qIVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9lczYtc2hpbVxuICogQGxpY2Vuc2UgZXM2LXNoaW0gQ29weXJpZ2h0IDIwMTMtMjAxNiBieSBQYXVsIE1pbGxlciAoaHR0cDovL3BhdWxtaWxsci5jb20pXG4gKiAgIGFuZCBjb250cmlidXRvcnMsICBNSVQgTGljZW5zZVxuICogZXM2LXNoaW06IHYwLjM1LjRcbiAqIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL2VzNi1zaGltL2Jsb2IvMC4zNS4zL0xJQ0VOU0VcbiAqIERldGFpbHMgYW5kIGRvY3VtZW50YXRpb246XG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL2VzNi1zaGltL1xuICovXG5cbi8vIFVNRCAoVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uKVxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91bWRqcy91bWQvYmxvYi9tYXN0ZXIvcmV0dXJuRXhwb3J0cy5qc1xuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gIC8qZ2xvYmFsIGRlZmluZSAqL1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcbiAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcbiAgICAvLyBsaWtlIE5vZGUuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcbiAgICByb290LnJldHVybkV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF9hcHBseSA9IEZ1bmN0aW9uLmNhbGwuYmluZChGdW5jdGlvbi5hcHBseSk7XG4gIHZhciBfY2FsbCA9IEZ1bmN0aW9uLmNhbGwuYmluZChGdW5jdGlvbi5jYWxsKTtcbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzO1xuXG4gIHZhciBub3QgPSBmdW5jdGlvbiBub3RUaHVua2VyKGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbm90VGh1bmsoKSB7XG4gICAgICByZXR1cm4gIV9hcHBseShmdW5jLCB0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG4gIHZhciB0aHJvd3NFcnJvciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZ1bmMoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIHZhciB2YWx1ZU9yRmFsc2VJZlRocm93cyA9IGZ1bmN0aW9uIHZhbHVlT3JGYWxzZUlmVGhyb3dzKGZ1bmMpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmMoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc0NhbGxhYmxlV2l0aG91dE5ldyA9IG5vdCh0aHJvd3NFcnJvcik7XG4gIHZhciBhcmVQcm9wZXJ0eURlc2NyaXB0b3JzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGlmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBleGlzdHMgYnV0IHRocm93cywgaXQncyBJRSA4XG4gICAgcmV0dXJuICF0aHJvd3NFcnJvcihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IH0gfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ2V0dGVyLXJldHVyblxuICAgIH0pO1xuICB9O1xuICB2YXIgc3VwcG9ydHNEZXNjcmlwdG9ycyA9ICEhT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIGFyZVByb3BlcnR5RGVzY3JpcHRvcnNTdXBwb3J0ZWQoKTtcbiAgdmFyIGZ1bmN0aW9uc0hhdmVOYW1lcyA9IChmdW5jdGlvbiBmb28oKSB7fSkubmFtZSA9PT0gJ2Zvbyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXh0cmEtcGFyZW5zXG5cbiAgdmFyIF9mb3JFYWNoID0gRnVuY3Rpb24uY2FsbC5iaW5kKEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKTtcbiAgdmFyIF9yZWR1Y2UgPSBGdW5jdGlvbi5jYWxsLmJpbmQoQXJyYXkucHJvdG90eXBlLnJlZHVjZSk7XG4gIHZhciBfZmlsdGVyID0gRnVuY3Rpb24uY2FsbC5iaW5kKEFycmF5LnByb3RvdHlwZS5maWx0ZXIpO1xuICB2YXIgX3NvbWUgPSBGdW5jdGlvbi5jYWxsLmJpbmQoQXJyYXkucHJvdG90eXBlLnNvbWUpO1xuXG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIHZhbHVlLCBmb3JjZSkge1xuICAgIGlmICghZm9yY2UgJiYgbmFtZSBpbiBvYmplY3QpIHsgcmV0dXJuOyB9XG4gICAgaWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdFtuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgfTtcblxuICAvLyBEZWZpbmUgY29uZmlndXJhYmxlLCB3cml0YWJsZSBhbmQgbm9uLWVudW1lcmFibGUgcHJvcHNcbiAgLy8gaWYgdGhleSBkb27igJl0IGV4aXN0LlxuICB2YXIgZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmplY3QsIG1hcCwgZm9yY2VPdmVycmlkZSkge1xuICAgIF9mb3JFYWNoKGtleXMobWFwKSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBtZXRob2QgPSBtYXBbbmFtZV07XG4gICAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIG1ldGhvZCwgISFmb3JjZU92ZXJyaWRlKTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgX3RvU3RyaW5nID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuICB2YXIgaXNDYWxsYWJsZSA9IHR5cGVvZiAvYWJjLyA9PT0gJ2Z1bmN0aW9uJyA/IGZ1bmN0aW9uIElzQ2FsbGFibGVTbG93KHgpIHtcbiAgICAvLyBTb21lIG9sZCBicm93c2VycyAoSUUsIEZGKSBzYXkgdGhhdCB0eXBlb2YgL2FiYy8gPT09ICdmdW5jdGlvbidcbiAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbicgJiYgX3RvU3RyaW5nKHgpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICB9IDogZnVuY3Rpb24gSXNDYWxsYWJsZUZhc3QoeCkgeyByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7IH07XG5cbiAgdmFyIFZhbHVlID0ge1xuICAgIGdldHRlcjogZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgZ2V0dGVyKSB7XG4gICAgICBpZiAoIXN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZ2V0dGVycyByZXF1aXJlIHRydWUgRVM1IHN1cHBvcnQnKTtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZ2V0OiBnZXR0ZXJcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcHJveHk6IGZ1bmN0aW9uIChvcmlnaW5hbE9iamVjdCwga2V5LCB0YXJnZXRPYmplY3QpIHtcbiAgICAgIGlmICghc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdnZXR0ZXJzIHJlcXVpcmUgdHJ1ZSBFUzUgc3VwcG9ydCcpO1xuICAgICAgfVxuICAgICAgdmFyIG9yaWdpbmFsRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob3JpZ2luYWxPYmplY3QsIGtleSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0T2JqZWN0LCBrZXksIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBvcmlnaW5hbERlc2NyaXB0b3IuY29uZmlndXJhYmxlLFxuICAgICAgICBlbnVtZXJhYmxlOiBvcmlnaW5hbERlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXRLZXkoKSB7IHJldHVybiBvcmlnaW5hbE9iamVjdFtrZXldOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldEtleSh2YWx1ZSkgeyBvcmlnaW5hbE9iamVjdFtrZXldID0gdmFsdWU7IH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcmVkZWZpbmU6IGZ1bmN0aW9uIChvYmplY3QsIHByb3BlcnR5LCBuZXdWYWx1ZSkge1xuICAgICAgaWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpO1xuICAgICAgICBkZXNjcmlwdG9yLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBkZXNjcmlwdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdFtwcm9wZXJ0eV0gPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlZmluZUJ5RGVzY3JpcHRvcjogZnVuY3Rpb24gKG9iamVjdCwgcHJvcGVydHksIGRlc2NyaXB0b3IpIHtcbiAgICAgIGlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBkZXNjcmlwdG9yKTtcbiAgICAgIH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSB7XG4gICAgICAgIG9iamVjdFtwcm9wZXJ0eV0gPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJlc2VydmVUb1N0cmluZzogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlICYmIGlzQ2FsbGFibGUoc291cmNlLnRvU3RyaW5nKSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsICd0b1N0cmluZycsIHNvdXJjZS50b1N0cmluZy5iaW5kKHNvdXJjZSksIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBTaW1wbGUgc2hpbSBmb3IgT2JqZWN0LmNyZWF0ZSBvbiBFUzMgYnJvd3NlcnNcbiAgLy8gKHVubGlrZSByZWFsIHNoaW0sIG5vIGF0dGVtcHQgdG8gc3VwcG9ydCBgcHJvdG90eXBlID09PSBudWxsYClcbiAgdmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuICAgIHZhciBQcm90b3R5cGUgPSBmdW5jdGlvbiBQcm90b3R5cGUoKSB7fTtcbiAgICBQcm90b3R5cGUucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHZhciBvYmplY3QgPSBuZXcgUHJvdG90eXBlKCk7XG4gICAgaWYgKHR5cGVvZiBwcm9wZXJ0aWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAga2V5cyhwcm9wZXJ0aWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgVmFsdWUuZGVmaW5lQnlEZXNjcmlwdG9yKG9iamVjdCwga2V5LCBwcm9wZXJ0aWVzW2tleV0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG5cbiAgdmFyIHN1cHBvcnRzU3ViY2xhc3NpbmcgPSBmdW5jdGlvbiAoQywgZikge1xuICAgIGlmICghT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7IHJldHVybiBmYWxzZTsgLyogc2tpcCB0ZXN0IG9uIElFIDwgMTEgKi8gfVxuICAgIHJldHVybiB2YWx1ZU9yRmFsc2VJZlRocm93cyhmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgU3ViID0gZnVuY3Rpb24gU3ViY2xhc3MoYXJnKSB7XG4gICAgICAgIHZhciBvID0gbmV3IEMoYXJnKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG8sIFN1YmNsYXNzLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfTtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihTdWIsIEMpO1xuICAgICAgU3ViLnByb3RvdHlwZSA9IGNyZWF0ZShDLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogU3ViIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGYoU3ViKTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ2V0R2xvYmFsID0gZnVuY3Rpb24gKCkge1xuICAgIC8qIGdsb2JhbCBzZWxmLCB3aW5kb3cgKi9cbiAgICAvLyB0aGUgb25seSByZWxpYWJsZSBtZWFucyB0byBnZXQgdGhlIGdsb2JhbCBvYmplY3QgaXNcbiAgICAvLyBgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKWBcbiAgICAvLyBIb3dldmVyLCB0aGlzIGNhdXNlcyBDU1AgdmlvbGF0aW9ucyBpbiBDaHJvbWUgYXBwcy5cbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBzZWxmOyB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiB3aW5kb3c7IH1cbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGdsb2JhbDsgfVxuICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0Jyk7XG4gIH07XG5cbiAgdmFyIGdsb2JhbHMgPSBnZXRHbG9iYWwoKTtcbiAgdmFyIGdsb2JhbElzRmluaXRlID0gZ2xvYmFscy5pc0Zpbml0ZTtcbiAgdmFyIF9pbmRleE9mID0gRnVuY3Rpb24uY2FsbC5iaW5kKFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZik7XG4gIHZhciBfYXJyYXlJbmRleE9mQXBwbHkgPSBGdW5jdGlvbi5hcHBseS5iaW5kKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKTtcbiAgdmFyIF9jb25jYXQgPSBGdW5jdGlvbi5jYWxsLmJpbmQoQXJyYXkucHJvdG90eXBlLmNvbmNhdCk7XG4gIC8vIHZhciBfc29ydCA9IEZ1bmN0aW9uLmNhbGwuYmluZChBcnJheS5wcm90b3R5cGUuc29ydCk7XG4gIHZhciBfc3RyU2xpY2UgPSBGdW5jdGlvbi5jYWxsLmJpbmQoU3RyaW5nLnByb3RvdHlwZS5zbGljZSk7XG4gIHZhciBfcHVzaCA9IEZ1bmN0aW9uLmNhbGwuYmluZChBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gIHZhciBfcHVzaEFwcGx5ID0gRnVuY3Rpb24uYXBwbHkuYmluZChBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gIHZhciBfam9pbiA9IEZ1bmN0aW9uLmNhbGwuYmluZChBcnJheS5wcm90b3R5cGUuam9pbik7XG4gIHZhciBfc2hpZnQgPSBGdW5jdGlvbi5jYWxsLmJpbmQoQXJyYXkucHJvdG90eXBlLnNoaWZ0KTtcbiAgdmFyIF9tYXggPSBNYXRoLm1heDtcbiAgdmFyIF9taW4gPSBNYXRoLm1pbjtcbiAgdmFyIF9mbG9vciA9IE1hdGguZmxvb3I7XG4gIHZhciBfYWJzID0gTWF0aC5hYnM7XG4gIHZhciBfZXhwID0gTWF0aC5leHA7XG4gIHZhciBfbG9nID0gTWF0aC5sb2c7XG4gIHZhciBfc3FydCA9IE1hdGguc3FydDtcbiAgdmFyIF9oYXNPd25Qcm9wZXJ0eSA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiAgdmFyIEFycmF5SXRlcmF0b3I7IC8vIG1ha2Ugb3VyIGltcGxlbWVudGF0aW9uIHByaXZhdGVcbiAgdmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcblxuICB2YXIgT3JpZ01hcCA9IGdsb2JhbHMuTWFwO1xuICB2YXIgb3JpZ01hcERlbGV0ZSA9IE9yaWdNYXAgJiYgT3JpZ01hcC5wcm90b3R5cGVbJ2RlbGV0ZSddO1xuICB2YXIgb3JpZ01hcEdldCA9IE9yaWdNYXAgJiYgT3JpZ01hcC5wcm90b3R5cGUuZ2V0O1xuICB2YXIgb3JpZ01hcEhhcyA9IE9yaWdNYXAgJiYgT3JpZ01hcC5wcm90b3R5cGUuaGFzO1xuICB2YXIgb3JpZ01hcFNldCA9IE9yaWdNYXAgJiYgT3JpZ01hcC5wcm90b3R5cGUuc2V0O1xuXG4gIHZhciBTeW1ib2wgPSBnbG9iYWxzLlN5bWJvbCB8fCB7fTtcbiAgdmFyIHN5bWJvbFNwZWNpZXMgPSBTeW1ib2wuc3BlY2llcyB8fCAnQEBzcGVjaWVzJztcblxuICB2YXIgbnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcbiAgICAvLyBOYU4gIT09IE5hTiwgYnV0IHRoZXkgYXJlIGlkZW50aWNhbC5cbiAgICAvLyBOYU5zIGFyZSB0aGUgb25seSBub24tcmVmbGV4aXZlIHZhbHVlLCBpLmUuLCBpZiB4ICE9PSB4LFxuICAgIC8vIHRoZW4geCBpcyBOYU4uXG4gICAgLy8gaXNOYU4gaXMgYnJva2VuOiBpdCBjb252ZXJ0cyBpdHMgYXJndW1lbnQgdG8gbnVtYmVyLCBzb1xuICAgIC8vIGlzTmFOKCdmb28nKSA9PiB0cnVlXG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbiAgfTtcbiAgdmFyIG51bWJlcklzRmluaXRlID0gTnVtYmVyLmlzRmluaXRlIHx8IGZ1bmN0aW9uIGlzRmluaXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgZ2xvYmFsSXNGaW5pdGUodmFsdWUpO1xuICB9O1xuICB2YXIgX3NpZ24gPSBpc0NhbGxhYmxlKE1hdGguc2lnbikgPyBNYXRoLnNpZ24gOiBmdW5jdGlvbiBzaWduKHZhbHVlKSB7XG4gICAgdmFyIG51bWJlciA9IE51bWJlcih2YWx1ZSk7XG4gICAgaWYgKG51bWJlciA9PT0gMCkgeyByZXR1cm4gbnVtYmVyOyB9XG4gICAgaWYgKG51bWJlcklzTmFOKG51bWJlcikpIHsgcmV0dXJuIG51bWJlcjsgfVxuICAgIHJldHVybiBudW1iZXIgPCAwID8gLTEgOiAxO1xuICB9O1xuICB2YXIgX2xvZzFwID0gZnVuY3Rpb24gbG9nMXAodmFsdWUpIHtcbiAgICB2YXIgeCA9IE51bWJlcih2YWx1ZSk7XG4gICAgaWYgKHggPCAtMSB8fCBudW1iZXJJc05hTih4KSkgeyByZXR1cm4gTmFOOyB9XG4gICAgaWYgKHggPT09IDAgfHwgeCA9PT0gSW5maW5pdHkpIHsgcmV0dXJuIHg7IH1cbiAgICBpZiAoeCA9PT0gLTEpIHsgcmV0dXJuIC1JbmZpbml0eTsgfVxuXG4gICAgcmV0dXJuICgxICsgeCkgLSAxID09PSAwID8geCA6IHggKiAoX2xvZygxICsgeCkgLyAoKDEgKyB4KSAtIDEpKTtcbiAgfTtcblxuICAvLyB0YWtlbiBkaXJlY3RseSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvaXMtYXJndW1lbnRzL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gIC8vIGNhbiBiZSByZXBsYWNlZCB3aXRoIHJlcXVpcmUoJ2lzLWFyZ3VtZW50cycpIGlmIHdlIGV2ZXIgdXNlIGEgYnVpbGQgcHJvY2VzcyBpbnN0ZWFkXG4gIHZhciBpc1N0YW5kYXJkQXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG4gIH07XG4gIHZhciBpc0xlZ2FjeUFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuICAgICAgdmFsdWUubGVuZ3RoID49IDAgJiZcbiAgICAgIF90b1N0cmluZyh2YWx1ZSkgIT09ICdbb2JqZWN0IEFycmF5XScgJiZcbiAgICAgIF90b1N0cmluZyh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICB9O1xuICB2YXIgaXNBcmd1bWVudHMgPSBpc1N0YW5kYXJkQXJndW1lbnRzKGFyZ3VtZW50cykgPyBpc1N0YW5kYXJkQXJndW1lbnRzIDogaXNMZWdhY3lBcmd1bWVudHM7XG5cbiAgdmFyIFR5cGUgPSB7XG4gICAgcHJpbWl0aXZlOiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCA9PT0gbnVsbCB8fCAodHlwZW9mIHggIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHggIT09ICdvYmplY3QnKTsgfSxcbiAgICBzdHJpbmc6IGZ1bmN0aW9uICh4KSB7IHJldHVybiBfdG9TdHJpbmcoeCkgPT09ICdbb2JqZWN0IFN0cmluZ10nOyB9LFxuICAgIHJlZ2V4OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4gX3RvU3RyaW5nKHgpID09PSAnW29iamVjdCBSZWdFeHBdJzsgfSxcbiAgICBzeW1ib2w6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGdsb2JhbHMuU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB4ID09PSAnc3ltYm9sJztcbiAgICB9XG4gIH07XG5cbiAgdmFyIG92ZXJyaWRlTmF0aXZlID0gZnVuY3Rpb24gb3ZlcnJpZGVOYXRpdmUob2JqZWN0LCBwcm9wZXJ0eSwgcmVwbGFjZW1lbnQpIHtcbiAgICB2YXIgb3JpZ2luYWwgPSBvYmplY3RbcHJvcGVydHldO1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIHJlcGxhY2VtZW50LCB0cnVlKTtcbiAgICBWYWx1ZS5wcmVzZXJ2ZVRvU3RyaW5nKG9iamVjdFtwcm9wZXJ0eV0sIG9yaWdpbmFsKTtcbiAgfTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG4gIHZhciBoYXNTeW1ib2xzID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sWydmb3InXSA9PT0gJ2Z1bmN0aW9uJyAmJiBUeXBlLnN5bWJvbChTeW1ib2woKSk7XG5cbiAgLy8gVGhpcyBpcyBhIHByaXZhdGUgbmFtZSBpbiB0aGUgZXM2IHNwZWMsIGVxdWFsIHRvICdbU3ltYm9sLml0ZXJhdG9yXSdcbiAgLy8gd2UncmUgZ29pbmcgdG8gdXNlIGFuIGFyYml0cmFyeSBfLXByZWZpeGVkIG5hbWUgdG8gbWFrZSBvdXIgc2hpbXNcbiAgLy8gd29yayBwcm9wZXJseSB3aXRoIGVhY2ggb3RoZXIsIGV2ZW4gdGhvdWdoIHdlIGRvbid0IGhhdmUgZnVsbCBJdGVyYXRvclxuICAvLyBzdXBwb3J0LiAgVGhhdCBpcywgYEFycmF5LmZyb20obWFwLmtleXMoKSlgIHdpbGwgd29yaywgYnV0IHdlIGRvbid0XG4gIC8vIHByZXRlbmQgdG8gZXhwb3J0IGEgXCJyZWFsXCIgSXRlcmF0b3IgaW50ZXJmYWNlLlxuICB2YXIgJGl0ZXJhdG9yJCA9IFR5cGUuc3ltYm9sKFN5bWJvbC5pdGVyYXRvcikgPyBTeW1ib2wuaXRlcmF0b3IgOiAnX2VzNi1zaGltIGl0ZXJhdG9yXyc7XG4gIC8vIEZpcmVmb3ggc2hpcHMgYSBwYXJ0aWFsIGltcGxlbWVudGF0aW9uIHVzaW5nIHRoZSBuYW1lIEBAaXRlcmF0b3IuXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTkwNzA3NyNjMTRcbiAgLy8gU28gdXNlIHRoYXQgbmFtZSBpZiB3ZSBkZXRlY3QgaXQuXG4gIGlmIChnbG9iYWxzLlNldCAmJiB0eXBlb2YgbmV3IGdsb2JhbHMuU2V0KClbJ0BAaXRlcmF0b3InXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICRpdGVyYXRvciQgPSAnQEBpdGVyYXRvcic7XG4gIH1cblxuICAvLyBSZWZsZWN0XG4gIGlmICghZ2xvYmFscy5SZWZsZWN0KSB7XG4gICAgZGVmaW5lUHJvcGVydHkoZ2xvYmFscywgJ1JlZmxlY3QnLCB7fSwgdHJ1ZSk7XG4gIH1cbiAgdmFyIFJlZmxlY3QgPSBnbG9iYWxzLlJlZmxlY3Q7XG5cbiAgdmFyICRTdHJpbmcgPSBTdHJpbmc7XG5cbiAgLyogZ2xvYmFsIGRvY3VtZW50ICovXG4gIHZhciBkb21BbGwgPSAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyB8fCAhZG9jdW1lbnQpID8gbnVsbCA6IGRvY3VtZW50LmFsbDtcbiAgdmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gZG9tQWxsID09IG51bGwgPyBmdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZCh4KSB7XG4gICAgcmV0dXJuIHggPT0gbnVsbDtcbiAgfSA6IGZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkQW5kTm90RG9jdW1lbnRBbGwoeCkge1xuICAgIHJldHVybiB4ID09IG51bGwgJiYgeCAhPT0gZG9tQWxsO1xuICB9O1xuXG4gIHZhciBFUyA9IHtcbiAgICAvLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtY2FsbFxuICAgIENhbGw6IGZ1bmN0aW9uIENhbGwoRiwgVikge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IFtdO1xuICAgICAgaWYgKCFFUy5Jc0NhbGxhYmxlKEYpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRiArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfYXBwbHkoRiwgViwgYXJncyk7XG4gICAgfSxcblxuICAgIFJlcXVpcmVPYmplY3RDb2VyY2libGU6IGZ1bmN0aW9uICh4LCBvcHRNZXNzYWdlKSB7XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoeCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihvcHRNZXNzYWdlIHx8ICdDYW5ub3QgY2FsbCBtZXRob2Qgb24gJyArIHgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcblxuICAgIC8vIFRoaXMgbWlnaHQgbWlzcyB0aGUgXCIobm9uLXN0YW5kYXJkIGV4b3RpYyBhbmQgZG9lcyBub3QgaW1wbGVtZW50XG4gICAgLy8gW1tDYWxsXV0pXCIgY2FzZSBmcm9tXG4gICAgLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXR5cGVvZi1vcGVyYXRvci1ydW50aW1lLXNlbWFudGljcy1ldmFsdWF0aW9uXG4gICAgLy8gYnV0IHdlIGNhbid0IGZpbmQgYW55IGV2aWRlbmNlIHRoZXNlIG9iamVjdHMgZXhpc3QgaW4gcHJhY3RpY2UuXG4gICAgLy8gSWYgd2UgZmluZCBzb21lIGluIHRoZSBmdXR1cmUsIHlvdSBjb3VsZCB0ZXN0IGBPYmplY3QoeCkgPT09IHhgLFxuICAgIC8vIHdoaWNoIGlzIHJlbGlhYmxlIGFjY29yZGluZyB0b1xuICAgIC8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b29iamVjdFxuICAgIC8vIGJ1dCBpcyBub3Qgd2VsbCBvcHRpbWl6ZWQgYnkgcnVudGltZXMgYW5kIGNyZWF0ZXMgYW4gb2JqZWN0XG4gICAgLy8gd2hlbmV2ZXIgaXQgcmV0dXJucyBmYWxzZSwgYW5kIHRodXMgaXMgdmVyeSBzbG93LlxuICAgIFR5cGVJc09iamVjdDogZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh4ID09PSB2b2lkIDAgfHwgeCA9PT0gbnVsbCB8fCB4ID09PSB0cnVlIHx8IHggPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgeCA9PT0gJ29iamVjdCcgfHwgeCA9PT0gZG9tQWxsO1xuICAgIH0sXG5cbiAgICBUb09iamVjdDogZnVuY3Rpb24gKG8sIG9wdE1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBPYmplY3QoRVMuUmVxdWlyZU9iamVjdENvZXJjaWJsZShvLCBvcHRNZXNzYWdlKSk7XG4gICAgfSxcblxuICAgIElzQ2FsbGFibGU6IGlzQ2FsbGFibGUsXG5cbiAgICBJc0NvbnN0cnVjdG9yOiBmdW5jdGlvbiAoeCkge1xuICAgICAgLy8gV2UgY2FuJ3QgdGVsbCBjYWxsYWJsZXMgZnJvbSBjb25zdHJ1Y3RvcnMgaW4gRVM1XG4gICAgICByZXR1cm4gRVMuSXNDYWxsYWJsZSh4KTtcbiAgICB9LFxuXG4gICAgVG9JbnQzMjogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBFUy5Ub051bWJlcih4KSA+PiAwO1xuICAgIH0sXG5cbiAgICBUb1VpbnQzMjogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBFUy5Ub051bWJlcih4KSA+Pj4gMDtcbiAgICB9LFxuXG4gICAgVG9OdW1iZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKGhhc1N5bWJvbHMgJiYgX3RvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU3ltYm9sXScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBudW1iZXInKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiArdmFsdWU7XG4gICAgfSxcblxuICAgIFRvSW50ZWdlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgbnVtYmVyID0gRVMuVG9OdW1iZXIodmFsdWUpO1xuICAgICAgaWYgKG51bWJlcklzTmFOKG51bWJlcikpIHsgcmV0dXJuIDA7IH1cbiAgICAgIGlmIChudW1iZXIgPT09IDAgfHwgIW51bWJlcklzRmluaXRlKG51bWJlcikpIHsgcmV0dXJuIG51bWJlcjsgfVxuICAgICAgcmV0dXJuIChudW1iZXIgPiAwID8gMSA6IC0xKSAqIF9mbG9vcihfYWJzKG51bWJlcikpO1xuICAgIH0sXG5cbiAgICBUb0xlbmd0aDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgbGVuID0gRVMuVG9JbnRlZ2VyKHZhbHVlKTtcbiAgICAgIGlmIChsZW4gPD0gMCkgeyByZXR1cm4gMDsgfSAvLyBpbmNsdWRlcyBjb252ZXJ0aW5nIC0wIHRvICswXG4gICAgICBpZiAobGVuID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHsgcmV0dXJuIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSOyB9XG4gICAgICByZXR1cm4gbGVuO1xuICAgIH0sXG5cbiAgICBTYW1lVmFsdWU6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAvLyAwID09PSAtMCwgYnV0IHRoZXkgYXJlIG5vdCBpZGVudGljYWwuXG4gICAgICAgIGlmIChhID09PSAwKSB7IHJldHVybiAxIC8gYSA9PT0gMSAvIGI7IH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVtYmVySXNOYU4oYSkgJiYgbnVtYmVySXNOYU4oYik7XG4gICAgfSxcblxuICAgIFNhbWVWYWx1ZVplcm86IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAvLyBzYW1lIGFzIFNhbWVWYWx1ZSBleGNlcHQgZm9yIFNhbWVWYWx1ZVplcm8oKzAsIC0wKSA9PSB0cnVlXG4gICAgICByZXR1cm4gKGEgPT09IGIpIHx8IChudW1iZXJJc05hTihhKSAmJiBudW1iZXJJc05hTihiKSk7XG4gICAgfSxcblxuICAgIElzSXRlcmFibGU6IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gRVMuVHlwZUlzT2JqZWN0KG8pICYmICh0eXBlb2Ygb1skaXRlcmF0b3IkXSAhPT0gJ3VuZGVmaW5lZCcgfHwgaXNBcmd1bWVudHMobykpO1xuICAgIH0sXG5cbiAgICBHZXRJdGVyYXRvcjogZnVuY3Rpb24gKG8pIHtcbiAgICAgIGlmIChpc0FyZ3VtZW50cyhvKSkge1xuICAgICAgICAvLyBzcGVjaWFsIGNhc2Ugc3VwcG9ydCBmb3IgYGFyZ3VtZW50c2BcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheUl0ZXJhdG9yKG8sICd2YWx1ZScpO1xuICAgICAgfVxuICAgICAgdmFyIGl0Rm4gPSBFUy5HZXRNZXRob2QobywgJGl0ZXJhdG9yJCk7XG4gICAgICBpZiAoIUVTLklzQ2FsbGFibGUoaXRGbikpIHtcbiAgICAgICAgLy8gQmV0dGVyIGRpYWdub3N0aWNzIGlmIGl0Rm4gaXMgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsdWUgaXMgbm90IGFuIGl0ZXJhYmxlJyk7XG4gICAgICB9XG4gICAgICB2YXIgaXQgPSBFUy5DYWxsKGl0Rm4sIG8pO1xuICAgICAgaWYgKCFFUy5UeXBlSXNPYmplY3QoaXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2JhZCBpdGVyYXRvcicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0O1xuICAgIH0sXG5cbiAgICBHZXRNZXRob2Q6IGZ1bmN0aW9uIChvLCBwKSB7XG4gICAgICB2YXIgZnVuYyA9IEVTLlRvT2JqZWN0KG8pW3BdO1xuICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKGZ1bmMpKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICBpZiAoIUVTLklzQ2FsbGFibGUoZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWV0aG9kIG5vdCBjYWxsYWJsZTogJyArIHApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfSxcblxuICAgIEl0ZXJhdG9yQ29tcGxldGU6IGZ1bmN0aW9uIChpdGVyUmVzdWx0KSB7XG4gICAgICByZXR1cm4gISFpdGVyUmVzdWx0LmRvbmU7XG4gICAgfSxcblxuICAgIEl0ZXJhdG9yQ2xvc2U6IGZ1bmN0aW9uIChpdGVyYXRvciwgY29tcGxldGlvbklzVGhyb3cpIHtcbiAgICAgIHZhciByZXR1cm5NZXRob2QgPSBFUy5HZXRNZXRob2QoaXRlcmF0b3IsICdyZXR1cm4nKTtcbiAgICAgIGlmIChyZXR1cm5NZXRob2QgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaW5uZXJSZXN1bHQsIGlubmVyRXhjZXB0aW9uO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaW5uZXJSZXN1bHQgPSBFUy5DYWxsKHJldHVybk1ldGhvZCwgaXRlcmF0b3IpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpbm5lckV4Y2VwdGlvbiA9IGU7XG4gICAgICB9XG4gICAgICBpZiAoY29tcGxldGlvbklzVGhyb3cpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlubmVyRXhjZXB0aW9uKSB7XG4gICAgICAgIHRocm93IGlubmVyRXhjZXB0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKCFFUy5UeXBlSXNPYmplY3QoaW5uZXJSZXN1bHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJdGVyYXRvcidzIHJldHVybiBtZXRob2QgcmV0dXJuZWQgYSBub24tb2JqZWN0LlwiKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgSXRlcmF0b3JOZXh0OiBmdW5jdGlvbiAoaXQpIHtcbiAgICAgIHZhciByZXN1bHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGl0Lm5leHQoYXJndW1lbnRzWzFdKSA6IGl0Lm5leHQoKTtcbiAgICAgIGlmICghRVMuVHlwZUlzT2JqZWN0KHJlc3VsdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYmFkIGl0ZXJhdG9yJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBJdGVyYXRvclN0ZXA6IGZ1bmN0aW9uIChpdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IEVTLkl0ZXJhdG9yTmV4dChpdCk7XG4gICAgICB2YXIgZG9uZSA9IEVTLkl0ZXJhdG9yQ29tcGxldGUocmVzdWx0KTtcbiAgICAgIHJldHVybiBkb25lID8gZmFsc2UgOiByZXN1bHQ7XG4gICAgfSxcblxuICAgIENvbnN0cnVjdDogZnVuY3Rpb24gKEMsIGFyZ3MsIG5ld1RhcmdldCwgaXNFUzZpbnRlcm5hbCkge1xuICAgICAgdmFyIHRhcmdldCA9IHR5cGVvZiBuZXdUYXJnZXQgPT09ICd1bmRlZmluZWQnID8gQyA6IG5ld1RhcmdldDtcblxuICAgICAgaWYgKCFpc0VTNmludGVybmFsICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFRyeSB0byB1c2UgUmVmbGVjdC5jb25zdHJ1Y3QgaWYgYXZhaWxhYmxlXG4gICAgICAgIHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdChDLCBhcmdzLCB0YXJnZXQpO1xuICAgICAgfVxuICAgICAgLy8gT0ssIHdlIGhhdmUgdG8gZmFrZSBpdC4gIFRoaXMgd2lsbCBvbmx5IHdvcmsgaWYgdGhlXG4gICAgICAvLyBDLltbQ29uc3RydWN0b3JLaW5kXV0gPT0gXCJiYXNlXCIgLS0gYnV0IHRoYXQncyB0aGUgb25seVxuICAgICAgLy8ga2luZCB3ZSBjYW4gbWFrZSBpbiBFUzUgY29kZSBhbnl3YXkuXG5cbiAgICAgIC8vIE9yZGluYXJ5Q3JlYXRlRnJvbUNvbnN0cnVjdG9yKHRhcmdldCwgXCIlT2JqZWN0UHJvdG90eXBlJVwiKVxuICAgICAgdmFyIHByb3RvID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgIGlmICghRVMuVHlwZUlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgICBwcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0gY3JlYXRlKHByb3RvKTtcbiAgICAgIC8vIENhbGwgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIHJlc3VsdCA9IEVTLkNhbGwoQywgb2JqLCBhcmdzKTtcbiAgICAgIHJldHVybiBFUy5UeXBlSXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IG9iajtcbiAgICB9LFxuXG4gICAgU3BlY2llc0NvbnN0cnVjdG9yOiBmdW5jdGlvbiAoTywgZGVmYXVsdENvbnN0cnVjdG9yKSB7XG4gICAgICB2YXIgQyA9IE8uY29uc3RydWN0b3I7XG4gICAgICBpZiAoQyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0Q29uc3RydWN0b3I7XG4gICAgICB9XG4gICAgICBpZiAoIUVTLlR5cGVJc09iamVjdChDKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCYWQgY29uc3RydWN0b3InKTtcbiAgICAgIH1cbiAgICAgIHZhciBTID0gQ1tzeW1ib2xTcGVjaWVzXTtcbiAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZChTKSkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdENvbnN0cnVjdG9yO1xuICAgICAgfVxuICAgICAgaWYgKCFFUy5Jc0NvbnN0cnVjdG9yKFMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JhZCBAQHNwZWNpZXMnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTO1xuICAgIH0sXG5cbiAgICBDcmVhdGVIVE1MOiBmdW5jdGlvbiAoc3RyaW5nLCB0YWcsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICAgIHZhciBTID0gRVMuVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHZhciBwMSA9ICc8JyArIHRhZztcbiAgICAgIGlmIChhdHRyaWJ1dGUgIT09ICcnKSB7XG4gICAgICAgIHZhciBWID0gRVMuVG9TdHJpbmcodmFsdWUpO1xuICAgICAgICB2YXIgZXNjYXBlZFYgPSBWLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbiAgICAgICAgcDEgKz0gJyAnICsgYXR0cmlidXRlICsgJz1cIicgKyBlc2NhcGVkViArICdcIic7XG4gICAgICB9XG4gICAgICB2YXIgcDIgPSBwMSArICc+JztcbiAgICAgIHZhciBwMyA9IHAyICsgUztcbiAgICAgIHJldHVybiBwMyArICc8LycgKyB0YWcgKyAnPic7XG4gICAgfSxcblxuICAgIElzUmVnRXhwOiBmdW5jdGlvbiBJc1JlZ0V4cChhcmd1bWVudCkge1xuICAgICAgaWYgKCFFUy5UeXBlSXNPYmplY3QoYXJndW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1JlZ0V4cCA9IGFyZ3VtZW50W1N5bWJvbC5tYXRjaF07XG4gICAgICBpZiAodHlwZW9mIGlzUmVnRXhwICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gISFpc1JlZ0V4cDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBUeXBlLnJlZ2V4KGFyZ3VtZW50KTtcbiAgICB9LFxuXG4gICAgVG9TdHJpbmc6IGZ1bmN0aW9uIFRvU3RyaW5nKHN0cmluZykge1xuICAgICAgaWYgKGhhc1N5bWJvbHMgJiYgX3RvU3RyaW5nKHN0cmluZykgPT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gJFN0cmluZyhzdHJpbmcpO1xuICAgIH1cbiAgfTtcblxuICAvLyBXZWxsLWtub3duIFN5bWJvbCBzaGltc1xuICBpZiAoc3VwcG9ydHNEZXNjcmlwdG9ycyAmJiBoYXNTeW1ib2xzKSB7XG4gICAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IGZ1bmN0aW9uIGRlZmluZVdlbGxLbm93blN5bWJvbChuYW1lKSB7XG4gICAgICBpZiAoVHlwZS5zeW1ib2woU3ltYm9sW25hbWVdKSkge1xuICAgICAgICByZXR1cm4gU3ltYm9sW25hbWVdO1xuICAgICAgfVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuICAgICAgdmFyIHN5bSA9IFN5bWJvbFsnZm9yJ10oJ1N5bWJvbC4nICsgbmFtZSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3ltYm9sLCBuYW1lLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzeW1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN5bTtcbiAgICB9O1xuICAgIGlmICghVHlwZS5zeW1ib2woU3ltYm9sLnNlYXJjaCkpIHtcbiAgICAgIHZhciBzeW1ib2xTZWFyY2ggPSBkZWZpbmVXZWxsS25vd25TeW1ib2woJ3NlYXJjaCcpO1xuICAgICAgdmFyIG9yaWdpbmFsU2VhcmNoID0gU3RyaW5nLnByb3RvdHlwZS5zZWFyY2g7XG4gICAgICBkZWZpbmVQcm9wZXJ0eShSZWdFeHAucHJvdG90eXBlLCBzeW1ib2xTZWFyY2gsIGZ1bmN0aW9uIHNlYXJjaChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIEVTLkNhbGwob3JpZ2luYWxTZWFyY2gsIHN0cmluZywgW3RoaXNdKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHNlYXJjaFNoaW0gPSBmdW5jdGlvbiBzZWFyY2gocmVnZXhwKSB7XG4gICAgICAgIHZhciBPID0gRVMuUmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKTtcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChyZWdleHApKSB7XG4gICAgICAgICAgdmFyIHNlYXJjaGVyID0gRVMuR2V0TWV0aG9kKHJlZ2V4cCwgc3ltYm9sU2VhcmNoKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHNlYXJjaGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIEVTLkNhbGwoc2VhcmNoZXIsIHJlZ2V4cCwgW09dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEVTLkNhbGwob3JpZ2luYWxTZWFyY2gsIE8sIFtFUy5Ub1N0cmluZyhyZWdleHApXSk7XG4gICAgICB9O1xuICAgICAgb3ZlcnJpZGVOYXRpdmUoU3RyaW5nLnByb3RvdHlwZSwgJ3NlYXJjaCcsIHNlYXJjaFNoaW0pO1xuICAgIH1cbiAgICBpZiAoIVR5cGUuc3ltYm9sKFN5bWJvbC5yZXBsYWNlKSkge1xuICAgICAgdmFyIHN5bWJvbFJlcGxhY2UgPSBkZWZpbmVXZWxsS25vd25TeW1ib2woJ3JlcGxhY2UnKTtcbiAgICAgIHZhciBvcmlnaW5hbFJlcGxhY2UgPSBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2U7XG4gICAgICBkZWZpbmVQcm9wZXJ0eShSZWdFeHAucHJvdG90eXBlLCBzeW1ib2xSZXBsYWNlLCBmdW5jdGlvbiByZXBsYWNlKHN0cmluZywgcmVwbGFjZVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBFUy5DYWxsKG9yaWdpbmFsUmVwbGFjZSwgc3RyaW5nLCBbdGhpcywgcmVwbGFjZVZhbHVlXSk7XG4gICAgICB9KTtcbiAgICAgIHZhciByZXBsYWNlU2hpbSA9IGZ1bmN0aW9uIHJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSkge1xuICAgICAgICB2YXIgTyA9IEVTLlJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcyk7XG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQoc2VhcmNoVmFsdWUpKSB7XG4gICAgICAgICAgdmFyIHJlcGxhY2VyID0gRVMuR2V0TWV0aG9kKHNlYXJjaFZhbHVlLCBzeW1ib2xSZXBsYWNlKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIEVTLkNhbGwocmVwbGFjZXIsIHNlYXJjaFZhbHVlLCBbTywgcmVwbGFjZVZhbHVlXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBFUy5DYWxsKG9yaWdpbmFsUmVwbGFjZSwgTywgW0VTLlRvU3RyaW5nKHNlYXJjaFZhbHVlKSwgcmVwbGFjZVZhbHVlXSk7XG4gICAgICB9O1xuICAgICAgb3ZlcnJpZGVOYXRpdmUoU3RyaW5nLnByb3RvdHlwZSwgJ3JlcGxhY2UnLCByZXBsYWNlU2hpbSk7XG4gICAgfVxuICAgIGlmICghVHlwZS5zeW1ib2woU3ltYm9sLnNwbGl0KSkge1xuICAgICAgdmFyIHN5bWJvbFNwbGl0ID0gZGVmaW5lV2VsbEtub3duU3ltYm9sKCdzcGxpdCcpO1xuICAgICAgdmFyIG9yaWdpbmFsU3BsaXQgPSBTdHJpbmcucHJvdG90eXBlLnNwbGl0O1xuICAgICAgZGVmaW5lUHJvcGVydHkoUmVnRXhwLnByb3RvdHlwZSwgc3ltYm9sU3BsaXQsIGZ1bmN0aW9uIHNwbGl0KHN0cmluZywgbGltaXQpIHtcbiAgICAgICAgcmV0dXJuIEVTLkNhbGwob3JpZ2luYWxTcGxpdCwgc3RyaW5nLCBbdGhpcywgbGltaXRdKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHNwbGl0U2hpbSA9IGZ1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgdmFyIE8gPSBFUy5SZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpO1xuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHNlcGFyYXRvcikpIHtcbiAgICAgICAgICB2YXIgc3BsaXR0ZXIgPSBFUy5HZXRNZXRob2Qoc2VwYXJhdG9yLCBzeW1ib2xTcGxpdCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzcGxpdHRlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBFUy5DYWxsKHNwbGl0dGVyLCBzZXBhcmF0b3IsIFtPLCBsaW1pdF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRVMuQ2FsbChvcmlnaW5hbFNwbGl0LCBPLCBbRVMuVG9TdHJpbmcoc2VwYXJhdG9yKSwgbGltaXRdKTtcbiAgICAgIH07XG4gICAgICBvdmVycmlkZU5hdGl2ZShTdHJpbmcucHJvdG90eXBlLCAnc3BsaXQnLCBzcGxpdFNoaW0pO1xuICAgIH1cbiAgICB2YXIgc3ltYm9sTWF0Y2hFeGlzdHMgPSBUeXBlLnN5bWJvbChTeW1ib2wubWF0Y2gpO1xuICAgIHZhciBzdHJpbmdNYXRjaElnbm9yZXNTeW1ib2xNYXRjaCA9IHN5bWJvbE1hdGNoRXhpc3RzICYmIChmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBGaXJlZm94IDQxLCB0aHJvdWdoIE5pZ2h0bHkgNDUgaGFzIFN5bWJvbC5tYXRjaCwgYnV0IFN0cmluZyNtYXRjaCBpZ25vcmVzIGl0LlxuICAgICAgLy8gRmlyZWZveCA0MCBhbmQgYmVsb3cgaGF2ZSBTeW1ib2wubWF0Y2ggYnV0IFN0cmluZyNtYXRjaCB3b3JrcyBmaW5lLlxuICAgICAgdmFyIG8gPSB7fTtcbiAgICAgIG9bU3ltYm9sLm1hdGNoXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyOyB9O1xuICAgICAgcmV0dXJuICdhJy5tYXRjaChvKSAhPT0gNDI7XG4gICAgfSgpKTtcbiAgICBpZiAoIXN5bWJvbE1hdGNoRXhpc3RzIHx8IHN0cmluZ01hdGNoSWdub3Jlc1N5bWJvbE1hdGNoKSB7XG4gICAgICB2YXIgc3ltYm9sTWF0Y2ggPSBkZWZpbmVXZWxsS25vd25TeW1ib2woJ21hdGNoJyk7XG5cbiAgICAgIHZhciBvcmlnaW5hbE1hdGNoID0gU3RyaW5nLnByb3RvdHlwZS5tYXRjaDtcbiAgICAgIGRlZmluZVByb3BlcnR5KFJlZ0V4cC5wcm90b3R5cGUsIHN5bWJvbE1hdGNoLCBmdW5jdGlvbiBtYXRjaChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIEVTLkNhbGwob3JpZ2luYWxNYXRjaCwgc3RyaW5nLCBbdGhpc10pO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBtYXRjaFNoaW0gPSBmdW5jdGlvbiBtYXRjaChyZWdleHApIHtcbiAgICAgICAgdmFyIE8gPSBFUy5SZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpO1xuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHJlZ2V4cCkpIHtcbiAgICAgICAgICB2YXIgbWF0Y2hlciA9IEVTLkdldE1ldGhvZChyZWdleHAsIHN5bWJvbE1hdGNoKTtcbiAgICAgICAgICBpZiAodHlwZW9mIG1hdGNoZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gRVMuQ2FsbChtYXRjaGVyLCByZWdleHAsIFtPXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBFUy5DYWxsKG9yaWdpbmFsTWF0Y2gsIE8sIFtFUy5Ub1N0cmluZyhyZWdleHApXSk7XG4gICAgICB9O1xuICAgICAgb3ZlcnJpZGVOYXRpdmUoU3RyaW5nLnByb3RvdHlwZSwgJ21hdGNoJywgbWF0Y2hTaGltKTtcbiAgICB9XG4gIH1cblxuICB2YXIgd3JhcENvbnN0cnVjdG9yID0gZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yKG9yaWdpbmFsLCByZXBsYWNlbWVudCwga2V5c1RvU2tpcCkge1xuICAgIFZhbHVlLnByZXNlcnZlVG9TdHJpbmcocmVwbGFjZW1lbnQsIG9yaWdpbmFsKTtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICAvLyBzZXRzIHVwIHByb3BlciBwcm90b3R5cGUgY2hhaW4gd2hlcmUgcG9zc2libGVcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihvcmlnaW5hbCwgcmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuICAgICAgX2ZvckVhY2goT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob3JpZ2luYWwpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChrZXkgaW4gbm9vcCB8fCBrZXlzVG9Ta2lwW2tleV0pIHsgcmV0dXJuOyB9XG4gICAgICAgIFZhbHVlLnByb3h5KG9yaWdpbmFsLCBrZXksIHJlcGxhY2VtZW50KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBfZm9yRWFjaChPYmplY3Qua2V5cyhvcmlnaW5hbCksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGtleSBpbiBub29wIHx8IGtleXNUb1NraXBba2V5XSkgeyByZXR1cm47IH1cbiAgICAgICAgcmVwbGFjZW1lbnRba2V5XSA9IG9yaWdpbmFsW2tleV07XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmVwbGFjZW1lbnQucHJvdG90eXBlID0gb3JpZ2luYWwucHJvdG90eXBlO1xuICAgIFZhbHVlLnJlZGVmaW5lKG9yaWdpbmFsLnByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgcmVwbGFjZW1lbnQpO1xuICB9O1xuXG4gIHZhciBkZWZhdWx0U3BlY2llc0dldHRlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG4gIHZhciBhZGREZWZhdWx0U3BlY2llcyA9IGZ1bmN0aW9uIChDKSB7XG4gICAgaWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMgJiYgIV9oYXNPd25Qcm9wZXJ0eShDLCBzeW1ib2xTcGVjaWVzKSkge1xuICAgICAgVmFsdWUuZ2V0dGVyKEMsIHN5bWJvbFNwZWNpZXMsIGRlZmF1bHRTcGVjaWVzR2V0dGVyKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGFkZEl0ZXJhdG9yID0gZnVuY3Rpb24gKHByb3RvdHlwZSwgaW1wbCkge1xuICAgIHZhciBpbXBsZW1lbnRhdGlvbiA9IGltcGwgfHwgZnVuY3Rpb24gaXRlcmF0b3IoKSB7IHJldHVybiB0aGlzOyB9O1xuICAgIGRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgJGl0ZXJhdG9yJCwgaW1wbGVtZW50YXRpb24pO1xuICAgIGlmICghcHJvdG90eXBlWyRpdGVyYXRvciRdICYmIFR5cGUuc3ltYm9sKCRpdGVyYXRvciQpKSB7XG4gICAgICAvLyBpbXBsZW1lbnRhdGlvbnMgYXJlIGJ1Z2d5IHdoZW4gJGl0ZXJhdG9yJCBpcyBhIFN5bWJvbFxuICAgICAgcHJvdG90eXBlWyRpdGVyYXRvciRdID0gaW1wbGVtZW50YXRpb247XG4gICAgfVxuICB9O1xuXG4gIHZhciBjcmVhdGVEYXRhUHJvcGVydHkgPSBmdW5jdGlvbiBjcmVhdGVEYXRhUHJvcGVydHkob2JqZWN0LCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdFtuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgfTtcbiAgdmFyIGNyZWF0ZURhdGFQcm9wZXJ0eU9yVGhyb3cgPSBmdW5jdGlvbiBjcmVhdGVEYXRhUHJvcGVydHlPclRocm93KG9iamVjdCwgbmFtZSwgdmFsdWUpIHtcbiAgICBjcmVhdGVEYXRhUHJvcGVydHkob2JqZWN0LCBuYW1lLCB2YWx1ZSk7XG4gICAgaWYgKCFFUy5TYW1lVmFsdWUob2JqZWN0W25hbWVdLCB2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Byb3BlcnR5IGlzIG5vbmNvbmZpZ3VyYWJsZScpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZW11bGF0ZUVTNmNvbnN0cnVjdCA9IGZ1bmN0aW9uIChvLCBkZWZhdWx0TmV3VGFyZ2V0LCBkZWZhdWx0UHJvdG8sIHNsb3RzKSB7XG4gICAgLy8gVGhpcyBpcyBhbiBlczUgYXBwcm94aW1hdGlvbiB0byBlczYgY29uc3RydWN0IHNlbWFudGljcy4gIGluIGVzNixcbiAgICAvLyAnbmV3IEZvbycgaW52b2tlcyBGb28uW1tDb25zdHJ1Y3RdXSB3aGljaCAoZm9yIGFsbW9zdCBhbGwgb2JqZWN0cylcbiAgICAvLyBqdXN0IHNldHMgdGhlIGludGVybmFsIHZhcmlhYmxlIE5ld1RhcmdldCAoaW4gZXM2IHN5bnRheCBgbmV3LnRhcmdldGApXG4gICAgLy8gdG8gRm9vIGFuZCB0aGVuIHJldHVybnMgRm9vKCkuXG5cbiAgICAvLyBNYW55IEVTNiBvYmplY3QgdGhlbiBoYXZlIGNvbnN0cnVjdG9ycyBvZiB0aGUgZm9ybTpcbiAgICAvLyAxLiBJZiBOZXdUYXJnZXQgaXMgdW5kZWZpbmVkLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb25cbiAgICAvLyAyLiBMZXQgeHh4IGJ5IE9yZGluYXJ5Q3JlYXRlRnJvbUNvbnN0cnVjdG9yKE5ld1RhcmdldCwgeXl5LCB6enopXG5cbiAgICAvLyBTbyB3ZSdyZSBnb2luZyB0byBlbXVsYXRlIHRob3NlIGZpcnN0IHR3byBzdGVwcy5cbiAgICBpZiAoIUVTLlR5cGVJc09iamVjdChvKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29uc3RydWN0b3IgcmVxdWlyZXMgYG5ld2A6ICcgKyBkZWZhdWx0TmV3VGFyZ2V0Lm5hbWUpO1xuICAgIH1cbiAgICB2YXIgcHJvdG8gPSBkZWZhdWx0TmV3VGFyZ2V0LnByb3RvdHlwZTtcbiAgICBpZiAoIUVTLlR5cGVJc09iamVjdChwcm90bykpIHtcbiAgICAgIHByb3RvID0gZGVmYXVsdFByb3RvO1xuICAgIH1cbiAgICB2YXIgb2JqID0gY3JlYXRlKHByb3RvKTtcbiAgICBmb3IgKHZhciBuYW1lIGluIHNsb3RzKSB7XG4gICAgICBpZiAoX2hhc093blByb3BlcnR5KHNsb3RzLCBuYW1lKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzbG90c1tuYW1lXTtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gRmlyZWZveCAzMSByZXBvcnRzIHRoaXMgZnVuY3Rpb24ncyBsZW5ndGggYXMgMFxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMDYyNDg0XG4gIGlmIChTdHJpbmcuZnJvbUNvZGVQb2ludCAmJiBTdHJpbmcuZnJvbUNvZGVQb2ludC5sZW5ndGggIT09IDEpIHtcbiAgICB2YXIgb3JpZ2luYWxGcm9tQ29kZVBvaW50ID0gU3RyaW5nLmZyb21Db2RlUG9pbnQ7XG4gICAgb3ZlcnJpZGVOYXRpdmUoU3RyaW5nLCAnZnJvbUNvZGVQb2ludCcsIGZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoY29kZVBvaW50cykge1xuICAgICAgcmV0dXJuIEVTLkNhbGwob3JpZ2luYWxGcm9tQ29kZVBvaW50LCB0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIFN0cmluZ1NoaW1zID0ge1xuICAgIGZyb21Db2RlUG9pbnQ6IGZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoY29kZVBvaW50cykge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFyIG5leHQ7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5leHQgPSBOdW1iZXIoYXJndW1lbnRzW2ldKTtcbiAgICAgICAgaWYgKCFFUy5TYW1lVmFsdWUobmV4dCwgRVMuVG9JbnRlZ2VyKG5leHQpKSB8fCBuZXh0IDwgMCB8fCBuZXh0ID4gMHgxMEZGRkYpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBjb2RlIHBvaW50ICcgKyBuZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0IDwgMHgxMDAwMCkge1xuICAgICAgICAgIF9wdXNoKHJlc3VsdCwgU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCAtPSAweDEwMDAwO1xuICAgICAgICAgIF9wdXNoKHJlc3VsdCwgU3RyaW5nLmZyb21DaGFyQ29kZSgobmV4dCA+PiAxMCkgKyAweEQ4MDApKTtcbiAgICAgICAgICBfcHVzaChyZXN1bHQsIFN0cmluZy5mcm9tQ2hhckNvZGUoKG5leHQgJSAweDQwMCkgKyAweERDMDApKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIF9qb2luKHJlc3VsdCwgJycpO1xuICAgIH0sXG5cbiAgICByYXc6IGZ1bmN0aW9uIHJhdyh0ZW1wbGF0ZSkge1xuICAgICAgdmFyIG51bWJlck9mU3Vic3RpdHV0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGNvb2tlZCA9IEVTLlRvT2JqZWN0KHRlbXBsYXRlLCAnYmFkIHRlbXBsYXRlJyk7XG4gICAgICB2YXIgcmF3ID0gRVMuVG9PYmplY3QoY29va2VkLnJhdywgJ2JhZCByYXcgdmFsdWUnKTtcbiAgICAgIHZhciBsZW4gPSByYXcubGVuZ3RoO1xuICAgICAgdmFyIGxpdGVyYWxTZWdtZW50cyA9IEVTLlRvTGVuZ3RoKGxlbik7XG4gICAgICBpZiAobGl0ZXJhbFNlZ21lbnRzIDw9IDApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RyaW5nRWxlbWVudHMgPSBbXTtcbiAgICAgIHZhciBuZXh0SW5kZXggPSAwO1xuICAgICAgdmFyIG5leHRLZXksIG5leHQsIG5leHRTZWcsIG5leHRTdWI7XG4gICAgICB3aGlsZSAobmV4dEluZGV4IDwgbGl0ZXJhbFNlZ21lbnRzKSB7XG4gICAgICAgIG5leHRLZXkgPSBFUy5Ub1N0cmluZyhuZXh0SW5kZXgpO1xuICAgICAgICBuZXh0U2VnID0gRVMuVG9TdHJpbmcocmF3W25leHRLZXldKTtcbiAgICAgICAgX3B1c2goc3RyaW5nRWxlbWVudHMsIG5leHRTZWcpO1xuICAgICAgICBpZiAobmV4dEluZGV4ICsgMSA+PSBsaXRlcmFsU2VnbWVudHMpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBuZXh0ID0gbmV4dEluZGV4ICsgMSA8IGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbbmV4dEluZGV4ICsgMV0gOiAnJztcbiAgICAgICAgbmV4dFN1YiA9IEVTLlRvU3RyaW5nKG5leHQpO1xuICAgICAgICBfcHVzaChzdHJpbmdFbGVtZW50cywgbmV4dFN1Yik7XG4gICAgICAgIG5leHRJbmRleCArPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9qb2luKHN0cmluZ0VsZW1lbnRzLCAnJyk7XG4gICAgfVxuICB9O1xuICBpZiAoU3RyaW5nLnJhdyAmJiBTdHJpbmcucmF3KHsgcmF3OiB7IDA6ICd4JywgMTogJ3knLCBsZW5ndGg6IDIgfSB9KSAhPT0gJ3h5Jykge1xuICAgIC8vIElFIDExIFRQIGhhcyBhIGJyb2tlbiBTdHJpbmcucmF3IGltcGxlbWVudGF0aW9uXG4gICAgb3ZlcnJpZGVOYXRpdmUoU3RyaW5nLCAncmF3JywgU3RyaW5nU2hpbXMucmF3KTtcbiAgfVxuICBkZWZpbmVQcm9wZXJ0aWVzKFN0cmluZywgU3RyaW5nU2hpbXMpO1xuXG4gIC8vIEZhc3QgcmVwZWF0LCB1c2VzIHRoZSBgRXhwb25lbnRpYXRpb24gYnkgc3F1YXJpbmdgIGFsZ29yaXRobS5cbiAgLy8gUGVyZjogaHR0cDovL2pzcGVyZi5jb20vc3RyaW5nLXJlcGVhdDIvMlxuICB2YXIgc3RyaW5nUmVwZWF0ID0gZnVuY3Rpb24gcmVwZWF0KHMsIHRpbWVzKSB7XG4gICAgaWYgKHRpbWVzIDwgMSkgeyByZXR1cm4gJyc7IH1cbiAgICBpZiAodGltZXMgJSAyKSB7IHJldHVybiByZXBlYXQocywgdGltZXMgLSAxKSArIHM7IH1cbiAgICB2YXIgaGFsZiA9IHJlcGVhdChzLCB0aW1lcyAvIDIpO1xuICAgIHJldHVybiBoYWxmICsgaGFsZjtcbiAgfTtcbiAgdmFyIHN0cmluZ01heExlbmd0aCA9IEluZmluaXR5O1xuXG4gIHZhciBTdHJpbmdQcm90b3R5cGVTaGltcyA9IHtcbiAgICByZXBlYXQ6IGZ1bmN0aW9uIHJlcGVhdCh0aW1lcykge1xuICAgICAgdmFyIHRoaXNTdHIgPSBFUy5Ub1N0cmluZyhFUy5SZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpKTtcbiAgICAgIHZhciBudW1UaW1lcyA9IEVTLlRvSW50ZWdlcih0aW1lcyk7XG4gICAgICBpZiAobnVtVGltZXMgPCAwIHx8IG51bVRpbWVzID49IHN0cmluZ01heExlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncmVwZWF0IGNvdW50IG11c3QgYmUgbGVzcyB0aGFuIGluZmluaXR5IGFuZCBub3Qgb3ZlcmZsb3cgbWF4aW11bSBzdHJpbmcgc2l6ZScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZ1JlcGVhdCh0aGlzU3RyLCBudW1UaW1lcyk7XG4gICAgfSxcblxuICAgIHN0YXJ0c1dpdGg6IGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nKSB7XG4gICAgICB2YXIgUyA9IEVTLlRvU3RyaW5nKEVTLlJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcykpO1xuICAgICAgaWYgKEVTLklzUmVnRXhwKHNlYXJjaFN0cmluZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgbWV0aG9kIFwic3RhcnRzV2l0aFwiIHdpdGggYSByZWdleCcpO1xuICAgICAgfVxuICAgICAgdmFyIHNlYXJjaFN0ciA9IEVTLlRvU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gICAgICB2YXIgcG9zaXRpb247XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcG9zaXRpb24gPSBhcmd1bWVudHNbMV07XG4gICAgICB9XG4gICAgICB2YXIgc3RhcnQgPSBfbWF4KEVTLlRvSW50ZWdlcihwb3NpdGlvbiksIDApO1xuICAgICAgcmV0dXJuIF9zdHJTbGljZShTLCBzdGFydCwgc3RhcnQgKyBzZWFyY2hTdHIubGVuZ3RoKSA9PT0gc2VhcmNoU3RyO1xuICAgIH0sXG5cbiAgICBlbmRzV2l0aDogZnVuY3Rpb24gZW5kc1dpdGgoc2VhcmNoU3RyaW5nKSB7XG4gICAgICB2YXIgUyA9IEVTLlRvU3RyaW5nKEVTLlJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcykpO1xuICAgICAgaWYgKEVTLklzUmVnRXhwKHNlYXJjaFN0cmluZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgbWV0aG9kIFwiZW5kc1dpdGhcIiB3aXRoIGEgcmVnZXgnKTtcbiAgICAgIH1cbiAgICAgIHZhciBzZWFyY2hTdHIgPSBFUy5Ub1N0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgICAgdmFyIGxlbiA9IFMubGVuZ3RoO1xuICAgICAgdmFyIGVuZFBvc2l0aW9uO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGVuZFBvc2l0aW9uID0gYXJndW1lbnRzWzFdO1xuICAgICAgfVxuICAgICAgdmFyIHBvcyA9IHR5cGVvZiBlbmRQb3NpdGlvbiA9PT0gJ3VuZGVmaW5lZCcgPyBsZW4gOiBFUy5Ub0ludGVnZXIoZW5kUG9zaXRpb24pO1xuICAgICAgdmFyIGVuZCA9IF9taW4oX21heChwb3MsIDApLCBsZW4pO1xuICAgICAgcmV0dXJuIF9zdHJTbGljZShTLCBlbmQgLSBzZWFyY2hTdHIubGVuZ3RoLCBlbmQpID09PSBzZWFyY2hTdHI7XG4gICAgfSxcblxuICAgIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hTdHJpbmcpIHtcbiAgICAgIGlmIChFUy5Jc1JlZ0V4cChzZWFyY2hTdHJpbmcpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiaW5jbHVkZXNcIiBkb2VzIG5vdCBhY2NlcHQgYSBSZWdFeHAnKTtcbiAgICAgIH1cbiAgICAgIHZhciBzZWFyY2hTdHIgPSBFUy5Ub1N0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgICAgdmFyIHBvc2l0aW9uO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHBvc2l0aW9uID0gYXJndW1lbnRzWzFdO1xuICAgICAgfVxuICAgICAgLy8gU29tZWhvdyB0aGlzIHRyaWNrIG1ha2VzIG1ldGhvZCAxMDAlIGNvbXBhdCB3aXRoIHRoZSBzcGVjLlxuICAgICAgcmV0dXJuIF9pbmRleE9mKHRoaXMsIHNlYXJjaFN0ciwgcG9zaXRpb24pICE9PSAtMTtcbiAgICB9LFxuXG4gICAgY29kZVBvaW50QXQ6IGZ1bmN0aW9uIGNvZGVQb2ludEF0KHBvcykge1xuICAgICAgdmFyIHRoaXNTdHIgPSBFUy5Ub1N0cmluZyhFUy5SZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpKTtcbiAgICAgIHZhciBwb3NpdGlvbiA9IEVTLlRvSW50ZWdlcihwb3MpO1xuICAgICAgdmFyIGxlbmd0aCA9IHRoaXNTdHIubGVuZ3RoO1xuICAgICAgaWYgKHBvc2l0aW9uID49IDAgJiYgcG9zaXRpb24gPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGZpcnN0ID0gdGhpc1N0ci5jaGFyQ29kZUF0KHBvc2l0aW9uKTtcbiAgICAgICAgdmFyIGlzRW5kID0gcG9zaXRpb24gKyAxID09PSBsZW5ndGg7XG4gICAgICAgIGlmIChmaXJzdCA8IDB4RDgwMCB8fCBmaXJzdCA+IDB4REJGRiB8fCBpc0VuZCkgeyByZXR1cm4gZmlyc3Q7IH1cbiAgICAgICAgdmFyIHNlY29uZCA9IHRoaXNTdHIuY2hhckNvZGVBdChwb3NpdGlvbiArIDEpO1xuICAgICAgICBpZiAoc2Vjb25kIDwgMHhEQzAwIHx8IHNlY29uZCA+IDB4REZGRikgeyByZXR1cm4gZmlyc3Q7IH1cbiAgICAgICAgcmV0dXJuICgoZmlyc3QgLSAweEQ4MDApICogMTAyNCkgKyAoc2Vjb25kIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBpZiAoU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyAmJiAnYScuaW5jbHVkZXMoJ2EnLCBJbmZpbml0eSkgIT09IGZhbHNlKSB7XG4gICAgb3ZlcnJpZGVOYXRpdmUoU3RyaW5nLnByb3RvdHlwZSwgJ2luY2x1ZGVzJywgU3RyaW5nUHJvdG90eXBlU2hpbXMuaW5jbHVkZXMpO1xuICB9XG5cbiAgaWYgKFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCAmJiBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKSB7XG4gICAgdmFyIHN0YXJ0c1dpdGhSZWplY3RzUmVnZXggPSB0aHJvd3NFcnJvcihmdW5jdGlvbiAoKSB7XG4gICAgICAvKiB0aHJvd3MgaWYgc3BlYy1jb21wbGlhbnQgKi9cbiAgICAgIHJldHVybiAnL2EvJy5zdGFydHNXaXRoKC9hLyk7XG4gICAgfSk7XG4gICAgdmFyIHN0YXJ0c1dpdGhIYW5kbGVzSW5maW5pdHkgPSB2YWx1ZU9yRmFsc2VJZlRocm93cyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gJ2FiYycuc3RhcnRzV2l0aCgnYScsIEluZmluaXR5KSA9PT0gZmFsc2U7XG4gICAgfSk7XG4gICAgaWYgKCFzdGFydHNXaXRoUmVqZWN0c1JlZ2V4IHx8ICFzdGFydHNXaXRoSGFuZGxlc0luZmluaXR5KSB7XG4gICAgICAvLyBGaXJlZm94ICg8IDM3PykgYW5kIElFIDExIFRQIGhhdmUgYSBub25jb21wbGlhbnQgc3RhcnRzV2l0aCBpbXBsZW1lbnRhdGlvblxuICAgICAgb3ZlcnJpZGVOYXRpdmUoU3RyaW5nLnByb3RvdHlwZSwgJ3N0YXJ0c1dpdGgnLCBTdHJpbmdQcm90b3R5cGVTaGltcy5zdGFydHNXaXRoKTtcbiAgICAgIG92ZXJyaWRlTmF0aXZlKFN0cmluZy5wcm90b3R5cGUsICdlbmRzV2l0aCcsIFN0cmluZ1Byb3RvdHlwZVNoaW1zLmVuZHNXaXRoKTtcbiAgICB9XG4gIH1cbiAgaWYgKGhhc1N5bWJvbHMpIHtcbiAgICB2YXIgc3RhcnRzV2l0aFN1cHBvcnRzU3ltYm9sTWF0Y2ggPSB2YWx1ZU9yRmFsc2VJZlRocm93cyhmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmUgPSAvYS87XG4gICAgICByZVtTeW1ib2wubWF0Y2hdID0gZmFsc2U7XG4gICAgICByZXR1cm4gJy9hLycuc3RhcnRzV2l0aChyZSk7XG4gICAgfSk7XG4gICAgaWYgKCFzdGFydHNXaXRoU3VwcG9ydHNTeW1ib2xNYXRjaCkge1xuICAgICAgb3ZlcnJpZGVOYXRpdmUoU3RyaW5nLnByb3RvdHlwZSwgJ3N0YXJ0c1dpdGgnLCBTdHJpbmdQcm90b3R5cGVTaGltcy5zdGFydHNXaXRoKTtcbiAgICB9XG4gICAgdmFyIGVuZHNXaXRoU3VwcG9ydHNTeW1ib2xNYXRjaCA9IHZhbHVlT3JGYWxzZUlmVGhyb3dzKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZSA9IC9hLztcbiAgICAgIHJlW1N5bWJvbC5tYXRjaF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAnL2EvJy5lbmRzV2l0aChyZSk7XG4gICAgfSk7XG4gICAgaWYgKCFlbmRzV2l0aFN1cHBvcnRzU3ltYm9sTWF0Y2gpIHtcbiAgICAgIG92ZXJyaWRlTmF0aXZlKFN0cmluZy5wcm90b3R5cGUsICdlbmRzV2l0aCcsIFN0cmluZ1Byb3RvdHlwZVNoaW1zLmVuZHNXaXRoKTtcbiAgICB9XG4gICAgdmFyIGluY2x1ZGVzU3VwcG9ydHNTeW1ib2xNYXRjaCA9IHZhbHVlT3JGYWxzZUlmVGhyb3dzKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZSA9IC9hLztcbiAgICAgIHJlW1N5bWJvbC5tYXRjaF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAnL2EvJy5pbmNsdWRlcyhyZSk7XG4gICAgfSk7XG4gICAgaWYgKCFpbmNsdWRlc1N1cHBvcnRzU3ltYm9sTWF0Y2gpIHtcbiAgICAgIG92ZXJyaWRlTmF0aXZlKFN0cmluZy5wcm90b3R5cGUsICdpbmNsdWRlcycsIFN0cmluZ1Byb3RvdHlwZVNoaW1zLmluY2x1ZGVzKTtcbiAgICB9XG4gIH1cblxuICBkZWZpbmVQcm9wZXJ0aWVzKFN0cmluZy5wcm90b3R5cGUsIFN0cmluZ1Byb3RvdHlwZVNoaW1zKTtcblxuICAvLyB3aGl0ZXNwYWNlIGZyb206IGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuNS40LjIwXG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2Jsb2IvdjMuNC4wL2VzNS1zaGltLmpzI0wxMzA0LUwxMzI0XG4gIHZhciB3cyA9IFtcbiAgICAnXFx4MDlcXHgwQVxceDBCXFx4MENcXHgwRFxceDIwXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDMnLFxuICAgICdcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOCcsXG4gICAgJ1xcdTIwMjlcXHVGRUZGJ1xuICBdLmpvaW4oJycpO1xuICB2YXIgdHJpbVJlZ2V4cCA9IG5ldyBSZWdFeHAoJyheWycgKyB3cyArICddKyl8KFsnICsgd3MgKyAnXSskKScsICdnJyk7XG4gIHZhciB0cmltU2hpbSA9IGZ1bmN0aW9uIHRyaW0oKSB7XG4gICAgcmV0dXJuIEVTLlRvU3RyaW5nKEVTLlJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcykpLnJlcGxhY2UodHJpbVJlZ2V4cCwgJycpO1xuICB9O1xuICB2YXIgbm9uV1MgPSBbJ1xcdTAwODUnLCAnXFx1MjAwYicsICdcXHVmZmZlJ10uam9pbignJyk7XG4gIHZhciBub25XU3JlZ2V4ID0gbmV3IFJlZ0V4cCgnWycgKyBub25XUyArICddJywgJ2cnKTtcbiAgdmFyIGlzQmFkSGV4UmVnZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcbiAgdmFyIGhhc1N0cmluZ1RyaW1CdWcgPSBub25XUy50cmltKCkubGVuZ3RoICE9PSBub25XUy5sZW5ndGg7XG4gIGRlZmluZVByb3BlcnR5KFN0cmluZy5wcm90b3R5cGUsICd0cmltJywgdHJpbVNoaW0sIGhhc1N0cmluZ1RyaW1CdWcpO1xuXG4gIC8vIEdpdmVuIGFuIGFyZ3VtZW50IHgsIGl0IHdpbGwgcmV0dXJuIGFuIEl0ZXJhdG9yUmVzdWx0IG9iamVjdCxcbiAgLy8gd2l0aCB2YWx1ZSBzZXQgdG8geCBhbmQgZG9uZSB0byBmYWxzZS5cbiAgLy8gR2l2ZW4gbm8gYXJndW1lbnRzLCBpdCB3aWxsIHJldHVybiBhbiBpdGVyYXRvciBjb21wbGV0aW9uIG9iamVjdC5cbiAgdmFyIGl0ZXJhdG9yUmVzdWx0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogeCwgZG9uZTogYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB9O1xuICB9O1xuXG4gIC8vIHNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc3RyaW5nLnByb3RvdHlwZS1AQGl0ZXJhdG9yXG4gIHZhciBTdHJpbmdJdGVyYXRvciA9IGZ1bmN0aW9uIChzKSB7XG4gICAgRVMuUmVxdWlyZU9iamVjdENvZXJjaWJsZShzKTtcbiAgICB0aGlzLl9zID0gRVMuVG9TdHJpbmcocyk7XG4gICAgdGhpcy5faSA9IDA7XG4gIH07XG4gIFN0cmluZ0l0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5fcztcbiAgICB2YXIgaSA9IHRoaXMuX2k7XG4gICAgaWYgKHR5cGVvZiBzID09PSAndW5kZWZpbmVkJyB8fCBpID49IHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9zID0gdm9pZCAwO1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yUmVzdWx0KCk7XG4gICAgfVxuICAgIHZhciBmaXJzdCA9IHMuY2hhckNvZGVBdChpKTtcbiAgICB2YXIgc2Vjb25kLCBsZW47XG4gICAgaWYgKGZpcnN0IDwgMHhEODAwIHx8IGZpcnN0ID4gMHhEQkZGIHx8IChpICsgMSkgPT09IHMubGVuZ3RoKSB7XG4gICAgICBsZW4gPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWNvbmQgPSBzLmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgbGVuID0gKHNlY29uZCA8IDB4REMwMCB8fCBzZWNvbmQgPiAweERGRkYpID8gMSA6IDI7XG4gICAgfVxuICAgIHRoaXMuX2kgPSBpICsgbGVuO1xuICAgIHJldHVybiBpdGVyYXRvclJlc3VsdChzLnN1YnN0cihpLCBsZW4pKTtcbiAgfTtcbiAgYWRkSXRlcmF0b3IoU3RyaW5nSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgYWRkSXRlcmF0b3IoU3RyaW5nLnByb3RvdHlwZSwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU3RyaW5nSXRlcmF0b3IodGhpcyk7XG4gIH0pO1xuXG4gIHZhciBBcnJheVNoaW1zID0ge1xuICAgIGZyb206IGZ1bmN0aW9uIGZyb20oaXRlbXMpIHtcbiAgICAgIHZhciBDID0gdGhpcztcbiAgICAgIHZhciBtYXBGbjtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBtYXBGbiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIH1cbiAgICAgIHZhciBtYXBwaW5nLCBUO1xuICAgICAgaWYgKHR5cGVvZiBtYXBGbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbWFwcGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFFUy5Jc0NhbGxhYmxlKG1hcEZuKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LmZyb206IHdoZW4gcHJvdmlkZWQsIHRoZSBzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgVCA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgfVxuICAgICAgICBtYXBwaW5nID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gTm90ZSB0aGF0IHRoYXQgQXJyYXlzIHdpbGwgdXNlIEFycmF5SXRlcmF0b3I6XG4gICAgICAvLyBodHRwczovL2J1Z3MuZWNtYXNjcmlwdC5vcmcvc2hvd19idWcuY2dpP2lkPTI0MTZcbiAgICAgIHZhciB1c2luZ0l0ZXJhdG9yID0gdHlwZW9mIChpc0FyZ3VtZW50cyhpdGVtcykgfHwgRVMuR2V0TWV0aG9kKGl0ZW1zLCAkaXRlcmF0b3IkKSkgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgICB2YXIgbGVuZ3RoLCByZXN1bHQsIGk7XG4gICAgICBpZiAodXNpbmdJdGVyYXRvcikge1xuICAgICAgICByZXN1bHQgPSBFUy5Jc0NvbnN0cnVjdG9yKEMpID8gT2JqZWN0KG5ldyBDKCkpIDogW107XG4gICAgICAgIHZhciBpdGVyYXRvciA9IEVTLkdldEl0ZXJhdG9yKGl0ZW1zKTtcbiAgICAgICAgdmFyIG5leHQsIG5leHRWYWx1ZTtcblxuICAgICAgICBpID0gMDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBuZXh0ID0gRVMuSXRlcmF0b3JTdGVwKGl0ZXJhdG9yKTtcbiAgICAgICAgICBpZiAobmV4dCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0VmFsdWUgPSBuZXh0LnZhbHVlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAobWFwcGluZykge1xuICAgICAgICAgICAgICBuZXh0VmFsdWUgPSB0eXBlb2YgVCA9PT0gJ3VuZGVmaW5lZCcgPyBtYXBGbihuZXh0VmFsdWUsIGkpIDogX2NhbGwobWFwRm4sIFQsIG5leHRWYWx1ZSwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBuZXh0VmFsdWU7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgRVMuSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgdHJ1ZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoID0gaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhcnJheUxpa2UgPSBFUy5Ub09iamVjdChpdGVtcyk7XG4gICAgICAgIGxlbmd0aCA9IEVTLlRvTGVuZ3RoKGFycmF5TGlrZS5sZW5ndGgpO1xuICAgICAgICByZXN1bHQgPSBFUy5Jc0NvbnN0cnVjdG9yKEMpID8gT2JqZWN0KG5ldyBDKGxlbmd0aCkpIDogbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFsdWUgPSBhcnJheUxpa2VbaV07XG4gICAgICAgICAgaWYgKG1hcHBpbmcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdHlwZW9mIFQgPT09ICd1bmRlZmluZWQnID8gbWFwRm4odmFsdWUsIGkpIDogX2NhbGwobWFwRm4sIFQsIHZhbHVlLCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3JlYXRlRGF0YVByb3BlcnR5T3JUaHJvdyhyZXN1bHQsIGksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXN1bHQubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgb2Y6IGZ1bmN0aW9uIG9mKCkge1xuICAgICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB2YXIgQyA9IHRoaXM7XG4gICAgICB2YXIgQSA9IGlzQXJyYXkoQykgfHwgIUVTLklzQ2FsbGFibGUoQykgPyBuZXcgQXJyYXkobGVuKSA6IEVTLkNvbnN0cnVjdChDLCBbbGVuXSk7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGxlbjsgKytrKSB7XG4gICAgICAgIGNyZWF0ZURhdGFQcm9wZXJ0eU9yVGhyb3coQSwgaywgYXJndW1lbnRzW2tdKTtcbiAgICAgIH1cbiAgICAgIEEubGVuZ3RoID0gbGVuO1xuICAgICAgcmV0dXJuIEE7XG4gICAgfVxuICB9O1xuICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5LCBBcnJheVNoaW1zKTtcbiAgYWRkRGVmYXVsdFNwZWNpZXMoQXJyYXkpO1xuXG4gIC8vIE91ciBBcnJheUl0ZXJhdG9yIGlzIHByaXZhdGU7IHNlZVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL2VzNi1zaGltL2lzc3Vlcy8yNTJcbiAgQXJyYXlJdGVyYXRvciA9IGZ1bmN0aW9uIChhcnJheSwga2luZCkge1xuICAgIHRoaXMuaSA9IDA7XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gIH07XG5cbiAgZGVmaW5lUHJvcGVydGllcyhBcnJheUl0ZXJhdG9yLnByb3RvdHlwZSwge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpID0gdGhpcy5pO1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBcnJheUl0ZXJhdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgYW4gQXJyYXlJdGVyYXRvcicpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBhcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIGxlbiA9IEVTLlRvTGVuZ3RoKGFycmF5Lmxlbmd0aCk7XG4gICAgICAgIGlmIChpIDwgbGVuKSB7XG4gICAgICAgIC8vZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBraW5kID0gdGhpcy5raW5kO1xuICAgICAgICAgIHZhciByZXR2YWw7XG4gICAgICAgICAgaWYgKGtpbmQgPT09ICdrZXknKSB7XG4gICAgICAgICAgICByZXR2YWwgPSBpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgcmV0dmFsID0gYXJyYXlbaV07XG4gICAgICAgICAgfSBlbHNlIGlmIChraW5kID09PSAnZW50cnknKSB7XG4gICAgICAgICAgICByZXR2YWwgPSBbaSwgYXJyYXlbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmkgPSBpICsgMTtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JSZXN1bHQocmV0dmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5hcnJheSA9IHZvaWQgMDtcbiAgICAgIHJldHVybiBpdGVyYXRvclJlc3VsdCgpO1xuICAgIH1cbiAgfSk7XG4gIGFkZEl0ZXJhdG9yKEFycmF5SXRlcmF0b3IucHJvdG90eXBlKTtcblxuICAvKlxuICB2YXIgb3JkZXJLZXlzID0gZnVuY3Rpb24gb3JkZXJLZXlzKGEsIGIpIHtcbiAgICB2YXIgYU51bWVyaWMgPSBTdHJpbmcoRVMuVG9JbnRlZ2VyKGEpKSA9PT0gYTtcbiAgICB2YXIgYk51bWVyaWMgPSBTdHJpbmcoRVMuVG9JbnRlZ2VyKGIpKSA9PT0gYjtcbiAgICBpZiAoYU51bWVyaWMgJiYgYk51bWVyaWMpIHtcbiAgICAgIHJldHVybiBiIC0gYTtcbiAgICB9IGVsc2UgaWYgKGFOdW1lcmljICYmICFiTnVtZXJpYykge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSBpZiAoIWFOdW1lcmljICYmIGJOdW1lcmljKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGEubG9jYWxlQ29tcGFyZShiKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEFsbEtleXMgPSBmdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICAgIHZhciBvd25LZXlzID0gW107XG4gICAgdmFyIGtleXMgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIF9wdXNoKF9oYXNPd25Qcm9wZXJ0eShvYmplY3QsIGtleSkgPyBvd25LZXlzIDoga2V5cywga2V5KTtcbiAgICB9XG4gICAgX3NvcnQob3duS2V5cywgb3JkZXJLZXlzKTtcbiAgICBfc29ydChrZXlzLCBvcmRlcktleXMpO1xuXG4gICAgcmV0dXJuIF9jb25jYXQob3duS2V5cywga2V5cyk7XG4gIH07XG4gICovXG5cbiAgLy8gbm90ZTogdGhpcyBpcyBwb3NpdGlvbmVkIGhlcmUgYmVjYXVzZSBpdCBkZXBlbmRzIG9uIEFycmF5SXRlcmF0b3JcbiAgdmFyIGFycmF5T2ZTdXBwb3J0c1N1YmNsYXNzaW5nID0gQXJyYXkub2YgPT09IEFycmF5U2hpbXMub2YgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBEZXRlY3RzIGEgYnVnIGluIFdlYmtpdCBuaWdodGx5IHIxODE4ODZcbiAgICB2YXIgRm9vID0gZnVuY3Rpb24gRm9vKGxlbikgeyB0aGlzLmxlbmd0aCA9IGxlbjsgfTtcbiAgICBGb28ucHJvdG90eXBlID0gW107XG4gICAgdmFyIGZvb0FyciA9IEFycmF5Lm9mLmFwcGx5KEZvbywgWzEsIDJdKTtcbiAgICByZXR1cm4gZm9vQXJyIGluc3RhbmNlb2YgRm9vICYmIGZvb0Fyci5sZW5ndGggPT09IDI7XG4gIH0oKSk7XG4gIGlmICghYXJyYXlPZlN1cHBvcnRzU3ViY2xhc3NpbmcpIHtcbiAgICBvdmVycmlkZU5hdGl2ZShBcnJheSwgJ29mJywgQXJyYXlTaGltcy5vZik7XG4gIH1cblxuICB2YXIgQXJyYXlQcm90b3R5cGVTaGltcyA9IHtcbiAgICBjb3B5V2l0aGluOiBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldCwgc3RhcnQpIHtcbiAgICAgIHZhciBvID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICB2YXIgbGVuID0gRVMuVG9MZW5ndGgoby5sZW5ndGgpO1xuICAgICAgdmFyIHJlbGF0aXZlVGFyZ2V0ID0gRVMuVG9JbnRlZ2VyKHRhcmdldCk7XG4gICAgICB2YXIgcmVsYXRpdmVTdGFydCA9IEVTLlRvSW50ZWdlcihzdGFydCk7XG4gICAgICB2YXIgdG8gPSByZWxhdGl2ZVRhcmdldCA8IDAgPyBfbWF4KGxlbiArIHJlbGF0aXZlVGFyZ2V0LCAwKSA6IF9taW4ocmVsYXRpdmVUYXJnZXQsIGxlbik7XG4gICAgICB2YXIgZnJvbSA9IHJlbGF0aXZlU3RhcnQgPCAwID8gX21heChsZW4gKyByZWxhdGl2ZVN0YXJ0LCAwKSA6IF9taW4ocmVsYXRpdmVTdGFydCwgbGVuKTtcbiAgICAgIHZhciBlbmQ7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgZW5kID0gYXJndW1lbnRzWzJdO1xuICAgICAgfVxuICAgICAgdmFyIHJlbGF0aXZlRW5kID0gdHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcgPyBsZW4gOiBFUy5Ub0ludGVnZXIoZW5kKTtcbiAgICAgIHZhciBmaW5hbEl0ZW0gPSByZWxhdGl2ZUVuZCA8IDAgPyBfbWF4KGxlbiArIHJlbGF0aXZlRW5kLCAwKSA6IF9taW4ocmVsYXRpdmVFbmQsIGxlbik7XG4gICAgICB2YXIgY291bnQgPSBfbWluKGZpbmFsSXRlbSAtIGZyb20sIGxlbiAtIHRvKTtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSAxO1xuICAgICAgaWYgKGZyb20gPCB0byAmJiB0byA8IChmcm9tICsgY291bnQpKSB7XG4gICAgICAgIGRpcmVjdGlvbiA9IC0xO1xuICAgICAgICBmcm9tICs9IGNvdW50IC0gMTtcbiAgICAgICAgdG8gKz0gY291bnQgLSAxO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGNvdW50ID4gMCkge1xuICAgICAgICBpZiAoZnJvbSBpbiBvKSB7XG4gICAgICAgICAgb1t0b10gPSBvW2Zyb21dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBvW3RvXTtcbiAgICAgICAgfVxuICAgICAgICBmcm9tICs9IGRpcmVjdGlvbjtcbiAgICAgICAgdG8gKz0gZGlyZWN0aW9uO1xuICAgICAgICBjb3VudCAtPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG87XG4gICAgfSxcblxuICAgIGZpbGw6IGZ1bmN0aW9uIGZpbGwodmFsdWUpIHtcbiAgICAgIHZhciBzdGFydDtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBzdGFydCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIH1cbiAgICAgIHZhciBlbmQ7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgZW5kID0gYXJndW1lbnRzWzJdO1xuICAgICAgfVxuICAgICAgdmFyIE8gPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgIHZhciBsZW4gPSBFUy5Ub0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICBzdGFydCA9IEVTLlRvSW50ZWdlcih0eXBlb2Ygc3RhcnQgPT09ICd1bmRlZmluZWQnID8gMCA6IHN0YXJ0KTtcbiAgICAgIGVuZCA9IEVTLlRvSW50ZWdlcih0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJyA/IGxlbiA6IGVuZCk7XG5cbiAgICAgIHZhciByZWxhdGl2ZVN0YXJ0ID0gc3RhcnQgPCAwID8gX21heChsZW4gKyBzdGFydCwgMCkgOiBfbWluKHN0YXJ0LCBsZW4pO1xuICAgICAgdmFyIHJlbGF0aXZlRW5kID0gZW5kIDwgMCA/IGxlbiArIGVuZCA6IGVuZDtcblxuICAgICAgZm9yICh2YXIgaSA9IHJlbGF0aXZlU3RhcnQ7IGkgPCBsZW4gJiYgaSA8IHJlbGF0aXZlRW5kOyArK2kpIHtcbiAgICAgICAgT1tpXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE87XG4gICAgfSxcblxuICAgIGZpbmQ6IGZ1bmN0aW9uIGZpbmQocHJlZGljYXRlKSB7XG4gICAgICB2YXIgbGlzdCA9IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvTGVuZ3RoKGxpc3QubGVuZ3RoKTtcbiAgICAgIGlmICghRVMuSXNDYWxsYWJsZShwcmVkaWNhdGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5I2ZpbmQ6IHByZWRpY2F0ZSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBsaXN0W2ldO1xuICAgICAgICBpZiAodGhpc0FyZykge1xuICAgICAgICAgIGlmIChfY2FsbChwcmVkaWNhdGUsIHRoaXNBcmcsIHZhbHVlLCBpLCBsaXN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwcmVkaWNhdGUodmFsdWUsIGksIGxpc3QpKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGxpc3QgPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgIHZhciBsZW5ndGggPSBFUy5Ub0xlbmd0aChsaXN0Lmxlbmd0aCk7XG4gICAgICBpZiAoIUVTLklzQ2FsbGFibGUocHJlZGljYXRlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheSNmaW5kSW5kZXg6IHByZWRpY2F0ZSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpc0FyZykge1xuICAgICAgICAgIGlmIChfY2FsbChwcmVkaWNhdGUsIHRoaXNBcmcsIGxpc3RbaV0sIGksIGxpc3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHJlZGljYXRlKGxpc3RbaV0sIGksIGxpc3QpKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9LFxuXG4gICAga2V5czogZnVuY3Rpb24ga2V5cygpIHtcbiAgICAgIHJldHVybiBuZXcgQXJyYXlJdGVyYXRvcih0aGlzLCAna2V5Jyk7XG4gICAgfSxcblxuICAgIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgcmV0dXJuIG5ldyBBcnJheUl0ZXJhdG9yKHRoaXMsICd2YWx1ZScpO1xuICAgIH0sXG5cbiAgICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIG5ldyBBcnJheUl0ZXJhdG9yKHRoaXMsICdlbnRyeScpO1xuICAgIH1cbiAgfTtcbiAgLy8gU2FmYXJpIDcuMSBkZWZpbmVzIEFycmF5I2tleXMgYW5kIEFycmF5I2VudHJpZXMgbmF0aXZlbHksXG4gIC8vIGJ1dCB0aGUgcmVzdWx0aW5nIEFycmF5SXRlcmF0b3Igb2JqZWN0cyBkb24ndCBoYXZlIGEgXCJuZXh0XCIgbWV0aG9kLlxuICBpZiAoQXJyYXkucHJvdG90eXBlLmtleXMgJiYgIUVTLklzQ2FsbGFibGUoWzFdLmtleXMoKS5uZXh0KSkge1xuICAgIGRlbGV0ZSBBcnJheS5wcm90b3R5cGUua2V5cztcbiAgfVxuICBpZiAoQXJyYXkucHJvdG90eXBlLmVudHJpZXMgJiYgIUVTLklzQ2FsbGFibGUoWzFdLmVudHJpZXMoKS5uZXh0KSkge1xuICAgIGRlbGV0ZSBBcnJheS5wcm90b3R5cGUuZW50cmllcztcbiAgfVxuXG4gIC8vIENocm9tZSAzOCBkZWZpbmVzIEFycmF5I2tleXMgYW5kIEFycmF5I2VudHJpZXMsIGFuZCBBcnJheSNAQGl0ZXJhdG9yLCBidXQgbm90IEFycmF5I3ZhbHVlc1xuICBpZiAoQXJyYXkucHJvdG90eXBlLmtleXMgJiYgQXJyYXkucHJvdG90eXBlLmVudHJpZXMgJiYgIUFycmF5LnByb3RvdHlwZS52YWx1ZXMgJiYgQXJyYXkucHJvdG90eXBlWyRpdGVyYXRvciRdKSB7XG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheS5wcm90b3R5cGUsIHtcbiAgICAgIHZhbHVlczogQXJyYXkucHJvdG90eXBlWyRpdGVyYXRvciRdXG4gICAgfSk7XG4gICAgaWYgKFR5cGUuc3ltYm9sKFN5bWJvbC51bnNjb3BhYmxlcykpIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZVtTeW1ib2wudW5zY29wYWJsZXNdLnZhbHVlcyA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8vIENocm9tZSA0MCBkZWZpbmVzIEFycmF5I3ZhbHVlcyB3aXRoIHRoZSBpbmNvcnJlY3QgbmFtZSwgYWx0aG91Z2ggQXJyYXkje2tleXMsZW50cmllc30gaGF2ZSB0aGUgY29ycmVjdCBuYW1lXG4gIGlmIChmdW5jdGlvbnNIYXZlTmFtZXMgJiYgQXJyYXkucHJvdG90eXBlLnZhbHVlcyAmJiBBcnJheS5wcm90b3R5cGUudmFsdWVzLm5hbWUgIT09ICd2YWx1ZXMnKSB7XG4gICAgdmFyIG9yaWdpbmFsQXJyYXlQcm90b3R5cGVWYWx1ZXMgPSBBcnJheS5wcm90b3R5cGUudmFsdWVzO1xuICAgIG92ZXJyaWRlTmF0aXZlKEFycmF5LnByb3RvdHlwZSwgJ3ZhbHVlcycsIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIEVTLkNhbGwob3JpZ2luYWxBcnJheVByb3RvdHlwZVZhbHVlcywgdGhpcywgYXJndW1lbnRzKTsgfSk7XG4gICAgZGVmaW5lUHJvcGVydHkoQXJyYXkucHJvdG90eXBlLCAkaXRlcmF0b3IkLCBBcnJheS5wcm90b3R5cGUudmFsdWVzLCB0cnVlKTtcbiAgfVxuICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5LnByb3RvdHlwZSwgQXJyYXlQcm90b3R5cGVTaGltcyk7XG5cbiAgaWYgKDEgLyBbdHJ1ZV0uaW5kZXhPZih0cnVlLCAtMCkgPCAwKSB7XG4gICAgLy8gaW5kZXhPZiB3aGVuIGdpdmVuIGEgcG9zaXRpb24gYXJnIG9mIC0wIHNob3VsZCByZXR1cm4gKzAuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvZWNtYTI2Mi9wdWxsLzMxNlxuICAgIGRlZmluZVByb3BlcnR5KEFycmF5LnByb3RvdHlwZSwgJ2luZGV4T2YnLCBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IF9hcnJheUluZGV4T2ZBcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHZhbHVlID09PSAwICYmICgxIC8gdmFsdWUpIDwgMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LCB0cnVlKTtcbiAgfVxuXG4gIGFkZEl0ZXJhdG9yKEFycmF5LnByb3RvdHlwZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy52YWx1ZXMoKTsgfSk7XG4gIC8vIENocm9tZSBkZWZpbmVzIGtleXMvdmFsdWVzL2VudHJpZXMgb24gQXJyYXksIGJ1dCBkb2Vzbid0IGdpdmUgdXNcbiAgLy8gYW55IHdheSB0byBpZGVudGlmeSBpdHMgaXRlcmF0b3IuICBTbyBhZGQgb3VyIG93biBzaGltbWVkIGZpZWxkLlxuICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKSB7XG4gICAgYWRkSXRlcmF0b3IoT2JqZWN0LmdldFByb3RvdHlwZU9mKFtdLnZhbHVlcygpKSk7XG4gIH1cblxuICAvLyBub3RlOiB0aGlzIGlzIHBvc2l0aW9uZWQgaGVyZSBiZWNhdXNlIGl0IHJlbGllcyBvbiBBcnJheSNlbnRyaWVzXG4gIHZhciBhcnJheUZyb21Td2FsbG93c05lZ2F0aXZlTGVuZ3RocyA9IChmdW5jdGlvbiAoKSB7XG4gICAgLy8gRGV0ZWN0cyBhIEZpcmVmb3ggYnVnIGluIHYzMlxuICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEwNjM5OTNcbiAgICByZXR1cm4gdmFsdWVPckZhbHNlSWZUaHJvd3MoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IC0xIH0pLmxlbmd0aCA9PT0gMDtcbiAgICB9KTtcbiAgfSgpKTtcbiAgdmFyIGFycmF5RnJvbUhhbmRsZXNJdGVyYWJsZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8vIERldGVjdHMgYSBidWcgaW4gV2Via2l0IG5pZ2h0bHkgcjE4MTg4NlxuICAgIHZhciBhcnIgPSBBcnJheS5mcm9tKFswXS5lbnRyaWVzKCkpO1xuICAgIHJldHVybiBhcnIubGVuZ3RoID09PSAxICYmIGlzQXJyYXkoYXJyWzBdKSAmJiBhcnJbMF1bMF0gPT09IDAgJiYgYXJyWzBdWzFdID09PSAwO1xuICB9KCkpO1xuICBpZiAoIWFycmF5RnJvbVN3YWxsb3dzTmVnYXRpdmVMZW5ndGhzIHx8ICFhcnJheUZyb21IYW5kbGVzSXRlcmFibGVzKSB7XG4gICAgb3ZlcnJpZGVOYXRpdmUoQXJyYXksICdmcm9tJywgQXJyYXlTaGltcy5mcm9tKTtcbiAgfVxuICB2YXIgYXJyYXlGcm9tSGFuZGxlc1VuZGVmaW5lZE1hcEZ1bmN0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBNaWNyb3NvZnQgRWRnZSB2MC4xMSB0aHJvd3MgaWYgdGhlIG1hcEZuIGFyZ3VtZW50IGlzICpwcm92aWRlZCogYnV0IHVuZGVmaW5lZCxcbiAgICAvLyBidXQgdGhlIHNwZWMgZG9lc24ndCBjYXJlIGlmIGl0J3MgcHJvdmlkZWQgb3Igbm90IC0gdW5kZWZpbmVkIGRvZXNuJ3QgdGhyb3cuXG4gICAgcmV0dXJuIHZhbHVlT3JGYWxzZUlmVGhyb3dzKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKFswXSwgdm9pZCAwKTtcbiAgICB9KTtcbiAgfSgpKTtcbiAgaWYgKCFhcnJheUZyb21IYW5kbGVzVW5kZWZpbmVkTWFwRnVuY3Rpb24pIHtcbiAgICB2YXIgb3JpZ0FycmF5RnJvbSA9IEFycmF5LmZyb207XG4gICAgb3ZlcnJpZGVOYXRpdmUoQXJyYXksICdmcm9tJywgZnVuY3Rpb24gZnJvbShpdGVtcykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBFUy5DYWxsKG9yaWdBcnJheUZyb20sIHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX2NhbGwob3JpZ0FycmF5RnJvbSwgdGhpcywgaXRlbXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGludDMyc0FzT25lID0gLShNYXRoLnBvdygyLCAzMikgLSAxKTtcbiAgdmFyIHRvTGVuZ3Roc0NvcnJlY3RseSA9IGZ1bmN0aW9uIChtZXRob2QsIHJldmVyc2VkKSB7XG4gICAgdmFyIG9iaiA9IHsgbGVuZ3RoOiBpbnQzMnNBc09uZSB9O1xuICAgIG9ialtyZXZlcnNlZCA/IChvYmoubGVuZ3RoID4+PiAwKSAtIDEgOiAwXSA9IHRydWU7XG4gICAgcmV0dXJuIHZhbHVlT3JGYWxzZUlmVGhyb3dzKGZ1bmN0aW9uICgpIHtcbiAgICAgIF9jYWxsKG1ldGhvZCwgb2JqLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIG5vdGU6IGluIG5vbmNvbmZvcm1pbmcgYnJvd3NlcnMsIHRoaXMgd2lsbCBiZSBjYWxsZWRcbiAgICAgICAgLy8gLTEgPj4+IDAgdGltZXMsIHdoaWNoIGlzIDQyOTQ5NjcyOTUsIHNvIHRoZSB0aHJvdyBtYXR0ZXJzLlxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2hvdWxkIG5vdCByZWFjaCBoZXJlJyk7XG4gICAgICB9LCBbXSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfTtcbiAgaWYgKCF0b0xlbmd0aHNDb3JyZWN0bHkoQXJyYXkucHJvdG90eXBlLmZvckVhY2gpKSB7XG4gICAgdmFyIG9yaWdpbmFsRm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xuICAgIG92ZXJyaWRlTmF0aXZlKEFycmF5LnByb3RvdHlwZSwgJ2ZvckVhY2gnLCBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrRm4pIHtcbiAgICAgIHJldHVybiBFUy5DYWxsKG9yaWdpbmFsRm9yRWFjaCwgdGhpcy5sZW5ndGggPj0gMCA/IHRoaXMgOiBbXSwgYXJndW1lbnRzKTtcbiAgICB9KTtcbiAgfVxuICBpZiAoIXRvTGVuZ3Roc0NvcnJlY3RseShBcnJheS5wcm90b3R5cGUubWFwKSkge1xuICAgIHZhciBvcmlnaW5hbE1hcCA9IEFycmF5LnByb3RvdHlwZS5tYXA7XG4gICAgb3ZlcnJpZGVOYXRpdmUoQXJyYXkucHJvdG90eXBlLCAnbWFwJywgZnVuY3Rpb24gbWFwKGNhbGxiYWNrRm4pIHtcbiAgICAgIHJldHVybiBFUy5DYWxsKG9yaWdpbmFsTWFwLCB0aGlzLmxlbmd0aCA+PSAwID8gdGhpcyA6IFtdLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuICB9XG4gIGlmICghdG9MZW5ndGhzQ29ycmVjdGx5KEFycmF5LnByb3RvdHlwZS5maWx0ZXIpKSB7XG4gICAgdmFyIG9yaWdpbmFsRmlsdGVyID0gQXJyYXkucHJvdG90eXBlLmZpbHRlcjtcbiAgICBvdmVycmlkZU5hdGl2ZShBcnJheS5wcm90b3R5cGUsICdmaWx0ZXInLCBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tGbikge1xuICAgICAgcmV0dXJuIEVTLkNhbGwob3JpZ2luYWxGaWx0ZXIsIHRoaXMubGVuZ3RoID49IDAgPyB0aGlzIDogW10sIGFyZ3VtZW50cyk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKCF0b0xlbmd0aHNDb3JyZWN0bHkoQXJyYXkucHJvdG90eXBlLnNvbWUpKSB7XG4gICAgdmFyIG9yaWdpbmFsU29tZSA9IEFycmF5LnByb3RvdHlwZS5zb21lO1xuICAgIG92ZXJyaWRlTmF0aXZlKEFycmF5LnByb3RvdHlwZSwgJ3NvbWUnLCBmdW5jdGlvbiBzb21lKGNhbGxiYWNrRm4pIHtcbiAgICAgIHJldHVybiBFUy5DYWxsKG9yaWdpbmFsU29tZSwgdGhpcy5sZW5ndGggPj0gMCA/IHRoaXMgOiBbXSwgYXJndW1lbnRzKTtcbiAgICB9KTtcbiAgfVxuICBpZiAoIXRvTGVuZ3Roc0NvcnJlY3RseShBcnJheS5wcm90b3R5cGUuZXZlcnkpKSB7XG4gICAgdmFyIG9yaWdpbmFsRXZlcnkgPSBBcnJheS5wcm90b3R5cGUuZXZlcnk7XG4gICAgb3ZlcnJpZGVOYXRpdmUoQXJyYXkucHJvdG90eXBlLCAnZXZlcnknLCBmdW5jdGlvbiBldmVyeShjYWxsYmFja0ZuKSB7XG4gICAgICByZXR1cm4gRVMuQ2FsbChvcmlnaW5hbEV2ZXJ5LCB0aGlzLmxlbmd0aCA+PSAwID8gdGhpcyA6IFtdLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuICB9XG4gIGlmICghdG9MZW5ndGhzQ29ycmVjdGx5KEFycmF5LnByb3RvdHlwZS5yZWR1Y2UpKSB7XG4gICAgdmFyIG9yaWdpbmFsUmVkdWNlID0gQXJyYXkucHJvdG90eXBlLnJlZHVjZTtcbiAgICBvdmVycmlkZU5hdGl2ZShBcnJheS5wcm90b3R5cGUsICdyZWR1Y2UnLCBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tGbikge1xuICAgICAgcmV0dXJuIEVTLkNhbGwob3JpZ2luYWxSZWR1Y2UsIHRoaXMubGVuZ3RoID49IDAgPyB0aGlzIDogW10sIGFyZ3VtZW50cyk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKCF0b0xlbmd0aHNDb3JyZWN0bHkoQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0LCB0cnVlKSkge1xuICAgIHZhciBvcmlnaW5hbFJlZHVjZVJpZ2h0ID0gQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0O1xuICAgIG92ZXJyaWRlTmF0aXZlKEFycmF5LnByb3RvdHlwZSwgJ3JlZHVjZVJpZ2h0JywgZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tGbikge1xuICAgICAgcmV0dXJuIEVTLkNhbGwob3JpZ2luYWxSZWR1Y2VSaWdodCwgdGhpcy5sZW5ndGggPj0gMCA/IHRoaXMgOiBbXSwgYXJndW1lbnRzKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBsYWNrc09jdGFsU3VwcG9ydCA9IE51bWJlcignMG8xMCcpICE9PSA4O1xuICB2YXIgbGFja3NCaW5hcnlTdXBwb3J0ID0gTnVtYmVyKCcwYjEwJykgIT09IDI7XG4gIHZhciB0cmltc05vbldoaXRlc3BhY2UgPSBfc29tZShub25XUywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gTnVtYmVyKGMgKyAwICsgYykgPT09IDA7XG4gIH0pO1xuICBpZiAobGFja3NPY3RhbFN1cHBvcnQgfHwgbGFja3NCaW5hcnlTdXBwb3J0IHx8IHRyaW1zTm9uV2hpdGVzcGFjZSkge1xuICAgIHZhciBPcmlnTnVtYmVyID0gTnVtYmVyO1xuICAgIHZhciBiaW5hcnlSZWdleCA9IC9eMGJbMDFdKyQvaTtcbiAgICB2YXIgb2N0YWxSZWdleCA9IC9eMG9bMC03XSskL2k7XG4gICAgLy8gTm90ZSB0aGF0IGluIElFIDgsIFJlZ0V4cC5wcm90b3R5cGUudGVzdCBkb2Vzbid0IHNlZW0gdG8gZXhpc3Q6IGllLCBcInRlc3RcIiBpcyBhbiBvd24gcHJvcGVydHkgb2YgcmVnZXhlcy4gd3RmLlxuICAgIHZhciBpc0JpbmFyeSA9IGJpbmFyeVJlZ2V4LnRlc3QuYmluZChiaW5hcnlSZWdleCk7XG4gICAgdmFyIGlzT2N0YWwgPSBvY3RhbFJlZ2V4LnRlc3QuYmluZChvY3RhbFJlZ2V4KTtcbiAgICB2YXIgdG9QcmltaXRpdmUgPSBmdW5jdGlvbiAoTywgaGludCkgeyAvLyBuZWVkIHRvIHJlcGxhY2UgdGhpcyB3aXRoIGBlcy10by1wcmltaXRpdmUvZXM2YFxuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGlmICh0eXBlb2YgTy52YWx1ZU9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlc3VsdCA9IE8udmFsdWVPZigpO1xuICAgICAgICBpZiAoVHlwZS5wcmltaXRpdmUocmVzdWx0KSkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgTy50b1N0cmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXN1bHQgPSBPLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChUeXBlLnByaW1pdGl2ZShyZXN1bHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm8gZGVmYXVsdCB2YWx1ZScpO1xuICAgIH07XG4gICAgdmFyIGhhc05vbldTID0gbm9uV1NyZWdleC50ZXN0LmJpbmQobm9uV1NyZWdleCk7XG4gICAgdmFyIGlzQmFkSGV4ID0gaXNCYWRIZXhSZWdleC50ZXN0LmJpbmQoaXNCYWRIZXhSZWdleCk7XG4gICAgdmFyIE51bWJlclNoaW0gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gdGhpcyBpcyB3cmFwcGVkIGluIGFuIElJRkUgYmVjYXVzZSBvZiBJRSA2LTgncyB3YWNreSBzY29waW5nIGlzc3VlcyB3aXRoIG5hbWVkIGZ1bmN0aW9uIGV4cHJlc3Npb25zLlxuICAgICAgdmFyIE51bWJlclNoaW0gPSBmdW5jdGlvbiBOdW1iZXIodmFsdWUpIHtcbiAgICAgICAgdmFyIHByaW1WYWx1ZTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcHJpbVZhbHVlID0gVHlwZS5wcmltaXRpdmUodmFsdWUpID8gdmFsdWUgOiB0b1ByaW1pdGl2ZSh2YWx1ZSwgJ251bWJlcicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByaW1WYWx1ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwcmltVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcHJpbVZhbHVlID0gRVMuQ2FsbCh0cmltU2hpbSwgcHJpbVZhbHVlKTtcbiAgICAgICAgICBpZiAoaXNCaW5hcnkocHJpbVZhbHVlKSkge1xuICAgICAgICAgICAgcHJpbVZhbHVlID0gcGFyc2VJbnQoX3N0clNsaWNlKHByaW1WYWx1ZSwgMiksIDIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNPY3RhbChwcmltVmFsdWUpKSB7XG4gICAgICAgICAgICBwcmltVmFsdWUgPSBwYXJzZUludChfc3RyU2xpY2UocHJpbVZhbHVlLCAyKSwgOCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNOb25XUyhwcmltVmFsdWUpIHx8IGlzQmFkSGV4KHByaW1WYWx1ZSkpIHtcbiAgICAgICAgICAgIHByaW1WYWx1ZSA9IE5hTjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlY2VpdmVyID0gdGhpcztcbiAgICAgICAgdmFyIHZhbHVlT2ZTdWNjZWVkcyA9IHZhbHVlT3JGYWxzZUlmVGhyb3dzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBPcmlnTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlY2VpdmVyIGluc3RhbmNlb2YgTnVtYmVyU2hpbSAmJiAhdmFsdWVPZlN1Y2NlZWRzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBPcmlnTnVtYmVyKHByaW1WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9yaWdOdW1iZXIocHJpbVZhbHVlKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gTnVtYmVyU2hpbTtcbiAgICB9KCkpO1xuICAgIHdyYXBDb25zdHJ1Y3RvcihPcmlnTnVtYmVyLCBOdW1iZXJTaGltLCB7fSk7XG4gICAgLy8gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIEVTMyBicm93c2Vycywgd2hlcmUgdGhlc2UgcHJvcGVydGllcyBhcmUgbm9uLWVudW1lcmFibGUuXG4gICAgZGVmaW5lUHJvcGVydGllcyhOdW1iZXJTaGltLCB7XG4gICAgICBOYU46IE9yaWdOdW1iZXIuTmFOLFxuICAgICAgTUFYX1ZBTFVFOiBPcmlnTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgIE1JTl9WQUxVRTogT3JpZ051bWJlci5NSU5fVkFMVUUsXG4gICAgICBORUdBVElWRV9JTkZJTklUWTogT3JpZ051bWJlci5ORUdBVElWRV9JTkZJTklUWSxcbiAgICAgIFBPU0lUSVZFX0lORklOSVRZOiBPcmlnTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gICAgfSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYsIG5vLWdsb2JhbC1hc3NpZ24gKi9cbiAgICBOdW1iZXIgPSBOdW1iZXJTaGltO1xuICAgIFZhbHVlLnJlZGVmaW5lKGdsb2JhbHMsICdOdW1iZXInLCBOdW1iZXJTaGltKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZGVmLCBuby1nbG9iYWwtYXNzaWduICovXG4gIH1cblxuICB2YXIgbWF4U2FmZUludGVnZXIgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuICBkZWZpbmVQcm9wZXJ0aWVzKE51bWJlciwge1xuICAgIE1BWF9TQUZFX0lOVEVHRVI6IG1heFNhZmVJbnRlZ2VyLFxuICAgIE1JTl9TQUZFX0lOVEVHRVI6IC1tYXhTYWZlSW50ZWdlcixcbiAgICBFUFNJTE9OOiAyLjIyMDQ0NjA0OTI1MDMxM2UtMTYsXG5cbiAgICBwYXJzZUludDogZ2xvYmFscy5wYXJzZUludCxcbiAgICBwYXJzZUZsb2F0OiBnbG9iYWxzLnBhcnNlRmxvYXQsXG5cbiAgICBpc0Zpbml0ZTogbnVtYmVySXNGaW5pdGUsXG5cbiAgICBpc0ludGVnZXI6IGZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIG51bWJlcklzRmluaXRlKHZhbHVlKSAmJiBFUy5Ub0ludGVnZXIodmFsdWUpID09PSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgaXNTYWZlSW50ZWdlcjogZnVuY3Rpb24gaXNTYWZlSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIodmFsdWUpICYmIF9hYnModmFsdWUpIDw9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgIH0sXG5cbiAgICBpc05hTjogbnVtYmVySXNOYU5cbiAgfSk7XG4gIC8vIEZpcmVmb3ggMzcgaGFzIGEgY29uZm9ybWluZyBOdW1iZXIucGFyc2VJbnQsIGJ1dCBpdCdzIG5vdCA9PT0gdG8gdGhlIGdsb2JhbCBwYXJzZUludCAoZml4ZWQgaW4gdjQwKVxuICBkZWZpbmVQcm9wZXJ0eShOdW1iZXIsICdwYXJzZUludCcsIGdsb2JhbHMucGFyc2VJbnQsIE51bWJlci5wYXJzZUludCAhPT0gZ2xvYmFscy5wYXJzZUludCk7XG5cbiAgLy8gV29yayBhcm91bmQgYnVncyBpbiBBcnJheSNmaW5kIGFuZCBBcnJheSNmaW5kSW5kZXggLS0gZWFybHlcbiAgLy8gaW1wbGVtZW50YXRpb25zIHNraXBwZWQgaG9sZXMgaW4gc3BhcnNlIGFycmF5cy4gKE5vdGUgdGhhdCB0aGVcbiAgLy8gaW1wbGVtZW50YXRpb25zIG9mIGZpbmQvZmluZEluZGV4IGluZGlyZWN0bHkgdXNlIHNoaW1tZWRcbiAgLy8gbWV0aG9kcyBvZiBOdW1iZXIsIHNvIHRoaXMgdGVzdCBoYXMgdG8gaGFwcGVuIGRvd24gaGVyZS4pXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXNwYXJzZS1hcnJheXMgKi9cbiAgaWYgKFssIDFdLmZpbmQoZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSkgPT09IDEpIHtcbiAgICBvdmVycmlkZU5hdGl2ZShBcnJheS5wcm90b3R5cGUsICdmaW5kJywgQXJyYXlQcm90b3R5cGVTaGltcy5maW5kKTtcbiAgfVxuICBpZiAoWywgMV0uZmluZEluZGV4KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0pICE9PSAwKSB7XG4gICAgb3ZlcnJpZGVOYXRpdmUoQXJyYXkucHJvdG90eXBlLCAnZmluZEluZGV4JywgQXJyYXlQcm90b3R5cGVTaGltcy5maW5kSW5kZXgpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tc3BhcnNlLWFycmF5cyAqL1xuXG4gIHZhciBpc0VudW1lcmFibGVPbiA9IEZ1bmN0aW9uLmJpbmQuY2FsbChGdW5jdGlvbi5iaW5kLCBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlKTtcbiAgdmFyIGVuc3VyZUVudW1lcmFibGUgPSBmdW5jdGlvbiBlbnN1cmVFbnVtZXJhYmxlKG9iaiwgcHJvcCkge1xuICAgIGlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzICYmIGlzRW51bWVyYWJsZU9uKG9iaiwgcHJvcCkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHsgZW51bWVyYWJsZTogZmFsc2UgfSk7XG4gICAgfVxuICB9O1xuICB2YXIgc2xpY2VBcmdzID0gZnVuY3Rpb24gc2xpY2VBcmdzKCkge1xuICAgIC8vIHBlciBodHRwczovL2dpdGh1Yi5jb20vcGV0a2FhbnRvbm92L2JsdWViaXJkL3dpa2kvT3B0aW1pemF0aW9uLWtpbGxlcnMjMzItbGVha2luZy1hcmd1bWVudHNcbiAgICAvLyBhbmQgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi80MzI3NzYyY2I4N2E4YzYzNGEyOVxuICAgIHZhciBpbml0aWFsID0gTnVtYmVyKHRoaXMpO1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBkZXNpcmVkQXJnQ291bnQgPSBsZW4gLSBpbml0aWFsO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGRlc2lyZWRBcmdDb3VudCA8IDAgPyAwIDogZGVzaXJlZEFyZ0NvdW50KTtcbiAgICBmb3IgKHZhciBpID0gaW5pdGlhbDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBhcmdzW2kgLSBpbml0aWFsXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZ3M7XG4gIH07XG4gIHZhciBhc3NpZ25UbyA9IGZ1bmN0aW9uIGFzc2lnblRvKHNvdXJjZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBhc3NpZ25Ub1NvdXJjZSh0YXJnZXQsIGtleSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcbiAgfTtcbiAgdmFyIGFzc2lnblJlZHVjZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICB2YXIgc291cmNlS2V5cyA9IGtleXMoT2JqZWN0KHNvdXJjZSkpO1xuICAgIHZhciBzeW1ib2xzO1xuICAgIGlmIChFUy5Jc0NhbGxhYmxlKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpKSB7XG4gICAgICBzeW1ib2xzID0gX2ZpbHRlcihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE9iamVjdChzb3VyY2UpKSwgaXNFbnVtZXJhYmxlT24oc291cmNlKSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVkdWNlKF9jb25jYXQoc291cmNlS2V5cywgc3ltYm9scyB8fCBbXSksIGFzc2lnblRvKHNvdXJjZSksIHRhcmdldCk7XG4gIH07XG5cbiAgdmFyIE9iamVjdFNoaW1zID0ge1xuICAgIC8vIDE5LjEuMy4xXG4gICAgYXNzaWduOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgIHZhciB0byA9IEVTLlRvT2JqZWN0KHRhcmdldCwgJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgICAgcmV0dXJuIF9yZWR1Y2UoRVMuQ2FsbChzbGljZUFyZ3MsIDEsIGFyZ3VtZW50cyksIGFzc2lnblJlZHVjZXIsIHRvKTtcbiAgICB9LFxuXG4gICAgLy8gQWRkZWQgaW4gV2ViS2l0IGluIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDM4NjVcbiAgICBpczogZnVuY3Rpb24gaXMoYSwgYikge1xuICAgICAgcmV0dXJuIEVTLlNhbWVWYWx1ZShhLCBiKTtcbiAgICB9XG4gIH07XG4gIHZhciBhc3NpZ25IYXNQZW5kaW5nRXhjZXB0aW9ucyA9IE9iamVjdC5hc3NpZ24gJiYgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zICYmIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gRmlyZWZveCAzNyBzdGlsbCBoYXMgXCJwZW5kaW5nIGV4Y2VwdGlvblwiIGxvZ2ljIGluIGl0cyBPYmplY3QuYXNzaWduIGltcGxlbWVudGF0aW9uLFxuICAgIC8vIHdoaWNoIGlzIDcyJSBzbG93ZXIgdGhhbiBvdXIgc2hpbSwgYW5kIEZpcmVmb3ggNDAncyBuYXRpdmUgaW1wbGVtZW50YXRpb24uXG4gICAgdmFyIHRocm93ZXIgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoeyAxOiAyIH0pO1xuICAgIHRyeSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRocm93ZXIsICd4eScpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0aHJvd2VyWzFdID09PSAneSc7XG4gICAgfVxuICB9KCkpO1xuICBpZiAoYXNzaWduSGFzUGVuZGluZ0V4Y2VwdGlvbnMpIHtcbiAgICBvdmVycmlkZU5hdGl2ZShPYmplY3QsICdhc3NpZ24nLCBPYmplY3RTaGltcy5hc3NpZ24pO1xuICB9XG4gIGRlZmluZVByb3BlcnRpZXMoT2JqZWN0LCBPYmplY3RTaGltcyk7XG5cbiAgaWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcbiAgICB2YXIgRVM1T2JqZWN0U2hpbXMgPSB7XG4gICAgICAvLyAxOS4xLjMuOVxuICAgICAgLy8gc2hpbSBmcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vNTU5MzU1NFxuICAgICAgc2V0UHJvdG90eXBlT2Y6IChmdW5jdGlvbiAoT2JqZWN0LCBtYWdpYykge1xuICAgICAgICB2YXIgc2V0O1xuXG4gICAgICAgIHZhciBjaGVja0FyZ3MgPSBmdW5jdGlvbiAoTywgcHJvdG8pIHtcbiAgICAgICAgICBpZiAoIUVTLlR5cGVJc09iamVjdChPKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IHNldCBwcm90b3R5cGUgb24gYSBub24tb2JqZWN0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghKHByb3RvID09PSBudWxsIHx8IEVTLlR5cGVJc09iamVjdChwcm90bykpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYW4gb25seSBzZXQgcHJvdG90eXBlIHRvIGFuIG9iamVjdCBvciBudWxsJyArIHByb3RvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHNldFByb3RvdHlwZU9mID0gZnVuY3Rpb24gKE8sIHByb3RvKSB7XG4gICAgICAgICAgY2hlY2tBcmdzKE8sIHByb3RvKTtcbiAgICAgICAgICBfY2FsbChzZXQsIE8sIHByb3RvKTtcbiAgICAgICAgICByZXR1cm4gTztcbiAgICAgICAgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIHRoaXMgd29ya3MgYWxyZWFkeSBpbiBGaXJlZm94IGFuZCBTYWZhcmlcbiAgICAgICAgICBzZXQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsIG1hZ2ljKS5zZXQ7XG4gICAgICAgICAgX2NhbGwoc2V0LCB7fSwgbnVsbCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZSAhPT0ge31bbWFnaWNdKSB7XG4gICAgICAgICAgICAvLyBJRSA8IDExIGNhbm5vdCBiZSBzaGltbWVkXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHByb2JhYmx5IENocm9tZSBvciBzb21lIG9sZCBNb2JpbGUgc3RvY2sgYnJvd3NlclxuICAgICAgICAgIHNldCA9IGZ1bmN0aW9uIChwcm90bykge1xuICAgICAgICAgICAgdGhpc1ttYWdpY10gPSBwcm90bztcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8vIHBsZWFzZSBub3RlIHRoYXQgdGhpcyB3aWxsICoqbm90Kiogd29ya1xuICAgICAgICAgIC8vIGluIHRob3NlIGJyb3dzZXJzIHRoYXQgZG8gbm90IGluaGVyaXRcbiAgICAgICAgICAvLyBfX3Byb3RvX18gYnkgbWlzdGFrZSBmcm9tIE9iamVjdC5wcm90b3R5cGVcbiAgICAgICAgICAvLyBpbiB0aGVzZSBjYXNlcyB3ZSBzaG91bGQgcHJvYmFibHkgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgICAvLyBvciBhdCBsZWFzdCBiZSBpbmZvcm1lZCBhYm91dCB0aGUgaXNzdWVcbiAgICAgICAgICBzZXRQcm90b3R5cGVPZi5wb2x5ZmlsbCA9IHNldFByb3RvdHlwZU9mKFxuICAgICAgICAgICAgc2V0UHJvdG90eXBlT2Yoe30sIG51bGwpLFxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZVxuICAgICAgICAgICkgaW5zdGFuY2VvZiBPYmplY3Q7XG4gICAgICAgICAgLy8gc2V0UHJvdG90eXBlT2YucG9seWZpbGwgPT09IHRydWUgbWVhbnMgaXQgd29ya3MgYXMgbWVhbnRcbiAgICAgICAgICAvLyBzZXRQcm90b3R5cGVPZi5wb2x5ZmlsbCA9PT0gZmFsc2UgbWVhbnMgaXQncyBub3QgMTAwJSByZWxpYWJsZVxuICAgICAgICAgIC8vIHNldFByb3RvdHlwZU9mLnBvbHlmaWxsID09PSB1bmRlZmluZWRcbiAgICAgICAgICAvLyBvclxuICAgICAgICAgIC8vIHNldFByb3RvdHlwZU9mLnBvbHlmaWxsID09ICBudWxsIG1lYW5zIGl0J3Mgbm90IGEgcG9seWZpbGxcbiAgICAgICAgICAvLyB3aGljaCBtZWFucyBpdCB3b3JrcyBhcyBleHBlY3RlZFxuICAgICAgICAgIC8vIHdlIGNhbiBldmVuIGRlbGV0ZSBPYmplY3QucHJvdG90eXBlLl9fcHJvdG9fXztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0UHJvdG90eXBlT2Y7XG4gICAgICB9KE9iamVjdCwgJ19fcHJvdG9fXycpKVxuICAgIH07XG5cbiAgICBkZWZpbmVQcm9wZXJ0aWVzKE9iamVjdCwgRVM1T2JqZWN0U2hpbXMpO1xuICB9XG5cbiAgLy8gV29ya2Fyb3VuZCBidWcgaW4gT3BlcmEgMTIgd2hlcmUgc2V0UHJvdG90eXBlT2YoeCwgbnVsbCkgZG9lc24ndCB3b3JrLFxuICAvLyBidXQgT2JqZWN0LmNyZWF0ZShudWxsKSBkb2VzLlxuICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJlxuICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5zZXRQcm90b3R5cGVPZih7fSwgbnVsbCkpICE9PSBudWxsICYmXG4gICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmNyZWF0ZShudWxsKSkgPT09IG51bGwpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIEZBS0VOVUxMID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHZhciBncG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gICAgICB2YXIgc3BvID0gT2JqZWN0LnNldFByb3RvdHlwZU9mO1xuICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGdwbyhvKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gRkFLRU5VTEwgPyBudWxsIDogcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZiA9IGZ1bmN0aW9uIChvLCBwKSB7XG4gICAgICAgIHZhciBwcm90byA9IHAgPT09IG51bGwgPyBGQUtFTlVMTCA6IHA7XG4gICAgICAgIHJldHVybiBzcG8obywgcHJvdG8pO1xuICAgICAgfTtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZi5wb2x5ZmlsbCA9IGZhbHNlO1xuICAgIH0oKSk7XG4gIH1cblxuICB2YXIgb2JqZWN0S2V5c0FjY2VwdHNQcmltaXRpdmVzID0gIXRocm93c0Vycm9yKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdC5rZXlzKCdmb28nKTsgfSk7XG4gIGlmICghb2JqZWN0S2V5c0FjY2VwdHNQcmltaXRpdmVzKSB7XG4gICAgdmFyIG9yaWdpbmFsT2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzO1xuICAgIG92ZXJyaWRlTmF0aXZlKE9iamVjdCwgJ2tleXMnLCBmdW5jdGlvbiBrZXlzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gb3JpZ2luYWxPYmplY3RLZXlzKEVTLlRvT2JqZWN0KHZhbHVlKSk7XG4gICAgfSk7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzO1xuICB9XG4gIHZhciBvYmplY3RLZXlzUmVqZWN0c1JlZ2V4ID0gdGhyb3dzRXJyb3IoZnVuY3Rpb24gKCkgeyByZXR1cm4gT2JqZWN0LmtleXMoL2EvZyk7IH0pO1xuICBpZiAob2JqZWN0S2V5c1JlamVjdHNSZWdleCkge1xuICAgIHZhciByZWdleFJlamVjdGluZ09iamVjdEtleXMgPSBPYmplY3Qua2V5cztcbiAgICBvdmVycmlkZU5hdGl2ZShPYmplY3QsICdrZXlzJywgZnVuY3Rpb24ga2V5cyh2YWx1ZSkge1xuICAgICAgaWYgKFR5cGUucmVnZXgodmFsdWUpKSB7XG4gICAgICAgIHZhciByZWdleEtleXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgayBpbiB2YWx1ZSkge1xuICAgICAgICAgIGlmIChfaGFzT3duUHJvcGVydHkodmFsdWUsIGspKSB7XG4gICAgICAgICAgICBfcHVzaChyZWdleEtleXMsIGspO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVnZXhLZXlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlZ2V4UmVqZWN0aW5nT2JqZWN0S2V5cyh2YWx1ZSk7XG4gICAgfSk7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKSB7XG4gICAgdmFyIG9iamVjdEdPUE5BY2NlcHRzUHJpbWl0aXZlcyA9ICF0aHJvd3NFcnJvcihmdW5jdGlvbiAoKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcygnZm9vJyk7IH0pO1xuICAgIGlmICghb2JqZWN0R09QTkFjY2VwdHNQcmltaXRpdmVzKSB7XG4gICAgICB2YXIgY2FjaGVkV2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcbiAgICAgIHZhciBvcmlnaW5hbE9iamVjdEdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgICAgIG92ZXJyaWRlTmF0aXZlKE9iamVjdCwgJ2dldE93blByb3BlcnR5TmFtZXMnLCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKSB7XG4gICAgICAgIHZhciB2YWwgPSBFUy5Ub09iamVjdCh2YWx1ZSk7XG4gICAgICAgIGlmIChfdG9TdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgV2luZG93XScpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsT2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcyh2YWwpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIElFIGJ1ZyB3aGVyZSBsYXlvdXQgZW5naW5lIGNhbGxzIHVzZXJsYW5kIGdPUE4gZm9yIGNyb3NzLWRvbWFpbiBgd2luZG93YCBvYmplY3RzXG4gICAgICAgICAgICByZXR1cm4gX2NvbmNhdChbXSwgY2FjaGVkV2luZG93TmFtZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZ2luYWxPYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IpIHtcbiAgICB2YXIgb2JqZWN0R09QREFjY2VwdHNQcmltaXRpdmVzID0gIXRocm93c0Vycm9yKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoJ2ZvbycsICdiYXInKTsgfSk7XG4gICAgaWYgKCFvYmplY3RHT1BEQWNjZXB0c1ByaW1pdGl2ZXMpIHtcbiAgICAgIHZhciBvcmlnaW5hbE9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgICBvdmVycmlkZU5hdGl2ZShPYmplY3QsICdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbE9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcihFUy5Ub09iamVjdCh2YWx1ZSksIHByb3BlcnR5KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoT2JqZWN0LnNlYWwpIHtcbiAgICB2YXIgb2JqZWN0U2VhbEFjY2VwdHNQcmltaXRpdmVzID0gIXRocm93c0Vycm9yKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdC5zZWFsKCdmb28nKTsgfSk7XG4gICAgaWYgKCFvYmplY3RTZWFsQWNjZXB0c1ByaW1pdGl2ZXMpIHtcbiAgICAgIHZhciBvcmlnaW5hbE9iamVjdFNlYWwgPSBPYmplY3Quc2VhbDtcbiAgICAgIG92ZXJyaWRlTmF0aXZlKE9iamVjdCwgJ3NlYWwnLCBmdW5jdGlvbiBzZWFsKHZhbHVlKSB7XG4gICAgICAgIGlmICghRVMuVHlwZUlzT2JqZWN0KHZhbHVlKSkgeyByZXR1cm4gdmFsdWU7IH1cbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsT2JqZWN0U2VhbCh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKE9iamVjdC5pc1NlYWxlZCkge1xuICAgIHZhciBvYmplY3RJc1NlYWxlZEFjY2VwdHNQcmltaXRpdmVzID0gIXRocm93c0Vycm9yKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdC5pc1NlYWxlZCgnZm9vJyk7IH0pO1xuICAgIGlmICghb2JqZWN0SXNTZWFsZWRBY2NlcHRzUHJpbWl0aXZlcykge1xuICAgICAgdmFyIG9yaWdpbmFsT2JqZWN0SXNTZWFsZWQgPSBPYmplY3QuaXNTZWFsZWQ7XG4gICAgICBvdmVycmlkZU5hdGl2ZShPYmplY3QsICdpc1NlYWxlZCcsIGZ1bmN0aW9uIGlzU2VhbGVkKHZhbHVlKSB7XG4gICAgICAgIGlmICghRVMuVHlwZUlzT2JqZWN0KHZhbHVlKSkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgICByZXR1cm4gb3JpZ2luYWxPYmplY3RJc1NlYWxlZCh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICB2YXIgb2JqZWN0RnJlZXplQWNjZXB0c1ByaW1pdGl2ZXMgPSAhdGhyb3dzRXJyb3IoZnVuY3Rpb24gKCkgeyByZXR1cm4gT2JqZWN0LmZyZWV6ZSgnZm9vJyk7IH0pO1xuICAgIGlmICghb2JqZWN0RnJlZXplQWNjZXB0c1ByaW1pdGl2ZXMpIHtcbiAgICAgIHZhciBvcmlnaW5hbE9iamVjdEZyZWV6ZSA9IE9iamVjdC5mcmVlemU7XG4gICAgICBvdmVycmlkZU5hdGl2ZShPYmplY3QsICdmcmVlemUnLCBmdW5jdGlvbiBmcmVlemUodmFsdWUpIHtcbiAgICAgICAgaWYgKCFFUy5UeXBlSXNPYmplY3QodmFsdWUpKSB7IHJldHVybiB2YWx1ZTsgfVxuICAgICAgICByZXR1cm4gb3JpZ2luYWxPYmplY3RGcmVlemUodmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChPYmplY3QuaXNGcm96ZW4pIHtcbiAgICB2YXIgb2JqZWN0SXNGcm96ZW5BY2NlcHRzUHJpbWl0aXZlcyA9ICF0aHJvd3NFcnJvcihmdW5jdGlvbiAoKSB7IHJldHVybiBPYmplY3QuaXNGcm96ZW4oJ2ZvbycpOyB9KTtcbiAgICBpZiAoIW9iamVjdElzRnJvemVuQWNjZXB0c1ByaW1pdGl2ZXMpIHtcbiAgICAgIHZhciBvcmlnaW5hbE9iamVjdElzRnJvemVuID0gT2JqZWN0LmlzRnJvemVuO1xuICAgICAgb3ZlcnJpZGVOYXRpdmUoT2JqZWN0LCAnaXNGcm96ZW4nLCBmdW5jdGlvbiBpc0Zyb3plbih2YWx1ZSkge1xuICAgICAgICBpZiAoIUVTLlR5cGVJc09iamVjdCh2YWx1ZSkpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsT2JqZWN0SXNGcm96ZW4odmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChPYmplY3QucHJldmVudEV4dGVuc2lvbnMpIHtcbiAgICB2YXIgb2JqZWN0UHJldmVudEV4dGVuc2lvbnNBY2NlcHRzUHJpbWl0aXZlcyA9ICF0aHJvd3NFcnJvcihmdW5jdGlvbiAoKSB7IHJldHVybiBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoJ2ZvbycpOyB9KTtcbiAgICBpZiAoIW9iamVjdFByZXZlbnRFeHRlbnNpb25zQWNjZXB0c1ByaW1pdGl2ZXMpIHtcbiAgICAgIHZhciBvcmlnaW5hbE9iamVjdFByZXZlbnRFeHRlbnNpb25zID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zO1xuICAgICAgb3ZlcnJpZGVOYXRpdmUoT2JqZWN0LCAncHJldmVudEV4dGVuc2lvbnMnLCBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyh2YWx1ZSkge1xuICAgICAgICBpZiAoIUVTLlR5cGVJc09iamVjdCh2YWx1ZSkpIHsgcmV0dXJuIHZhbHVlOyB9XG4gICAgICAgIHJldHVybiBvcmlnaW5hbE9iamVjdFByZXZlbnRFeHRlbnNpb25zKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoT2JqZWN0LmlzRXh0ZW5zaWJsZSkge1xuICAgIHZhciBvYmplY3RJc0V4dGVuc2libGVBY2NlcHRzUHJpbWl0aXZlcyA9ICF0aHJvd3NFcnJvcihmdW5jdGlvbiAoKSB7IHJldHVybiBPYmplY3QuaXNFeHRlbnNpYmxlKCdmb28nKTsgfSk7XG4gICAgaWYgKCFvYmplY3RJc0V4dGVuc2libGVBY2NlcHRzUHJpbWl0aXZlcykge1xuICAgICAgdmFyIG9yaWdpbmFsT2JqZWN0SXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcbiAgICAgIG92ZXJyaWRlTmF0aXZlKE9iamVjdCwgJ2lzRXh0ZW5zaWJsZScsIGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIUVTLlR5cGVJc09iamVjdCh2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIHJldHVybiBvcmlnaW5hbE9iamVjdElzRXh0ZW5zaWJsZSh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZikge1xuICAgIHZhciBvYmplY3RHZXRQcm90b0FjY2VwdHNQcmltaXRpdmVzID0gIXRocm93c0Vycm9yKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZignZm9vJyk7IH0pO1xuICAgIGlmICghb2JqZWN0R2V0UHJvdG9BY2NlcHRzUHJpbWl0aXZlcykge1xuICAgICAgdmFyIG9yaWdpbmFsR2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gICAgICBvdmVycmlkZU5hdGl2ZShPYmplY3QsICdnZXRQcm90b3R5cGVPZicsIGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbEdldFByb3RvKEVTLlRvT2JqZWN0KHZhbHVlKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICB2YXIgaGFzRmxhZ3MgPSBzdXBwb3J0c0Rlc2NyaXB0b3JzICYmIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJlZ0V4cC5wcm90b3R5cGUsICdmbGFncycpO1xuICAgIHJldHVybiBkZXNjICYmIEVTLklzQ2FsbGFibGUoZGVzYy5nZXQpO1xuICB9KCkpO1xuICBpZiAoc3VwcG9ydHNEZXNjcmlwdG9ycyAmJiAhaGFzRmxhZ3MpIHtcbiAgICB2YXIgcmVnRXhwRmxhZ3NHZXR0ZXIgPSBmdW5jdGlvbiBmbGFncygpIHtcbiAgICAgIGlmICghRVMuVHlwZUlzT2JqZWN0KHRoaXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01ldGhvZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlIHR5cGU6IG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgaWYgKHRoaXMuZ2xvYmFsKSB7XG4gICAgICAgIHJlc3VsdCArPSAnZyc7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pZ25vcmVDYXNlKSB7XG4gICAgICAgIHJlc3VsdCArPSAnaSc7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tdWx0aWxpbmUpIHtcbiAgICAgICAgcmVzdWx0ICs9ICdtJztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnVuaWNvZGUpIHtcbiAgICAgICAgcmVzdWx0ICs9ICd1JztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0aWNreSkge1xuICAgICAgICByZXN1bHQgKz0gJ3knO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgVmFsdWUuZ2V0dGVyKFJlZ0V4cC5wcm90b3R5cGUsICdmbGFncycsIHJlZ0V4cEZsYWdzR2V0dGVyKTtcbiAgfVxuXG4gIHZhciByZWdFeHBTdXBwb3J0c0ZsYWdzV2l0aFJlZ2V4ID0gc3VwcG9ydHNEZXNjcmlwdG9ycyAmJiB2YWx1ZU9yRmFsc2VJZlRocm93cyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFN0cmluZyhuZXcgUmVnRXhwKC9hL2csICdpJykpID09PSAnL2EvaSc7XG4gIH0pO1xuICB2YXIgcmVnRXhwTmVlZHNUb1N1cHBvcnRTeW1ib2xNYXRjaCA9IGhhc1N5bWJvbHMgJiYgc3VwcG9ydHNEZXNjcmlwdG9ycyAmJiAoZnVuY3Rpb24gKCkge1xuICAgIC8vIEVkZ2UgMC4xMiBzdXBwb3J0cyBmbGFncyBmdWxseSwgYnV0IGRvZXMgbm90IHN1cHBvcnQgU3ltYm9sLm1hdGNoXG4gICAgdmFyIHJlZ2V4ID0gLy4vO1xuICAgIHJlZ2V4W1N5bWJvbC5tYXRjaF0gPSBmYWxzZTtcbiAgICByZXR1cm4gUmVnRXhwKHJlZ2V4KSA9PT0gcmVnZXg7XG4gIH0oKSk7XG5cbiAgdmFyIHJlZ2V4VG9TdHJpbmdJc0dlbmVyaWMgPSB2YWx1ZU9yRmFsc2VJZlRocm93cyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh7IHNvdXJjZTogJ2FiYycgfSkgPT09ICcvYWJjLyc7XG4gIH0pO1xuICB2YXIgcmVnZXhUb1N0cmluZ1N1cHBvcnRzR2VuZXJpY0ZsYWdzID0gcmVnZXhUb1N0cmluZ0lzR2VuZXJpYyAmJiB2YWx1ZU9yRmFsc2VJZlRocm93cyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh7IHNvdXJjZTogJ2EnLCBmbGFnczogJ2InIH0pID09PSAnL2EvYic7XG4gIH0pO1xuICBpZiAoIXJlZ2V4VG9TdHJpbmdJc0dlbmVyaWMgfHwgIXJlZ2V4VG9TdHJpbmdTdXBwb3J0c0dlbmVyaWNGbGFncykge1xuICAgIHZhciBvcmlnUmVnRXhwVG9TdHJpbmcgPSBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nO1xuICAgIGRlZmluZVByb3BlcnR5KFJlZ0V4cC5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIFIgPSBFUy5SZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpO1xuICAgICAgaWYgKFR5cGUucmVnZXgoUikpIHtcbiAgICAgICAgcmV0dXJuIF9jYWxsKG9yaWdSZWdFeHBUb1N0cmluZywgUik7XG4gICAgICB9XG4gICAgICB2YXIgcGF0dGVybiA9ICRTdHJpbmcoUi5zb3VyY2UpO1xuICAgICAgdmFyIGZsYWdzID0gJFN0cmluZyhSLmZsYWdzKTtcbiAgICAgIHJldHVybiAnLycgKyBwYXR0ZXJuICsgJy8nICsgZmxhZ3M7XG4gICAgfSwgdHJ1ZSk7XG4gICAgVmFsdWUucHJlc2VydmVUb1N0cmluZyhSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLCBvcmlnUmVnRXhwVG9TdHJpbmcpO1xuICB9XG5cbiAgaWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMgJiYgKCFyZWdFeHBTdXBwb3J0c0ZsYWdzV2l0aFJlZ2V4IHx8IHJlZ0V4cE5lZWRzVG9TdXBwb3J0U3ltYm9sTWF0Y2gpKSB7XG4gICAgdmFyIGZsYWdzR2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihSZWdFeHAucHJvdG90eXBlLCAnZmxhZ3MnKS5nZXQ7XG4gICAgdmFyIHNvdXJjZURlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJlZ0V4cC5wcm90b3R5cGUsICdzb3VyY2UnKSB8fCB7fTtcbiAgICB2YXIgbGVnYWN5U291cmNlR2V0dGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gcHJpb3IgdG8gaXQgYmVpbmcgYSBnZXR0ZXIsIGl0J3Mgb3duICsgbm9uY29uZmlndXJhYmxlXG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2U7XG4gICAgfTtcbiAgICB2YXIgc291cmNlR2V0dGVyID0gRVMuSXNDYWxsYWJsZShzb3VyY2VEZXNjLmdldCkgPyBzb3VyY2VEZXNjLmdldCA6IGxlZ2FjeVNvdXJjZUdldHRlcjtcblxuICAgIHZhciBPcmlnUmVnRXhwID0gUmVnRXhwO1xuICAgIHZhciBSZWdFeHBTaGltID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBSZWdFeHAocGF0dGVybiwgZmxhZ3MpIHtcbiAgICAgICAgdmFyIHBhdHRlcm5Jc1JlZ0V4cCA9IEVTLklzUmVnRXhwKHBhdHRlcm4pO1xuICAgICAgICB2YXIgY2FsbGVkV2l0aE5ldyA9IHRoaXMgaW5zdGFuY2VvZiBSZWdFeHA7XG4gICAgICAgIGlmICghY2FsbGVkV2l0aE5ldyAmJiBwYXR0ZXJuSXNSZWdFeHAgJiYgdHlwZW9mIGZsYWdzID09PSAndW5kZWZpbmVkJyAmJiBwYXR0ZXJuLmNvbnN0cnVjdG9yID09PSBSZWdFeHApIHtcbiAgICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBQID0gcGF0dGVybjtcbiAgICAgICAgdmFyIEYgPSBmbGFncztcbiAgICAgICAgaWYgKFR5cGUucmVnZXgocGF0dGVybikpIHtcbiAgICAgICAgICBQID0gRVMuQ2FsbChzb3VyY2VHZXR0ZXIsIHBhdHRlcm4pO1xuICAgICAgICAgIEYgPSB0eXBlb2YgZmxhZ3MgPT09ICd1bmRlZmluZWQnID8gRVMuQ2FsbChmbGFnc0dldHRlciwgcGF0dGVybikgOiBmbGFncztcbiAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChQLCBGKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXR0ZXJuSXNSZWdFeHApIHtcbiAgICAgICAgICBQID0gcGF0dGVybi5zb3VyY2U7XG4gICAgICAgICAgRiA9IHR5cGVvZiBmbGFncyA9PT0gJ3VuZGVmaW5lZCcgPyBwYXR0ZXJuLmZsYWdzIDogZmxhZ3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBPcmlnUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgICAgIH07XG4gICAgfSgpKTtcbiAgICB3cmFwQ29uc3RydWN0b3IoT3JpZ1JlZ0V4cCwgUmVnRXhwU2hpbSwge1xuICAgICAgJGlucHV0OiB0cnVlIC8vIENocm9tZSA8IHYzOSAmIE9wZXJhIDwgMjYgaGF2ZSBhIG5vbnN0YW5kYXJkIFwiJGlucHV0XCIgcHJvcGVydHlcbiAgICB9KTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiwgbm8tZ2xvYmFsLWFzc2lnbiAqL1xuICAgIFJlZ0V4cCA9IFJlZ0V4cFNoaW07XG4gICAgVmFsdWUucmVkZWZpbmUoZ2xvYmFscywgJ1JlZ0V4cCcsIFJlZ0V4cFNoaW0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5kZWYsIG5vLWdsb2JhbC1hc3NpZ24gKi9cbiAgfVxuXG4gIGlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG4gICAgdmFyIHJlZ2V4R2xvYmFscyA9IHtcbiAgICAgIGlucHV0OiAnJF8nLFxuICAgICAgbGFzdE1hdGNoOiAnJCYnLFxuICAgICAgbGFzdFBhcmVuOiAnJCsnLFxuICAgICAgbGVmdENvbnRleHQ6ICckYCcsXG4gICAgICByaWdodENvbnRleHQ6ICckXFwnJ1xuICAgIH07XG4gICAgX2ZvckVhY2goa2V5cyhyZWdleEdsb2JhbHMpLCBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgaWYgKHByb3AgaW4gUmVnRXhwICYmICEocmVnZXhHbG9iYWxzW3Byb3BdIGluIFJlZ0V4cCkpIHtcbiAgICAgICAgVmFsdWUuZ2V0dGVyKFJlZ0V4cCwgcmVnZXhHbG9iYWxzW3Byb3BdLCBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIFJlZ0V4cFtwcm9wXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYWRkRGVmYXVsdFNwZWNpZXMoUmVnRXhwKTtcblxuICB2YXIgaW52ZXJzZUVwc2lsb24gPSAxIC8gTnVtYmVyLkVQU0lMT047XG4gIHZhciByb3VuZFRpZXNUb0V2ZW4gPSBmdW5jdGlvbiByb3VuZFRpZXNUb0V2ZW4obikge1xuICAgIC8vIEV2ZW4gdGhvdWdoIHRoaXMgcmVkdWNlcyBkb3duIHRvIGByZXR1cm4gbmAsIGl0IHRha2VzIGFkdmFudGFnZSBvZiBidWlsdC1pbiByb3VuZGluZy5cbiAgICByZXR1cm4gKG4gKyBpbnZlcnNlRXBzaWxvbikgLSBpbnZlcnNlRXBzaWxvbjtcbiAgfTtcbiAgdmFyIEJJTkFSWV8zMl9FUFNJTE9OID0gTWF0aC5wb3coMiwgLTIzKTtcbiAgdmFyIEJJTkFSWV8zMl9NQVhfVkFMVUUgPSBNYXRoLnBvdygyLCAxMjcpICogKDIgLSBCSU5BUllfMzJfRVBTSUxPTik7XG4gIHZhciBCSU5BUllfMzJfTUlOX1ZBTFVFID0gTWF0aC5wb3coMiwgLTEyNik7XG4gIHZhciBFID0gTWF0aC5FO1xuICB2YXIgTE9HMkUgPSBNYXRoLkxPRzJFO1xuICB2YXIgTE9HMTBFID0gTWF0aC5MT0cxMEU7XG4gIHZhciBudW1iZXJDTFogPSBOdW1iZXIucHJvdG90eXBlLmNsejtcbiAgZGVsZXRlIE51bWJlci5wcm90b3R5cGUuY2x6OyAvLyBTYWZhcmkgOCBoYXMgTnVtYmVyI2NselxuXG4gIHZhciBNYXRoU2hpbXMgPSB7XG4gICAgYWNvc2g6IGZ1bmN0aW9uIGFjb3NoKHZhbHVlKSB7XG4gICAgICB2YXIgeCA9IE51bWJlcih2YWx1ZSk7XG4gICAgICBpZiAobnVtYmVySXNOYU4oeCkgfHwgdmFsdWUgPCAxKSB7IHJldHVybiBOYU47IH1cbiAgICAgIGlmICh4ID09PSAxKSB7IHJldHVybiAwOyB9XG4gICAgICBpZiAoeCA9PT0gSW5maW5pdHkpIHsgcmV0dXJuIHg7IH1cblxuICAgICAgdmFyIHhJbnZTcXVhcmVkID0gMSAvICh4ICogeCk7XG4gICAgICBpZiAoeCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIF9sb2cxcCh4IC0gMSArIChfc3FydCgxIC0geEludlNxdWFyZWQpICogeCkpO1xuICAgICAgfVxuICAgICAgdmFyIGhhbGZYID0geCAvIDI7XG4gICAgICByZXR1cm4gX2xvZzFwKGhhbGZYICsgKF9zcXJ0KDEgLSB4SW52U3F1YXJlZCkgKiBoYWxmWCkgLSAxKSArICgxIC8gTE9HMkUpO1xuICAgIH0sXG5cbiAgICBhc2luaDogZnVuY3Rpb24gYXNpbmgodmFsdWUpIHtcbiAgICAgIHZhciB4ID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgIGlmICh4ID09PSAwIHx8ICFnbG9iYWxJc0Zpbml0ZSh4KSkge1xuICAgICAgICByZXR1cm4geDtcbiAgICAgIH1cblxuICAgICAgdmFyIGEgPSBfYWJzKHgpO1xuICAgICAgdmFyIGFTcXVhcmVkID0gYSAqIGE7XG4gICAgICB2YXIgcyA9IF9zaWduKHgpO1xuICAgICAgaWYgKGEgPCAxKSB7XG4gICAgICAgIHJldHVybiBzICogX2xvZzFwKGEgKyAoYVNxdWFyZWQgLyAoX3NxcnQoYVNxdWFyZWQgKyAxKSArIDEpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcyAqIChfbG9nMXAoKGEgLyAyKSArIChfc3FydCgxICsgKDEgLyBhU3F1YXJlZCkpICogYSAvIDIpIC0gMSkgKyAoMSAvIExPRzJFKSk7XG4gICAgfSxcblxuICAgIGF0YW5oOiBmdW5jdGlvbiBhdGFuaCh2YWx1ZSkge1xuICAgICAgdmFyIHggPSBOdW1iZXIodmFsdWUpO1xuXG4gICAgICBpZiAoeCA9PT0gMCkgeyByZXR1cm4geDsgfVxuICAgICAgaWYgKHggPT09IC0xKSB7IHJldHVybiAtSW5maW5pdHk7IH1cbiAgICAgIGlmICh4ID09PSAxKSB7IHJldHVybiBJbmZpbml0eTsgfVxuICAgICAgaWYgKG51bWJlcklzTmFOKHgpIHx8IHggPCAtMSB8fCB4ID4gMSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgfVxuXG4gICAgICB2YXIgYSA9IF9hYnMoeCk7XG4gICAgICByZXR1cm4gX3NpZ24oeCkgKiBfbG9nMXAoMiAqIGEgLyAoMSAtIGEpKSAvIDI7XG4gICAgfSxcblxuICAgIGNicnQ6IGZ1bmN0aW9uIGNicnQodmFsdWUpIHtcbiAgICAgIHZhciB4ID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgIGlmICh4ID09PSAwKSB7IHJldHVybiB4OyB9XG4gICAgICB2YXIgbmVnYXRlID0geCA8IDA7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgaWYgKG5lZ2F0ZSkgeyB4ID0gLXg7IH1cbiAgICAgIGlmICh4ID09PSBJbmZpbml0eSkge1xuICAgICAgICByZXN1bHQgPSBJbmZpbml0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IF9leHAoX2xvZyh4KSAvIDMpO1xuICAgICAgICAvLyBmcm9tIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3ViZV9yb290I051bWVyaWNhbF9tZXRob2RzXG4gICAgICAgIHJlc3VsdCA9ICgoeCAvIChyZXN1bHQgKiByZXN1bHQpKSArICgyICogcmVzdWx0KSkgLyAzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5lZ2F0ZSA/IC1yZXN1bHQgOiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGNsejMyOiBmdW5jdGlvbiBjbHozMih2YWx1ZSkge1xuICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy5lY21hc2NyaXB0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjQ2NVxuICAgICAgdmFyIHggPSBOdW1iZXIodmFsdWUpO1xuICAgICAgdmFyIG51bWJlciA9IEVTLlRvVWludDMyKHgpO1xuICAgICAgaWYgKG51bWJlciA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMzI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVtYmVyQ0xaID8gRVMuQ2FsbChudW1iZXJDTFosIG51bWJlcikgOiAzMSAtIF9mbG9vcihfbG9nKG51bWJlciArIDAuNSkgKiBMT0cyRSk7XG4gICAgfSxcblxuICAgIGNvc2g6IGZ1bmN0aW9uIGNvc2godmFsdWUpIHtcbiAgICAgIHZhciB4ID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgIGlmICh4ID09PSAwKSB7IHJldHVybiAxOyB9IC8vICswIG9yIC0wXG4gICAgICBpZiAobnVtYmVySXNOYU4oeCkpIHsgcmV0dXJuIE5hTjsgfVxuICAgICAgaWYgKCFnbG9iYWxJc0Zpbml0ZSh4KSkgeyByZXR1cm4gSW5maW5pdHk7IH1cblxuICAgICAgdmFyIHQgPSBfZXhwKF9hYnMoeCkgLSAxKTtcbiAgICAgIHJldHVybiAodCArICgxIC8gKHQgKiBFICogRSkpKSAqIChFIC8gMik7XG4gICAgfSxcblxuICAgIGV4cG0xOiBmdW5jdGlvbiBleHBtMSh2YWx1ZSkge1xuICAgICAgdmFyIHggPSBOdW1iZXIodmFsdWUpO1xuICAgICAgaWYgKHggPT09IC1JbmZpbml0eSkgeyByZXR1cm4gLTE7IH1cbiAgICAgIGlmICghZ2xvYmFsSXNGaW5pdGUoeCkgfHwgeCA9PT0gMCkgeyByZXR1cm4geDsgfVxuICAgICAgaWYgKF9hYnMoeCkgPiAwLjUpIHtcbiAgICAgICAgcmV0dXJuIF9leHAoeCkgLSAxO1xuICAgICAgfVxuICAgICAgLy8gQSBtb3JlIHByZWNpc2UgYXBwcm94aW1hdGlvbiB1c2luZyBUYXlsb3Igc2VyaWVzIGV4cGFuc2lvblxuICAgICAgLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL2VzNi1zaGltL2lzc3Vlcy8zMTQjaXNzdWVjb21tZW50LTcwMjkzOTg2XG4gICAgICB2YXIgdCA9IHg7XG4gICAgICB2YXIgc3VtID0gMDtcbiAgICAgIHZhciBuID0gMTtcbiAgICAgIHdoaWxlIChzdW0gKyB0ICE9PSBzdW0pIHtcbiAgICAgICAgc3VtICs9IHQ7XG4gICAgICAgIG4gKz0gMTtcbiAgICAgICAgdCAqPSB4IC8gbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdW07XG4gICAgfSxcblxuICAgIGh5cG90OiBmdW5jdGlvbiBoeXBvdCh4LCB5KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICAgIHZhciBsYXJnZXN0ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IF9hYnMoTnVtYmVyKGFyZ3VtZW50c1tpXSkpO1xuICAgICAgICBpZiAobGFyZ2VzdCA8IHZhbHVlKSB7XG4gICAgICAgICAgcmVzdWx0ICo9IChsYXJnZXN0IC8gdmFsdWUpICogKGxhcmdlc3QgLyB2YWx1ZSk7XG4gICAgICAgICAgcmVzdWx0ICs9IDE7XG4gICAgICAgICAgbGFyZ2VzdCA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCArPSB2YWx1ZSA+IDAgPyAodmFsdWUgLyBsYXJnZXN0KSAqICh2YWx1ZSAvIGxhcmdlc3QpIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBsYXJnZXN0ID09PSBJbmZpbml0eSA/IEluZmluaXR5IDogbGFyZ2VzdCAqIF9zcXJ0KHJlc3VsdCk7XG4gICAgfSxcblxuICAgIGxvZzI6IGZ1bmN0aW9uIGxvZzIodmFsdWUpIHtcbiAgICAgIHJldHVybiBfbG9nKHZhbHVlKSAqIExPRzJFO1xuICAgIH0sXG5cbiAgICBsb2cxMDogZnVuY3Rpb24gbG9nMTAodmFsdWUpIHtcbiAgICAgIHJldHVybiBfbG9nKHZhbHVlKSAqIExPRzEwRTtcbiAgICB9LFxuXG4gICAgbG9nMXA6IF9sb2cxcCxcblxuICAgIHNpZ246IF9zaWduLFxuXG4gICAgc2luaDogZnVuY3Rpb24gc2luaCh2YWx1ZSkge1xuICAgICAgdmFyIHggPSBOdW1iZXIodmFsdWUpO1xuICAgICAgaWYgKCFnbG9iYWxJc0Zpbml0ZSh4KSB8fCB4ID09PSAwKSB7IHJldHVybiB4OyB9XG5cbiAgICAgIHZhciBhID0gX2Ficyh4KTtcbiAgICAgIGlmIChhIDwgMSkge1xuICAgICAgICB2YXIgdSA9IE1hdGguZXhwbTEoYSk7XG4gICAgICAgIHJldHVybiBfc2lnbih4KSAqIHUgKiAoMSArICgxIC8gKHUgKyAxKSkpIC8gMjtcbiAgICAgIH1cbiAgICAgIHZhciB0ID0gX2V4cChhIC0gMSk7XG4gICAgICByZXR1cm4gX3NpZ24oeCkgKiAodCAtICgxIC8gKHQgKiBFICogRSkpKSAqIChFIC8gMik7XG4gICAgfSxcblxuICAgIHRhbmg6IGZ1bmN0aW9uIHRhbmgodmFsdWUpIHtcbiAgICAgIHZhciB4ID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgIGlmIChudW1iZXJJc05hTih4KSB8fCB4ID09PSAwKSB7IHJldHVybiB4OyB9XG4gICAgICAvLyBjYW4gZXhpdCBlYXJseSBhdCArLTIwIGFzIEpTIGxvc2VzIHByZWNpc2lvbiBmb3IgdHJ1ZSB2YWx1ZSBhdCB0aGlzIGludGVnZXJcbiAgICAgIGlmICh4ID49IDIwKSB7IHJldHVybiAxOyB9XG4gICAgICBpZiAoeCA8PSAtMjApIHsgcmV0dXJuIC0xOyB9XG5cbiAgICAgIHJldHVybiAoTWF0aC5leHBtMSh4KSAtIE1hdGguZXhwbTEoLXgpKSAvIChfZXhwKHgpICsgX2V4cCgteCkpO1xuICAgIH0sXG5cbiAgICB0cnVuYzogZnVuY3Rpb24gdHJ1bmModmFsdWUpIHtcbiAgICAgIHZhciB4ID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgIHJldHVybiB4IDwgMCA/IC1fZmxvb3IoLXgpIDogX2Zsb29yKHgpO1xuICAgIH0sXG5cbiAgICBpbXVsOiBmdW5jdGlvbiBpbXVsKHgsIHkpIHtcbiAgICAgIC8vIHRha2VuIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9pbXVsXG4gICAgICB2YXIgYSA9IEVTLlRvVWludDMyKHgpO1xuICAgICAgdmFyIGIgPSBFUy5Ub1VpbnQzMih5KTtcbiAgICAgIHZhciBhaCA9IChhID4+PiAxNikgJiAweGZmZmY7XG4gICAgICB2YXIgYWwgPSBhICYgMHhmZmZmO1xuICAgICAgdmFyIGJoID0gKGIgPj4+IDE2KSAmIDB4ZmZmZjtcbiAgICAgIHZhciBibCA9IGIgJiAweGZmZmY7XG4gICAgICAvLyB0aGUgc2hpZnQgYnkgMCBmaXhlcyB0aGUgc2lnbiBvbiB0aGUgaGlnaCBwYXJ0XG4gICAgICAvLyB0aGUgZmluYWwgfDAgY29udmVydHMgdGhlIHVuc2lnbmVkIHZhbHVlIGludG8gYSBzaWduZWQgdmFsdWVcbiAgICAgIHJldHVybiAoYWwgKiBibCkgKyAoKCgoYWggKiBibCkgKyAoYWwgKiBiaCkpIDw8IDE2KSA+Pj4gMCkgfCAwO1xuICAgIH0sXG5cbiAgICBmcm91bmQ6IGZ1bmN0aW9uIGZyb3VuZCh4KSB7XG4gICAgICB2YXIgdiA9IE51bWJlcih4KTtcbiAgICAgIGlmICh2ID09PSAwIHx8IHYgPT09IEluZmluaXR5IHx8IHYgPT09IC1JbmZpbml0eSB8fCBudW1iZXJJc05hTih2KSkge1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH1cbiAgICAgIHZhciBzaWduID0gX3NpZ24odik7XG4gICAgICB2YXIgYWJzID0gX2Ficyh2KTtcbiAgICAgIGlmIChhYnMgPCBCSU5BUllfMzJfTUlOX1ZBTFVFKSB7XG4gICAgICAgIHJldHVybiBzaWduICogcm91bmRUaWVzVG9FdmVuKGFicyAvIEJJTkFSWV8zMl9NSU5fVkFMVUUgLyBCSU5BUllfMzJfRVBTSUxPTikgKiBCSU5BUllfMzJfTUlOX1ZBTFVFICogQklOQVJZXzMyX0VQU0lMT047XG4gICAgICB9XG4gICAgICAvLyBWZWx0a2FtcCdzIHNwbGl0dGluZyAoPylcbiAgICAgIHZhciBhID0gKDEgKyAoQklOQVJZXzMyX0VQU0lMT04gLyBOdW1iZXIuRVBTSUxPTikpICogYWJzO1xuICAgICAgdmFyIHJlc3VsdCA9IGEgLSAoYSAtIGFicyk7XG4gICAgICBpZiAocmVzdWx0ID4gQklOQVJZXzMyX01BWF9WQUxVRSB8fCBudW1iZXJJc05hTihyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiBzaWduICogSW5maW5pdHk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2lnbiAqIHJlc3VsdDtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHdpdGhpblVMUERpc3RhbmNlID0gZnVuY3Rpb24gd2l0aGluVUxQRGlzdGFuY2UocmVzdWx0LCBleHBlY3RlZCwgZGlzdGFuY2UpIHtcbiAgICByZXR1cm4gX2FicygxIC0gKHJlc3VsdCAvIGV4cGVjdGVkKSkgLyBOdW1iZXIuRVBTSUxPTiA8IChkaXN0YW5jZSB8fCA4KTtcbiAgfTtcblxuICBkZWZpbmVQcm9wZXJ0aWVzKE1hdGgsIE1hdGhTaGltcyk7XG4gIC8vIENocm9tZSA8IDQwIHNpbmggcmV0dXJucyDiiJ4gZm9yIGxhcmdlIG51bWJlcnNcbiAgZGVmaW5lUHJvcGVydHkoTWF0aCwgJ3NpbmgnLCBNYXRoU2hpbXMuc2luaCwgTWF0aC5zaW5oKDcxMCkgPT09IEluZmluaXR5KTtcbiAgLy8gQ2hyb21lIDwgNDAgY29zaCByZXR1cm5zIOKIniBmb3IgbGFyZ2UgbnVtYmVyc1xuICBkZWZpbmVQcm9wZXJ0eShNYXRoLCAnY29zaCcsIE1hdGhTaGltcy5jb3NoLCBNYXRoLmNvc2goNzEwKSA9PT0gSW5maW5pdHkpO1xuICAvLyBJRSAxMSBUUCBoYXMgYW4gaW1wcmVjaXNlIGxvZzFwOiByZXBvcnRzIE1hdGgubG9nMXAoLTFlLTE3KSBhcyAwXG4gIGRlZmluZVByb3BlcnR5KE1hdGgsICdsb2cxcCcsIE1hdGhTaGltcy5sb2cxcCwgTWF0aC5sb2cxcCgtMWUtMTcpICE9PSAtMWUtMTcpO1xuICAvLyBJRSAxMSBUUCBoYXMgYW4gaW1wcmVjaXNlIGFzaW5oOiByZXBvcnRzIE1hdGguYXNpbmgoLTFlNykgYXMgbm90IGV4YWN0bHkgZXF1YWwgdG8gLU1hdGguYXNpbmgoMWU3KVxuICBkZWZpbmVQcm9wZXJ0eShNYXRoLCAnYXNpbmgnLCBNYXRoU2hpbXMuYXNpbmgsIE1hdGguYXNpbmgoLTFlNykgIT09IC1NYXRoLmFzaW5oKDFlNykpO1xuICAvLyBDaHJvbWUgPCA1NCBhc2luaCByZXR1cm5zIOKIniBmb3IgbGFyZ2UgbnVtYmVycyBhbmQgc2hvdWxkIG5vdFxuICBkZWZpbmVQcm9wZXJ0eShNYXRoLCAnYXNpbmgnLCBNYXRoU2hpbXMuYXNpbmgsIE1hdGguYXNpbmgoMWUrMzAwKSA9PT0gSW5maW5pdHkpO1xuICAvLyBDaHJvbWUgPCA1NCBhdGFuaCBpbmNvcnJlY3RseSByZXR1cm5zIDAgZm9yIGxhcmdlIG51bWJlcnNcbiAgZGVmaW5lUHJvcGVydHkoTWF0aCwgJ2F0YW5oJywgTWF0aFNoaW1zLmF0YW5oLCBNYXRoLmF0YW5oKDFlLTMwMCkgPT09IDApO1xuICAvLyBDaHJvbWUgNDAgaGFzIGFuIGltcHJlY2lzZSBNYXRoLnRhbmggd2l0aCB2ZXJ5IHNtYWxsIG51bWJlcnNcbiAgZGVmaW5lUHJvcGVydHkoTWF0aCwgJ3RhbmgnLCBNYXRoU2hpbXMudGFuaCwgTWF0aC50YW5oKC0yZS0xNykgIT09IC0yZS0xNyk7XG4gIC8vIENocm9tZSA0MCBsb3NlcyBNYXRoLmFjb3NoIHByZWNpc2lvbiB3aXRoIGhpZ2ggbnVtYmVyc1xuICBkZWZpbmVQcm9wZXJ0eShNYXRoLCAnYWNvc2gnLCBNYXRoU2hpbXMuYWNvc2gsIE1hdGguYWNvc2goTnVtYmVyLk1BWF9WQUxVRSkgPT09IEluZmluaXR5KTtcbiAgLy8gQ2hyb21lIDwgNTQgaGFzIGFuIGluYWNjdXJhdGUgYWNvc2ggZm9yIEVQU0lMT04gZGVsdGFzXG4gIGRlZmluZVByb3BlcnR5KE1hdGgsICdhY29zaCcsIE1hdGhTaGltcy5hY29zaCwgIXdpdGhpblVMUERpc3RhbmNlKE1hdGguYWNvc2goMSArIE51bWJlci5FUFNJTE9OKSwgTWF0aC5zcXJ0KDIgKiBOdW1iZXIuRVBTSUxPTikpKTtcbiAgLy8gRmlyZWZveCAzOCBvbiBXaW5kb3dzXG4gIGRlZmluZVByb3BlcnR5KE1hdGgsICdjYnJ0JywgTWF0aFNoaW1zLmNicnQsICF3aXRoaW5VTFBEaXN0YW5jZShNYXRoLmNicnQoMWUtMzAwKSwgMWUtMTAwKSk7XG4gIC8vIG5vZGUgMC4xMSBoYXMgYW4gaW1wcmVjaXNlIE1hdGguc2luaCB3aXRoIHZlcnkgc21hbGwgbnVtYmVyc1xuICBkZWZpbmVQcm9wZXJ0eShNYXRoLCAnc2luaCcsIE1hdGhTaGltcy5zaW5oLCBNYXRoLnNpbmgoLTJlLTE3KSAhPT0gLTJlLTE3KTtcbiAgLy8gRkYgMzUgb24gTGludXggcmVwb3J0cyAyMjAyNS40NjU3OTQ4MDY3MjUgZm9yIE1hdGguZXhwbTEoMTApXG4gIHZhciBleHBtMU9mVGVuID0gTWF0aC5leHBtMSgxMCk7XG4gIGRlZmluZVByb3BlcnR5KE1hdGgsICdleHBtMScsIE1hdGhTaGltcy5leHBtMSwgZXhwbTFPZlRlbiA+IDIyMDI1LjQ2NTc5NDgwNjcxOSB8fCBleHBtMU9mVGVuIDwgMjIwMjUuNDY1Nzk0ODA2NzE2NTE2OCk7XG4gIC8vIG5vZGUgdjEyLjExIC0gdjEyLjE1IHJlcG9ydCBOYU5cbiAgZGVmaW5lUHJvcGVydHkoTWF0aCwgJ2h5cG90JywgTWF0aFNoaW1zLmh5cG90LCBNYXRoLmh5cG90KEluZmluaXR5LCBOYU4pICE9PSBJbmZpbml0eSk7XG5cbiAgdmFyIG9yaWdNYXRoUm91bmQgPSBNYXRoLnJvdW5kO1xuICAvLyBicmVha3MgaW4gZS5nLiBTYWZhcmkgOCwgSW50ZXJuZXQgRXhwbG9yZXIgMTEsIE9wZXJhIDEyXG4gIHZhciByb3VuZEhhbmRsZXNCb3VuZGFyeUNvbmRpdGlvbnMgPSBNYXRoLnJvdW5kKDAuNSAtIChOdW1iZXIuRVBTSUxPTiAvIDQpKSA9PT0gMCAmJlxuICAgIE1hdGgucm91bmQoLTAuNSArIChOdW1iZXIuRVBTSUxPTiAvIDMuOTkpKSA9PT0gMTtcblxuICAvLyBXaGVuIGVuZ2luZXMgdXNlIE1hdGguZmxvb3IoeCArIDAuNSkgaW50ZXJuYWxseSwgTWF0aC5yb3VuZCBjYW4gYmUgYnVnZ3kgZm9yIGxhcmdlIGludGVnZXJzLlxuICAvLyBUaGlzIGJlaGF2aW9yIHNob3VsZCBiZSBnb3Zlcm5lZCBieSBcInJvdW5kIHRvIG5lYXJlc3QsIHRpZXMgdG8gZXZlbiBtb2RlXCJcbiAgLy8gc2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10ZXJtcy1hbmQtZGVmaW5pdGlvbnMtbnVtYmVyLXR5cGVcbiAgLy8gVGhlc2UgYXJlIHRoZSBib3VuZGFyeSBjYXNlcyB3aGVyZSBpdCBicmVha3MuXG4gIHZhciBzbWFsbGVzdFBvc2l0aXZlTnVtYmVyV2hlcmVSb3VuZEJyZWFrcyA9IGludmVyc2VFcHNpbG9uICsgMTtcbiAgdmFyIGxhcmdlc3RQb3NpdGl2ZU51bWJlcldoZXJlUm91bmRCcmVha3MgPSAoMiAqIGludmVyc2VFcHNpbG9uKSAtIDE7XG4gIHZhciByb3VuZERvZXNOb3RJbmNyZWFzZUludGVnZXJzID0gW1xuICAgIHNtYWxsZXN0UG9zaXRpdmVOdW1iZXJXaGVyZVJvdW5kQnJlYWtzLFxuICAgIGxhcmdlc3RQb3NpdGl2ZU51bWJlcldoZXJlUm91bmRCcmVha3NcbiAgXS5ldmVyeShmdW5jdGlvbiAobnVtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobnVtKSA9PT0gbnVtO1xuICB9KTtcbiAgZGVmaW5lUHJvcGVydHkoTWF0aCwgJ3JvdW5kJywgZnVuY3Rpb24gcm91bmQoeCkge1xuICAgIHZhciBmbG9vciA9IF9mbG9vcih4KTtcbiAgICB2YXIgY2VpbCA9IGZsb29yID09PSAtMSA/IC0wIDogZmxvb3IgKyAxO1xuICAgIHJldHVybiB4IC0gZmxvb3IgPCAwLjUgPyBmbG9vciA6IGNlaWw7XG4gIH0sICFyb3VuZEhhbmRsZXNCb3VuZGFyeUNvbmRpdGlvbnMgfHwgIXJvdW5kRG9lc05vdEluY3JlYXNlSW50ZWdlcnMpO1xuICBWYWx1ZS5wcmVzZXJ2ZVRvU3RyaW5nKE1hdGgucm91bmQsIG9yaWdNYXRoUm91bmQpO1xuXG4gIHZhciBvcmlnSW11bCA9IE1hdGguaW11bDtcbiAgaWYgKE1hdGguaW11bCgweGZmZmZmZmZmLCA1KSAhPT0gLTUpIHtcbiAgICAvLyBTYWZhcmkgNi4xLCBhdCBsZWFzdCwgcmVwb3J0cyBcIjBcIiBmb3IgdGhpcyB2YWx1ZVxuICAgIE1hdGguaW11bCA9IE1hdGhTaGltcy5pbXVsO1xuICAgIFZhbHVlLnByZXNlcnZlVG9TdHJpbmcoTWF0aC5pbXVsLCBvcmlnSW11bCk7XG4gIH1cbiAgaWYgKE1hdGguaW11bC5sZW5ndGggIT09IDIpIHtcbiAgICAvLyBTYWZhcmkgOC4wLjQgaGFzIGEgbGVuZ3RoIG9mIDFcbiAgICAvLyBmaXhlZCBpbiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQzNjU4XG4gICAgb3ZlcnJpZGVOYXRpdmUoTWF0aCwgJ2ltdWwnLCBmdW5jdGlvbiBpbXVsKHgsIHkpIHtcbiAgICAgIHJldHVybiBFUy5DYWxsKG9yaWdJbXVsLCBNYXRoLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gUHJvbWlzZXNcbiAgLy8gU2ltcGxlc3QgcG9zc2libGUgaW1wbGVtZW50YXRpb247IHVzZSBhIDNyZC1wYXJ0eSBsaWJyYXJ5IGlmIHlvdVxuICAvLyB3YW50IHRoZSBiZXN0IHBvc3NpYmxlIHNwZWVkIGFuZC9vciBsb25nIHN0YWNrIHRyYWNlcy5cbiAgdmFyIFByb21pc2VTaGltID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2V0VGltZW91dCA9IGdsb2JhbHMuc2V0VGltZW91dDtcbiAgICAvLyBzb21lIGVudmlyb25tZW50cyBkb24ndCBoYXZlIHNldFRpbWVvdXQgLSBubyB3YXkgdG8gc2hpbSBoZXJlLlxuICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc2V0VGltZW91dCAhPT0gJ29iamVjdCcpIHsgcmV0dXJuOyB9XG5cbiAgICBFUy5Jc1Byb21pc2UgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgaWYgKCFFUy5UeXBlSXNPYmplY3QocHJvbWlzZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwcm9taXNlLl9wcm9taXNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHVuaW5pdGlhbGl6ZWQsIG9yIG1pc3Npbmcgb3VyIGhpZGRlbiBmaWVsZC5cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvLyBcIlByb21pc2VDYXBhYmlsaXR5XCIgaW4gdGhlIHNwZWMgaXMgd2hhdCBtb3N0IHByb21pc2UgaW1wbGVtZW50YXRpb25zXG4gICAgLy8gY2FsbCBhIFwiZGVmZXJyZWRcIi5cbiAgICB2YXIgUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICAgICAgaWYgKCFFUy5Jc0NvbnN0cnVjdG9yKEMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JhZCBwcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgICB9XG4gICAgICB2YXIgY2FwYWJpbGl0eSA9IHRoaXM7XG4gICAgICB2YXIgcmVzb2x2ZXIgPSBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGlmIChjYXBhYmlsaXR5LnJlc29sdmUgIT09IHZvaWQgMCB8fCBjYXBhYmlsaXR5LnJlamVjdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQmFkIFByb21pc2UgaW1wbGVtZW50YXRpb24hJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2FwYWJpbGl0eS5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgY2FwYWJpbGl0eS5yZWplY3QgPSByZWplY3Q7XG4gICAgICB9O1xuICAgICAgLy8gSW5pdGlhbGl6ZSBmaWVsZHMgdG8gaW5mb3JtIG9wdGltaXplcnMgYWJvdXQgdGhlIG9iamVjdCBzaGFwZS5cbiAgICAgIGNhcGFiaWxpdHkucmVzb2x2ZSA9IHZvaWQgMDtcbiAgICAgIGNhcGFiaWxpdHkucmVqZWN0ID0gdm9pZCAwO1xuICAgICAgY2FwYWJpbGl0eS5wcm9taXNlID0gbmV3IEMocmVzb2x2ZXIpO1xuICAgICAgaWYgKCEoRVMuSXNDYWxsYWJsZShjYXBhYmlsaXR5LnJlc29sdmUpICYmIEVTLklzQ2FsbGFibGUoY2FwYWJpbGl0eS5yZWplY3QpKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCYWQgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBmaW5kIGFuIGFwcHJvcHJpYXRlIHNldEltbWVkaWF0ZS1hbGlrZVxuICAgIHZhciBtYWtlWmVyb1RpbWVvdXQ7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIEVTLklzQ2FsbGFibGUod2luZG93LnBvc3RNZXNzYWdlKSkge1xuICAgICAgbWFrZVplcm9UaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBmcm9tIGh0dHA6Ly9kYmFyb24ub3JnL2xvZy8yMDEwMDMwOS1mYXN0ZXItdGltZW91dHNcbiAgICAgICAgdmFyIHRpbWVvdXRzID0gW107XG4gICAgICAgIHZhciBtZXNzYWdlTmFtZSA9ICd6ZXJvLXRpbWVvdXQtbWVzc2FnZSc7XG4gICAgICAgIHZhciBzZXRaZXJvVGltZW91dCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgIF9wdXNoKHRpbWVvdXRzLCBmbik7XG4gICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2VOYW1lLCAnKicpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgaGFuZGxlTWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IHdpbmRvdyAmJiBldmVudC5kYXRhID09PSBtZXNzYWdlTmFtZSkge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBpZiAodGltZW91dHMubGVuZ3RoID09PSAwKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgdmFyIGZuID0gX3NoaWZ0KHRpbWVvdXRzKTtcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZU1lc3NhZ2UsIHRydWUpO1xuICAgICAgICByZXR1cm4gc2V0WmVyb1RpbWVvdXQ7XG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgbWFrZVByb21pc2VBc2FwID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gQW4gZWZmaWNpZW50IHRhc2stc2NoZWR1bGVyIGJhc2VkIG9uIGEgcHJlLWV4aXN0aW5nIFByb21pc2VcbiAgICAgIC8vIGltcGxlbWVudGF0aW9uLCB3aGljaCB3ZSBjYW4gdXNlIGV2ZW4gaWYgd2Ugb3ZlcnJpZGUgdGhlXG4gICAgICAvLyBnbG9iYWwgUHJvbWlzZSBiZWxvdyAoaW4gb3JkZXIgdG8gd29ya2Fyb3VuZCBidWdzKVxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1JheW5vcy9vYnNlcnYtaGFzaC9pc3N1ZXMvMiNpc3N1ZWNvbW1lbnQtMzU4NTc2NzFcbiAgICAgIHZhciBQID0gZ2xvYmFscy5Qcm9taXNlO1xuICAgICAgdmFyIHByID0gUCAmJiBQLnJlc29sdmUgJiYgUC5yZXNvbHZlKCk7XG4gICAgICByZXR1cm4gcHIgJiYgZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgcmV0dXJuIHByLnRoZW4odGFzayk7XG4gICAgICB9O1xuICAgIH07XG4gICAgdmFyIGVucXVldWUgPSBFUy5Jc0NhbGxhYmxlKGdsb2JhbHMuc2V0SW1tZWRpYXRlKSA/XG4gICAgICBnbG9iYWxzLnNldEltbWVkaWF0ZSA6XG4gICAgICB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgcHJvY2Vzcy5uZXh0VGljayA/IHByb2Nlc3MubmV4dFRpY2sgOiBtYWtlUHJvbWlzZUFzYXAoKSB8fFxuICAgICAgKEVTLklzQ2FsbGFibGUobWFrZVplcm9UaW1lb3V0KSA/IG1ha2VaZXJvVGltZW91dCgpIDogZnVuY3Rpb24gKHRhc2spIHsgc2V0VGltZW91dCh0YXNrLCAwKTsgfSk7IC8vIGZhbGxiYWNrXG5cbiAgICAvLyBDb25zdGFudHMgZm9yIFByb21pc2UgaW1wbGVtZW50YXRpb25cbiAgICB2YXIgUFJPTUlTRV9JREVOVElUWSA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9O1xuICAgIHZhciBQUk9NSVNFX1RIUk9XRVIgPSBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9O1xuICAgIHZhciBQUk9NSVNFX1BFTkRJTkcgPSAwO1xuICAgIHZhciBQUk9NSVNFX0ZVTEZJTExFRCA9IDE7XG4gICAgdmFyIFBST01JU0VfUkVKRUNURUQgPSAyO1xuICAgIC8vIFdlIHN0b3JlIGZ1bGZpbGwvcmVqZWN0IGhhbmRsZXJzIGFuZCBjYXBhYmlsaXRpZXMgaW4gYSBzaW5nbGUgYXJyYXkuXG4gICAgdmFyIFBST01JU0VfRlVMRklMTF9PRkZTRVQgPSAwO1xuICAgIHZhciBQUk9NSVNFX1JFSkVDVF9PRkZTRVQgPSAxO1xuICAgIHZhciBQUk9NSVNFX0NBUEFCSUxJVFlfT0ZGU0VUID0gMjtcbiAgICAvLyBUaGlzIGlzIHVzZWQgaW4gYW4gb3B0aW1pemF0aW9uIGZvciBjaGFpbmluZyBwcm9taXNlcyB2aWEgdGhlbi5cbiAgICB2YXIgUFJPTUlTRV9GQUtFX0NBUEFCSUxJVFkgPSB7fTtcblxuICAgIHZhciBlbnF1ZXVlUHJvbWlzZVJlYWN0aW9uSm9iID0gZnVuY3Rpb24gKGhhbmRsZXIsIGNhcGFiaWxpdHksIGFyZ3VtZW50KSB7XG4gICAgICBlbnF1ZXVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcHJvbWlzZVJlYWN0aW9uSm9iKGhhbmRsZXIsIGNhcGFiaWxpdHksIGFyZ3VtZW50KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgcHJvbWlzZVJlYWN0aW9uSm9iID0gZnVuY3Rpb24gKGhhbmRsZXIsIHByb21pc2VDYXBhYmlsaXR5LCBhcmd1bWVudCkge1xuICAgICAgdmFyIGhhbmRsZXJSZXN1bHQsIGY7XG4gICAgICBpZiAocHJvbWlzZUNhcGFiaWxpdHkgPT09IFBST01JU0VfRkFLRV9DQVBBQklMSVRZKSB7XG4gICAgICAgIC8vIEZhc3QgY2FzZSwgd2hlbiB3ZSBkb24ndCBhY3R1YWxseSBuZWVkIHRvIGNoYWluIHRocm91Z2ggdG8gYVxuICAgICAgICAvLyAocmVhbCkgcHJvbWlzZUNhcGFiaWxpdHkuXG4gICAgICAgIHJldHVybiBoYW5kbGVyKGFyZ3VtZW50KTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXJSZXN1bHQgPSBoYW5kbGVyKGFyZ3VtZW50KTtcbiAgICAgICAgZiA9IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZXJSZXN1bHQgPSBlO1xuICAgICAgICBmID0gcHJvbWlzZUNhcGFiaWxpdHkucmVqZWN0O1xuICAgICAgfVxuICAgICAgZihoYW5kbGVyUmVzdWx0KTtcbiAgICB9O1xuXG4gICAgdmFyIGZ1bGZpbGxQcm9taXNlID0gZnVuY3Rpb24gKHByb21pc2UsIHZhbHVlKSB7XG4gICAgICB2YXIgX3Byb21pc2UgPSBwcm9taXNlLl9wcm9taXNlO1xuICAgICAgdmFyIGxlbmd0aCA9IF9wcm9taXNlLnJlYWN0aW9uTGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgZW5xdWV1ZVByb21pc2VSZWFjdGlvbkpvYihcbiAgICAgICAgICBfcHJvbWlzZS5mdWxmaWxsUmVhY3Rpb25IYW5kbGVyMCxcbiAgICAgICAgICBfcHJvbWlzZS5yZWFjdGlvbkNhcGFiaWxpdHkwLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgICk7XG4gICAgICAgIF9wcm9taXNlLmZ1bGZpbGxSZWFjdGlvbkhhbmRsZXIwID0gdm9pZCAwO1xuICAgICAgICBfcHJvbWlzZS5yZWplY3RSZWFjdGlvbnMwID0gdm9pZCAwO1xuICAgICAgICBfcHJvbWlzZS5yZWFjdGlvbkNhcGFiaWxpdHkwID0gdm9pZCAwO1xuICAgICAgICBpZiAobGVuZ3RoID4gMSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxLCBpZHggPSAwOyBpIDwgbGVuZ3RoOyBpKyssIGlkeCArPSAzKSB7XG4gICAgICAgICAgICBlbnF1ZXVlUHJvbWlzZVJlYWN0aW9uSm9iKFxuICAgICAgICAgICAgICBfcHJvbWlzZVtpZHggKyBQUk9NSVNFX0ZVTEZJTExfT0ZGU0VUXSxcbiAgICAgICAgICAgICAgX3Byb21pc2VbaWR4ICsgUFJPTUlTRV9DQVBBQklMSVRZX09GRlNFVF0sXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcHJvbWlzZVtpZHggKyBQUk9NSVNFX0ZVTEZJTExfT0ZGU0VUXSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHByb21pc2VbaWR4ICsgUFJPTUlTRV9SRUpFQ1RfT0ZGU0VUXSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHByb21pc2VbaWR4ICsgUFJPTUlTRV9DQVBBQklMSVRZX09GRlNFVF0gPSB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfcHJvbWlzZS5yZXN1bHQgPSB2YWx1ZTtcbiAgICAgIF9wcm9taXNlLnN0YXRlID0gUFJPTUlTRV9GVUxGSUxMRUQ7XG4gICAgICBfcHJvbWlzZS5yZWFjdGlvbkxlbmd0aCA9IDA7XG4gICAgfTtcblxuICAgIHZhciByZWplY3RQcm9taXNlID0gZnVuY3Rpb24gKHByb21pc2UsIHJlYXNvbikge1xuICAgICAgdmFyIF9wcm9taXNlID0gcHJvbWlzZS5fcHJvbWlzZTtcbiAgICAgIHZhciBsZW5ndGggPSBfcHJvbWlzZS5yZWFjdGlvbkxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgIGVucXVldWVQcm9taXNlUmVhY3Rpb25Kb2IoXG4gICAgICAgICAgX3Byb21pc2UucmVqZWN0UmVhY3Rpb25IYW5kbGVyMCxcbiAgICAgICAgICBfcHJvbWlzZS5yZWFjdGlvbkNhcGFiaWxpdHkwLFxuICAgICAgICAgIHJlYXNvblxuICAgICAgICApO1xuICAgICAgICBfcHJvbWlzZS5mdWxmaWxsUmVhY3Rpb25IYW5kbGVyMCA9IHZvaWQgMDtcbiAgICAgICAgX3Byb21pc2UucmVqZWN0UmVhY3Rpb25zMCA9IHZvaWQgMDtcbiAgICAgICAgX3Byb21pc2UucmVhY3Rpb25DYXBhYmlsaXR5MCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMSwgaWR4ID0gMDsgaSA8IGxlbmd0aDsgaSsrLCBpZHggKz0gMykge1xuICAgICAgICAgICAgZW5xdWV1ZVByb21pc2VSZWFjdGlvbkpvYihcbiAgICAgICAgICAgICAgX3Byb21pc2VbaWR4ICsgUFJPTUlTRV9SRUpFQ1RfT0ZGU0VUXSxcbiAgICAgICAgICAgICAgX3Byb21pc2VbaWR4ICsgUFJPTUlTRV9DQVBBQklMSVRZX09GRlNFVF0sXG4gICAgICAgICAgICAgIHJlYXNvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHByb21pc2VbaWR4ICsgUFJPTUlTRV9GVUxGSUxMX09GRlNFVF0gPSB2b2lkIDA7XG4gICAgICAgICAgICBwcm9taXNlW2lkeCArIFBST01JU0VfUkVKRUNUX09GRlNFVF0gPSB2b2lkIDA7XG4gICAgICAgICAgICBwcm9taXNlW2lkeCArIFBST01JU0VfQ0FQQUJJTElUWV9PRkZTRVRdID0gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX3Byb21pc2UucmVzdWx0ID0gcmVhc29uO1xuICAgICAgX3Byb21pc2Uuc3RhdGUgPSBQUk9NSVNFX1JFSkVDVEVEO1xuICAgICAgX3Byb21pc2UucmVhY3Rpb25MZW5ndGggPSAwO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlUmVzb2x2aW5nRnVuY3Rpb25zID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgIHZhciBhbHJlYWR5UmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgIHZhciByZXNvbHZlID0gZnVuY3Rpb24gKHJlc29sdXRpb24pIHtcbiAgICAgICAgdmFyIHRoZW47XG4gICAgICAgIGlmIChhbHJlYWR5UmVzb2x2ZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgIGFscmVhZHlSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgIGlmIChyZXNvbHV0aW9uID09PSBwcm9taXNlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdFByb21pc2UocHJvbWlzZSwgbmV3IFR5cGVFcnJvcignU2VsZiByZXNvbHV0aW9uJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghRVMuVHlwZUlzT2JqZWN0KHJlc29sdXRpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bGZpbGxQcm9taXNlKHByb21pc2UsIHJlc29sdXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbiA9IHJlc29sdXRpb24udGhlbjtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiByZWplY3RQcm9taXNlKHByb21pc2UsIGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghRVMuSXNDYWxsYWJsZSh0aGVuKSkge1xuICAgICAgICAgIHJldHVybiBmdWxmaWxsUHJvbWlzZShwcm9taXNlLCByZXNvbHV0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbnF1ZXVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwcm9taXNlUmVzb2x2ZVRoZW5hYmxlSm9iKHByb21pc2UsIHJlc29sdXRpb24sIHRoZW4pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICB2YXIgcmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBpZiAoYWxyZWFkeVJlc29sdmVkKSB7IHJldHVybjsgfVxuICAgICAgICBhbHJlYWR5UmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVqZWN0UHJvbWlzZShwcm9taXNlLCByZWFzb24pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7IHJlc29sdmU6IHJlc29sdmUsIHJlamVjdDogcmVqZWN0IH07XG4gICAgfTtcblxuICAgIHZhciBvcHRpbWl6ZWRUaGVuID0gZnVuY3Rpb24gKHRoZW4sIHRoZW5hYmxlLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIC8vIE9wdGltaXphdGlvbjogc2luY2Ugd2UgZGlzY2FyZCB0aGUgcmVzdWx0LCB3ZSBjYW4gcGFzcyBvdXJcbiAgICAgIC8vIG93biB0aGVuIGltcGxlbWVudGF0aW9uIGEgc3BlY2lhbCBoaW50IHRvIGxldCBpdCBrbm93IGl0XG4gICAgICAvLyBkb2Vzbid0IGhhdmUgdG8gY3JlYXRlIGl0LiAgKFRoZSBQUk9NSVNFX0ZBS0VfQ0FQQUJJTElUWVxuICAgICAgLy8gb2JqZWN0IGlzIGxvY2FsIHRvIHRoaXMgaW1wbGVtZW50YXRpb24gYW5kIHVuZm9yZ2VhYmxlIG91dHNpZGUuKVxuICAgICAgaWYgKHRoZW4gPT09IFByb21pc2UkcHJvdG90eXBlJHRoZW4pIHtcbiAgICAgICAgX2NhbGwodGhlbiwgdGhlbmFibGUsIHJlc29sdmUsIHJlamVjdCwgUFJPTUlTRV9GQUtFX0NBUEFCSUxJVFkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2NhbGwodGhlbiwgdGhlbmFibGUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcHJvbWlzZVJlc29sdmVUaGVuYWJsZUpvYiA9IGZ1bmN0aW9uIChwcm9taXNlLCB0aGVuYWJsZSwgdGhlbikge1xuICAgICAgdmFyIHJlc29sdmluZ0Z1bmN0aW9ucyA9IGNyZWF0ZVJlc29sdmluZ0Z1bmN0aW9ucyhwcm9taXNlKTtcbiAgICAgIHZhciByZXNvbHZlID0gcmVzb2x2aW5nRnVuY3Rpb25zLnJlc29sdmU7XG4gICAgICB2YXIgcmVqZWN0ID0gcmVzb2x2aW5nRnVuY3Rpb25zLnJlamVjdDtcbiAgICAgIHRyeSB7XG4gICAgICAgIG9wdGltaXplZFRoZW4odGhlbiwgdGhlbmFibGUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIFByb21pc2UkcHJvdG90eXBlLCBQcm9taXNlJHByb3RvdHlwZSR0aGVuO1xuICAgIHZhciBQcm9taXNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBQcm9taXNlU2hpbSA9IGZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2VTaGltKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbnN0cnVjdG9yIFByb21pc2UgcmVxdWlyZXMgXCJuZXdcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzICYmIHRoaXMuX3Byb21pc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCYWQgY29uc3RydWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vYnVncy5lY21hc2NyaXB0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjQ4MlxuICAgICAgICBpZiAoIUVTLklzQ2FsbGFibGUocmVzb2x2ZXIpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm90IGEgdmFsaWQgcmVzb2x2ZXInKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvbWlzZSA9IGVtdWxhdGVFUzZjb25zdHJ1Y3QodGhpcywgUHJvbWlzZVNoaW0sIFByb21pc2UkcHJvdG90eXBlLCB7XG4gICAgICAgICAgX3Byb21pc2U6IHtcbiAgICAgICAgICAgIHJlc3VsdDogdm9pZCAwLFxuICAgICAgICAgICAgc3RhdGU6IFBST01JU0VfUEVORElORyxcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBtZW1iZXIgb2YgdGhlIFwicmVhY3Rpb25zXCIgYXJyYXkgaXMgaW5saW5lZCBoZXJlLFxuICAgICAgICAgICAgLy8gc2luY2UgbW9zdCBwcm9taXNlcyBvbmx5IGhhdmUgb25lIHJlYWN0aW9uLlxuICAgICAgICAgICAgLy8gV2UndmUgYWxzbyBleHBsb2RlZCB0aGUgJ3JlYWN0aW9uJyBvYmplY3QgdG8gaW5saW5lIHRoZVxuICAgICAgICAgICAgLy8gXCJoYW5kbGVyXCIgYW5kIFwiY2FwYWJpbGl0eVwiIGZpZWxkcywgc2luY2UgYm90aCBmdWxmaWxsIGFuZFxuICAgICAgICAgICAgLy8gcmVqZWN0IHJlYWN0aW9ucyBzaGFyZSB0aGUgc2FtZSBjYXBhYmlsaXR5LlxuICAgICAgICAgICAgcmVhY3Rpb25MZW5ndGg6IDAsXG4gICAgICAgICAgICBmdWxmaWxsUmVhY3Rpb25IYW5kbGVyMDogdm9pZCAwLFxuICAgICAgICAgICAgcmVqZWN0UmVhY3Rpb25IYW5kbGVyMDogdm9pZCAwLFxuICAgICAgICAgICAgcmVhY3Rpb25DYXBhYmlsaXR5MDogdm9pZCAwXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHJlc29sdmluZ0Z1bmN0aW9ucyA9IGNyZWF0ZVJlc29sdmluZ0Z1bmN0aW9ucyhwcm9taXNlKTtcbiAgICAgICAgdmFyIHJlamVjdCA9IHJlc29sdmluZ0Z1bmN0aW9ucy5yZWplY3Q7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzb2x2ZXIocmVzb2x2aW5nRnVuY3Rpb25zLnJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFByb21pc2VTaGltO1xuICAgIH0oKSk7XG4gICAgUHJvbWlzZSRwcm90b3R5cGUgPSBQcm9taXNlLnByb3RvdHlwZTtcblxuICAgIHZhciBfcHJvbWlzZUFsbFJlc29sdmVyID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZXMsIGNhcGFiaWxpdHksIHJlbWFpbmluZykge1xuICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAoYWxyZWFkeUNhbGxlZCkgeyByZXR1cm47IH1cbiAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgICAgIHZhbHVlc1tpbmRleF0gPSB4O1xuICAgICAgICBpZiAoKC0tcmVtYWluaW5nLmNvdW50KSA9PT0gMCkge1xuICAgICAgICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgICAgICAgIHJlc29sdmUodmFsdWVzKTsgLy8gY2FsbCB3LyB0aGlzPT09dW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBwZXJmb3JtUHJvbWlzZUFsbCA9IGZ1bmN0aW9uIChpdGVyYXRvclJlY29yZCwgQywgcmVzdWx0Q2FwYWJpbGl0eSkge1xuICAgICAgdmFyIGl0ID0gaXRlcmF0b3JSZWNvcmQuaXRlcmF0b3I7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICB2YXIgcmVtYWluaW5nID0geyBjb3VudDogMSB9O1xuICAgICAgdmFyIG5leHQsIG5leHRWYWx1ZTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5leHQgPSBFUy5JdGVyYXRvclN0ZXAoaXQpO1xuICAgICAgICAgIGlmIChuZXh0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaXRlcmF0b3JSZWNvcmQuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dFZhbHVlID0gbmV4dC52YWx1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGl0ZXJhdG9yUmVjb3JkLmRvbmUgPSB0cnVlO1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzW2luZGV4XSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIG5leHRQcm9taXNlID0gQy5yZXNvbHZlKG5leHRWYWx1ZSk7XG4gICAgICAgIHZhciByZXNvbHZlRWxlbWVudCA9IF9wcm9taXNlQWxsUmVzb2x2ZXIoXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgdmFsdWVzLFxuICAgICAgICAgIHJlc3VsdENhcGFiaWxpdHksXG4gICAgICAgICAgcmVtYWluaW5nXG4gICAgICAgICk7XG4gICAgICAgIHJlbWFpbmluZy5jb3VudCArPSAxO1xuICAgICAgICBvcHRpbWl6ZWRUaGVuKG5leHRQcm9taXNlLnRoZW4sIG5leHRQcm9taXNlLCByZXNvbHZlRWxlbWVudCwgcmVzdWx0Q2FwYWJpbGl0eS5yZWplY3QpO1xuICAgICAgICBpbmRleCArPSAxO1xuICAgICAgfVxuICAgICAgaWYgKCgtLXJlbWFpbmluZy5jb3VudCkgPT09IDApIHtcbiAgICAgICAgdmFyIHJlc29sdmUgPSByZXN1bHRDYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgICAgIHJlc29sdmUodmFsdWVzKTsgLy8gY2FsbCB3LyB0aGlzPT09dW5kZWZpbmVkXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIH07XG5cbiAgICB2YXIgcGVyZm9ybVByb21pc2VSYWNlID0gZnVuY3Rpb24gKGl0ZXJhdG9yUmVjb3JkLCBDLCByZXN1bHRDYXBhYmlsaXR5KSB7XG4gICAgICB2YXIgaXQgPSBpdGVyYXRvclJlY29yZC5pdGVyYXRvcjtcbiAgICAgIHZhciBuZXh0LCBuZXh0VmFsdWUsIG5leHRQcm9taXNlO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXh0ID0gRVMuSXRlcmF0b3JTdGVwKGl0KTtcbiAgICAgICAgICBpZiAobmV4dCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IElmIGl0ZXJhYmxlIGhhcyBubyBpdGVtcywgcmVzdWx0aW5nIHByb21pc2Ugd2lsbCBuZXZlclxuICAgICAgICAgICAgLy8gcmVzb2x2ZTsgc2VlOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2RvbWVuaWMvcHJvbWlzZXMtdW53cmFwcGluZy9pc3N1ZXMvNzVcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVncy5lY21hc2NyaXB0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjUxNVxuICAgICAgICAgICAgaXRlcmF0b3JSZWNvcmQuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dFZhbHVlID0gbmV4dC52YWx1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGl0ZXJhdG9yUmVjb3JkLmRvbmUgPSB0cnVlO1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dFByb21pc2UgPSBDLnJlc29sdmUobmV4dFZhbHVlKTtcbiAgICAgICAgb3B0aW1pemVkVGhlbihuZXh0UHJvbWlzZS50aGVuLCBuZXh0UHJvbWlzZSwgcmVzdWx0Q2FwYWJpbGl0eS5yZXNvbHZlLCByZXN1bHRDYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIH07XG5cbiAgICBkZWZpbmVQcm9wZXJ0aWVzKFByb21pc2UsIHtcbiAgICAgIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgICAgIHZhciBDID0gdGhpcztcbiAgICAgICAgaWYgKCFFUy5UeXBlSXNPYmplY3QoQykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlIGlzIG5vdCBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FwYWJpbGl0eSA9IG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICAgICAgdmFyIGl0ZXJhdG9yLCBpdGVyYXRvclJlY29yZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpdGVyYXRvciA9IEVTLkdldEl0ZXJhdG9yKGl0ZXJhYmxlKTtcbiAgICAgICAgICBpdGVyYXRvclJlY29yZCA9IHsgaXRlcmF0b3I6IGl0ZXJhdG9yLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgIHJldHVybiBwZXJmb3JtUHJvbWlzZUFsbChpdGVyYXRvclJlY29yZCwgQywgY2FwYWJpbGl0eSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB2YXIgZXhjZXB0aW9uID0gZTtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JSZWNvcmQgJiYgIWl0ZXJhdG9yUmVjb3JkLmRvbmUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEVTLkl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIHRydWUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZWUpIHtcbiAgICAgICAgICAgICAgZXhjZXB0aW9uID0gZWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICAgICAgICByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgICAgIHZhciBDID0gdGhpcztcbiAgICAgICAgaWYgKCFFUy5UeXBlSXNPYmplY3QoQykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlIGlzIG5vdCBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FwYWJpbGl0eSA9IG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICAgICAgdmFyIGl0ZXJhdG9yLCBpdGVyYXRvclJlY29yZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpdGVyYXRvciA9IEVTLkdldEl0ZXJhdG9yKGl0ZXJhYmxlKTtcbiAgICAgICAgICBpdGVyYXRvclJlY29yZCA9IHsgaXRlcmF0b3I6IGl0ZXJhdG9yLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgIHJldHVybiBwZXJmb3JtUHJvbWlzZVJhY2UoaXRlcmF0b3JSZWNvcmQsIEMsIGNhcGFiaWxpdHkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdmFyIGV4Y2VwdGlvbiA9IGU7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yUmVjb3JkICYmICFpdGVyYXRvclJlY29yZC5kb25lKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBFUy5JdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCB0cnVlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVlKSB7XG4gICAgICAgICAgICAgIGV4Y2VwdGlvbiA9IGVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgICAgICAgcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgICAgIHZhciBDID0gdGhpcztcbiAgICAgICAgaWYgKCFFUy5UeXBlSXNPYmplY3QoQykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCYWQgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgICAgICB2YXIgcmVqZWN0RnVuYyA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICAgICByZWplY3RGdW5jKHJlYXNvbik7IC8vIGNhbGwgd2l0aCB0aGlzPT09dW5kZWZpbmVkXG4gICAgICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9LFxuXG4gICAgICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHYpIHtcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZXNkaXNjdXNzLm9yZy90b3BpYy9maXhpbmctcHJvbWlzZS1yZXNvbHZlIGZvciBzcGVjXG4gICAgICAgIHZhciBDID0gdGhpcztcbiAgICAgICAgaWYgKCFFUy5UeXBlSXNPYmplY3QoQykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCYWQgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChFUy5Jc1Byb21pc2UodikpIHtcbiAgICAgICAgICB2YXIgY29uc3RydWN0b3IgPSB2LmNvbnN0cnVjdG9yO1xuICAgICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gQykge1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgICAgICB2YXIgcmVzb2x2ZUZ1bmMgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgICAgIHJlc29sdmVGdW5jKHYpOyAvLyBjYWxsIHdpdGggdGhpcz09PXVuZGVmaW5lZFxuICAgICAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZGVmaW5lUHJvcGVydGllcyhQcm9taXNlJHByb3RvdHlwZSwge1xuICAgICAgJ2NhdGNoJzogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcbiAgICAgIH0sXG5cbiAgICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgICAgICBpZiAoIUVTLklzUHJvbWlzZShwcm9taXNlKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBwcm9taXNlJyk7IH1cbiAgICAgICAgdmFyIEMgPSBFUy5TcGVjaWVzQ29uc3RydWN0b3IocHJvbWlzZSwgUHJvbWlzZSk7XG4gICAgICAgIHZhciByZXN1bHRDYXBhYmlsaXR5O1xuICAgICAgICB2YXIgcmV0dXJuVmFsdWVJc0lnbm9yZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IFBST01JU0VfRkFLRV9DQVBBQklMSVRZO1xuICAgICAgICBpZiAocmV0dXJuVmFsdWVJc0lnbm9yZWQgJiYgQyA9PT0gUHJvbWlzZSkge1xuICAgICAgICAgIHJlc3VsdENhcGFiaWxpdHkgPSBQUk9NSVNFX0ZBS0VfQ0FQQUJJTElUWTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRDYXBhYmlsaXR5ID0gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBlcmZvcm1Qcm9taXNlVGhlbihwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcmVzdWx0Q2FwYWJpbGl0eSlcbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlJ3ZlIHNwbGl0IHRoZSAncmVhY3Rpb24nIG9iamVjdCBpbnRvIGl0cyB0d29cbiAgICAgICAgLy8gY29tcG9uZW50cywgXCJjYXBhYmlsaXRpZXNcIiBhbmQgXCJoYW5kbGVyXCJcbiAgICAgICAgLy8gXCJjYXBhYmlsaXRpZXNcIiBpcyBhbHdheXMgZXF1YWwgdG8gYHJlc3VsdENhcGFiaWxpdHlgXG4gICAgICAgIHZhciBmdWxmaWxsUmVhY3Rpb25IYW5kbGVyID0gRVMuSXNDYWxsYWJsZShvbkZ1bGZpbGxlZCkgPyBvbkZ1bGZpbGxlZCA6IFBST01JU0VfSURFTlRJVFk7XG4gICAgICAgIHZhciByZWplY3RSZWFjdGlvbkhhbmRsZXIgPSBFUy5Jc0NhbGxhYmxlKG9uUmVqZWN0ZWQpID8gb25SZWplY3RlZCA6IFBST01JU0VfVEhST1dFUjtcbiAgICAgICAgdmFyIF9wcm9taXNlID0gcHJvbWlzZS5fcHJvbWlzZTtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICBpZiAoX3Byb21pc2Uuc3RhdGUgPT09IFBST01JU0VfUEVORElORykge1xuICAgICAgICAgIGlmIChfcHJvbWlzZS5yZWFjdGlvbkxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgX3Byb21pc2UuZnVsZmlsbFJlYWN0aW9uSGFuZGxlcjAgPSBmdWxmaWxsUmVhY3Rpb25IYW5kbGVyO1xuICAgICAgICAgICAgX3Byb21pc2UucmVqZWN0UmVhY3Rpb25IYW5kbGVyMCA9IHJlamVjdFJlYWN0aW9uSGFuZGxlcjtcbiAgICAgICAgICAgIF9wcm9taXNlLnJlYWN0aW9uQ2FwYWJpbGl0eTAgPSByZXN1bHRDYXBhYmlsaXR5O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gMyAqIChfcHJvbWlzZS5yZWFjdGlvbkxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgX3Byb21pc2VbaWR4ICsgUFJPTUlTRV9GVUxGSUxMX09GRlNFVF0gPSBmdWxmaWxsUmVhY3Rpb25IYW5kbGVyO1xuICAgICAgICAgICAgX3Byb21pc2VbaWR4ICsgUFJPTUlTRV9SRUpFQ1RfT0ZGU0VUXSA9IHJlamVjdFJlYWN0aW9uSGFuZGxlcjtcbiAgICAgICAgICAgIF9wcm9taXNlW2lkeCArIFBST01JU0VfQ0FQQUJJTElUWV9PRkZTRVRdID0gcmVzdWx0Q2FwYWJpbGl0eTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3Byb21pc2UucmVhY3Rpb25MZW5ndGggKz0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChfcHJvbWlzZS5zdGF0ZSA9PT0gUFJPTUlTRV9GVUxGSUxMRUQpIHtcbiAgICAgICAgICB2YWx1ZSA9IF9wcm9taXNlLnJlc3VsdDtcbiAgICAgICAgICBlbnF1ZXVlUHJvbWlzZVJlYWN0aW9uSm9iKFxuICAgICAgICAgICAgZnVsZmlsbFJlYWN0aW9uSGFuZGxlcixcbiAgICAgICAgICAgIHJlc3VsdENhcGFiaWxpdHksXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoX3Byb21pc2Uuc3RhdGUgPT09IFBST01JU0VfUkVKRUNURUQpIHtcbiAgICAgICAgICB2YWx1ZSA9IF9wcm9taXNlLnJlc3VsdDtcbiAgICAgICAgICBlbnF1ZXVlUHJvbWlzZVJlYWN0aW9uSm9iKFxuICAgICAgICAgICAgcmVqZWN0UmVhY3Rpb25IYW5kbGVyLFxuICAgICAgICAgICAgcmVzdWx0Q2FwYWJpbGl0eSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmV4cGVjdGVkIFByb21pc2Ugc3RhdGUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIFRoaXMgaGVscHMgdGhlIG9wdGltaXplciBieSBlbnN1cmluZyB0aGF0IG1ldGhvZHMgd2hpY2ggdGFrZVxuICAgIC8vIGNhcGFiaWxpdGllcyBhcmVuJ3QgcG9seW1vcnBoaWMuXG4gICAgUFJPTUlTRV9GQUtFX0NBUEFCSUxJVFkgPSBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoUHJvbWlzZSk7XG4gICAgUHJvbWlzZSRwcm90b3R5cGUkdGhlbiA9IFByb21pc2UkcHJvdG90eXBlLnRoZW47XG5cbiAgICByZXR1cm4gUHJvbWlzZTtcbiAgfSgpKTtcblxuICAvLyBDaHJvbWUncyBuYXRpdmUgUHJvbWlzZSBoYXMgZXh0cmEgbWV0aG9kcyB0aGF0IGl0IHNob3VsZG4ndCBoYXZlLiBMZXQncyByZW1vdmUgdGhlbS5cbiAgaWYgKGdsb2JhbHMuUHJvbWlzZSkge1xuICAgIGRlbGV0ZSBnbG9iYWxzLlByb21pc2UuYWNjZXB0O1xuICAgIGRlbGV0ZSBnbG9iYWxzLlByb21pc2UuZGVmZXI7XG4gICAgZGVsZXRlIGdsb2JhbHMuUHJvbWlzZS5wcm90b3R5cGUuY2hhaW47XG4gIH1cblxuICBpZiAodHlwZW9mIFByb21pc2VTaGltID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gZXhwb3J0IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yLlxuICAgIGRlZmluZVByb3BlcnRpZXMoZ2xvYmFscywgeyBQcm9taXNlOiBQcm9taXNlU2hpbSB9KTtcbiAgICAvLyBJbiBDaHJvbWUgMzMgKGFuZCB0aGVyZWFib3V0cykgUHJvbWlzZSBpcyBkZWZpbmVkLCBidXQgdGhlXG4gICAgLy8gaW1wbGVtZW50YXRpb24gaXMgYnVnZ3kgaW4gYSBudW1iZXIgb2Ygd2F5cy4gIExldCdzIGNoZWNrIHN1YmNsYXNzaW5nXG4gICAgLy8gc3VwcG9ydCB0byBzZWUgaWYgd2UgaGF2ZSBhIGJ1Z2d5IGltcGxlbWVudGF0aW9uLlxuICAgIHZhciBwcm9taXNlU3VwcG9ydHNTdWJjbGFzc2luZyA9IHN1cHBvcnRzU3ViY2xhc3NpbmcoZ2xvYmFscy5Qcm9taXNlLCBmdW5jdGlvbiAoUykge1xuICAgICAgcmV0dXJuIFMucmVzb2x2ZSg0MikudGhlbihmdW5jdGlvbiAoKSB7fSkgaW5zdGFuY2VvZiBTO1xuICAgIH0pO1xuICAgIHZhciBwcm9taXNlSWdub3Jlc05vbkZ1bmN0aW9uVGhlbkNhbGxiYWNrcyA9ICF0aHJvd3NFcnJvcihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZ2xvYmFscy5Qcm9taXNlLnJlamVjdCg0MikudGhlbihudWxsLCA1KS50aGVuKG51bGwsIG5vb3ApO1xuICAgIH0pO1xuICAgIHZhciBwcm9taXNlUmVxdWlyZXNPYmplY3RDb250ZXh0ID0gdGhyb3dzRXJyb3IoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2xvYmFscy5Qcm9taXNlLmNhbGwoMywgbm9vcCk7IH0pO1xuICAgIC8vIFByb21pc2UucmVzb2x2ZSgpIHdhcyBlcnJhdGEnZWQgbGF0ZSBpbiB0aGUgRVM2IHByb2Nlc3MuXG4gICAgLy8gU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTcwNzQyXG4gICAgLy8gICAgICBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDE2MVxuICAgIC8vIEl0IHNlcnZlcyBhcyBhIHByb3h5IGZvciBhIG51bWJlciBvZiBvdGhlciBidWdzIGluIGVhcmx5IFByb21pc2VcbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMuXG4gICAgdmFyIHByb21pc2VSZXNvbHZlQnJva2VuID0gKGZ1bmN0aW9uIChQcm9taXNlKSB7XG4gICAgICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSg1KTtcbiAgICAgIHAuY29uc3RydWN0b3IgPSB7fTtcbiAgICAgIHZhciBwMiA9IFByb21pc2UucmVzb2x2ZShwKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHAyLnRoZW4obnVsbCwgbm9vcCkudGhlbihudWxsLCBub29wKTsgLy8gYXZvaWQgXCJ1bmNhdWdodCByZWplY3Rpb25cIiB3YXJuaW5ncyBpbiBjb25zb2xlXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyB2OCBuYXRpdmUgUHJvbWlzZXMgYnJlYWsgaGVyZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTc1MzE0XG4gICAgICB9XG4gICAgICByZXR1cm4gcCA9PT0gcDI7IC8vIFRoaXMgKnNob3VsZCogYmUgZmFsc2UhXG4gICAgfShnbG9iYWxzLlByb21pc2UpKTtcblxuICAgIC8vIENocm9tZSA0NiAocHJvYmFibHkgb2xkZXIgdG9vKSBkb2VzIG5vdCByZXRyaWV2ZSBhIHRoZW5hYmxlJ3MgLnRoZW4gc3luY2hyb25vdXNseVxuICAgIHZhciBnZXRzVGhlblN5bmNocm9ub3VzbHkgPSBzdXBwb3J0c0Rlc2NyaXB0b3JzICYmIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdldHRlci1yZXR1cm5cbiAgICAgIHZhciB0aGVuYWJsZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3RoZW4nLCB7IGdldDogZnVuY3Rpb24gKCkgeyBjb3VudCArPSAxOyB9IH0pO1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKHRoZW5hYmxlKTtcbiAgICAgIHJldHVybiBjb3VudCA9PT0gMTtcbiAgICB9KCkpO1xuXG4gICAgdmFyIEJhZFJlc29sdmVyUHJvbWlzZSA9IGZ1bmN0aW9uIEJhZFJlc29sdmVyUHJvbWlzZShleGVjdXRvcikge1xuICAgICAgdmFyIHAgPSBuZXcgUHJvbWlzZShleGVjdXRvcik7XG4gICAgICBleGVjdXRvcigzLCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgICB0aGlzLnRoZW4gPSBwLnRoZW47XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yID0gQmFkUmVzb2x2ZXJQcm9taXNlO1xuICAgIH07XG4gICAgQmFkUmVzb2x2ZXJQcm9taXNlLnByb3RvdHlwZSA9IFByb21pc2UucHJvdG90eXBlO1xuICAgIEJhZFJlc29sdmVyUHJvbWlzZS5hbGwgPSBQcm9taXNlLmFsbDtcbiAgICAvLyBDaHJvbWUgQ2FuYXJ5IDQ5IChwcm9iYWJseSBvbGRlciB0b28pIGhhcyBzb21lIGltcGxlbWVudGF0aW9uIGJ1Z3NcbiAgICB2YXIgaGFzQmFkUmVzb2x2ZXJQcm9taXNlID0gdmFsdWVPckZhbHNlSWZUaHJvd3MoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEhQmFkUmVzb2x2ZXJQcm9taXNlLmFsbChbMSwgMl0pO1xuICAgIH0pO1xuXG4gICAgaWYgKCFwcm9taXNlU3VwcG9ydHNTdWJjbGFzc2luZyB8fCAhcHJvbWlzZUlnbm9yZXNOb25GdW5jdGlvblRoZW5DYWxsYmFja3MgfHxcbiAgICAgICAgIXByb21pc2VSZXF1aXJlc09iamVjdENvbnRleHQgfHwgcHJvbWlzZVJlc29sdmVCcm9rZW4gfHxcbiAgICAgICAgIWdldHNUaGVuU3luY2hyb25vdXNseSB8fCBoYXNCYWRSZXNvbHZlclByb21pc2UpIHtcbiAgICAgIC8qIGdsb2JhbHMgUHJvbWlzZTogdHJ1ZSAqL1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYsIG5vLWdsb2JhbC1hc3NpZ24gKi9cbiAgICAgIFByb21pc2UgPSBQcm9taXNlU2hpbTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5kZWYsIG5vLWdsb2JhbC1hc3NpZ24gKi9cbiAgICAgIG92ZXJyaWRlTmF0aXZlKGdsb2JhbHMsICdQcm9taXNlJywgUHJvbWlzZVNoaW0pO1xuICAgIH1cbiAgICBpZiAoUHJvbWlzZS5hbGwubGVuZ3RoICE9PSAxKSB7XG4gICAgICB2YXIgb3JpZ0FsbCA9IFByb21pc2UuYWxsO1xuICAgICAgb3ZlcnJpZGVOYXRpdmUoUHJvbWlzZSwgJ2FsbCcsIGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gRVMuQ2FsbChvcmlnQWxsLCB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChQcm9taXNlLnJhY2UubGVuZ3RoICE9PSAxKSB7XG4gICAgICB2YXIgb3JpZ1JhY2UgPSBQcm9taXNlLnJhY2U7XG4gICAgICBvdmVycmlkZU5hdGl2ZShQcm9taXNlLCAncmFjZScsIGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIEVTLkNhbGwob3JpZ1JhY2UsIHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKFByb21pc2UucmVzb2x2ZS5sZW5ndGggIT09IDEpIHtcbiAgICAgIHZhciBvcmlnUmVzb2x2ZSA9IFByb21pc2UucmVzb2x2ZTtcbiAgICAgIG92ZXJyaWRlTmF0aXZlKFByb21pc2UsICdyZXNvbHZlJywgZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgICAgIHJldHVybiBFUy5DYWxsKG9yaWdSZXNvbHZlLCB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChQcm9taXNlLnJlamVjdC5sZW5ndGggIT09IDEpIHtcbiAgICAgIHZhciBvcmlnUmVqZWN0ID0gUHJvbWlzZS5yZWplY3Q7XG4gICAgICBvdmVycmlkZU5hdGl2ZShQcm9taXNlLCAncmVqZWN0JywgZnVuY3Rpb24gcmVqZWN0KHIpIHtcbiAgICAgICAgcmV0dXJuIEVTLkNhbGwob3JpZ1JlamVjdCwgdGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbnN1cmVFbnVtZXJhYmxlKFByb21pc2UsICdhbGwnKTtcbiAgICBlbnN1cmVFbnVtZXJhYmxlKFByb21pc2UsICdyYWNlJyk7XG4gICAgZW5zdXJlRW51bWVyYWJsZShQcm9taXNlLCAncmVzb2x2ZScpO1xuICAgIGVuc3VyZUVudW1lcmFibGUoUHJvbWlzZSwgJ3JlamVjdCcpO1xuICAgIGFkZERlZmF1bHRTcGVjaWVzKFByb21pc2UpO1xuICB9XG5cbiAgLy8gTWFwIGFuZCBTZXQgcmVxdWlyZSBhIHRydWUgRVM1IGVudmlyb25tZW50XG4gIC8vIFRoZWlyIGZhc3QgcGF0aCBhbHNvIHJlcXVpcmVzIHRoYXQgdGhlIGVudmlyb25tZW50IHByZXNlcnZlXG4gIC8vIHByb3BlcnR5IGluc2VydGlvbiBvcmRlciwgd2hpY2ggaXMgbm90IGd1YXJhbnRlZWQgYnkgdGhlIHNwZWMuXG4gIHZhciB0ZXN0T3JkZXIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciBiID0ga2V5cyhfcmVkdWNlKGEsIGZ1bmN0aW9uIChvLCBrKSB7XG4gICAgICBvW2tdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBvO1xuICAgIH0sIHt9KSk7XG4gICAgcmV0dXJuIGEuam9pbignOicpID09PSBiLmpvaW4oJzonKTtcbiAgfTtcbiAgdmFyIHByZXNlcnZlc0luc2VydGlvbk9yZGVyID0gdGVzdE9yZGVyKFsneicsICdhJywgJ2JiJ10pO1xuICAvLyBzb21lIGVuZ2luZXMgKGVnLCBDaHJvbWUpIG9ubHkgcHJlc2VydmUgaW5zZXJ0aW9uIG9yZGVyIGZvciBzdHJpbmcga2V5c1xuICB2YXIgcHJlc2VydmVzTnVtZXJpY0luc2VydGlvbk9yZGVyID0gdGVzdE9yZGVyKFsneicsIDEsICdhJywgJzMnLCAyXSk7XG5cbiAgaWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcblxuICAgIHZhciBmYXN0a2V5ID0gZnVuY3Rpb24gZmFzdGtleShrZXksIHNraXBJbnNlcnRpb25PcmRlckNoZWNrKSB7XG4gICAgICBpZiAoIXNraXBJbnNlcnRpb25PcmRlckNoZWNrICYmICFwcmVzZXJ2ZXNJbnNlcnRpb25PcmRlcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZChrZXkpKSB7XG4gICAgICAgIHJldHVybiAnXicgKyBFUy5Ub1N0cmluZyhrZXkpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gJyQnICsga2V5O1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Yga2V5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBub3RlIHRoYXQgLTAgd2lsbCBnZXQgY29lcmNlZCB0byBcIjBcIiB3aGVuIHVzZWQgYXMgYSBwcm9wZXJ0eSBrZXlcbiAgICAgICAgaWYgKCFwcmVzZXJ2ZXNOdW1lcmljSW5zZXJ0aW9uT3JkZXIpIHtcbiAgICAgICAgICByZXR1cm4gJ24nICsga2V5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBrZXkgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gJ2InICsga2V5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHZhciBlbXB0eU9iamVjdCA9IGZ1bmN0aW9uIGVtcHR5T2JqZWN0KCkge1xuICAgICAgLy8gYWNjb21vZGF0ZSBzb21lIG9sZGVyIG5vdC1xdWl0ZS1FUzUgYnJvd3NlcnNcbiAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuICAgIH07XG5cbiAgICB2YXIgYWRkSXRlcmFibGVUb01hcCA9IGZ1bmN0aW9uIGFkZEl0ZXJhYmxlVG9NYXAoTWFwQ29uc3RydWN0b3IsIG1hcCwgaXRlcmFibGUpIHtcbiAgICAgIGlmIChpc0FycmF5KGl0ZXJhYmxlKSB8fCBUeXBlLnN0cmluZyhpdGVyYWJsZSkpIHtcbiAgICAgICAgX2ZvckVhY2goaXRlcmFibGUsIGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgIGlmICghRVMuVHlwZUlzT2JqZWN0KGVudHJ5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSXRlcmF0b3IgdmFsdWUgJyArIGVudHJ5ICsgJyBpcyBub3QgYW4gZW50cnkgb2JqZWN0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcC5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGl0ZXJhYmxlIGluc3RhbmNlb2YgTWFwQ29uc3RydWN0b3IpIHtcbiAgICAgICAgX2NhbGwoTWFwQ29uc3RydWN0b3IucHJvdG90eXBlLmZvckVhY2gsIGl0ZXJhYmxlLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGl0ZXIsIGFkZGVyO1xuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGl0ZXJhYmxlKSkge1xuICAgICAgICAgIGFkZGVyID0gbWFwLnNldDtcbiAgICAgICAgICBpZiAoIUVTLklzQ2FsbGFibGUoYWRkZXIpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ2JhZCBtYXAnKTsgfVxuICAgICAgICAgIGl0ZXIgPSBFUy5HZXRJdGVyYXRvcihpdGVyYWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBpdGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IEVTLkl0ZXJhdG9yU3RlcChpdGVyKTtcbiAgICAgICAgICAgIGlmIChuZXh0ID09PSBmYWxzZSkgeyBicmVhazsgfVxuICAgICAgICAgICAgdmFyIG5leHRJdGVtID0gbmV4dC52YWx1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICghRVMuVHlwZUlzT2JqZWN0KG5leHRJdGVtKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0l0ZXJhdG9yIHZhbHVlICcgKyBuZXh0SXRlbSArICcgaXMgbm90IGFuIGVudHJ5IG9iamVjdCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9jYWxsKGFkZGVyLCBtYXAsIG5leHRJdGVtWzBdLCBuZXh0SXRlbVsxXSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIEVTLkl0ZXJhdG9yQ2xvc2UoaXRlciwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgYWRkSXRlcmFibGVUb1NldCA9IGZ1bmN0aW9uIGFkZEl0ZXJhYmxlVG9TZXQoU2V0Q29uc3RydWN0b3IsIHNldCwgaXRlcmFibGUpIHtcbiAgICAgIGlmIChpc0FycmF5KGl0ZXJhYmxlKSB8fCBUeXBlLnN0cmluZyhpdGVyYWJsZSkpIHtcbiAgICAgICAgX2ZvckVhY2goaXRlcmFibGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHNldC5hZGQodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoaXRlcmFibGUgaW5zdGFuY2VvZiBTZXRDb25zdHJ1Y3Rvcikge1xuICAgICAgICBfY2FsbChTZXRDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZm9yRWFjaCwgaXRlcmFibGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHNldC5hZGQodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpdGVyLCBhZGRlcjtcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChpdGVyYWJsZSkpIHtcbiAgICAgICAgICBhZGRlciA9IHNldC5hZGQ7XG4gICAgICAgICAgaWYgKCFFUy5Jc0NhbGxhYmxlKGFkZGVyKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdiYWQgc2V0Jyk7IH1cbiAgICAgICAgICBpdGVyID0gRVMuR2V0SXRlcmF0b3IoaXRlcmFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaXRlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIG5leHQgPSBFUy5JdGVyYXRvclN0ZXAoaXRlcik7XG4gICAgICAgICAgICBpZiAobmV4dCA9PT0gZmFsc2UpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIHZhciBuZXh0VmFsdWUgPSBuZXh0LnZhbHVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgX2NhbGwoYWRkZXIsIHNldCwgbmV4dFZhbHVlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgRVMuSXRlcmF0b3JDbG9zZShpdGVyLCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNvbGxlY3Rpb25TaGltcyA9IHtcbiAgICAgIE1hcDogKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB2YXIgZW1wdHkgPSB7fTtcblxuICAgICAgICB2YXIgTWFwRW50cnkgPSBmdW5jdGlvbiBNYXBFbnRyeShrZXksIHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICBNYXBFbnRyeS5wcm90b3R5cGUuaXNSZW1vdmVkID0gZnVuY3Rpb24gaXNSZW1vdmVkKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmtleSA9PT0gZW1wdHk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGlzTWFwID0gZnVuY3Rpb24gaXNNYXAobWFwKSB7XG4gICAgICAgICAgcmV0dXJuICEhbWFwLl9lczZtYXA7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlcXVpcmVNYXBTbG90ID0gZnVuY3Rpb24gcmVxdWlyZU1hcFNsb3QobWFwLCBtZXRob2QpIHtcbiAgICAgICAgICBpZiAoIUVTLlR5cGVJc09iamVjdChtYXApIHx8ICFpc01hcChtYXApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNZXRob2QgTWFwLnByb3RvdHlwZS4nICsgbWV0aG9kICsgJyBjYWxsZWQgb24gaW5jb21wYXRpYmxlIHJlY2VpdmVyICcgKyBFUy5Ub1N0cmluZyhtYXApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIE1hcEl0ZXJhdG9yID0gZnVuY3Rpb24gTWFwSXRlcmF0b3IobWFwLCBraW5kKSB7XG4gICAgICAgICAgcmVxdWlyZU1hcFNsb3QobWFwLCAnW1tNYXBJdGVyYXRvcl1dJyk7XG4gICAgICAgICAgdGhpcy5oZWFkID0gbWFwLl9oZWFkO1xuICAgICAgICAgIHRoaXMuaSA9IHRoaXMuaGVhZDtcbiAgICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgICAgICB9O1xuXG4gICAgICAgIE1hcEl0ZXJhdG9yLnByb3RvdHlwZSA9IHtcbiAgICAgICAgICBpc01hcEl0ZXJhdG9yOiB0cnVlLFxuICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNNYXBJdGVyYXRvcikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgYSBNYXBJdGVyYXRvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmk7XG4gICAgICAgICAgICB2YXIga2luZCA9IHRoaXMua2luZDtcbiAgICAgICAgICAgIHZhciBoZWFkID0gdGhpcy5oZWFkO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvclJlc3VsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGkuaXNSZW1vdmVkKCkgJiYgaSAhPT0gaGVhZCkge1xuICAgICAgICAgICAgICAvLyBiYWNrIHVwIG9mZiBvZiByZW1vdmVkIGVudHJpZXNcbiAgICAgICAgICAgICAgaSA9IGkucHJldjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFkdmFuY2UgdG8gbmV4dCB1bnJldHVybmVkIGVsZW1lbnQuXG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgd2hpbGUgKGkubmV4dCAhPT0gaGVhZCkge1xuICAgICAgICAgICAgICBpID0gaS5uZXh0O1xuICAgICAgICAgICAgICBpZiAoIWkuaXNSZW1vdmVkKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2luZCA9PT0gJ2tleScpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGkua2V5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gaS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW2kua2V5LCBpLnZhbHVlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pID0gaTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3JSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb25jZSB0aGUgaXRlcmF0b3IgaXMgZG9uZSwgaXQgaXMgZG9uZSBmb3JldmVyLlxuICAgICAgICAgICAgdGhpcy5pID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yUmVzdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBhZGRJdGVyYXRvcihNYXBJdGVyYXRvci5wcm90b3R5cGUpO1xuXG4gICAgICAgIHZhciBNYXAkcHJvdG90eXBlO1xuICAgICAgICB2YXIgTWFwU2hpbSA9IGZ1bmN0aW9uIE1hcCgpIHtcbiAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29uc3RydWN0b3IgTWFwIHJlcXVpcmVzIFwibmV3XCInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMgJiYgdGhpcy5fZXM2bWFwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCYWQgY29uc3RydWN0aW9uJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtYXAgPSBlbXVsYXRlRVM2Y29uc3RydWN0KHRoaXMsIE1hcCwgTWFwJHByb3RvdHlwZSwge1xuICAgICAgICAgICAgX2VzNm1hcDogdHJ1ZSxcbiAgICAgICAgICAgIF9oZWFkOiBudWxsLFxuICAgICAgICAgICAgX21hcDogT3JpZ01hcCA/IG5ldyBPcmlnTWFwKCkgOiBudWxsLFxuICAgICAgICAgICAgX3NpemU6IDAsXG4gICAgICAgICAgICBfc3RvcmFnZTogZW1wdHlPYmplY3QoKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIGhlYWQgPSBuZXcgTWFwRW50cnkobnVsbCwgbnVsbCk7XG4gICAgICAgICAgLy8gY2lyY3VsYXIgZG91Ymx5LWxpbmtlZCBsaXN0LlxuICAgICAgICAgIC8qIGVzbGludCBuby1tdWx0aS1hc3NpZ246IDEgKi9cbiAgICAgICAgICBoZWFkLm5leHQgPSBoZWFkLnByZXYgPSBoZWFkO1xuICAgICAgICAgIG1hcC5faGVhZCA9IGhlYWQ7XG5cbiAgICAgICAgICAvLyBPcHRpb25hbGx5IGluaXRpYWxpemUgbWFwIGZyb20gaXRlcmFibGVcbiAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGFkZEl0ZXJhYmxlVG9NYXAoTWFwLCBtYXAsIGFyZ3VtZW50c1swXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgIH07XG4gICAgICAgIE1hcCRwcm90b3R5cGUgPSBNYXBTaGltLnByb3RvdHlwZTtcblxuICAgICAgICBWYWx1ZS5nZXR0ZXIoTWFwJHByb3RvdHlwZSwgJ3NpemUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9zaXplID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZSBtZXRob2QgY2FsbGVkIG9uIGluY29tcGF0aWJsZSBNYXAnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMoTWFwJHByb3RvdHlwZSwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgICAgICAgcmVxdWlyZU1hcFNsb3QodGhpcywgJ2dldCcpO1xuICAgICAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICAgICAgdmFyIGZrZXkgPSBmYXN0a2V5KGtleSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoZmtleSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBmYXN0IE8oMSkgcGF0aFxuICAgICAgICAgICAgICBlbnRyeSA9IHRoaXMuX3N0b3JhZ2VbZmtleV07XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXApIHtcbiAgICAgICAgICAgICAgLy8gZmFzdCBvYmplY3Qga2V5IHBhdGhcbiAgICAgICAgICAgICAgZW50cnkgPSBvcmlnTWFwR2V0LmNhbGwodGhpcy5fbWFwLCBrZXkpO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgICAgICB2YXIgaSA9IGhlYWQ7XG4gICAgICAgICAgICB3aGlsZSAoKGkgPSBpLm5leHQpICE9PSBoZWFkKSB7XG4gICAgICAgICAgICAgIGlmIChFUy5TYW1lVmFsdWVaZXJvKGkua2V5LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkudmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgICAgICByZXF1aXJlTWFwU2xvdCh0aGlzLCAnaGFzJyk7XG4gICAgICAgICAgICB2YXIgZmtleSA9IGZhc3RrZXkoa2V5LCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChma2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIGZhc3QgTygxKSBwYXRoXG4gICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5fc3RvcmFnZVtma2V5XSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fbWFwKSB7XG4gICAgICAgICAgICAgIC8vIGZhc3Qgb2JqZWN0IGtleSBwYXRoXG4gICAgICAgICAgICAgIHJldHVybiBvcmlnTWFwSGFzLmNhbGwodGhpcy5fbWFwLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhlYWQgPSB0aGlzLl9oZWFkO1xuICAgICAgICAgICAgdmFyIGkgPSBoZWFkO1xuICAgICAgICAgICAgd2hpbGUgKChpID0gaS5uZXh0KSAhPT0gaGVhZCkge1xuICAgICAgICAgICAgICBpZiAoRVMuU2FtZVZhbHVlWmVybyhpLmtleSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJlcXVpcmVNYXBTbG90KHRoaXMsICdzZXQnKTtcbiAgICAgICAgICAgIHZhciBoZWFkID0gdGhpcy5faGVhZDtcbiAgICAgICAgICAgIHZhciBpID0gaGVhZDtcbiAgICAgICAgICAgIHZhciBlbnRyeTtcbiAgICAgICAgICAgIHZhciBma2V5ID0gZmFzdGtleShrZXksIHRydWUpO1xuICAgICAgICAgICAgaWYgKGZrZXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gZmFzdCBPKDEpIHBhdGhcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9zdG9yYWdlW2ZrZXldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3JhZ2VbZmtleV0udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbnRyeSA9IHRoaXMuX3N0b3JhZ2VbZmtleV0gPSBuZXcgTWFwRW50cnkoa2V5LCB2YWx1ZSk7IC8qIGVzbGludCBuby1tdWx0aS1hc3NpZ246IDEgKi9cbiAgICAgICAgICAgICAgICBpID0gaGVhZC5wcmV2O1xuICAgICAgICAgICAgICAgIC8vIGZhbGwgdGhyb3VnaFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX21hcCkge1xuICAgICAgICAgICAgICAvLyBmYXN0IG9iamVjdCBrZXkgcGF0aFxuICAgICAgICAgICAgICBpZiAob3JpZ01hcEhhcy5jYWxsKHRoaXMuX21hcCwga2V5KSkge1xuICAgICAgICAgICAgICAgIG9yaWdNYXBHZXQuY2FsbCh0aGlzLl9tYXAsIGtleSkudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbnRyeSA9IG5ldyBNYXBFbnRyeShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBvcmlnTWFwU2V0LmNhbGwodGhpcy5fbWFwLCBrZXksIGVudHJ5KTtcbiAgICAgICAgICAgICAgICBpID0gaGVhZC5wcmV2O1xuICAgICAgICAgICAgICAgIC8vIGZhbGwgdGhyb3VnaFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoKGkgPSBpLm5leHQpICE9PSBoZWFkKSB7XG4gICAgICAgICAgICAgIGlmIChFUy5TYW1lVmFsdWVaZXJvKGkua2V5LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgaS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnRyeSA9IGVudHJ5IHx8IG5ldyBNYXBFbnRyeShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChFUy5TYW1lVmFsdWUoLTAsIGtleSkpIHtcbiAgICAgICAgICAgICAgZW50cnkua2V5ID0gKzA7IC8vIGNvZXJjZSAtMCB0byArMCBpbiBlbnRyeVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW50cnkubmV4dCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgICAgICBlbnRyeS5wcmV2ID0gdGhpcy5faGVhZC5wcmV2O1xuICAgICAgICAgICAgZW50cnkucHJldi5uZXh0ID0gZW50cnk7XG4gICAgICAgICAgICBlbnRyeS5uZXh0LnByZXYgPSBlbnRyeTtcbiAgICAgICAgICAgIHRoaXMuX3NpemUgKz0gMTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmVxdWlyZU1hcFNsb3QodGhpcywgJ2RlbGV0ZScpO1xuICAgICAgICAgICAgdmFyIGhlYWQgPSB0aGlzLl9oZWFkO1xuICAgICAgICAgICAgdmFyIGkgPSBoZWFkO1xuICAgICAgICAgICAgdmFyIGZrZXkgPSBmYXN0a2V5KGtleSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoZmtleSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBmYXN0IE8oMSkgcGF0aFxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX3N0b3JhZ2VbZmtleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGkgPSB0aGlzLl9zdG9yYWdlW2ZrZXldLnByZXY7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zdG9yYWdlW2ZrZXldO1xuICAgICAgICAgICAgICAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fbWFwKSB7XG4gICAgICAgICAgICAgIC8vIGZhc3Qgb2JqZWN0IGtleSBwYXRoXG4gICAgICAgICAgICAgIGlmICghb3JpZ01hcEhhcy5jYWxsKHRoaXMuX21hcCwga2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpID0gb3JpZ01hcEdldC5jYWxsKHRoaXMuX21hcCwga2V5KS5wcmV2O1xuICAgICAgICAgICAgICBvcmlnTWFwRGVsZXRlLmNhbGwodGhpcy5fbWFwLCBrZXkpO1xuICAgICAgICAgICAgICAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICgoaSA9IGkubmV4dCkgIT09IGhlYWQpIHtcbiAgICAgICAgICAgICAgaWYgKEVTLlNhbWVWYWx1ZVplcm8oaS5rZXksIGtleSkpIHtcbiAgICAgICAgICAgICAgICBpLmtleSA9IGVtcHR5O1xuICAgICAgICAgICAgICAgIGkudmFsdWUgPSBlbXB0eTtcbiAgICAgICAgICAgICAgICBpLnByZXYubmV4dCA9IGkubmV4dDtcbiAgICAgICAgICAgICAgICBpLm5leHQucHJldiA9IGkucHJldjtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaXplIC09IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICAgICAgLyogZXNsaW50IG5vLW11bHRpLWFzc2lnbjogMSAqL1xuICAgICAgICAgICAgcmVxdWlyZU1hcFNsb3QodGhpcywgJ2NsZWFyJyk7XG4gICAgICAgICAgICB0aGlzLl9tYXAgPSBPcmlnTWFwID8gbmV3IE9yaWdNYXAoKSA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3N0b3JhZ2UgPSBlbXB0eU9iamVjdCgpO1xuICAgICAgICAgICAgdmFyIGhlYWQgPSB0aGlzLl9oZWFkO1xuICAgICAgICAgICAgdmFyIGkgPSBoZWFkO1xuICAgICAgICAgICAgdmFyIHAgPSBpLm5leHQ7XG4gICAgICAgICAgICB3aGlsZSAoKGkgPSBwKSAhPT0gaGVhZCkge1xuICAgICAgICAgICAgICBpLmtleSA9IGVtcHR5O1xuICAgICAgICAgICAgICBpLnZhbHVlID0gZW1wdHk7XG4gICAgICAgICAgICAgIHAgPSBpLm5leHQ7XG4gICAgICAgICAgICAgIGkubmV4dCA9IGkucHJldiA9IGhlYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoZWFkLm5leHQgPSBoZWFkLnByZXYgPSBoZWFkO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBrZXlzOiBmdW5jdGlvbiBrZXlzKCkge1xuICAgICAgICAgICAgcmVxdWlyZU1hcFNsb3QodGhpcywgJ2tleXMnKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcywgJ2tleScpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgICAgICAgIHJlcXVpcmVNYXBTbG90KHRoaXMsICd2YWx1ZXMnKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcywgJ3ZhbHVlJyk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgICAgICAgICByZXF1aXJlTWFwU2xvdCh0aGlzLCAnZW50cmllcycpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXBJdGVyYXRvcih0aGlzLCAna2V5K3ZhbHVlJyk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJlcXVpcmVNYXBTbG90KHRoaXMsICdmb3JFYWNoJyk7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICAgICAgICAgIHZhciBpdCA9IHRoaXMuZW50cmllcygpO1xuICAgICAgICAgICAgZm9yICh2YXIgZW50cnkgPSBpdC5uZXh0KCk7ICFlbnRyeS5kb25lOyBlbnRyeSA9IGl0Lm5leHQoKSkge1xuICAgICAgICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgICAgIF9jYWxsKGNhbGxiYWNrLCBjb250ZXh0LCBlbnRyeS52YWx1ZVsxXSwgZW50cnkudmFsdWVbMF0sIHRoaXMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVudHJ5LnZhbHVlWzFdLCBlbnRyeS52YWx1ZVswXSwgdGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhZGRJdGVyYXRvcihNYXAkcHJvdG90eXBlLCBNYXAkcHJvdG90eXBlLmVudHJpZXMpO1xuXG4gICAgICAgIHJldHVybiBNYXBTaGltO1xuICAgICAgfSgpKSxcblxuICAgICAgU2V0OiAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXNTZXQgPSBmdW5jdGlvbiBpc1NldChzZXQpIHtcbiAgICAgICAgICByZXR1cm4gc2V0Ll9lczZzZXQgJiYgdHlwZW9mIHNldC5fc3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXF1aXJlU2V0U2xvdCA9IGZ1bmN0aW9uIHJlcXVpcmVTZXRTbG90KHNldCwgbWV0aG9kKSB7XG4gICAgICAgICAgaWYgKCFFUy5UeXBlSXNPYmplY3Qoc2V0KSB8fCAhaXNTZXQoc2V0KSkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9lczYtc2hpbS9pc3N1ZXMvMTc2XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTZXQucHJvdG90eXBlLicgKyBtZXRob2QgKyAnIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgcmVjZWl2ZXIgJyArIEVTLlRvU3RyaW5nKHNldCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDcmVhdGluZyBhIE1hcCBpcyBleHBlbnNpdmUuICBUbyBzcGVlZCB1cCB0aGUgY29tbW9uIGNhc2Ugb2ZcbiAgICAgICAgLy8gU2V0cyBjb250YWluaW5nIG9ubHkgc3RyaW5nIG9yIG51bWVyaWMga2V5cywgd2UgdXNlIGFuIG9iamVjdFxuICAgICAgICAvLyBhcyBiYWNraW5nIHN0b3JhZ2UgYW5kIGxhemlseSBjcmVhdGUgYSBmdWxsIE1hcCBvbmx5IHdoZW5cbiAgICAgICAgLy8gcmVxdWlyZWQuXG4gICAgICAgIHZhciBTZXQkcHJvdG90eXBlO1xuICAgICAgICB2YXIgU2V0U2hpbSA9IGZ1bmN0aW9uIFNldCgpIHtcbiAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29uc3RydWN0b3IgU2V0IHJlcXVpcmVzIFwibmV3XCInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMgJiYgdGhpcy5fZXM2c2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCYWQgY29uc3RydWN0aW9uJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzZXQgPSBlbXVsYXRlRVM2Y29uc3RydWN0KHRoaXMsIFNldCwgU2V0JHByb3RvdHlwZSwge1xuICAgICAgICAgICAgX2VzNnNldDogdHJ1ZSxcbiAgICAgICAgICAgICdbW1NldERhdGFdXSc6IG51bGwsXG4gICAgICAgICAgICBfc3RvcmFnZTogZW1wdHlPYmplY3QoKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghc2V0Ll9lczZzZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2JhZCBzZXQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBPcHRpb25hbGx5IGluaXRpYWxpemUgU2V0IGZyb20gaXRlcmFibGVcbiAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGFkZEl0ZXJhYmxlVG9TZXQoU2V0LCBzZXQsIGFyZ3VtZW50c1swXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzZXQ7XG4gICAgICAgIH07XG4gICAgICAgIFNldCRwcm90b3R5cGUgPSBTZXRTaGltLnByb3RvdHlwZTtcblxuICAgICAgICB2YXIgZGVjb2RlS2V5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHZhciBrID0ga2V5O1xuICAgICAgICAgIGlmIChrID09PSAnXm51bGwnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGsgPT09ICdedW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZpcnN0ID0gay5jaGFyQXQoMCk7XG4gICAgICAgICAgICBpZiAoZmlyc3QgPT09ICckJykge1xuICAgICAgICAgICAgICByZXR1cm4gX3N0clNsaWNlKGssIDEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmaXJzdCA9PT0gJ24nKSB7XG4gICAgICAgICAgICAgIHJldHVybiArX3N0clNsaWNlKGssIDEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmaXJzdCA9PT0gJ2InKSB7XG4gICAgICAgICAgICAgIHJldHVybiBrID09PSAnYnRydWUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gK2s7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFN3aXRjaCBmcm9tIHRoZSBvYmplY3QgYmFja2luZyBzdG9yYWdlIHRvIGEgZnVsbCBNYXAuXG4gICAgICAgIHZhciBlbnN1cmVNYXAgPSBmdW5jdGlvbiBlbnN1cmVNYXAoc2V0KSB7XG4gICAgICAgICAgaWYgKCFzZXRbJ1tbU2V0RGF0YV1dJ10pIHtcbiAgICAgICAgICAgIHZhciBtID0gbmV3IGNvbGxlY3Rpb25TaGltcy5NYXAoKTtcbiAgICAgICAgICAgIHNldFsnW1tTZXREYXRhXV0nXSA9IG07XG4gICAgICAgICAgICBfZm9yRWFjaChrZXlzKHNldC5fc3RvcmFnZSksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgdmFyIGsgPSBkZWNvZGVLZXkoa2V5KTtcbiAgICAgICAgICAgICAgbS5zZXQoaywgayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldFsnW1tTZXREYXRhXV0nXSA9IG07XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldC5fc3RvcmFnZSA9IG51bGw7IC8vIGZyZWUgb2xkIGJhY2tpbmcgc3RvcmFnZVxuICAgICAgICB9O1xuXG4gICAgICAgIFZhbHVlLmdldHRlcihTZXRTaGltLnByb3RvdHlwZSwgJ3NpemUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVxdWlyZVNldFNsb3QodGhpcywgJ3NpemUnKTtcbiAgICAgICAgICBpZiAodGhpcy5fc3RvcmFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIGtleXModGhpcy5fc3RvcmFnZSkubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbnN1cmVNYXAodGhpcyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXNbJ1tbU2V0RGF0YV1dJ10uc2l6ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyhTZXRTaGltLnByb3RvdHlwZSwge1xuICAgICAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICAgICAgcmVxdWlyZVNldFNsb3QodGhpcywgJ2hhcycpO1xuICAgICAgICAgICAgdmFyIGZrZXk7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RvcmFnZSAmJiAoZmtleSA9IGZhc3RrZXkoa2V5KSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5fc3RvcmFnZVtma2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuc3VyZU1hcCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzWydbW1NldERhdGFdXSddLmhhcyhrZXkpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBhZGQ6IGZ1bmN0aW9uIGFkZChrZXkpIHtcbiAgICAgICAgICAgIHJlcXVpcmVTZXRTbG90KHRoaXMsICdhZGQnKTtcbiAgICAgICAgICAgIHZhciBma2V5O1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0b3JhZ2UgJiYgKGZrZXkgPSBmYXN0a2V5KGtleSkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3N0b3JhZ2VbZmtleV0gPSB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuc3VyZU1hcCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXNbJ1tbU2V0RGF0YV1dJ10uc2V0KGtleSwga2V5KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmVxdWlyZVNldFNsb3QodGhpcywgJ2RlbGV0ZScpO1xuICAgICAgICAgICAgdmFyIGZrZXk7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RvcmFnZSAmJiAoZmtleSA9IGZhc3RrZXkoa2V5KSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIGhhc0ZLZXkgPSBfaGFzT3duUHJvcGVydHkodGhpcy5fc3RvcmFnZSwgZmtleSk7XG4gICAgICAgICAgICAgIHJldHVybiAoZGVsZXRlIHRoaXMuX3N0b3JhZ2VbZmtleV0pICYmIGhhc0ZLZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnN1cmVNYXAodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1snW1tTZXREYXRhXV0nXVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICAgICAgcmVxdWlyZVNldFNsb3QodGhpcywgJ2NsZWFyJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RvcmFnZSkge1xuICAgICAgICAgICAgICB0aGlzLl9zdG9yYWdlID0gZW1wdHlPYmplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzWydbW1NldERhdGFdXSddKSB7XG4gICAgICAgICAgICAgIHRoaXNbJ1tbU2V0RGF0YV1dJ10uY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICAgICAgICByZXF1aXJlU2V0U2xvdCh0aGlzLCAndmFsdWVzJyk7XG4gICAgICAgICAgICBlbnN1cmVNYXAodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNldEl0ZXJhdG9yKHRoaXNbJ1tbU2V0RGF0YV1dJ10udmFsdWVzKCkpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgICAgICAgcmVxdWlyZVNldFNsb3QodGhpcywgJ2VudHJpZXMnKTtcbiAgICAgICAgICAgIGVuc3VyZU1hcCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2V0SXRlcmF0b3IodGhpc1snW1tTZXREYXRhXV0nXS5lbnRyaWVzKCkpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXF1aXJlU2V0U2xvdCh0aGlzLCAnZm9yRWFjaCcpO1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgICAgICAgICB2YXIgZW50aXJlU2V0ID0gdGhpcztcbiAgICAgICAgICAgIGVuc3VyZU1hcChlbnRpcmVTZXQpO1xuICAgICAgICAgICAgdGhpc1snW1tTZXREYXRhXV0nXS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgX2NhbGwoY2FsbGJhY2ssIGNvbnRleHQsIGtleSwga2V5LCBlbnRpcmVTZXQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGtleSwga2V5LCBlbnRpcmVTZXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eShTZXRTaGltLnByb3RvdHlwZSwgJ2tleXMnLCBTZXRTaGltLnByb3RvdHlwZS52YWx1ZXMsIHRydWUpO1xuICAgICAgICBhZGRJdGVyYXRvcihTZXRTaGltLnByb3RvdHlwZSwgU2V0U2hpbS5wcm90b3R5cGUudmFsdWVzKTtcblxuICAgICAgICB2YXIgU2V0SXRlcmF0b3IgPSBmdW5jdGlvbiBTZXRJdGVyYXRvcihpdCkge1xuICAgICAgICAgIHRoaXMuaXQgPSBpdDtcbiAgICAgICAgfTtcbiAgICAgICAgU2V0SXRlcmF0b3IucHJvdG90eXBlID0ge1xuICAgICAgICAgIGlzU2V0SXRlcmF0b3I6IHRydWUsXG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1NldEl0ZXJhdG9yKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBhIFNldEl0ZXJhdG9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdC5uZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBhZGRJdGVyYXRvcihTZXRJdGVyYXRvci5wcm90b3R5cGUpO1xuXG4gICAgICAgIHJldHVybiBTZXRTaGltO1xuICAgICAgfSgpKVxuICAgIH07XG5cbiAgICB2YXIgaXNHb29nbGVUcmFuc2xhdGUgPSBnbG9iYWxzLlNldCAmJiAhU2V0LnByb3RvdHlwZVsnZGVsZXRlJ10gJiYgU2V0LnByb3RvdHlwZS5yZW1vdmUgJiYgU2V0LnByb3RvdHlwZS5pdGVtcyAmJiBTZXQucHJvdG90eXBlLm1hcCAmJiBBcnJheS5pc0FycmF5KG5ldyBTZXQoKS5rZXlzKTtcbiAgICBpZiAoaXNHb29nbGVUcmFuc2xhdGUpIHtcbiAgICAgIC8vIHNwZWNpYWwtY2FzZSBmb3JjZSByZW1vdmFsIG9mIHdpbGRseSBpbnZhbGlkIFNldCBpbXBsZW1lbnRhdGlvbiBpbiBHb29nbGUgVHJhbnNsYXRlIGlmcmFtZXNcbiAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL2VzNi1zaGltL2lzc3Vlcy80MzggLyBodHRwczovL3R3aXR0ZXIuY29tL2xqaGFyYi9zdGF0dXMvODQ5MzM1NTczMTE0MzYzOTA0XG4gICAgICBnbG9iYWxzLlNldCA9IGNvbGxlY3Rpb25TaGltcy5TZXQ7XG4gICAgfVxuICAgIGlmIChnbG9iYWxzLk1hcCB8fCBnbG9iYWxzLlNldCkge1xuICAgICAgLy8gU2FmYXJpIDgsIGZvciBleGFtcGxlLCBkb2Vzbid0IGFjY2VwdCBhbiBpdGVyYWJsZS5cbiAgICAgIHZhciBtYXBBY2NlcHRzQXJndW1lbnRzID0gdmFsdWVPckZhbHNlSWZUaHJvd3MoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IE1hcChbWzEsIDJdXSkuZ2V0KDEpID09PSAyOyB9KTtcbiAgICAgIGlmICghbWFwQWNjZXB0c0FyZ3VtZW50cykge1xuICAgICAgICBnbG9iYWxzLk1hcCA9IGZ1bmN0aW9uIE1hcCgpIHtcbiAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29uc3RydWN0b3IgTWFwIHJlcXVpcmVzIFwibmV3XCInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG0gPSBuZXcgT3JpZ01hcCgpO1xuICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYWRkSXRlcmFibGVUb01hcChNYXAsIG0sIGFyZ3VtZW50c1swXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSBtLmNvbnN0cnVjdG9yO1xuICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihtLCBnbG9iYWxzLk1hcC5wcm90b3R5cGUpO1xuICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9O1xuICAgICAgICBnbG9iYWxzLk1hcC5wcm90b3R5cGUgPSBjcmVhdGUoT3JpZ01hcC5wcm90b3R5cGUpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eShnbG9iYWxzLk1hcC5wcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIGdsb2JhbHMuTWFwLCB0cnVlKTtcbiAgICAgICAgVmFsdWUucHJlc2VydmVUb1N0cmluZyhnbG9iYWxzLk1hcCwgT3JpZ01hcCk7XG4gICAgICB9XG4gICAgICB2YXIgdGVzdE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgIHZhciBtYXBVc2VzU2FtZVZhbHVlWmVybyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENocm9tZSAzOC00Miwgbm9kZSAwLjExLzAuMTIsIGlvanMgMS8yIGFsc28gaGF2ZSBhIGJ1ZyB3aGVuIHRoZSBNYXAgaGFzIGEgc2l6ZSA+IDRcbiAgICAgICAgdmFyIG0gPSBuZXcgTWFwKFtbMSwgMF0sIFsyLCAwXSwgWzMsIDBdLCBbNCwgMF1dKTtcbiAgICAgICAgbS5zZXQoLTAsIG0pO1xuICAgICAgICByZXR1cm4gbS5nZXQoMCkgPT09IG0gJiYgbS5nZXQoLTApID09PSBtICYmIG0uaGFzKDApICYmIG0uaGFzKC0wKTtcbiAgICAgIH0oKSk7XG4gICAgICB2YXIgbWFwU3VwcG9ydHNDaGFpbmluZyA9IHRlc3RNYXAuc2V0KDEsIDIpID09PSB0ZXN0TWFwO1xuICAgICAgaWYgKCFtYXBVc2VzU2FtZVZhbHVlWmVybyB8fCAhbWFwU3VwcG9ydHNDaGFpbmluZykge1xuICAgICAgICBvdmVycmlkZU5hdGl2ZShNYXAucHJvdG90eXBlLCAnc2V0JywgZnVuY3Rpb24gc2V0KGssIHYpIHtcbiAgICAgICAgICBfY2FsbChvcmlnTWFwU2V0LCB0aGlzLCBrID09PSAwID8gMCA6IGssIHYpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghbWFwVXNlc1NhbWVWYWx1ZVplcm8pIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyhNYXAucHJvdG90eXBlLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoaykge1xuICAgICAgICAgICAgcmV0dXJuIF9jYWxsKG9yaWdNYXBHZXQsIHRoaXMsIGsgPT09IDAgPyAwIDogayk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrKSB7XG4gICAgICAgICAgICByZXR1cm4gX2NhbGwob3JpZ01hcEhhcywgdGhpcywgayA9PT0gMCA/IDAgOiBrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICBWYWx1ZS5wcmVzZXJ2ZVRvU3RyaW5nKE1hcC5wcm90b3R5cGUuZ2V0LCBvcmlnTWFwR2V0KTtcbiAgICAgICAgVmFsdWUucHJlc2VydmVUb1N0cmluZyhNYXAucHJvdG90eXBlLmhhcywgb3JpZ01hcEhhcyk7XG4gICAgICB9XG4gICAgICB2YXIgdGVzdFNldCA9IG5ldyBTZXQoKTtcbiAgICAgIHZhciBzZXRVc2VzU2FtZVZhbHVlWmVybyA9IFNldC5wcm90b3R5cGVbJ2RlbGV0ZSddICYmIFNldC5wcm90b3R5cGUuYWRkICYmIFNldC5wcm90b3R5cGUuaGFzICYmIChmdW5jdGlvbiAocykge1xuICAgICAgICBzWydkZWxldGUnXSgwKTtcbiAgICAgICAgcy5hZGQoLTApO1xuICAgICAgICByZXR1cm4gIXMuaGFzKDApO1xuICAgICAgfSh0ZXN0U2V0KSk7XG4gICAgICB2YXIgc2V0U3VwcG9ydHNDaGFpbmluZyA9IHRlc3RTZXQuYWRkKDEpID09PSB0ZXN0U2V0O1xuICAgICAgaWYgKCFzZXRVc2VzU2FtZVZhbHVlWmVybyB8fCAhc2V0U3VwcG9ydHNDaGFpbmluZykge1xuICAgICAgICB2YXIgb3JpZ1NldEFkZCA9IFNldC5wcm90b3R5cGUuYWRkO1xuICAgICAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCh2KSB7XG4gICAgICAgICAgX2NhbGwob3JpZ1NldEFkZCwgdGhpcywgdiA9PT0gMCA/IDAgOiB2KTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgVmFsdWUucHJlc2VydmVUb1N0cmluZyhTZXQucHJvdG90eXBlLmFkZCwgb3JpZ1NldEFkZCk7XG4gICAgICB9XG4gICAgICBpZiAoIXNldFVzZXNTYW1lVmFsdWVaZXJvKSB7XG4gICAgICAgIHZhciBvcmlnU2V0SGFzID0gU2V0LnByb3RvdHlwZS5oYXM7XG4gICAgICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzKHYpIHtcbiAgICAgICAgICByZXR1cm4gX2NhbGwob3JpZ1NldEhhcywgdGhpcywgdiA9PT0gMCA/IDAgOiB2KTtcbiAgICAgICAgfTtcbiAgICAgICAgVmFsdWUucHJlc2VydmVUb1N0cmluZyhTZXQucHJvdG90eXBlLmhhcywgb3JpZ1NldEhhcyk7XG4gICAgICAgIHZhciBvcmlnU2V0RGVsID0gU2V0LnByb3RvdHlwZVsnZGVsZXRlJ107XG4gICAgICAgIFNldC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24gU2V0RGVsZXRlKHYpIHtcbiAgICAgICAgICByZXR1cm4gX2NhbGwob3JpZ1NldERlbCwgdGhpcywgdiA9PT0gMCA/IDAgOiB2KTtcbiAgICAgICAgfTtcbiAgICAgICAgVmFsdWUucHJlc2VydmVUb1N0cmluZyhTZXQucHJvdG90eXBlWydkZWxldGUnXSwgb3JpZ1NldERlbCk7XG4gICAgICB9XG4gICAgICB2YXIgbWFwU3VwcG9ydHNTdWJjbGFzc2luZyA9IHN1cHBvcnRzU3ViY2xhc3NpbmcoZ2xvYmFscy5NYXAsIGZ1bmN0aW9uIChNKSB7XG4gICAgICAgIHZhciBtID0gbmV3IE0oW10pO1xuICAgICAgICAvLyBGaXJlZm94IDMyIGlzIG9rIHdpdGggdGhlIGluc3RhbnRpYXRpbmcgdGhlIHN1YmNsYXNzIGJ1dCB3aWxsXG4gICAgICAgIC8vIHRocm93IHdoZW4gdGhlIG1hcCBpcyB1c2VkLlxuICAgICAgICBtLnNldCg0MiwgNDIpO1xuICAgICAgICByZXR1cm4gbSBpbnN0YW5jZW9mIE07XG4gICAgICB9KTtcbiAgICAgIC8vIHdpdGhvdXQgT2JqZWN0LnNldFByb3RvdHlwZU9mLCBzdWJjbGFzc2luZyBpcyBub3QgcG9zc2libGVcbiAgICAgIHZhciBtYXBGYWlsc1RvU3VwcG9ydFN1YmNsYXNzaW5nID0gT2JqZWN0LnNldFByb3RvdHlwZU9mICYmICFtYXBTdXBwb3J0c1N1YmNsYXNzaW5nO1xuICAgICAgdmFyIG1hcFJlcXVpcmVzTmV3ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gIShnbG9iYWxzLk1hcCgpIGluc3RhbmNlb2YgZ2xvYmFscy5NYXApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBUeXBlRXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0oKSk7XG4gICAgICBpZiAoZ2xvYmFscy5NYXAubGVuZ3RoICE9PSAwIHx8IG1hcEZhaWxzVG9TdXBwb3J0U3ViY2xhc3NpbmcgfHwgIW1hcFJlcXVpcmVzTmV3KSB7XG4gICAgICAgIGdsb2JhbHMuTWFwID0gZnVuY3Rpb24gTWFwKCkge1xuICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYXApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb25zdHJ1Y3RvciBNYXAgcmVxdWlyZXMgXCJuZXdcIicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbSA9IG5ldyBPcmlnTWFwKCk7XG4gICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBhZGRJdGVyYWJsZVRvTWFwKE1hcCwgbSwgYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsZXRlIG0uY29uc3RydWN0b3I7XG4gICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG0sIE1hcC5wcm90b3R5cGUpO1xuICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9O1xuICAgICAgICBnbG9iYWxzLk1hcC5wcm90b3R5cGUgPSBPcmlnTWFwLnByb3RvdHlwZTtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkoZ2xvYmFscy5NYXAucHJvdG90eXBlLCAnY29uc3RydWN0b3InLCBnbG9iYWxzLk1hcCwgdHJ1ZSk7XG4gICAgICAgIFZhbHVlLnByZXNlcnZlVG9TdHJpbmcoZ2xvYmFscy5NYXAsIE9yaWdNYXApO1xuICAgICAgfVxuICAgICAgdmFyIHNldFN1cHBvcnRzU3ViY2xhc3NpbmcgPSBzdXBwb3J0c1N1YmNsYXNzaW5nKGdsb2JhbHMuU2V0LCBmdW5jdGlvbiAoUykge1xuICAgICAgICB2YXIgcyA9IG5ldyBTKFtdKTtcbiAgICAgICAgcy5hZGQoNDIsIDQyKTtcbiAgICAgICAgcmV0dXJuIHMgaW5zdGFuY2VvZiBTO1xuICAgICAgfSk7XG4gICAgICAvLyB3aXRob3V0IE9iamVjdC5zZXRQcm90b3R5cGVPZiwgc3ViY2xhc3NpbmcgaXMgbm90IHBvc3NpYmxlXG4gICAgICB2YXIgc2V0RmFpbHNUb1N1cHBvcnRTdWJjbGFzc2luZyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiAmJiAhc2V0U3VwcG9ydHNTdWJjbGFzc2luZztcbiAgICAgIHZhciBzZXRSZXF1aXJlc05ldyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuICEoZ2xvYmFscy5TZXQoKSBpbnN0YW5jZW9mIGdsb2JhbHMuU2V0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgVHlwZUVycm9yO1xuICAgICAgICB9XG4gICAgICB9KCkpO1xuICAgICAgaWYgKGdsb2JhbHMuU2V0Lmxlbmd0aCAhPT0gMCB8fCBzZXRGYWlsc1RvU3VwcG9ydFN1YmNsYXNzaW5nIHx8ICFzZXRSZXF1aXJlc05ldykge1xuICAgICAgICB2YXIgT3JpZ1NldCA9IGdsb2JhbHMuU2V0O1xuICAgICAgICBnbG9iYWxzLlNldCA9IGZ1bmN0aW9uIFNldCgpIHtcbiAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29uc3RydWN0b3IgU2V0IHJlcXVpcmVzIFwibmV3XCInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHMgPSBuZXcgT3JpZ1NldCgpO1xuICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYWRkSXRlcmFibGVUb1NldChTZXQsIHMsIGFyZ3VtZW50c1swXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSBzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihzLCBTZXQucHJvdG90eXBlKTtcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfTtcbiAgICAgICAgZ2xvYmFscy5TZXQucHJvdG90eXBlID0gT3JpZ1NldC5wcm90b3R5cGU7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KGdsb2JhbHMuU2V0LnByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgZ2xvYmFscy5TZXQsIHRydWUpO1xuICAgICAgICBWYWx1ZS5wcmVzZXJ2ZVRvU3RyaW5nKGdsb2JhbHMuU2V0LCBPcmlnU2V0KTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdNYXAgPSBuZXcgZ2xvYmFscy5NYXAoKTtcbiAgICAgIHZhciBtYXBJdGVyYXRpb25UaHJvd3NTdG9wSXRlcmF0b3IgPSAhdmFsdWVPckZhbHNlSWZUaHJvd3MoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3TWFwLmtleXMoKS5uZXh0KCkuZG9uZTtcbiAgICAgIH0pO1xuICAgICAgLypcbiAgICAgICAgLSBJbiBGaXJlZm94IDwgMjMsIE1hcCNzaXplIGlzIGEgZnVuY3Rpb24uXG4gICAgICAgIC0gSW4gYWxsIGN1cnJlbnQgRmlyZWZveCwgU2V0I2VudHJpZXMva2V5cy92YWx1ZXMgJiBNYXAjY2xlYXIgZG8gbm90IGV4aXN0XG4gICAgICAgIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODY5OTk2XG4gICAgICAgIC0gSW4gRmlyZWZveCAyNCwgTWFwIGFuZCBTZXQgZG8gbm90IGltcGxlbWVudCBmb3JFYWNoXG4gICAgICAgIC0gSW4gRmlyZWZveCAyNSBhdCBsZWFzdCwgTWFwIGFuZCBTZXQgYXJlIGNhbGxhYmxlIHdpdGhvdXQgXCJuZXdcIlxuICAgICAgKi9cbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIGdsb2JhbHMuTWFwLnByb3RvdHlwZS5jbGVhciAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICBuZXcgZ2xvYmFscy5TZXQoKS5zaXplICE9PSAwIHx8XG4gICAgICAgIG5ld01hcC5zaXplICE9PSAwIHx8XG4gICAgICAgIHR5cGVvZiBnbG9iYWxzLk1hcC5wcm90b3R5cGUua2V5cyAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICB0eXBlb2YgZ2xvYmFscy5TZXQucHJvdG90eXBlLmtleXMgIT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgdHlwZW9mIGdsb2JhbHMuTWFwLnByb3RvdHlwZS5mb3JFYWNoICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIHR5cGVvZiBnbG9iYWxzLlNldC5wcm90b3R5cGUuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICBpc0NhbGxhYmxlV2l0aG91dE5ldyhnbG9iYWxzLk1hcCkgfHxcbiAgICAgICAgaXNDYWxsYWJsZVdpdGhvdXROZXcoZ2xvYmFscy5TZXQpIHx8XG4gICAgICAgIHR5cGVvZiBuZXdNYXAua2V5cygpLm5leHQgIT09ICdmdW5jdGlvbicgfHwgLy8gU2FmYXJpIDhcbiAgICAgICAgbWFwSXRlcmF0aW9uVGhyb3dzU3RvcEl0ZXJhdG9yIHx8IC8vIEZpcmVmb3ggMjVcbiAgICAgICAgIW1hcFN1cHBvcnRzU3ViY2xhc3NpbmdcbiAgICAgICkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKGdsb2JhbHMsIHtcbiAgICAgICAgICBNYXA6IGNvbGxlY3Rpb25TaGltcy5NYXAsXG4gICAgICAgICAgU2V0OiBjb2xsZWN0aW9uU2hpbXMuU2V0XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2xvYmFscy5TZXQucHJvdG90eXBlLmtleXMgIT09IGdsb2JhbHMuU2V0LnByb3RvdHlwZS52YWx1ZXMpIHtcbiAgICAgICAgLy8gRml4ZWQgaW4gV2ViS2l0IHdpdGggaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE0NDE5MFxuICAgICAgICBkZWZpbmVQcm9wZXJ0eShnbG9iYWxzLlNldC5wcm90b3R5cGUsICdrZXlzJywgZ2xvYmFscy5TZXQucHJvdG90eXBlLnZhbHVlcywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNoaW0gaW5jb21wbGV0ZSBpdGVyYXRvciBpbXBsZW1lbnRhdGlvbnMuXG4gICAgICBhZGRJdGVyYXRvcihPYmplY3QuZ2V0UHJvdG90eXBlT2YoKG5ldyBnbG9iYWxzLk1hcCgpKS5rZXlzKCkpKTtcbiAgICAgIGFkZEl0ZXJhdG9yKE9iamVjdC5nZXRQcm90b3R5cGVPZigobmV3IGdsb2JhbHMuU2V0KCkpLmtleXMoKSkpO1xuXG4gICAgICBpZiAoZnVuY3Rpb25zSGF2ZU5hbWVzICYmIGdsb2JhbHMuU2V0LnByb3RvdHlwZS5oYXMubmFtZSAhPT0gJ2hhcycpIHtcbiAgICAgICAgLy8gTWljcm9zb2Z0IEVkZ2UgdjAuMTEuMTAwNzQuMCBpcyBtaXNzaW5nIGEgbmFtZSBvbiBTZXQjaGFzXG4gICAgICAgIHZhciBhbm9ueW1vdXNTZXRIYXMgPSBnbG9iYWxzLlNldC5wcm90b3R5cGUuaGFzO1xuICAgICAgICBvdmVycmlkZU5hdGl2ZShnbG9iYWxzLlNldC5wcm90b3R5cGUsICdoYXMnLCBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIF9jYWxsKGFub255bW91c1NldEhhcywgdGhpcywga2V5KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGRlZmluZVByb3BlcnRpZXMoZ2xvYmFscywgY29sbGVjdGlvblNoaW1zKTtcbiAgICBhZGREZWZhdWx0U3BlY2llcyhnbG9iYWxzLk1hcCk7XG4gICAgYWRkRGVmYXVsdFNwZWNpZXMoZ2xvYmFscy5TZXQpO1xuICB9XG5cbiAgdmFyIHRocm93VW5sZXNzVGFyZ2V0SXNPYmplY3QgPSBmdW5jdGlvbiB0aHJvd1VubGVzc1RhcmdldElzT2JqZWN0KHRhcmdldCkge1xuICAgIGlmICghRVMuVHlwZUlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhcmdldCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH1cbiAgfTtcblxuICAvLyBTb21lIFJlZmxlY3QgbWV0aG9kcyBhcmUgYmFzaWNhbGx5IHRoZSBzYW1lIGFzXG4gIC8vIHRob3NlIG9uIHRoZSBPYmplY3QgZ2xvYmFsLCBleGNlcHQgdGhhdCBhIFR5cGVFcnJvciBpcyB0aHJvd24gaWZcbiAgLy8gdGFyZ2V0IGlzbid0IGFuIG9iamVjdC4gQXMgd2VsbCBhcyByZXR1cm5pbmcgYSBib29sZWFuIGluZGljYXRpbmdcbiAgLy8gdGhlIHN1Y2Nlc3Mgb2YgdGhlIG9wZXJhdGlvbi5cbiAgdmFyIFJlZmxlY3RTaGltcyA9IHtcbiAgICAvLyBBcHBseSBtZXRob2QgaW4gYSBmdW5jdGlvbmFsIGZvcm0uXG4gICAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KCkge1xuICAgICAgcmV0dXJuIEVTLkNhbGwoRVMuQ2FsbCwgbnVsbCwgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLy8gTmV3IG9wZXJhdG9yIGluIGEgZnVuY3Rpb25hbCBmb3JtLlxuICAgIGNvbnN0cnVjdDogZnVuY3Rpb24gY29uc3RydWN0KGNvbnN0cnVjdG9yLCBhcmdzKSB7XG4gICAgICBpZiAoIUVTLklzQ29uc3RydWN0b3IoY29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBjb25zdHJ1Y3Rvci4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdUYXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IGNvbnN0cnVjdG9yO1xuICAgICAgaWYgKCFFUy5Jc0NvbnN0cnVjdG9yKG5ld1RhcmdldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbmV3LnRhcmdldCBtdXN0IGJlIGEgY29uc3RydWN0b3IuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gRVMuQ29uc3RydWN0KGNvbnN0cnVjdG9yLCBhcmdzLCBuZXdUYXJnZXQsICdpbnRlcm5hbCcpO1xuICAgIH0sXG5cbiAgICAvLyBXaGVuIGRlbGV0aW5nIGEgbm9uLWV4aXN0ZW50IG9yIGNvbmZpZ3VyYWJsZSBwcm9wZXJ0eSxcbiAgICAvLyB0cnVlIGlzIHJldHVybmVkLlxuICAgIC8vIFdoZW4gYXR0ZW1wdGluZyB0byBkZWxldGUgYSBub24tY29uZmlndXJhYmxlIHByb3BlcnR5LFxuICAgIC8vIGl0IHdpbGwgcmV0dXJuIGZhbHNlLlxuICAgIGRlbGV0ZVByb3BlcnR5OiBmdW5jdGlvbiBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xuICAgICAgdGhyb3dVbmxlc3NUYXJnZXRJc09iamVjdCh0YXJnZXQpO1xuICAgICAgaWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcbiAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcblxuICAgICAgICBpZiAoZGVzYyAmJiAhZGVzYy5jb25maWd1cmFibGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gV2lsbCByZXR1cm4gdHJ1ZS5cbiAgICAgIHJldHVybiBkZWxldGUgdGFyZ2V0W2tleV07XG4gICAgfSxcblxuICAgIGhhczogZnVuY3Rpb24gaGFzKHRhcmdldCwga2V5KSB7XG4gICAgICB0aHJvd1VubGVzc1RhcmdldElzT2JqZWN0KHRhcmdldCk7XG4gICAgICByZXR1cm4ga2V5IGluIHRhcmdldDtcbiAgICB9XG4gIH07XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKSB7XG4gICAgT2JqZWN0LmFzc2lnbihSZWZsZWN0U2hpbXMsIHtcbiAgICAgIC8vIEJhc2ljYWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIGludGVybmFsIFtbT3duUHJvcGVydHlLZXlzXV0uXG4gICAgICAvLyBDb25jYXRlbmF0aW5nIHByb3BlcnR5TmFtZXMgYW5kIHByb3BlcnR5U3ltYm9scyBzaG91bGQgZG8gdGhlIHRyaWNrLlxuICAgICAgLy8gVGhpcyBzaG91bGQgY29udGludWUgdG8gd29yayB0b2dldGhlciB3aXRoIGEgU3ltYm9sIHNoaW1cbiAgICAgIC8vIHdoaWNoIG92ZXJyaWRlcyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyBhbmQgaW1wbGVtZW50c1xuICAgICAgLy8gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scy5cbiAgICAgIG93bktleXM6IGZ1bmN0aW9uIG93bktleXModGFyZ2V0KSB7XG4gICAgICAgIHRocm93VW5sZXNzVGFyZ2V0SXNPYmplY3QodGFyZ2V0KTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuXG4gICAgICAgIGlmIChFUy5Jc0NhbGxhYmxlKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpKSB7XG4gICAgICAgICAgX3B1c2hBcHBseShrZXlzLCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgY2FsbEFuZENhdGNoRXhjZXB0aW9uID0gZnVuY3Rpb24gQ29udmVydEV4Y2VwdGlvblRvQm9vbGVhbihmdW5jKSB7XG4gICAgcmV0dXJuICF0aHJvd3NFcnJvcihmdW5jKTtcbiAgfTtcblxuICBpZiAoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKSB7XG4gICAgT2JqZWN0LmFzc2lnbihSZWZsZWN0U2hpbXMsIHtcbiAgICAgIGlzRXh0ZW5zaWJsZTogZnVuY3Rpb24gaXNFeHRlbnNpYmxlKHRhcmdldCkge1xuICAgICAgICB0aHJvd1VubGVzc1RhcmdldElzT2JqZWN0KHRhcmdldCk7XG4gICAgICAgIHJldHVybiBPYmplY3QuaXNFeHRlbnNpYmxlKHRhcmdldCk7XG4gICAgICB9LFxuICAgICAgcHJldmVudEV4dGVuc2lvbnM6IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCkge1xuICAgICAgICB0aHJvd1VubGVzc1RhcmdldElzT2JqZWN0KHRhcmdldCk7XG4gICAgICAgIHJldHVybiBjYWxsQW5kQ2F0Y2hFeGNlcHRpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGFyZ2V0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuICAgIHZhciBpbnRlcm5hbEdldCA9IGZ1bmN0aW9uIGdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpIHtcbiAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG5cbiAgICAgIGlmICghZGVzYykge1xuICAgICAgICB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCk7XG5cbiAgICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxHZXQocGFyZW50LCBrZXksIHJlY2VpdmVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCd2YWx1ZScgaW4gZGVzYykge1xuICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgIHJldHVybiBFUy5DYWxsKGRlc2MuZ2V0LCByZWNlaXZlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcblxuICAgIHZhciBpbnRlcm5hbFNldCA9IGZ1bmN0aW9uIHNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuXG4gICAgICBpZiAoIWRlc2MpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpO1xuXG4gICAgICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuYWxTZXQocGFyZW50LCBrZXksIHZhbHVlLCByZWNlaXZlcik7XG4gICAgICAgIH1cblxuICAgICAgICBkZXNjID0ge1xuICAgICAgICAgIHZhbHVlOiB2b2lkIDAsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKCd2YWx1ZScgaW4gZGVzYykge1xuICAgICAgICBpZiAoIWRlc2Mud3JpdGFibGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUVTLlR5cGVJc09iamVjdChyZWNlaXZlcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXhpc3RpbmdEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyZWNlaXZlciwga2V5KTtcblxuICAgICAgICBpZiAoZXhpc3RpbmdEZXNjKSB7XG4gICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICAgIF9jYWxsKGRlc2Muc2V0LCByZWNlaXZlciwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBPYmplY3QuYXNzaWduKFJlZmxlY3RTaGltcywge1xuICAgICAgZGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdGhyb3dVbmxlc3NUYXJnZXRJc09iamVjdCh0YXJnZXQpO1xuICAgICAgICByZXR1cm4gY2FsbEFuZENhdGNoRXhjZXB0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICAgICAgdGhyb3dVbmxlc3NUYXJnZXRJc09iamVjdCh0YXJnZXQpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIFN5bnRheCBpbiBhIGZ1bmN0aW9uYWwgZm9ybS5cbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgICAgIHRocm93VW5sZXNzVGFyZ2V0SXNPYmplY3QodGFyZ2V0KTtcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB0YXJnZXQ7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFsR2V0KHRhcmdldCwga2V5LCByZWNlaXZlcik7XG4gICAgICB9LFxuXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhyb3dVbmxlc3NUYXJnZXRJc09iamVjdCh0YXJnZXQpO1xuICAgICAgICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IHRhcmdldDtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxTZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKSB7XG4gICAgdmFyIG9iamVjdERvdEdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICAgIFJlZmxlY3RTaGltcy5nZXRQcm90b3R5cGVPZiA9IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKHRhcmdldCkge1xuICAgICAgdGhyb3dVbmxlc3NUYXJnZXRJc09iamVjdCh0YXJnZXQpO1xuICAgICAgcmV0dXJuIG9iamVjdERvdEdldFByb3RvdHlwZU9mKHRhcmdldCk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YgJiYgUmVmbGVjdFNoaW1zLmdldFByb3RvdHlwZU9mKSB7XG4gICAgdmFyIHdpbGxDcmVhdGVDaXJjdWxhclByb3RvdHlwZSA9IGZ1bmN0aW9uIChvYmplY3QsIGxhc3RQcm90bykge1xuICAgICAgdmFyIHByb3RvID0gbGFzdFByb3RvO1xuICAgICAgd2hpbGUgKHByb3RvKSB7XG4gICAgICAgIGlmIChvYmplY3QgPT09IHByb3RvKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcHJvdG8gPSBSZWZsZWN0U2hpbXMuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBPYmplY3QuYXNzaWduKFJlZmxlY3RTaGltcywge1xuICAgICAgLy8gU2V0cyB0aGUgcHJvdG90eXBlIG9mIHRoZSBnaXZlbiBvYmplY3QuXG4gICAgICAvLyBSZXR1cm5zIHRydWUgb24gc3VjY2Vzcywgb3RoZXJ3aXNlIGZhbHNlLlxuICAgICAgc2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKG9iamVjdCwgcHJvdG8pIHtcbiAgICAgICAgdGhyb3dVbmxlc3NUYXJnZXRJc09iamVjdChvYmplY3QpO1xuICAgICAgICBpZiAocHJvdG8gIT09IG51bGwgJiYgIUVTLlR5cGVJc09iamVjdChwcm90bykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcm90byBtdXN0IGJlIGFuIG9iamVjdCBvciBudWxsJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGV5IGFscmVhZHkgYXJlIHRoZSBzYW1lLCB3ZSdyZSBkb25lLlxuICAgICAgICBpZiAocHJvdG8gPT09IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2Fubm90IGFsdGVyIHByb3RvdHlwZSBpZiBvYmplY3Qgbm90IGV4dGVuc2libGUuXG4gICAgICAgIGlmIChSZWZsZWN0LmlzRXh0ZW5zaWJsZSAmJiAhUmVmbGVjdC5pc0V4dGVuc2libGUob2JqZWN0KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHdlIGRvIG5vdCBjcmVhdGUgYSBjaXJjdWxhciBwcm90b3R5cGUgY2hhaW4uXG4gICAgICAgIGlmICh3aWxsQ3JlYXRlQ2lyY3VsYXJQcm90b3R5cGUob2JqZWN0LCBwcm90bykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yob2JqZWN0LCBwcm90byk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdmFyIGRlZmluZU9yT3ZlcnJpZGVSZWZsZWN0UHJvcGVydHkgPSBmdW5jdGlvbiAoa2V5LCBzaGltKSB7XG4gICAgaWYgKCFFUy5Jc0NhbGxhYmxlKGdsb2JhbHMuUmVmbGVjdFtrZXldKSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkoZ2xvYmFscy5SZWZsZWN0LCBrZXksIHNoaW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWNjZXB0c1ByaW1pdGl2ZXMgPSB2YWx1ZU9yRmFsc2VJZlRocm93cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGdsb2JhbHMuUmVmbGVjdFtrZXldKDEpO1xuICAgICAgICBnbG9iYWxzLlJlZmxlY3Rba2V5XShOYU4pO1xuICAgICAgICBnbG9iYWxzLlJlZmxlY3Rba2V5XSh0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICAgIGlmIChhY2NlcHRzUHJpbWl0aXZlcykge1xuICAgICAgICBvdmVycmlkZU5hdGl2ZShnbG9iYWxzLlJlZmxlY3QsIGtleSwgc2hpbSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBPYmplY3Qua2V5cyhSZWZsZWN0U2hpbXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGRlZmluZU9yT3ZlcnJpZGVSZWZsZWN0UHJvcGVydHkoa2V5LCBSZWZsZWN0U2hpbXNba2V5XSk7XG4gIH0pO1xuICB2YXIgb3JpZ2luYWxSZWZsZWN0R2V0UHJvdG8gPSBnbG9iYWxzLlJlZmxlY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIGlmIChmdW5jdGlvbnNIYXZlTmFtZXMgJiYgb3JpZ2luYWxSZWZsZWN0R2V0UHJvdG8gJiYgb3JpZ2luYWxSZWZsZWN0R2V0UHJvdG8ubmFtZSAhPT0gJ2dldFByb3RvdHlwZU9mJykge1xuICAgIG92ZXJyaWRlTmF0aXZlKGdsb2JhbHMuUmVmbGVjdCwgJ2dldFByb3RvdHlwZU9mJywgZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gX2NhbGwob3JpZ2luYWxSZWZsZWN0R2V0UHJvdG8sIGdsb2JhbHMuUmVmbGVjdCwgdGFyZ2V0KTtcbiAgICB9KTtcbiAgfVxuICBpZiAoZ2xvYmFscy5SZWZsZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgaWYgKHZhbHVlT3JGYWxzZUlmVGhyb3dzKGZ1bmN0aW9uICgpIHtcbiAgICAgIGdsb2JhbHMuUmVmbGVjdC5zZXRQcm90b3R5cGVPZigxLCB7fSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KSkge1xuICAgICAgb3ZlcnJpZGVOYXRpdmUoZ2xvYmFscy5SZWZsZWN0LCAnc2V0UHJvdG90eXBlT2YnLCBSZWZsZWN0U2hpbXMuc2V0UHJvdG90eXBlT2YpO1xuICAgIH1cbiAgfVxuICBpZiAoZ2xvYmFscy5SZWZsZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gICAgaWYgKCF2YWx1ZU9yRmFsc2VJZlRocm93cyhmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYmFzaWMgPSAhZ2xvYmFscy5SZWZsZWN0LmRlZmluZVByb3BlcnR5KDEsICd0ZXN0JywgeyB2YWx1ZTogMSB9KTtcbiAgICAgIC8vIFwiZXh0ZW5zaWJsZVwiIGZhaWxzIG9uIEVkZ2UgMC4xMlxuICAgICAgdmFyIGV4dGVuc2libGUgPSB0eXBlb2YgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zICE9PSAnZnVuY3Rpb24nIHx8ICFnbG9iYWxzLlJlZmxlY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSwgJ3Rlc3QnLCB7fSk7XG4gICAgICByZXR1cm4gYmFzaWMgJiYgZXh0ZW5zaWJsZTtcbiAgICB9KSkge1xuICAgICAgb3ZlcnJpZGVOYXRpdmUoZ2xvYmFscy5SZWZsZWN0LCAnZGVmaW5lUHJvcGVydHknLCBSZWZsZWN0U2hpbXMuZGVmaW5lUHJvcGVydHkpO1xuICAgIH1cbiAgfVxuICBpZiAoZ2xvYmFscy5SZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgIGlmICghdmFsdWVPckZhbHNlSWZUaHJvd3MoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307XG4gICAgICByZXR1cm4gZ2xvYmFscy5SZWZsZWN0LmNvbnN0cnVjdChmdW5jdGlvbiAoKSB7fSwgW10sIEYpIGluc3RhbmNlb2YgRjtcbiAgICB9KSkge1xuICAgICAgb3ZlcnJpZGVOYXRpdmUoZ2xvYmFscy5SZWZsZWN0LCAnY29uc3RydWN0JywgUmVmbGVjdFNoaW1zLmNvbnN0cnVjdCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKFN0cmluZyhuZXcgRGF0ZShOYU4pKSAhPT0gJ0ludmFsaWQgRGF0ZScpIHtcbiAgICB2YXIgZGF0ZVRvU3RyaW5nID0gRGF0ZS5wcm90b3R5cGUudG9TdHJpbmc7XG4gICAgdmFyIHNoaW1tZWREYXRlVG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciB2YWx1ZU9mID0gK3RoaXM7XG4gICAgICBpZiAodmFsdWVPZiAhPT0gdmFsdWVPZikge1xuICAgICAgICByZXR1cm4gJ0ludmFsaWQgRGF0ZSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gRVMuQ2FsbChkYXRlVG9TdHJpbmcsIHRoaXMpO1xuICAgIH07XG4gICAgb3ZlcnJpZGVOYXRpdmUoRGF0ZS5wcm90b3R5cGUsICd0b1N0cmluZycsIHNoaW1tZWREYXRlVG9TdHJpbmcpO1xuICB9XG5cbiAgLy8gQW5uZXggQiBIVE1MIG1ldGhvZHNcbiAgLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWFkZGl0aW9uYWwtcHJvcGVydGllcy1vZi10aGUtc3RyaW5nLnByb3RvdHlwZS1vYmplY3RcbiAgdmFyIHN0cmluZ0hUTUxzaGltcyA9IHtcbiAgICBhbmNob3I6IGZ1bmN0aW9uIGFuY2hvcihuYW1lKSB7IHJldHVybiBFUy5DcmVhdGVIVE1MKHRoaXMsICdhJywgJ25hbWUnLCBuYW1lKTsgfSxcbiAgICBiaWc6IGZ1bmN0aW9uIGJpZygpIHsgcmV0dXJuIEVTLkNyZWF0ZUhUTUwodGhpcywgJ2JpZycsICcnLCAnJyk7IH0sXG4gICAgYmxpbms6IGZ1bmN0aW9uIGJsaW5rKCkgeyByZXR1cm4gRVMuQ3JlYXRlSFRNTCh0aGlzLCAnYmxpbmsnLCAnJywgJycpOyB9LFxuICAgIGJvbGQ6IGZ1bmN0aW9uIGJvbGQoKSB7IHJldHVybiBFUy5DcmVhdGVIVE1MKHRoaXMsICdiJywgJycsICcnKTsgfSxcbiAgICBmaXhlZDogZnVuY3Rpb24gZml4ZWQoKSB7IHJldHVybiBFUy5DcmVhdGVIVE1MKHRoaXMsICd0dCcsICcnLCAnJyk7IH0sXG4gICAgZm9udGNvbG9yOiBmdW5jdGlvbiBmb250Y29sb3IoY29sb3IpIHsgcmV0dXJuIEVTLkNyZWF0ZUhUTUwodGhpcywgJ2ZvbnQnLCAnY29sb3InLCBjb2xvcik7IH0sXG4gICAgZm9udHNpemU6IGZ1bmN0aW9uIGZvbnRzaXplKHNpemUpIHsgcmV0dXJuIEVTLkNyZWF0ZUhUTUwodGhpcywgJ2ZvbnQnLCAnc2l6ZScsIHNpemUpOyB9LFxuICAgIGl0YWxpY3M6IGZ1bmN0aW9uIGl0YWxpY3MoKSB7IHJldHVybiBFUy5DcmVhdGVIVE1MKHRoaXMsICdpJywgJycsICcnKTsgfSxcbiAgICBsaW5rOiBmdW5jdGlvbiBsaW5rKHVybCkgeyByZXR1cm4gRVMuQ3JlYXRlSFRNTCh0aGlzLCAnYScsICdocmVmJywgdXJsKTsgfSxcbiAgICBzbWFsbDogZnVuY3Rpb24gc21hbGwoKSB7IHJldHVybiBFUy5DcmVhdGVIVE1MKHRoaXMsICdzbWFsbCcsICcnLCAnJyk7IH0sXG4gICAgc3RyaWtlOiBmdW5jdGlvbiBzdHJpa2UoKSB7IHJldHVybiBFUy5DcmVhdGVIVE1MKHRoaXMsICdzdHJpa2UnLCAnJywgJycpOyB9LFxuICAgIHN1YjogZnVuY3Rpb24gc3ViKCkgeyByZXR1cm4gRVMuQ3JlYXRlSFRNTCh0aGlzLCAnc3ViJywgJycsICcnKTsgfSxcbiAgICBzdXA6IGZ1bmN0aW9uIHN1YigpIHsgcmV0dXJuIEVTLkNyZWF0ZUhUTUwodGhpcywgJ3N1cCcsICcnLCAnJyk7IH1cbiAgfTtcbiAgX2ZvckVhY2goT2JqZWN0LmtleXMoc3RyaW5nSFRNTHNoaW1zKSwgZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBtZXRob2QgPSBTdHJpbmcucHJvdG90eXBlW2tleV07XG4gICAgdmFyIHNob3VsZE92ZXJ3cml0ZSA9IGZhbHNlO1xuICAgIGlmIChFUy5Jc0NhbGxhYmxlKG1ldGhvZCkpIHtcbiAgICAgIHZhciBvdXRwdXQgPSBfY2FsbChtZXRob2QsICcnLCAnIFwiICcpO1xuICAgICAgdmFyIHF1b3Rlc0NvdW50ID0gX2NvbmNhdChbXSwgb3V0cHV0Lm1hdGNoKC9cIi9nKSkubGVuZ3RoO1xuICAgICAgc2hvdWxkT3ZlcndyaXRlID0gb3V0cHV0ICE9PSBvdXRwdXQudG9Mb3dlckNhc2UoKSB8fCBxdW90ZXNDb3VudCA+IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZE92ZXJ3cml0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChzaG91bGRPdmVyd3JpdGUpIHtcbiAgICAgIG92ZXJyaWRlTmF0aXZlKFN0cmluZy5wcm90b3R5cGUsIGtleSwgc3RyaW5nSFRNTHNoaW1zW2tleV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIEpTT05zdHJpbmdpZmllc1N5bWJvbHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8vIE1pY3Jvc29mdCBFZGdlIHYwLjEyIHN0cmluZ2lmaWVzIFN5bWJvbHMgaW5jb3JyZWN0bHlcbiAgICBpZiAoIWhhc1N5bWJvbHMpIHsgcmV0dXJuIGZhbHNlOyB9IC8vIFN5bWJvbHMgYXJlIG5vdCBzdXBwb3J0ZWRcbiAgICB2YXIgc3RyaW5naWZ5ID0gdHlwZW9mIEpTT04gPT09ICdvYmplY3QnICYmIHR5cGVvZiBKU09OLnN0cmluZ2lmeSA9PT0gJ2Z1bmN0aW9uJyA/IEpTT04uc3RyaW5naWZ5IDogbnVsbDtcbiAgICBpZiAoIXN0cmluZ2lmeSkgeyByZXR1cm4gZmFsc2U7IH0gLy8gSlNPTi5zdHJpbmdpZnkgaXMgbm90IHN1cHBvcnRlZFxuICAgIGlmICh0eXBlb2Ygc3RyaW5naWZ5KFN5bWJvbCgpKSAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIHRydWU7IH0gLy8gU3ltYm9scyBzaG91bGQgYmVjb21lIGB1bmRlZmluZWRgXG4gICAgaWYgKHN0cmluZ2lmeShbU3ltYm9sKCldKSAhPT0gJ1tudWxsXScpIHsgcmV0dXJuIHRydWU7IH0gLy8gU3ltYm9scyBpbiBhcnJheXMgc2hvdWxkIGJlY29tZSBgbnVsbGBcbiAgICB2YXIgb2JqID0geyBhOiBTeW1ib2woKSB9O1xuICAgIG9ialtTeW1ib2woKV0gPSB0cnVlO1xuICAgIGlmIChzdHJpbmdpZnkob2JqKSAhPT0gJ3t9JykgeyByZXR1cm4gdHJ1ZTsgfSAvLyBTeW1ib2wtdmFsdWVkIGtleXMgKmFuZCogU3ltYm9sLXZhbHVlZCBwcm9wZXJ0aWVzIHNob3VsZCBiZSBvbWl0dGVkXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KCkpO1xuICB2YXIgSlNPTnN0cmluZ2lmeUFjY2VwdHNPYmplY3RTeW1ib2wgPSB2YWx1ZU9yRmFsc2VJZlRocm93cyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gQ2hyb21lIDQ1IHRocm93cyBvbiBzdHJpbmdpZnlpbmcgb2JqZWN0IHN5bWJvbHNcbiAgICBpZiAoIWhhc1N5bWJvbHMpIHsgcmV0dXJuIHRydWU7IH0gLy8gU3ltYm9scyBhcmUgbm90IHN1cHBvcnRlZFxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShPYmplY3QoU3ltYm9sKCkpKSA9PT0gJ3t9JyAmJiBKU09OLnN0cmluZ2lmeShbT2JqZWN0KFN5bWJvbCgpKV0pID09PSAnW3t9XSc7XG4gIH0pO1xuICBpZiAoSlNPTnN0cmluZ2lmaWVzU3ltYm9scyB8fCAhSlNPTnN0cmluZ2lmeUFjY2VwdHNPYmplY3RTeW1ib2wpIHtcbiAgICB2YXIgb3JpZ1N0cmluZ2lmeSA9IEpTT04uc3RyaW5naWZ5O1xuICAgIG92ZXJyaWRlTmF0aXZlKEpTT04sICdzdHJpbmdpZnknLCBmdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSB7IHJldHVybjsgfVxuICAgICAgdmFyIHJlcGxhY2VyO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHJlcGxhY2VyID0gYXJndW1lbnRzWzFdO1xuICAgICAgfVxuICAgICAgdmFyIGFyZ3MgPSBbdmFsdWVdO1xuICAgICAgaWYgKCFpc0FycmF5KHJlcGxhY2VyKSkge1xuICAgICAgICB2YXIgcmVwbGFjZUZuID0gRVMuSXNDYWxsYWJsZShyZXBsYWNlcikgPyByZXBsYWNlciA6IG51bGw7XG4gICAgICAgIHZhciB3cmFwcGVkUmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICAgICAgICB2YXIgcGFyc2VkVmFsdWUgPSByZXBsYWNlRm4gPyBfY2FsbChyZXBsYWNlRm4sIHRoaXMsIGtleSwgdmFsKSA6IHZhbDtcbiAgICAgICAgICBpZiAodHlwZW9mIHBhcnNlZFZhbHVlICE9PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgaWYgKFR5cGUuc3ltYm9sKHBhcnNlZFZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gYXNzaWduVG8oe30pKHBhcnNlZFZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGFyZ3MucHVzaCh3cmFwcGVkUmVwbGFjZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3JlYXRlIHdyYXBwZWQgcmVwbGFjZXIgdGhhdCBoYW5kbGVzIGFuIGFycmF5IHJlcGxhY2VyP1xuICAgICAgICBhcmdzLnB1c2gocmVwbGFjZXIpO1xuICAgICAgfVxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbMl0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdTdHJpbmdpZnkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZ2xvYmFscztcbn0pKTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIDpmb2N1cy12aXNpYmxlIHBvbHlmaWxsIGF0IHRoZSBnaXZlbiBzY29wZS5cbiAgICogQSBzY29wZSBpbiB0aGlzIGNhc2UgaXMgZWl0aGVyIHRoZSB0b3AtbGV2ZWwgRG9jdW1lbnQgb3IgYSBTaGFkb3cgUm9vdC5cbiAgICpcbiAgICogQHBhcmFtIHsoRG9jdW1lbnR8U2hhZG93Um9vdCl9IHNjb3BlXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvZm9jdXMtdmlzaWJsZVxuICAgKi9cbiAgZnVuY3Rpb24gYXBwbHlGb2N1c1Zpc2libGVQb2x5ZmlsbChzY29wZSkge1xuICAgIHZhciBoYWRLZXlib2FyZEV2ZW50ID0gdHJ1ZTtcbiAgICB2YXIgaGFkRm9jdXNWaXNpYmxlUmVjZW50bHkgPSBmYWxzZTtcbiAgICB2YXIgaGFkRm9jdXNWaXNpYmxlUmVjZW50bHlUaW1lb3V0ID0gbnVsbDtcblxuICAgIHZhciBpbnB1dFR5cGVzQWxsb3dsaXN0ID0ge1xuICAgICAgdGV4dDogdHJ1ZSxcbiAgICAgIHNlYXJjaDogdHJ1ZSxcbiAgICAgIHVybDogdHJ1ZSxcbiAgICAgIHRlbDogdHJ1ZSxcbiAgICAgIGVtYWlsOiB0cnVlLFxuICAgICAgcGFzc3dvcmQ6IHRydWUsXG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBkYXRlOiB0cnVlLFxuICAgICAgbW9udGg6IHRydWUsXG4gICAgICB3ZWVrOiB0cnVlLFxuICAgICAgdGltZTogdHJ1ZSxcbiAgICAgIGRhdGV0aW1lOiB0cnVlLFxuICAgICAgJ2RhdGV0aW1lLWxvY2FsJzogdHJ1ZVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIGxlZ2FjeSBicm93c2VycyBhbmQgaWZyYW1lcyB3aGljaCBzb21ldGltZXMgZm9jdXNcbiAgICAgKiBlbGVtZW50cyBsaWtlIGRvY3VtZW50LCBib2R5LCBhbmQgbm9uLWludGVyYWN0aXZlIFNWRy5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNWYWxpZEZvY3VzVGFyZ2V0KGVsKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGVsICYmXG4gICAgICAgIGVsICE9PSBkb2N1bWVudCAmJlxuICAgICAgICBlbC5ub2RlTmFtZSAhPT0gJ0hUTUwnICYmXG4gICAgICAgIGVsLm5vZGVOYW1lICE9PSAnQk9EWScgJiZcbiAgICAgICAgJ2NsYXNzTGlzdCcgaW4gZWwgJiZcbiAgICAgICAgJ2NvbnRhaW5zJyBpbiBlbC5jbGFzc0xpc3RcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB3aGV0aGVyIHRoZSBnaXZlbiBlbGVtZW50IHNob3VsZCBhdXRvbWF0aWNhbGx5IHRyaWdnZXIgdGhlXG4gICAgICogYGZvY3VzLXZpc2libGVgIGNsYXNzIGJlaW5nIGFkZGVkLCBpLmUuIHdoZXRoZXIgaXQgc2hvdWxkIGFsd2F5cyBtYXRjaFxuICAgICAqIGA6Zm9jdXMtdmlzaWJsZWAgd2hlbiBmb2N1c2VkLlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvY3VzVHJpZ2dlcnNLZXlib2FyZE1vZGFsaXR5KGVsKSB7XG4gICAgICB2YXIgdHlwZSA9IGVsLnR5cGU7XG4gICAgICB2YXIgdGFnTmFtZSA9IGVsLnRhZ05hbWU7XG5cbiAgICAgIGlmICh0YWdOYW1lID09PSAnSU5QVVQnICYmIGlucHV0VHlwZXNBbGxvd2xpc3RbdHlwZV0gJiYgIWVsLnJlYWRPbmx5KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyAmJiAhZWwucmVhZE9ubHkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbC5pc0NvbnRlbnRFZGl0YWJsZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgYGZvY3VzLXZpc2libGVgIGNsYXNzIHRvIHRoZSBnaXZlbiBlbGVtZW50IGlmIGl0IHdhcyBub3QgYWRkZWQgYnlcbiAgICAgKiB0aGUgYXV0aG9yLlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRGb2N1c1Zpc2libGVDbGFzcyhlbCkge1xuICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnZm9jdXMtdmlzaWJsZScpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2ZvY3VzLXZpc2libGUnKTtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1mb2N1cy12aXNpYmxlLWFkZGVkJywgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgYGZvY3VzLXZpc2libGVgIGNsYXNzIGZyb20gdGhlIGdpdmVuIGVsZW1lbnQgaWYgaXQgd2FzIG5vdFxuICAgICAqIG9yaWdpbmFsbHkgYWRkZWQgYnkgdGhlIGF1dGhvci5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlRm9jdXNWaXNpYmxlQ2xhc3MoZWwpIHtcbiAgICAgIGlmICghZWwuaGFzQXR0cmlidXRlKCdkYXRhLWZvY3VzLXZpc2libGUtYWRkZWQnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdmb2N1cy12aXNpYmxlJyk7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtZm9jdXMtdmlzaWJsZS1hZGRlZCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBtb3N0IHJlY2VudCB1c2VyIGludGVyYWN0aW9uIHdhcyB2aWEgdGhlIGtleWJvYXJkO1xuICAgICAqIGFuZCB0aGUga2V5IHByZXNzIGRpZCBub3QgaW5jbHVkZSBhIG1ldGEsIGFsdC9vcHRpb24sIG9yIGNvbnRyb2wga2V5O1xuICAgICAqIHRoZW4gdGhlIG1vZGFsaXR5IGlzIGtleWJvYXJkLiBPdGhlcndpc2UsIHRoZSBtb2RhbGl0eSBpcyBub3Qga2V5Ym9hcmQuXG4gICAgICogQXBwbHkgYGZvY3VzLXZpc2libGVgIHRvIGFueSBjdXJyZW50IGFjdGl2ZSBlbGVtZW50IGFuZCBrZWVwIHRyYWNrXG4gICAgICogb2Ygb3VyIGtleWJvYXJkIG1vZGFsaXR5IHN0YXRlIHdpdGggYGhhZEtleWJvYXJkRXZlbnRgLlxuICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XG4gICAgICBpZiAoZS5tZXRhS2V5IHx8IGUuYWx0S2V5IHx8IGUuY3RybEtleSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1ZhbGlkRm9jdXNUYXJnZXQoc2NvcGUuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgYWRkRm9jdXNWaXNpYmxlQ2xhc3Moc2NvcGUuYWN0aXZlRWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGhhZEtleWJvYXJkRXZlbnQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIGF0IGFueSBwb2ludCBhIHVzZXIgY2xpY2tzIHdpdGggYSBwb2ludGluZyBkZXZpY2UsIGVuc3VyZSB0aGF0IHdlIGNoYW5nZVxuICAgICAqIHRoZSBtb2RhbGl0eSBhd2F5IGZyb20ga2V5Ym9hcmQuXG4gICAgICogVGhpcyBhdm9pZHMgdGhlIHNpdHVhdGlvbiB3aGVyZSBhIHVzZXIgcHJlc3NlcyBhIGtleSBvbiBhbiBhbHJlYWR5IGZvY3VzZWRcbiAgICAgKiBlbGVtZW50LCBhbmQgdGhlbiBjbGlja3Mgb24gYSBkaWZmZXJlbnQgZWxlbWVudCwgZm9jdXNpbmcgaXQgd2l0aCBhXG4gICAgICogcG9pbnRpbmcgZGV2aWNlLCB3aGlsZSB3ZSBzdGlsbCB0aGluayB3ZSdyZSBpbiBrZXlib2FyZCBtb2RhbGl0eS5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25Qb2ludGVyRG93bihlKSB7XG4gICAgICBoYWRLZXlib2FyZEV2ZW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT24gYGZvY3VzYCwgYWRkIHRoZSBgZm9jdXMtdmlzaWJsZWAgY2xhc3MgdG8gdGhlIHRhcmdldCBpZjpcbiAgICAgKiAtIHRoZSB0YXJnZXQgcmVjZWl2ZWQgZm9jdXMgYXMgYSByZXN1bHQgb2Yga2V5Ym9hcmQgbmF2aWdhdGlvbiwgb3JcbiAgICAgKiAtIHRoZSBldmVudCB0YXJnZXQgaXMgYW4gZWxlbWVudCB0aGF0IHdpbGwgbGlrZWx5IHJlcXVpcmUgaW50ZXJhY3Rpb25cbiAgICAgKiAgIHZpYSB0aGUga2V5Ym9hcmQgKGUuZy4gYSB0ZXh0IGJveClcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25Gb2N1cyhlKSB7XG4gICAgICAvLyBQcmV2ZW50IElFIGZyb20gZm9jdXNpbmcgdGhlIGRvY3VtZW50IG9yIEhUTUwgZWxlbWVudC5cbiAgICAgIGlmICghaXNWYWxpZEZvY3VzVGFyZ2V0KGUudGFyZ2V0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChoYWRLZXlib2FyZEV2ZW50IHx8IGZvY3VzVHJpZ2dlcnNLZXlib2FyZE1vZGFsaXR5KGUudGFyZ2V0KSkge1xuICAgICAgICBhZGRGb2N1c1Zpc2libGVDbGFzcyhlLnRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT24gYGJsdXJgLCByZW1vdmUgdGhlIGBmb2N1cy12aXNpYmxlYCBjbGFzcyBmcm9tIHRoZSB0YXJnZXQuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uQmx1cihlKSB7XG4gICAgICBpZiAoIWlzVmFsaWRGb2N1c1RhcmdldChlLnRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnZm9jdXMtdmlzaWJsZScpIHx8XG4gICAgICAgIGUudGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnZGF0YS1mb2N1cy12aXNpYmxlLWFkZGVkJylcbiAgICAgICkge1xuICAgICAgICAvLyBUbyBkZXRlY3QgYSB0YWIvd2luZG93IHN3aXRjaCwgd2UgbG9vayBmb3IgYSBibHVyIGV2ZW50IGZvbGxvd2VkXG4gICAgICAgIC8vIHJhcGlkbHkgYnkgYSB2aXNpYmlsaXR5IGNoYW5nZS5cbiAgICAgICAgLy8gSWYgd2UgZG9uJ3Qgc2VlIGEgdmlzaWJpbGl0eSBjaGFuZ2Ugd2l0aGluIDEwMG1zLCBpdCdzIHByb2JhYmx5IGFcbiAgICAgICAgLy8gcmVndWxhciBmb2N1cyBjaGFuZ2UuXG4gICAgICAgIGhhZEZvY3VzVmlzaWJsZVJlY2VudGx5ID0gdHJ1ZTtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChoYWRGb2N1c1Zpc2libGVSZWNlbnRseVRpbWVvdXQpO1xuICAgICAgICBoYWRGb2N1c1Zpc2libGVSZWNlbnRseVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBoYWRGb2N1c1Zpc2libGVSZWNlbnRseSA9IGZhbHNlO1xuICAgICAgICB9LCAxMDApO1xuICAgICAgICByZW1vdmVGb2N1c1Zpc2libGVDbGFzcyhlLnRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIHVzZXIgY2hhbmdlcyB0YWJzLCBrZWVwIHRyYWNrIG9mIHdoZXRoZXIgb3Igbm90IHRoZSBwcmV2aW91c2x5XG4gICAgICogZm9jdXNlZCBlbGVtZW50IGhhZCAuZm9jdXMtdmlzaWJsZS5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25WaXNpYmlsaXR5Q2hhbmdlKGUpIHtcbiAgICAgIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nKSB7XG4gICAgICAgIC8vIElmIHRoZSB0YWIgYmVjb21lcyBhY3RpdmUgYWdhaW4sIHRoZSBicm93c2VyIHdpbGwgaGFuZGxlIGNhbGxpbmcgZm9jdXNcbiAgICAgICAgLy8gb24gdGhlIGVsZW1lbnQgKFNhZmFyaSBhY3R1YWxseSBjYWxscyBpdCB0d2ljZSkuXG4gICAgICAgIC8vIElmIHRoaXMgdGFiIGNoYW5nZSBjYXVzZWQgYSBibHVyIG9uIGFuIGVsZW1lbnQgd2l0aCBmb2N1cy12aXNpYmxlLFxuICAgICAgICAvLyByZS1hcHBseSB0aGUgY2xhc3Mgd2hlbiB0aGUgdXNlciBzd2l0Y2hlcyBiYWNrIHRvIHRoZSB0YWIuXG4gICAgICAgIGlmIChoYWRGb2N1c1Zpc2libGVSZWNlbnRseSkge1xuICAgICAgICAgIGhhZEtleWJvYXJkRXZlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGFkZEluaXRpYWxQb2ludGVyTW92ZUxpc3RlbmVycygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGdyb3VwIG9mIGxpc3RlbmVycyB0byBkZXRlY3QgdXNhZ2Ugb2YgYW55IHBvaW50aW5nIGRldmljZXMuXG4gICAgICogVGhlc2UgbGlzdGVuZXJzIHdpbGwgYmUgYWRkZWQgd2hlbiB0aGUgcG9seWZpbGwgZmlyc3QgbG9hZHMsIGFuZCBhbnl0aW1lXG4gICAgICogdGhlIHdpbmRvdyBpcyBibHVycmVkLCBzbyB0aGF0IHRoZXkgYXJlIGFjdGl2ZSB3aGVuIHRoZSB3aW5kb3cgcmVnYWluc1xuICAgICAqIGZvY3VzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZEluaXRpYWxQb2ludGVyTW92ZUxpc3RlbmVycygpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uSW5pdGlhbFBvaW50ZXJNb3ZlKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uSW5pdGlhbFBvaW50ZXJNb3ZlKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbkluaXRpYWxQb2ludGVyTW92ZSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIG9uSW5pdGlhbFBvaW50ZXJNb3ZlKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgb25Jbml0aWFsUG9pbnRlck1vdmUpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgb25Jbml0aWFsUG9pbnRlck1vdmUpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Jbml0aWFsUG9pbnRlck1vdmUpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uSW5pdGlhbFBvaW50ZXJNb3ZlKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Jbml0aWFsUG9pbnRlck1vdmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUluaXRpYWxQb2ludGVyTW92ZUxpc3RlbmVycygpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uSW5pdGlhbFBvaW50ZXJNb3ZlKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uSW5pdGlhbFBvaW50ZXJNb3ZlKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbkluaXRpYWxQb2ludGVyTW92ZSk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIG9uSW5pdGlhbFBvaW50ZXJNb3ZlKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgb25Jbml0aWFsUG9pbnRlck1vdmUpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgb25Jbml0aWFsUG9pbnRlck1vdmUpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Jbml0aWFsUG9pbnRlck1vdmUpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uSW5pdGlhbFBvaW50ZXJNb3ZlKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Jbml0aWFsUG9pbnRlck1vdmUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIHBvbGZ5aWxsIGZpcnN0IGxvYWRzLCBhc3N1bWUgdGhlIHVzZXIgaXMgaW4ga2V5Ym9hcmQgbW9kYWxpdHkuXG4gICAgICogSWYgYW55IGV2ZW50IGlzIHJlY2VpdmVkIGZyb20gYSBwb2ludGluZyBkZXZpY2UgKGUuZy4gbW91c2UsIHBvaW50ZXIsXG4gICAgICogdG91Y2gpLCB0dXJuIG9mZiBrZXlib2FyZCBtb2RhbGl0eS5cbiAgICAgKiBUaGlzIGFjY291bnRzIGZvciBzaXR1YXRpb25zIHdoZXJlIGZvY3VzIGVudGVycyB0aGUgcGFnZSBmcm9tIHRoZSBVUkwgYmFyLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkluaXRpYWxQb2ludGVyTW92ZShlKSB7XG4gICAgICAvLyBXb3JrIGFyb3VuZCBhIFNhZmFyaSBxdWlyayB0aGF0IGZpcmVzIGEgbW91c2Vtb3ZlIG9uIDxodG1sPiB3aGVuZXZlciB0aGVcbiAgICAgIC8vIHdpbmRvdyBibHVycywgZXZlbiBpZiB5b3UncmUgdGFiYmluZyBvdXQgb2YgdGhlIHBhZ2UuIMKvXFxfKOODhClfL8KvXG4gICAgICBpZiAoZS50YXJnZXQubm9kZU5hbWUgJiYgZS50YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2h0bWwnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaGFkS2V5Ym9hcmRFdmVudCA9IGZhbHNlO1xuICAgICAgcmVtb3ZlSW5pdGlhbFBvaW50ZXJNb3ZlTGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgLy8gRm9yIHNvbWUga2luZHMgb2Ygc3RhdGUsIHdlIGFyZSBpbnRlcmVzdGVkIGluIGNoYW5nZXMgYXQgdGhlIGdsb2JhbCBzY29wZVxuICAgIC8vIG9ubHkuIEZvciBleGFtcGxlLCBnbG9iYWwgcG9pbnRlciBpbnB1dCwgZ2xvYmFsIGtleSBwcmVzc2VzIGFuZCBnbG9iYWxcbiAgICAvLyB2aXNpYmlsaXR5IGNoYW5nZSBzaG91bGQgYWZmZWN0IHRoZSBzdGF0ZSBhdCBldmVyeSBzY29wZTpcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb25LZXlEb3duLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvblBvaW50ZXJEb3duLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIG9uUG9pbnRlckRvd24sIHRydWUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblBvaW50ZXJEb3duLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgb25WaXNpYmlsaXR5Q2hhbmdlLCB0cnVlKTtcblxuICAgIGFkZEluaXRpYWxQb2ludGVyTW92ZUxpc3RlbmVycygpO1xuXG4gICAgLy8gRm9yIGZvY3VzIGFuZCBibHVyLCB3ZSBzcGVjaWZpY2FsbHkgY2FyZSBhYm91dCBzdGF0ZSBjaGFuZ2VzIGluIHRoZSBsb2NhbFxuICAgIC8vIHNjb3BlLiBUaGlzIGlzIGJlY2F1c2UgZm9jdXMgLyBibHVyIGV2ZW50cyB0aGF0IG9yaWdpbmF0ZSBmcm9tIHdpdGhpbiBhXG4gICAgLy8gc2hhZG93IHJvb3QgYXJlIG5vdCByZS1kaXNwYXRjaGVkIGZyb20gdGhlIGhvc3QgZWxlbWVudCBpZiBpdCB3YXMgYWxyZWFkeVxuICAgIC8vIHRoZSBhY3RpdmUgZWxlbWVudCBpbiBpdHMgb3duIHNjb3BlOlxuICAgIHNjb3BlLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgb25Gb2N1cywgdHJ1ZSk7XG4gICAgc2NvcGUuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIG9uQmx1ciwgdHJ1ZSk7XG5cbiAgICAvLyBXZSBkZXRlY3QgdGhhdCBhIG5vZGUgaXMgYSBTaGFkb3dSb290IGJ5IGVuc3VyaW5nIHRoYXQgaXQgaXMgYVxuICAgIC8vIERvY3VtZW50RnJhZ21lbnQgYW5kIGFsc28gaGFzIGEgaG9zdCBwcm9wZXJ0eS4gVGhpcyBjaGVjayBjb3ZlcnMgbmF0aXZlXG4gICAgLy8gaW1wbGVtZW50YXRpb24gYW5kIHBvbHlmaWxsIGltcGxlbWVudGF0aW9uIHRyYW5zcGFyZW50bHkuIElmIHdlIG9ubHkgY2FyZWRcbiAgICAvLyBhYm91dCB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLCB3ZSBjb3VsZCBqdXN0IGNoZWNrIGlmIHRoZSBzY29wZSB3YXNcbiAgICAvLyBhbiBpbnN0YW5jZSBvZiBhIFNoYWRvd1Jvb3QuXG4gICAgaWYgKHNjb3BlLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgJiYgc2NvcGUuaG9zdCkge1xuICAgICAgLy8gU2luY2UgYSBTaGFkb3dSb290IGlzIGEgc3BlY2lhbCBraW5kIG9mIERvY3VtZW50RnJhZ21lbnQsIGl0IGRvZXMgbm90XG4gICAgICAvLyBoYXZlIGEgcm9vdCBlbGVtZW50IHRvIGFkZCBhIGNsYXNzIHRvLiBTbywgd2UgYWRkIHRoaXMgYXR0cmlidXRlIHRvIHRoZVxuICAgICAgLy8gaG9zdCBlbGVtZW50IGluc3RlYWQ6XG4gICAgICBzY29wZS5ob3N0LnNldEF0dHJpYnV0ZSgnZGF0YS1qcy1mb2N1cy12aXNpYmxlJywgJycpO1xuICAgIH0gZWxzZSBpZiAoc2NvcGUubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfTk9ERSkge1xuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2pzLWZvY3VzLXZpc2libGUnKTtcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtanMtZm9jdXMtdmlzaWJsZScsICcnKTtcbiAgICB9XG4gIH1cblxuICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gd3JhcCBhbGwgcmVmZXJlbmNlcyB0byBnbG9iYWwgd2luZG93IGFuZCBkb2N1bWVudCBpblxuICAvLyB0aGVzZSBjaGVja3MgdG8gc3VwcG9ydCBzZXJ2ZXItc2lkZSByZW5kZXJpbmcgdXNlIGNhc2VzXG4gIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvZm9jdXMtdmlzaWJsZS9pc3N1ZXMvMTk5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gTWFrZSB0aGUgcG9seWZpbGwgaGVscGVyIGdsb2JhbGx5IGF2YWlsYWJsZS4gVGhpcyBjYW4gYmUgdXNlZCBhcyBhIHNpZ25hbFxuICAgIC8vIHRvIGludGVyZXN0ZWQgbGlicmFyaWVzIHRoYXQgd2lzaCB0byBjb29yZGluYXRlIHdpdGggdGhlIHBvbHlmaWxsIGZvciBlLmcuLFxuICAgIC8vIGFwcGx5aW5nIHRoZSBwb2x5ZmlsbCB0byBhIHNoYWRvdyByb290OlxuICAgIHdpbmRvdy5hcHBseUZvY3VzVmlzaWJsZVBvbHlmaWxsID0gYXBwbHlGb2N1c1Zpc2libGVQb2x5ZmlsbDtcblxuICAgIC8vIE5vdGlmeSBpbnRlcmVzdGVkIGxpYnJhcmllcyBvZiB0aGUgcG9seWZpbGwncyBwcmVzZW5jZSwgaW4gY2FzZSB0aGVcbiAgICAvLyBwb2x5ZmlsbCB3YXMgbG9hZGVkIGxhemlseTpcbiAgICB2YXIgZXZlbnQ7XG5cbiAgICB0cnkge1xuICAgICAgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2ZvY3VzLXZpc2libGUtcG9seWZpbGwtcmVhZHknKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gSUUxMSBkb2VzIG5vdCBzdXBwb3J0IHVzaW5nIEN1c3RvbUV2ZW50IGFzIGEgY29uc3RydWN0b3IgZGlyZWN0bHk6XG4gICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KCdmb2N1cy12aXNpYmxlLXBvbHlmaWxsLXJlYWR5JywgZmFsc2UsIGZhbHNlLCB7fSk7XG4gICAgfVxuXG4gICAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBBcHBseSB0aGUgcG9seWZpbGwgdG8gdGhlIGdsb2JhbCBkb2N1bWVudCwgc28gdGhhdCBubyBKYXZhU2NyaXB0XG4gICAgLy8gY29vcmRpbmF0aW9uIGlzIHJlcXVpcmVkIHRvIHVzZSB0aGUgcG9seWZpbGwgaW4gdGhlIHRvcC1sZXZlbCBkb2N1bWVudDpcbiAgICBhcHBseUZvY3VzVmlzaWJsZVBvbHlmaWxsKGRvY3VtZW50KTtcbiAgfVxuXG59KSkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgbm8taW52YWxpZC10aGlzOiAxICovXG5cbnZhciBFUlJPUl9NRVNTQUdFID0gJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJztcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZnVuY1R5cGUgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQodGhhdCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHRvU3RyLmNhbGwodGFyZ2V0KSAhPT0gZnVuY1R5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJPUl9NRVNTQUdFICsgdGFyZ2V0KTtcbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgYm91bmQ7XG4gICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBib3VuZExlbmd0aCA9IE1hdGgubWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG4gICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICBib3VuZEFyZ3MucHVzaCgnJCcgKyBpKTtcbiAgICB9XG5cbiAgICBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgYm91bmRBcmdzLmpvaW4oJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICB2YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgaW1wbGVtZW50YXRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBJc0NhbGxhYmxlID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvMjAyMS9Jc0NhbGxhYmxlJyk7XG52YXIgZnVuY3Rpb25zSGF2ZU5hbWVzID0gcmVxdWlyZSgnZnVuY3Rpb25zLWhhdmUtbmFtZXMnKSgpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcbnZhciAkZnVuY3Rpb25Ub1N0cmluZyA9IGNhbGxCb3VuZCgnRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nJyk7XG52YXIgJHN0cmluZ01hdGNoID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLm1hdGNoJyk7XG5cbnZhciBjbGFzc1JlZ2V4ID0gL15jbGFzcyAvO1xuXG52YXIgaXNDbGFzcyA9IGZ1bmN0aW9uIGlzQ2xhc3NDb25zdHJ1Y3Rvcihmbikge1xuXHRpZiAoSXNDYWxsYWJsZShmbikpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHR0cnkge1xuXHRcdHZhciBtYXRjaCA9ICRzdHJpbmdNYXRjaCgkZnVuY3Rpb25Ub1N0cmluZyhmbiksIGNsYXNzUmVnZXgpO1xuXHRcdHJldHVybiAhIW1hdGNoO1xuXHR9IGNhdGNoIChlKSB7fVxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgcmVnZXggPSAvXFxzKmZ1bmN0aW9uXFxzKyhbXihcXHNdKilcXHMqLztcblxudmFyIGZ1bmN0aW9uUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0TmFtZSgpIHtcblx0aWYgKCFpc0NsYXNzKHRoaXMpICYmICFJc0NhbGxhYmxlKHRoaXMpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24ucHJvdG90eXBlLm5hbWUgc2hhbSBnZXR0ZXIgY2FsbGVkIG9uIG5vbi1mdW5jdGlvbicpO1xuXHR9XG5cdGlmIChmdW5jdGlvbnNIYXZlTmFtZXMpIHtcblx0XHRyZXR1cm4gdGhpcy5uYW1lO1xuXHR9XG5cdGlmICh0aGlzID09PSBmdW5jdGlvblByb3RvKSB7XG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cdHZhciBzdHIgPSAkZnVuY3Rpb25Ub1N0cmluZyh0aGlzKTtcblx0dmFyIG1hdGNoID0gJHN0cmluZ01hdGNoKHN0ciwgcmVnZXgpO1xuXHR2YXIgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuXHRyZXR1cm4gbmFtZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcblx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHN1cHBvcnRzRGVzY3JpcHRvcnMgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpLnN1cHBvcnRzRGVzY3JpcHRvcnM7XG52YXIgZnVuY3Rpb25zSGF2ZU5hbWVzID0gcmVxdWlyZSgnZnVuY3Rpb25zLWhhdmUtbmFtZXMnKSgpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIFR5cGVFcnIgPSBUeXBlRXJyb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbU5hbWUoKSB7XG5cdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG5cdGlmIChmdW5jdGlvbnNIYXZlTmFtZXMpIHtcblx0XHRyZXR1cm4gcG9seWZpbGw7XG5cdH1cblx0aWYgKCFzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnIoJ1NoaW1taW5nIEZ1bmN0aW9uLnByb3RvdHlwZS5uYW1lIHN1cHBvcnQgcmVxdWlyZXMgRVM1IHByb3BlcnR5IGRlc2NyaXB0b3Igc3VwcG9ydC4nKTtcblx0fVxuXHR2YXIgZnVuY3Rpb25Qcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblx0ZGVmaW5lUHJvcGVydHkoZnVuY3Rpb25Qcm90bywgJ25hbWUnLCB7XG5cdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIG5hbWUgPSBwb2x5ZmlsbC5jYWxsKHRoaXMpO1xuXHRcdFx0aWYgKHRoaXMgIT09IGZ1bmN0aW9uUHJvdG8pIHtcblx0XHRcdFx0ZGVmaW5lUHJvcGVydHkodGhpcywgJ25hbWUnLCB7XG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0XHRcdHZhbHVlOiBuYW1lLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiBmYWxzZVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmdW5jdGlvbnNIYXZlTmFtZXMgPSBmdW5jdGlvbiBmdW5jdGlvbnNIYXZlTmFtZXMoKSB7XG5cdHJldHVybiB0eXBlb2YgZnVuY3Rpb24gZigpIHt9Lm5hbWUgPT09ICdzdHJpbmcnO1xufTtcblxudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuaWYgKGdPUEQpIHtcblx0dHJ5IHtcblx0XHRnT1BEKFtdLCAnbGVuZ3RoJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBnT1BEXG5cdFx0Z09QRCA9IG51bGw7XG5cdH1cbn1cblxuZnVuY3Rpb25zSGF2ZU5hbWVzLmZ1bmN0aW9uc0hhdmVDb25maWd1cmFibGVOYW1lcyA9IGZ1bmN0aW9uIGZ1bmN0aW9uc0hhdmVDb25maWd1cmFibGVOYW1lcygpIHtcblx0cmV0dXJuIGZ1bmN0aW9uc0hhdmVOYW1lcygpICYmIGdPUEQgJiYgISFnT1BEKGZ1bmN0aW9uICgpIHt9LCAnbmFtZScpLmNvbmZpZ3VyYWJsZTtcbn07XG5cbnZhciAkYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kO1xuXG5mdW5jdGlvbnNIYXZlTmFtZXMuYm91bmRGdW5jdGlvbnNIYXZlTmFtZXMgPSBmdW5jdGlvbiBib3VuZEZ1bmN0aW9uc0hhdmVOYW1lcygpIHtcblx0cmV0dXJuIGZ1bmN0aW9uc0hhdmVOYW1lcygpICYmIHR5cGVvZiAkYmluZCA9PT0gJ2Z1bmN0aW9uJyAmJiBmdW5jdGlvbiBmKCkge30uYmluZCgpLm5hbWUgIT09ICcnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbnNIYXZlTmFtZXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1bmRlZmluZWQ7XG5cbnZhciAkU3ludGF4RXJyb3IgPSBTeW50YXhFcnJvcjtcbnZhciAkRnVuY3Rpb24gPSBGdW5jdGlvbjtcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbnZhciBnZXRFdmFsbGVkQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoZXhwcmVzc2lvblN5bnRheCkge1xuXHR0cnkge1xuXHRcdHJldHVybiAkRnVuY3Rpb24oJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcgKyBleHByZXNzaW9uU3ludGF4ICsgJykuY29uc3RydWN0b3I7JykoKTtcblx0fSBjYXRjaCAoZSkge31cbn07XG5cbnZhciAkZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRCh7fSwgJycpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0JGdPUEQgPSBudWxsOyAvLyB0aGlzIGlzIElFIDgsIHdoaWNoIGhhcyBhIGJyb2tlbiBnT1BEXG5cdH1cbn1cblxudmFyIHRocm93VHlwZUVycm9yID0gZnVuY3Rpb24gKCkge1xuXHR0aHJvdyBuZXcgJFR5cGVFcnJvcigpO1xufTtcbnZhciBUaHJvd1R5cGVFcnJvciA9ICRnT1BEXG5cdD8gKGZ1bmN0aW9uICgpIHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9ucywgbm8tY2FsbGVyLCBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcblx0XHRcdGFyZ3VtZW50cy5jYWxsZWU7IC8vIElFIDggZG9lcyBub3QgdGhyb3cgaGVyZVxuXHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdH0gY2F0Y2ggKGNhbGxlZVRocm93cykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gSUUgOCB0aHJvd3Mgb24gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhcmd1bWVudHMsICcnKVxuXHRcdFx0XHRyZXR1cm4gJGdPUEQoYXJndW1lbnRzLCAnY2FsbGVlJykuZ2V0O1xuXHRcdFx0fSBjYXRjaCAoZ09QRHRocm93cykge1xuXHRcdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCkpXG5cdDogdGhyb3dUeXBlRXJyb3I7XG5cbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMnKSgpO1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguX19wcm90b19fOyB9OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvXG5cbnZhciBuZWVkc0V2YWwgPSB7fTtcblxudmFyIFR5cGVkQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBnZXRQcm90byhVaW50OEFycmF5KTtcblxudmFyIElOVFJJTlNJQ1MgPSB7XG5cdCclQWdncmVnYXRlRXJyb3IlJzogdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFnZ3JlZ2F0ZUVycm9yLFxuXHQnJUFycmF5JSc6IEFycmF5LFxuXHQnJUFycmF5QnVmZmVyJSc6IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBcnJheUJ1ZmZlcixcblx0JyVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnJvbVN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogbmVlZHNFdmFsLFxuXHQnJUF0b21pY3MlJzogdHlwZW9mIEF0b21pY3MgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXRvbWljcyxcblx0JyVCaWdJbnQlJzogdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdJbnQsXG5cdCclQm9vbGVhbiUnOiBCb29sZWFuLFxuXHQnJURhdGFWaWV3JSc6IHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBEYXRhVmlldyxcblx0JyVEYXRlJSc6IERhdGUsXG5cdCclZGVjb2RlVVJJJSc6IGRlY29kZVVSSSxcblx0JyVkZWNvZGVVUklDb21wb25lbnQlJzogZGVjb2RlVVJJQ29tcG9uZW50LFxuXHQnJWVuY29kZVVSSSUnOiBlbmNvZGVVUkksXG5cdCclZW5jb2RlVVJJQ29tcG9uZW50JSc6IGVuY29kZVVSSUNvbXBvbmVudCxcblx0JyVFcnJvciUnOiBFcnJvcixcblx0JyVldmFsJSc6IGV2YWwsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxuXHQnJUV2YWxFcnJvciUnOiBFdmFsRXJyb3IsXG5cdCclRmxvYXQzMkFycmF5JSc6IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQzMkFycmF5LFxuXHQnJUZsb2F0NjRBcnJheSUnOiB0eXBlb2YgRmxvYXQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0NjRBcnJheSxcblx0JyVGaW5hbGl6YXRpb25SZWdpc3RyeSUnOiB0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmluYWxpemF0aW9uUmVnaXN0cnksXG5cdCclRnVuY3Rpb24lJzogJEZ1bmN0aW9uLFxuXHQnJUdlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVJbnQ4QXJyYXklJzogdHlwZW9mIEludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQ4QXJyYXksXG5cdCclSW50MTZBcnJheSUnOiB0eXBlb2YgSW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQxNkFycmF5LFxuXHQnJUludDMyQXJyYXklJzogdHlwZW9mIEludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MzJBcnJheSxcblx0JyVpc0Zpbml0ZSUnOiBpc0Zpbml0ZSxcblx0JyVpc05hTiUnOiBpc05hTixcblx0JyVJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSkgOiB1bmRlZmluZWQsXG5cdCclSlNPTiUnOiB0eXBlb2YgSlNPTiA9PT0gJ29iamVjdCcgPyBKU09OIDogdW5kZWZpbmVkLFxuXHQnJU1hcCUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IE1hcCxcblx0JyVNYXBJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBNYXAoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJU1hdGglJzogTWF0aCxcblx0JyVOdW1iZXIlJzogTnVtYmVyLFxuXHQnJU9iamVjdCUnOiBPYmplY3QsXG5cdCclcGFyc2VGbG9hdCUnOiBwYXJzZUZsb2F0LFxuXHQnJXBhcnNlSW50JSc6IHBhcnNlSW50LFxuXHQnJVByb21pc2UlJzogdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJvbWlzZSxcblx0JyVQcm94eSUnOiB0eXBlb2YgUHJveHkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJveHksXG5cdCclUmFuZ2VFcnJvciUnOiBSYW5nZUVycm9yLFxuXHQnJVJlZmVyZW5jZUVycm9yJSc6IFJlZmVyZW5jZUVycm9yLFxuXHQnJVJlZmxlY3QlJzogdHlwZW9mIFJlZmxlY3QgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUmVmbGVjdCxcblx0JyVSZWdFeHAlJzogUmVnRXhwLFxuXHQnJVNldCUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNldCxcblx0JyVTZXRJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBTZXQoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyJSc6IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTaGFyZWRBcnJheUJ1ZmZlcixcblx0JyVTdHJpbmclJzogU3RyaW5nLFxuXHQnJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90bygnJ1tTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJVN5bWJvbCUnOiBoYXNTeW1ib2xzID8gU3ltYm9sIDogdW5kZWZpbmVkLFxuXHQnJVN5bnRheEVycm9yJSc6ICRTeW50YXhFcnJvcixcblx0JyVUaHJvd1R5cGVFcnJvciUnOiBUaHJvd1R5cGVFcnJvcixcblx0JyVUeXBlZEFycmF5JSc6IFR5cGVkQXJyYXksXG5cdCclVHlwZUVycm9yJSc6ICRUeXBlRXJyb3IsXG5cdCclVWludDhBcnJheSUnOiB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OEFycmF5LFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5JSc6IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OENsYW1wZWRBcnJheSxcblx0JyVVaW50MTZBcnJheSUnOiB0eXBlb2YgVWludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDE2QXJyYXksXG5cdCclVWludDMyQXJyYXklJzogdHlwZW9mIFVpbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQzMkFycmF5LFxuXHQnJVVSSUVycm9yJSc6IFVSSUVycm9yLFxuXHQnJVdlYWtNYXAlJzogdHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha01hcCxcblx0JyVXZWFrUmVmJSc6IHR5cGVvZiBXZWFrUmVmID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtSZWYsXG5cdCclV2Vha1NldCUnOiB0eXBlb2YgV2Vha1NldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrU2V0XG59O1xuXG52YXIgZG9FdmFsID0gZnVuY3Rpb24gZG9FdmFsKG5hbWUpIHtcblx0dmFyIHZhbHVlO1xuXHRpZiAobmFtZSA9PT0gJyVBc3luY0Z1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24gKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUdlbmVyYXRvckZ1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignZnVuY3Rpb24qICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24qICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvciUnKSB7XG5cdFx0dmFyIGZuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKTtcblx0XHRpZiAoZm4pIHtcblx0XHRcdHZhbHVlID0gZm4ucHJvdG90eXBlO1xuXHRcdH1cblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJykge1xuXHRcdHZhciBnZW4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvciUnKTtcblx0XHRpZiAoZ2VuKSB7XG5cdFx0XHR2YWx1ZSA9IGdldFByb3RvKGdlbi5wcm90b3R5cGUpO1xuXHRcdH1cblx0fVxuXG5cdElOVFJJTlNJQ1NbbmFtZV0gPSB2YWx1ZTtcblxuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgTEVHQUNZX0FMSUFTRVMgPSB7XG5cdCclQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvdHlwZSUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG9fZW50cmllcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdlbnRyaWVzJ10sXG5cdCclQXJyYXlQcm90b19mb3JFYWNoJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2ZvckVhY2gnXSxcblx0JyVBcnJheVByb3RvX2tleXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAna2V5cyddLFxuXHQnJUFycmF5UHJvdG9fdmFsdWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ3ZhbHVlcyddLFxuXHQnJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlJzogWydBc3luY0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUJvb2xlYW5Qcm90b3R5cGUlJzogWydCb29sZWFuJywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGFWaWV3UHJvdG90eXBlJSc6IFsnRGF0YVZpZXcnLCAncHJvdG90eXBlJ10sXG5cdCclRGF0ZVByb3RvdHlwZSUnOiBbJ0RhdGUnLCAncHJvdG90eXBlJ10sXG5cdCclRXJyb3JQcm90b3R5cGUlJzogWydFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVFdmFsRXJyb3JQcm90b3R5cGUlJzogWydFdmFsRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQzMkFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0NjRBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0NjRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvciUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQ4QXJyYXlQcm90b3R5cGUlJzogWydJbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ0ludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ0ludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSlNPTlBhcnNlJSc6IFsnSlNPTicsICdwYXJzZSddLFxuXHQnJUpTT05TdHJpbmdpZnklJzogWydKU09OJywgJ3N0cmluZ2lmeSddLFxuXHQnJU1hcFByb3RvdHlwZSUnOiBbJ01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVOdW1iZXJQcm90b3R5cGUlJzogWydOdW1iZXInLCAncHJvdG90eXBlJ10sXG5cdCclT2JqZWN0UHJvdG90eXBlJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZSddLFxuXHQnJU9ialByb3RvX3RvU3RyaW5nJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd0b1N0cmluZyddLFxuXHQnJU9ialByb3RvX3ZhbHVlT2YlJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3ZhbHVlT2YnXSxcblx0JyVQcm9taXNlUHJvdG90eXBlJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnXSxcblx0JyVQcm9taXNlUHJvdG9fdGhlbiUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJywgJ3RoZW4nXSxcblx0JyVQcm9taXNlX2FsbCUnOiBbJ1Byb21pc2UnLCAnYWxsJ10sXG5cdCclUHJvbWlzZV9yZWplY3QlJzogWydQcm9taXNlJywgJ3JlamVjdCddLFxuXHQnJVByb21pc2VfcmVzb2x2ZSUnOiBbJ1Byb21pc2UnLCAncmVzb2x2ZSddLFxuXHQnJVJhbmdlRXJyb3JQcm90b3R5cGUlJzogWydSYW5nZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZmVyZW5jZUVycm9yUHJvdG90eXBlJSc6IFsnUmVmZXJlbmNlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVnRXhwUHJvdG90eXBlJSc6IFsnUmVnRXhwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVNldFByb3RvdHlwZSUnOiBbJ1NldCcsICdwcm90b3R5cGUnXSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ1NoYXJlZEFycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN0cmluZ1Byb3RvdHlwZSUnOiBbJ1N0cmluZycsICdwcm90b3R5cGUnXSxcblx0JyVTeW1ib2xQcm90b3R5cGUlJzogWydTeW1ib2wnLCAncHJvdG90eXBlJ10sXG5cdCclU3ludGF4RXJyb3JQcm90b3R5cGUlJzogWydTeW50YXhFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVHlwZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlRXJyb3JQcm90b3R5cGUlJzogWydUeXBlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUlJzogWydVaW50OENsYW1wZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnVWludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVVJJRXJyb3JQcm90b3R5cGUlJzogWydVUklFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrTWFwUHJvdG90eXBlJSc6IFsnV2Vha01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrU2V0UHJvdG90eXBlJSc6IFsnV2Vha1NldCcsICdwcm90b3R5cGUnXVxufTtcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnaGFzJyk7XG52YXIgJGNvbmNhdCA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBBcnJheS5wcm90b3R5cGUuY29uY2F0KTtcbnZhciAkc3BsaWNlQXBwbHkgPSBiaW5kLmNhbGwoRnVuY3Rpb24uYXBwbHksIEFycmF5LnByb3RvdHlwZS5zcGxpY2UpO1xudmFyICRyZXBsYWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG52YXIgJHN0clNsaWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUuc2xpY2UpO1xuXG4vKiBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi80LjE3LjE1L2Rpc3QvbG9kYXNoLmpzI0w2NzM1LUw2NzQ0ICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXiUuW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JSQpKS9nO1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nOyAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBmdW5jdGlvbiBzdHJpbmdUb1BhdGgoc3RyaW5nKSB7XG5cdHZhciBmaXJzdCA9ICRzdHJTbGljZShzdHJpbmcsIDAsIDEpO1xuXHR2YXIgbGFzdCA9ICRzdHJTbGljZShzdHJpbmcsIC0xKTtcblx0aWYgKGZpcnN0ID09PSAnJScgJiYgbGFzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYCcpO1xuXHR9IGVsc2UgaWYgKGxhc3QgPT09ICclJyAmJiBmaXJzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBvcGVuaW5nIGAlYCcpO1xuXHR9XG5cdHZhciByZXN1bHQgPSBbXTtcblx0JHJlcGxhY2Uoc3RyaW5nLCByZVByb3BOYW1lLCBmdW5jdGlvbiAobWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuXHRcdHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHF1b3RlID8gJHJlcGxhY2Uoc3ViU3RyaW5nLCByZUVzY2FwZUNoYXIsICckMScpIDogbnVtYmVyIHx8IG1hdGNoO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG4vKiBlbmQgYWRhcHRhdGlvbiAqL1xuXG52YXIgZ2V0QmFzZUludHJpbnNpYyA9IGZ1bmN0aW9uIGdldEJhc2VJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWNOYW1lID0gbmFtZTtcblx0dmFyIGFsaWFzO1xuXHRpZiAoaGFzT3duKExFR0FDWV9BTElBU0VTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdGFsaWFzID0gTEVHQUNZX0FMSUFTRVNbaW50cmluc2ljTmFtZV07XG5cdFx0aW50cmluc2ljTmFtZSA9ICclJyArIGFsaWFzWzBdICsgJyUnO1xuXHR9XG5cblx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdHZhciB2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljTmFtZV07XG5cdFx0aWYgKHZhbHVlID09PSBuZWVkc0V2YWwpIHtcblx0XHRcdHZhbHVlID0gZG9FdmFsKGludHJpbnNpY05hbWUpO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyAmJiAhYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSEnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YWxpYXM6IGFsaWFzLFxuXHRcdFx0bmFtZTogaW50cmluc2ljTmFtZSxcblx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdH07XG5cdH1cblxuXHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGRvZXMgbm90IGV4aXN0IScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBHZXRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgbmFtZS5sZW5ndGggPT09IDApIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGFsbG93TWlzc2luZyAhPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1wiYWxsb3dNaXNzaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblx0fVxuXG5cdHZhciBwYXJ0cyA9IHN0cmluZ1RvUGF0aChuYW1lKTtcblx0dmFyIGludHJpbnNpY0Jhc2VOYW1lID0gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzWzBdIDogJyc7XG5cblx0dmFyIGludHJpbnNpYyA9IGdldEJhc2VJbnRyaW5zaWMoJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJScsIGFsbG93TWlzc2luZyk7XG5cdHZhciBpbnRyaW5zaWNSZWFsTmFtZSA9IGludHJpbnNpYy5uYW1lO1xuXHR2YXIgdmFsdWUgPSBpbnRyaW5zaWMudmFsdWU7XG5cdHZhciBza2lwRnVydGhlckNhY2hpbmcgPSBmYWxzZTtcblxuXHR2YXIgYWxpYXMgPSBpbnRyaW5zaWMuYWxpYXM7XG5cdGlmIChhbGlhcykge1xuXHRcdGludHJpbnNpY0Jhc2VOYW1lID0gYWxpYXNbMF07XG5cdFx0JHNwbGljZUFwcGx5KHBhcnRzLCAkY29uY2F0KFswLCAxXSwgYWxpYXMpKTtcblx0fVxuXG5cdGZvciAodmFyIGkgPSAxLCBpc093biA9IHRydWU7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdHZhciBwYXJ0ID0gcGFydHNbaV07XG5cdFx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHBhcnQsIDAsIDEpO1xuXHRcdHZhciBsYXN0ID0gJHN0clNsaWNlKHBhcnQsIC0xKTtcblx0XHRpZiAoXG5cdFx0XHQoXG5cdFx0XHRcdChmaXJzdCA9PT0gJ1wiJyB8fCBmaXJzdCA9PT0gXCInXCIgfHwgZmlyc3QgPT09ICdgJylcblx0XHRcdFx0fHwgKGxhc3QgPT09ICdcIicgfHwgbGFzdCA9PT0gXCInXCIgfHwgbGFzdCA9PT0gJ2AnKVxuXHRcdFx0KVxuXHRcdFx0JiYgZmlyc3QgIT09IGxhc3Rcblx0XHQpIHtcblx0XHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ3Byb3BlcnR5IG5hbWVzIHdpdGggcXVvdGVzIG11c3QgaGF2ZSBtYXRjaGluZyBxdW90ZXMnKTtcblx0XHR9XG5cdFx0aWYgKHBhcnQgPT09ICdjb25zdHJ1Y3RvcicgfHwgIWlzT3duKSB7XG5cdFx0XHRza2lwRnVydGhlckNhY2hpbmcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGludHJpbnNpY0Jhc2VOYW1lICs9ICcuJyArIHBhcnQ7XG5cdFx0aW50cmluc2ljUmVhbE5hbWUgPSAnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJztcblxuXHRcdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljUmVhbE5hbWUpKSB7XG5cdFx0XHR2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0aWYgKCEocGFydCBpbiB2YWx1ZSkpIHtcblx0XHRcdFx0aWYgKCFhbGxvd01pc3NpbmcpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYmFzZSBpbnRyaW5zaWMgZm9yICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCB0aGUgcHJvcGVydHkgaXMgbm90IGF2YWlsYWJsZS4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdm9pZCB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoJGdPUEQgJiYgKGkgKyAxKSA+PSBwYXJ0cy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGRlc2MgPSAkZ09QRCh2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdGlzT3duID0gISFkZXNjO1xuXG5cdFx0XHRcdC8vIEJ5IGNvbnZlbnRpb24sIHdoZW4gYSBkYXRhIHByb3BlcnR5IGlzIGNvbnZlcnRlZCB0byBhbiBhY2Nlc3NvclxuXHRcdFx0XHQvLyBwcm9wZXJ0eSB0byBlbXVsYXRlIGEgZGF0YSBwcm9wZXJ0eSB0aGF0IGRvZXMgbm90IHN1ZmZlciBmcm9tXG5cdFx0XHRcdC8vIHRoZSBvdmVycmlkZSBtaXN0YWtlLCB0aGF0IGFjY2Vzc29yJ3MgZ2V0dGVyIGlzIG1hcmtlZCB3aXRoXG5cdFx0XHRcdC8vIGFuIGBvcmlnaW5hbFZhbHVlYCBwcm9wZXJ0eS4gSGVyZSwgd2hlbiB3ZSBkZXRlY3QgdGhpcywgd2Vcblx0XHRcdFx0Ly8gdXBob2xkIHRoZSBpbGx1c2lvbiBieSBwcmV0ZW5kaW5nIHRvIHNlZSB0aGF0IG9yaWdpbmFsIGRhdGFcblx0XHRcdFx0Ly8gcHJvcGVydHksIGkuZS4sIHJldHVybmluZyB0aGUgdmFsdWUgcmF0aGVyIHRoYW4gdGhlIGdldHRlclxuXHRcdFx0XHQvLyBpdHNlbGYuXG5cdFx0XHRcdGlmIChpc093biAmJiAnZ2V0JyBpbiBkZXNjICYmICEoJ29yaWdpbmFsVmFsdWUnIGluIGRlc2MuZ2V0KSkge1xuXHRcdFx0XHRcdHZhbHVlID0gZGVzYy5nZXQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aXNPd24gPSBoYXNPd24odmFsdWUsIHBhcnQpO1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNPd24gJiYgIXNraXBGdXJ0aGVyQ2FjaGluZykge1xuXHRcdFx0XHRJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0SW5mZXJyZWROYW1lO1xudHJ5IHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG5cdGdldEluZmVycmVkTmFtZSA9IEZ1bmN0aW9uKCdzJywgJ3JldHVybiB7IFtzXSgpIHt9IH1bc10ubmFtZTsnKTtcbn0gY2F0Y2ggKGUpIHt9XG5cbnZhciBpbmZlcnJlZCA9IGZ1bmN0aW9uICgpIHt9O1xubW9kdWxlLmV4cG9ydHMgPSBnZXRJbmZlcnJlZE5hbWUgJiYgaW5mZXJyZWQubmFtZSA9PT0gJ2luZmVycmVkJyA/IGdldEluZmVycmVkTmFtZSA6IG51bGw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG5cbnZhciAkU3ludGF4RXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVTeW50YXhFcnJvciUnKTtcbnZhciBnZXRHbG9iYWxTeW1ib2xEZXNjcmlwdGlvbiA9IEdldEludHJpbnNpYygnJVN5bWJvbC5rZXlGb3IlJywgdHJ1ZSk7XG52YXIgdGhpc1N5bWJvbFZhbHVlID0gY2FsbEJvdW5kKCclU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mJScsIHRydWUpO1xudmFyIHN5bVRvU3RyID0gY2FsbEJvdW5kKCdTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nJywgdHJ1ZSk7XG5cbnZhciBnZXRJbmZlcnJlZE5hbWUgPSByZXF1aXJlKCcuL2dldEluZmVycmVkTmFtZScpO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb25zaXN0ZW50LXJldHVybiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjYWxsQm91bmQoJyVTeW1ib2wucHJvdG90eXBlLmRlc2NyaXB0aW9uJScsIHRydWUpIHx8IGZ1bmN0aW9uIGdldFN5bWJvbERlc2NyaXB0aW9uKHN5bWJvbCkge1xuXHRpZiAoIXRoaXNTeW1ib2xWYWx1ZSkge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ1N5bWJvbHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuXHR9XG5cblx0Ly8gd2lsbCB0aHJvdyBpZiBub3QgYSBzeW1ib2wgcHJpbWl0aXZlIG9yIHdyYXBwZXIgb2JqZWN0XG5cdHZhciBzeW0gPSB0aGlzU3ltYm9sVmFsdWUoc3ltYm9sKTtcblxuXHRpZiAoZ2V0SW5mZXJyZWROYW1lKSB7XG5cdFx0dmFyIG5hbWUgPSBnZXRJbmZlcnJlZE5hbWUoc3ltKTtcblx0XHRpZiAobmFtZSA9PT0gJycpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWUuc2xpY2UoMSwgLTEpOyAvLyBuYW1lLnNsaWNlKCdbJy5sZW5ndGgsIC0nXScubGVuZ3RoKTtcblx0fVxuXG5cdHZhciBkZXNjO1xuXHRpZiAoZ2V0R2xvYmFsU3ltYm9sRGVzY3JpcHRpb24pIHtcblx0XHRkZXNjID0gZ2V0R2xvYmFsU3ltYm9sRGVzY3JpcHRpb24oc3ltKTtcblx0XHRpZiAodHlwZW9mIGRlc2MgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gZGVzYztcblx0XHR9XG5cdH1cblxuXHRkZXNjID0gc3ltVG9TdHIoc3ltKS5zbGljZSg3LCAtMSk7IC8vIHN0ci5zbGljZSgnU3ltYm9sKCcubGVuZ3RoLCAtJyknLmxlbmd0aCk7XG5cdGlmIChkZXNjKSB7XG5cdFx0cmV0dXJuIGRlc2M7XG5cdH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4vc2hpbScpKCk7XG4iLCIvKiBlc2xpbnQgbm8tbmVnYXRlZC1jb25kaXRpb246IDAsIG5vLW5ldy1mdW5jOiAwICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHNlbGY7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gd2luZG93O1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsICE9PSAnb2JqZWN0JyB8fCAhZ2xvYmFsIHx8IGdsb2JhbC5NYXRoICE9PSBNYXRoIHx8IGdsb2JhbC5BcnJheSAhPT0gQXJyYXkpIHtcblx0XHRyZXR1cm4gaW1wbGVtZW50YXRpb247XG5cdH1cblx0cmV0dXJuIGdsb2JhbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1HbG9iYWwoKSB7XG5cdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG5cdGlmIChkZWZpbmUuc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuXHRcdHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwb2x5ZmlsbCwgJ2dsb2JhbFRoaXMnKTtcblx0XHRpZiAoIWRlc2NyaXB0b3IgfHwgKGRlc2NyaXB0b3IuY29uZmlndXJhYmxlICYmIChkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZGVzY3JpcHRvci53cml0YWJsZSB8fCBnbG9iYWxUaGlzICE9PSBwb2x5ZmlsbCkpKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbWF4LWxlblxuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHBvbHlmaWxsLCAnZ2xvYmFsVGhpcycsIHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdFx0dmFsdWU6IHBvbHlmaWxsLFxuXHRcdFx0XHR3cml0YWJsZTogZmFsc2Vcblx0XHRcdH0pO1xuXHRcdH1cblx0fSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ29iamVjdCcgfHwgZ2xvYmFsVGhpcyAhPT0gcG9seWZpbGwpIHtcblx0XHRwb2x5ZmlsbC5nbG9iYWxUaGlzID0gcG9seWZpbGw7XG5cdH1cblx0cmV0dXJuIHBvbHlmaWxsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG9yaWdTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2w7XG52YXIgaGFzU3ltYm9sU2hhbSA9IHJlcXVpcmUoJy4vc2hhbXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2woJ2ZvbycpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2woJ2JhcicpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRyZXR1cm4gaGFzU3ltYm9sU2hhbSgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IGNvbXBsZXhpdHk6IFsyLCAxOF0sIG1heC1zdGF0ZW1lbnRzOiBbMiwgMzNdICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1N5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHsgcmV0dXJuIHRydWU7IH1cblxuXHR2YXIgb2JqID0ge307XG5cdHZhciBzeW0gPSBTeW1ib2woJ3Rlc3QnKTtcblx0dmFyIHN5bU9iaiA9IE9iamVjdChzeW0pO1xuXHRpZiAodHlwZW9mIHN5bSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW1PYmopICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL29iamVjdC5hc3NpZ24vaXNzdWVzLzE3XG5cdC8vIGlmIChzeW0gaW5zdGFuY2VvZiBTeW1ib2wpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uL2dldC1vd24tcHJvcGVydHktc3ltYm9scy9pc3N1ZXMvNFxuXHQvLyBpZiAoIShzeW1PYmogaW5zdGFuY2VvZiBTeW1ib2wpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIGlmICh0eXBlb2YgU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gaWYgKFN0cmluZyhzeW0pICE9PSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltVmFsID0gNDI7XG5cdG9ialtzeW1dID0gc3ltVmFsO1xuXHRmb3IgKHN5bSBpbiBvYmopIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLXVucmVhY2hhYmxlLWxvb3Bcblx0aWYgKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1zID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopO1xuXHRpZiAoc3ltcy5sZW5ndGggIT09IDEgfHwgc3ltc1swXSAhPT0gc3ltKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwgc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBzeW0pO1xuXHRcdGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBzeW1WYWwgfHwgZGVzY3JpcHRvci5lbnVtZXJhYmxlICE9PSB0cnVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzL3NoYW1zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzVG9TdHJpbmdUYWdTaGFtcygpIHtcblx0cmV0dXJuIGhhc1N5bWJvbHMoKSAmJiAhIVN5bWJvbC50b1N0cmluZ1RhZztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiIsIihmdW5jdGlvbigpIHtcblx0dmFyIHRlc3RPYmplY3QgPSB7fTtcblxuXHRpZiAoIShPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgdGVzdE9iamVjdC5fX3Byb3RvX18pKSB7XG5cdFx0dmFyIG5hdGl2ZUdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG5cdFx0T2JqZWN0LmdldFByb3RvdHlwZU9mID0gZnVuY3Rpb24ob2JqZWN0KSB7XG5cdFx0XHRpZiAob2JqZWN0Ll9fcHJvdG9fXykge1xuXHRcdFx0XHRyZXR1cm4gb2JqZWN0Ll9fcHJvdG9fXztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBuYXRpdmVHZXRQcm90b3R5cGVPZi5jYWxsKE9iamVjdCwgb2JqZWN0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pKCk7XG4iLCJmdW5jdGlvbiBoaWRlUGxhY2Vob2xkZXJPbkZvY3VzKGEpe3RhcmdldD1hLmN1cnJlbnRUYXJnZXQ/YS5jdXJyZW50VGFyZ2V0OmEuc3JjRWxlbWVudCx0YXJnZXQudmFsdWU9PXRhcmdldC5nZXRBdHRyaWJ1dGUoXCJwbGFjZWhvbGRlclwiKSYmKHRhcmdldC52YWx1ZT1cIlwiKX1mdW5jdGlvbiB1bmZvY3VzT25BbkVsZW1lbnQoYSl7dGFyZ2V0PWEuY3VycmVudFRhcmdldD9hLmN1cnJlbnRUYXJnZXQ6YS5zcmNFbGVtZW50LFwiXCI9PXRhcmdldC52YWx1ZSYmKHRhcmdldC52YWx1ZT10YXJnZXQuZ2V0QXR0cmlidXRlKFwicGxhY2Vob2xkZXJcIikpfWlmKCEoXCJwbGFjZWhvbGRlclwiaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpKSlmb3IodmFyIGlucHV0cz1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpLGk9MDtpPGlucHV0cy5sZW5ndGg7aSsrKWlucHV0c1tpXS52YWx1ZXx8KGlucHV0c1tpXS52YWx1ZT1pbnB1dHNbaV0uZ2V0QXR0cmlidXRlKFwicGxhY2Vob2xkZXJcIikpLGlucHV0c1tpXS5hZGRFdmVudExpc3RlbmVyPyhpbnB1dHNbaV0uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsaGlkZVBsYWNlaG9sZGVyT25Gb2N1cywhMSksaW5wdXRzW2ldLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsdW5mb2N1c09uQW5FbGVtZW50LCExKSk6aW5wdXRzW2ldLmF0dGFjaEV2ZW50JiYoaW5wdXRzW2ldLmF0dGFjaEV2ZW50KFwib25jbGlja1wiLGhpZGVQbGFjZWhvbGRlck9uRm9jdXMpLGlucHV0c1tpXS5hdHRhY2hFdmVudChcIm9uYmx1clwiLHVuZm9jdXNPbkFuRWxlbWVudCkpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcbnZhciBoYXMgPSByZXF1aXJlKCdoYXMnKTtcbnZhciBjaGFubmVsID0gcmVxdWlyZSgnc2lkZS1jaGFubmVsJykoKTtcblxudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG5cbnZhciBTTE9UID0ge1xuXHRhc3NlcnQ6IGZ1bmN0aW9uIChPLCBzbG90KSB7XG5cdFx0aWYgKCFPIHx8ICh0eXBlb2YgTyAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIE8gIT09ICdmdW5jdGlvbicpKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYE9gIGlzIG5vdCBhbiBvYmplY3QnKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiBzbG90ICE9PSAnc3RyaW5nJykge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2BzbG90YCBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cdFx0fVxuXHRcdGNoYW5uZWwuYXNzZXJ0KE8pO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uIChPLCBzbG90KSB7XG5cdFx0aWYgKCFPIHx8ICh0eXBlb2YgTyAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIE8gIT09ICdmdW5jdGlvbicpKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYE9gIGlzIG5vdCBhbiBvYmplY3QnKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiBzbG90ICE9PSAnc3RyaW5nJykge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2BzbG90YCBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cdFx0fVxuXHRcdHZhciBzbG90cyA9IGNoYW5uZWwuZ2V0KE8pO1xuXHRcdHJldHVybiBzbG90cyAmJiBzbG90c1snJCcgKyBzbG90XTtcblx0fSxcblx0aGFzOiBmdW5jdGlvbiAoTywgc2xvdCkge1xuXHRcdGlmICghTyB8fCAodHlwZW9mIE8gIT09ICdvYmplY3QnICYmIHR5cGVvZiBPICE9PSAnZnVuY3Rpb24nKSkge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2BPYCBpcyBub3QgYW4gb2JqZWN0Jyk7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2Ygc2xvdCAhPT0gJ3N0cmluZycpIHtcblx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgc2xvdGAgbXVzdCBiZSBhIHN0cmluZycpO1xuXHRcdH1cblx0XHR2YXIgc2xvdHMgPSBjaGFubmVsLmdldChPKTtcblx0XHRyZXR1cm4gISFzbG90cyAmJiBoYXMoc2xvdHMsICckJyArIHNsb3QpO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uIChPLCBzbG90LCBWKSB7XG5cdFx0aWYgKCFPIHx8ICh0eXBlb2YgTyAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIE8gIT09ICdmdW5jdGlvbicpKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYE9gIGlzIG5vdCBhbiBvYmplY3QnKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiBzbG90ICE9PSAnc3RyaW5nJykge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2BzbG90YCBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cdFx0fVxuXHRcdHZhciBzbG90cyA9IGNoYW5uZWwuZ2V0KE8pO1xuXHRcdGlmICghc2xvdHMpIHtcblx0XHRcdHNsb3RzID0ge307XG5cdFx0XHRjaGFubmVsLnNldChPLCBzbG90cyk7XG5cdFx0fVxuXHRcdHNsb3RzWyckJyArIHNsb3RdID0gVjtcblx0fVxufTtcblxuaWYgKE9iamVjdC5mcmVlemUpIHtcblx0T2JqZWN0LmZyZWV6ZShTTE9UKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTTE9UO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBXM0MgU09GVFdBUkUgQU5EIERPQ1VNRU5UIE5PVElDRSBBTkQgTElDRU5TRS5cbiAqXG4gKiAgaHR0cHM6Ly93d3cudzMub3JnL0NvbnNvcnRpdW0vTGVnYWwvMjAxNS9jb3B5cmlnaHQtc29mdHdhcmUtYW5kLWRvY3VtZW50XG4gKlxuICovXG5cbihmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50KSB7XG4ndXNlIHN0cmljdCc7XG5cblxuLy8gRXhpdHMgZWFybHkgaWYgYWxsIEludGVyc2VjdGlvbk9ic2VydmVyIGFuZCBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5XG4vLyBmZWF0dXJlcyBhcmUgbmF0aXZlbHkgc3VwcG9ydGVkLlxuaWYgKCdJbnRlcnNlY3Rpb25PYnNlcnZlcicgaW4gd2luZG93ICYmXG4gICAgJ0ludGVyc2VjdGlvbk9ic2VydmVyRW50cnknIGluIHdpbmRvdyAmJlxuICAgICdpbnRlcnNlY3Rpb25SYXRpbycgaW4gd2luZG93LkludGVyc2VjdGlvbk9ic2VydmVyRW50cnkucHJvdG90eXBlKSB7XG5cbiAgLy8gTWluaW1hbCBwb2x5ZmlsbCBmb3IgRWRnZSAxNSdzIGxhY2sgb2YgYGlzSW50ZXJzZWN0aW5nYFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvSW50ZXJzZWN0aW9uT2JzZXJ2ZXIvaXNzdWVzLzIxMVxuICBpZiAoISgnaXNJbnRlcnNlY3RpbmcnIGluIHdpbmRvdy5JbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5LnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LkludGVyc2VjdGlvbk9ic2VydmVyRW50cnkucHJvdG90eXBlLFxuICAgICAgJ2lzSW50ZXJzZWN0aW5nJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVyc2VjdGlvblJhdGlvID4gMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm47XG59XG5cblxuLyoqXG4gKiBBbiBJbnRlcnNlY3Rpb25PYnNlcnZlciByZWdpc3RyeS4gVGhpcyByZWdpc3RyeSBleGlzdHMgdG8gaG9sZCBhIHN0cm9uZ1xuICogcmVmZXJlbmNlIHRvIEludGVyc2VjdGlvbk9ic2VydmVyIGluc3RhbmNlcyBjdXJyZW50bHkgb2JzZXJ2aW5nIGEgdGFyZ2V0XG4gKiBlbGVtZW50LiBXaXRob3V0IHRoaXMgcmVnaXN0cnksIGluc3RhbmNlcyB3aXRob3V0IGFub3RoZXIgcmVmZXJlbmNlIG1heSBiZVxuICogZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gKi9cbnZhciByZWdpc3RyeSA9IFtdO1xuXG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgZ2xvYmFsIEludGVyc2VjdGlvbk9ic2VydmVyRW50cnkgY29uc3RydWN0b3IuXG4gKiBodHRwczovL3czYy5naXRodWIuaW8vSW50ZXJzZWN0aW9uT2JzZXJ2ZXIvI2ludGVyc2VjdGlvbi1vYnNlcnZlci1lbnRyeVxuICogQHBhcmFtIHtPYmplY3R9IGVudHJ5IEEgZGljdGlvbmFyeSBvZiBpbnN0YW5jZSBwcm9wZXJ0aWVzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEludGVyc2VjdGlvbk9ic2VydmVyRW50cnkoZW50cnkpIHtcbiAgdGhpcy50aW1lID0gZW50cnkudGltZTtcbiAgdGhpcy50YXJnZXQgPSBlbnRyeS50YXJnZXQ7XG4gIHRoaXMucm9vdEJvdW5kcyA9IGVudHJ5LnJvb3RCb3VuZHM7XG4gIHRoaXMuYm91bmRpbmdDbGllbnRSZWN0ID0gZW50cnkuYm91bmRpbmdDbGllbnRSZWN0O1xuICB0aGlzLmludGVyc2VjdGlvblJlY3QgPSBlbnRyeS5pbnRlcnNlY3Rpb25SZWN0IHx8IGdldEVtcHR5UmVjdCgpO1xuICB0aGlzLmlzSW50ZXJzZWN0aW5nID0gISFlbnRyeS5pbnRlcnNlY3Rpb25SZWN0O1xuXG4gIC8vIENhbGN1bGF0ZXMgdGhlIGludGVyc2VjdGlvbiByYXRpby5cbiAgdmFyIHRhcmdldFJlY3QgPSB0aGlzLmJvdW5kaW5nQ2xpZW50UmVjdDtcbiAgdmFyIHRhcmdldEFyZWEgPSB0YXJnZXRSZWN0LndpZHRoICogdGFyZ2V0UmVjdC5oZWlnaHQ7XG4gIHZhciBpbnRlcnNlY3Rpb25SZWN0ID0gdGhpcy5pbnRlcnNlY3Rpb25SZWN0O1xuICB2YXIgaW50ZXJzZWN0aW9uQXJlYSA9IGludGVyc2VjdGlvblJlY3Qud2lkdGggKiBpbnRlcnNlY3Rpb25SZWN0LmhlaWdodDtcblxuICAvLyBTZXRzIGludGVyc2VjdGlvbiByYXRpby5cbiAgaWYgKHRhcmdldEFyZWEpIHtcbiAgICAvLyBSb3VuZCB0aGUgaW50ZXJzZWN0aW9uIHJhdGlvIHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IG1hdGggaXNzdWVzOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvSW50ZXJzZWN0aW9uT2JzZXJ2ZXIvaXNzdWVzLzMyNFxuICAgIHRoaXMuaW50ZXJzZWN0aW9uUmF0aW8gPSBOdW1iZXIoKGludGVyc2VjdGlvbkFyZWEgLyB0YXJnZXRBcmVhKS50b0ZpeGVkKDQpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBhcmVhIGlzIHplcm8gYW5kIGlzIGludGVyc2VjdGluZywgc2V0cyB0byAxLCBvdGhlcndpc2UgdG8gMFxuICAgIHRoaXMuaW50ZXJzZWN0aW9uUmF0aW8gPSB0aGlzLmlzSW50ZXJzZWN0aW5nID8gMSA6IDA7XG4gIH1cbn1cblxuXG4vKipcbiAqIENyZWF0ZXMgdGhlIGdsb2JhbCBJbnRlcnNlY3Rpb25PYnNlcnZlciBjb25zdHJ1Y3Rvci5cbiAqIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9JbnRlcnNlY3Rpb25PYnNlcnZlci8jaW50ZXJzZWN0aW9uLW9ic2VydmVyLWludGVyZmFjZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgaW50ZXJzZWN0aW9uXG4gKiAgICAgY2hhbmdlcyBoYXZlIHF1ZXVlZC4gVGhlIGZ1bmN0aW9uIGlzIG5vdCBpbnZva2VkIGlmIHRoZSBxdWV1ZSBoYXNcbiAqICAgICBiZWVuIGVtcHRpZWQgYnkgY2FsbGluZyB0aGUgYHRha2VSZWNvcmRzYCBtZXRob2QuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF9vcHRpb25zIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBJbnRlcnNlY3Rpb25PYnNlcnZlcihjYWxsYmFjaywgb3B0X29wdGlvbnMpIHtcblxuICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5yb290ICYmIG9wdGlvbnMucm9vdC5ub2RlVHlwZSAhPSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyb290IG11c3QgYmUgYW4gRWxlbWVudCcpO1xuICB9XG5cbiAgLy8gQmluZHMgYW5kIHRocm90dGxlcyBgdGhpcy5fY2hlY2tGb3JJbnRlcnNlY3Rpb25zYC5cbiAgdGhpcy5fY2hlY2tGb3JJbnRlcnNlY3Rpb25zID0gdGhyb3R0bGUoXG4gICAgICB0aGlzLl9jaGVja0ZvckludGVyc2VjdGlvbnMuYmluZCh0aGlzKSwgdGhpcy5USFJPVFRMRV9USU1FT1VUKTtcblxuICAvLyBQcml2YXRlIHByb3BlcnRpZXMuXG4gIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2s7XG4gIHRoaXMuX29ic2VydmF0aW9uVGFyZ2V0cyA9IFtdO1xuICB0aGlzLl9xdWV1ZWRFbnRyaWVzID0gW107XG4gIHRoaXMuX3Jvb3RNYXJnaW5WYWx1ZXMgPSB0aGlzLl9wYXJzZVJvb3RNYXJnaW4ob3B0aW9ucy5yb290TWFyZ2luKTtcblxuICAvLyBQdWJsaWMgcHJvcGVydGllcy5cbiAgdGhpcy50aHJlc2hvbGRzID0gdGhpcy5faW5pdFRocmVzaG9sZHMob3B0aW9ucy50aHJlc2hvbGQpO1xuICB0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3QgfHwgbnVsbDtcbiAgdGhpcy5yb290TWFyZ2luID0gdGhpcy5fcm9vdE1hcmdpblZhbHVlcy5tYXAoZnVuY3Rpb24obWFyZ2luKSB7XG4gICAgcmV0dXJuIG1hcmdpbi52YWx1ZSArIG1hcmdpbi51bml0O1xuICB9KS5qb2luKCcgJyk7XG59XG5cblxuLyoqXG4gKiBUaGUgbWluaW11bSBpbnRlcnZhbCB3aXRoaW4gd2hpY2ggdGhlIGRvY3VtZW50IHdpbGwgYmUgY2hlY2tlZCBmb3JcbiAqIGludGVyc2VjdGlvbiBjaGFuZ2VzLlxuICovXG5JbnRlcnNlY3Rpb25PYnNlcnZlci5wcm90b3R5cGUuVEhST1RUTEVfVElNRU9VVCA9IDEwMDtcblxuXG4vKipcbiAqIFRoZSBmcmVxdWVuY3kgaW4gd2hpY2ggdGhlIHBvbHlmaWxsIHBvbGxzIGZvciBpbnRlcnNlY3Rpb24gY2hhbmdlcy5cbiAqIHRoaXMgY2FuIGJlIHVwZGF0ZWQgb24gYSBwZXIgaW5zdGFuY2UgYmFzaXMgYW5kIG11c3QgYmUgc2V0IHByaW9yIHRvXG4gKiBjYWxsaW5nIGBvYnNlcnZlYCBvbiB0aGUgZmlyc3QgdGFyZ2V0LlxuICovXG5JbnRlcnNlY3Rpb25PYnNlcnZlci5wcm90b3R5cGUuUE9MTF9JTlRFUlZBTCA9IG51bGw7XG5cbi8qKlxuICogVXNlIGEgbXV0YXRpb24gb2JzZXJ2ZXIgb24gdGhlIHJvb3QgZWxlbWVudFxuICogdG8gZGV0ZWN0IGludGVyc2VjdGlvbiBjaGFuZ2VzLlxuICovXG5JbnRlcnNlY3Rpb25PYnNlcnZlci5wcm90b3R5cGUuVVNFX01VVEFUSU9OX09CU0VSVkVSID0gdHJ1ZTtcblxuXG4vKipcbiAqIFN0YXJ0cyBvYnNlcnZpbmcgYSB0YXJnZXQgZWxlbWVudCBmb3IgaW50ZXJzZWN0aW9uIGNoYW5nZXMgYmFzZWQgb25cbiAqIHRoZSB0aHJlc2hvbGRzIHZhbHVlcy5cbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IFRoZSBET00gZWxlbWVudCB0byBvYnNlcnZlLlxuICovXG5JbnRlcnNlY3Rpb25PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICB2YXIgaXNUYXJnZXRBbHJlYWR5T2JzZXJ2ZWQgPSB0aGlzLl9vYnNlcnZhdGlvblRhcmdldHMuc29tZShmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0uZWxlbWVudCA9PSB0YXJnZXQ7XG4gIH0pO1xuXG4gIGlmIChpc1RhcmdldEFscmVhZHlPYnNlcnZlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghKHRhcmdldCAmJiB0YXJnZXQubm9kZVR5cGUgPT0gMSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldCBtdXN0IGJlIGFuIEVsZW1lbnQnKTtcbiAgfVxuXG4gIHRoaXMuX3JlZ2lzdGVySW5zdGFuY2UoKTtcbiAgdGhpcy5fb2JzZXJ2YXRpb25UYXJnZXRzLnB1c2goe2VsZW1lbnQ6IHRhcmdldCwgZW50cnk6IG51bGx9KTtcbiAgdGhpcy5fbW9uaXRvckludGVyc2VjdGlvbnMoKTtcbiAgdGhpcy5fY2hlY2tGb3JJbnRlcnNlY3Rpb25zKCk7XG59O1xuXG5cbi8qKlxuICogU3RvcHMgb2JzZXJ2aW5nIGEgdGFyZ2V0IGVsZW1lbnQgZm9yIGludGVyc2VjdGlvbiBjaGFuZ2VzLlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgVGhlIERPTSBlbGVtZW50IHRvIG9ic2VydmUuXG4gKi9cbkludGVyc2VjdGlvbk9ic2VydmVyLnByb3RvdHlwZS51bm9ic2VydmUgPSBmdW5jdGlvbih0YXJnZXQpIHtcbiAgdGhpcy5fb2JzZXJ2YXRpb25UYXJnZXRzID1cbiAgICAgIHRoaXMuX29ic2VydmF0aW9uVGFyZ2V0cy5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuXG4gICAgcmV0dXJuIGl0ZW0uZWxlbWVudCAhPSB0YXJnZXQ7XG4gIH0pO1xuICBpZiAoIXRoaXMuX29ic2VydmF0aW9uVGFyZ2V0cy5sZW5ndGgpIHtcbiAgICB0aGlzLl91bm1vbml0b3JJbnRlcnNlY3Rpb25zKCk7XG4gICAgdGhpcy5fdW5yZWdpc3Rlckluc3RhbmNlKCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTdG9wcyBvYnNlcnZpbmcgYWxsIHRhcmdldCBlbGVtZW50cyBmb3IgaW50ZXJzZWN0aW9uIGNoYW5nZXMuXG4gKi9cbkludGVyc2VjdGlvbk9ic2VydmVyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX29ic2VydmF0aW9uVGFyZ2V0cyA9IFtdO1xuICB0aGlzLl91bm1vbml0b3JJbnRlcnNlY3Rpb25zKCk7XG4gIHRoaXMuX3VucmVnaXN0ZXJJbnN0YW5jZSgpO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgYW55IHF1ZXVlIGVudHJpZXMgdGhhdCBoYXZlIG5vdCB5ZXQgYmVlbiByZXBvcnRlZCB0byB0aGVcbiAqIGNhbGxiYWNrIGFuZCBjbGVhcnMgdGhlIHF1ZXVlLiBUaGlzIGNhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlXG4gKiBjYWxsYmFjayB0byBvYnRhaW4gdGhlIGFic29sdXRlIG1vc3QgdXAtdG8tZGF0ZSBpbnRlcnNlY3Rpb24gaW5mb3JtYXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGN1cnJlbnRseSBxdWV1ZWQgZW50cmllcy5cbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLnRha2VSZWNvcmRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZWNvcmRzID0gdGhpcy5fcXVldWVkRW50cmllcy5zbGljZSgpO1xuICB0aGlzLl9xdWV1ZWRFbnRyaWVzID0gW107XG4gIHJldHVybiByZWNvcmRzO1xufTtcblxuXG4vKipcbiAqIEFjY2VwdHMgdGhlIHRocmVzaG9sZCB2YWx1ZSBmcm9tIHRoZSB1c2VyIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGFuZFxuICogcmV0dXJucyBhIHNvcnRlZCBhcnJheSBvZiB1bmlxdWUgdGhyZXNob2xkIHZhbHVlcy4gSWYgYSB2YWx1ZSBpcyBub3RcbiAqIGJldHdlZW4gMCBhbmQgMSBhbmQgZXJyb3IgaXMgdGhyb3duLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8bnVtYmVyPX0gb3B0X3RocmVzaG9sZCBBbiBvcHRpb25hbCB0aHJlc2hvbGQgdmFsdWUgb3JcbiAqICAgICBhIGxpc3Qgb2YgdGhyZXNob2xkIHZhbHVlcywgZGVmYXVsdGluZyB0byBbMF0uXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBzb3J0ZWQgbGlzdCBvZiB1bmlxdWUgYW5kIHZhbGlkIHRocmVzaG9sZCB2YWx1ZXMuXG4gKi9cbkludGVyc2VjdGlvbk9ic2VydmVyLnByb3RvdHlwZS5faW5pdFRocmVzaG9sZHMgPSBmdW5jdGlvbihvcHRfdGhyZXNob2xkKSB7XG4gIHZhciB0aHJlc2hvbGQgPSBvcHRfdGhyZXNob2xkIHx8IFswXTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHRocmVzaG9sZCkpIHRocmVzaG9sZCA9IFt0aHJlc2hvbGRdO1xuXG4gIHJldHVybiB0aHJlc2hvbGQuc29ydCgpLmZpbHRlcihmdW5jdGlvbih0LCBpLCBhKSB7XG4gICAgaWYgKHR5cGVvZiB0ICE9ICdudW1iZXInIHx8IGlzTmFOKHQpIHx8IHQgPCAwIHx8IHQgPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RocmVzaG9sZCBtdXN0IGJlIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSBpbmNsdXNpdmVseScpO1xuICAgIH1cbiAgICByZXR1cm4gdCAhPT0gYVtpIC0gMV07XG4gIH0pO1xufTtcblxuXG4vKipcbiAqIEFjY2VwdHMgdGhlIHJvb3RNYXJnaW4gdmFsdWUgZnJvbSB0aGUgdXNlciBjb25maWd1cmF0aW9uIG9iamVjdFxuICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGZvdXIgbWFyZ2luIHZhbHVlcyBhcyBhbiBvYmplY3QgY29udGFpbmluZ1xuICogdGhlIHZhbHVlIGFuZCB1bml0IHByb3BlcnRpZXMuIElmIGFueSBvZiB0aGUgdmFsdWVzIGFyZSBub3QgcHJvcGVybHlcbiAqIGZvcm1hdHRlZCBvciB1c2UgYSB1bml0IG90aGVyIHRoYW4gcHggb3IgJSwgYW5kIGVycm9yIGlzIHRocm93bi5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdF9yb290TWFyZ2luIEFuIG9wdGlvbmFsIHJvb3RNYXJnaW4gdmFsdWUsXG4gKiAgICAgZGVmYXVsdGluZyB0byAnMHB4Jy5cbiAqIEByZXR1cm4ge0FycmF5PE9iamVjdD59IEFuIGFycmF5IG9mIG1hcmdpbiBvYmplY3RzIHdpdGggdGhlIGtleXNcbiAqICAgICB2YWx1ZSBhbmQgdW5pdC5cbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLl9wYXJzZVJvb3RNYXJnaW4gPSBmdW5jdGlvbihvcHRfcm9vdE1hcmdpbikge1xuICB2YXIgbWFyZ2luU3RyaW5nID0gb3B0X3Jvb3RNYXJnaW4gfHwgJzBweCc7XG4gIHZhciBtYXJnaW5zID0gbWFyZ2luU3RyaW5nLnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uKG1hcmdpbikge1xuICAgIHZhciBwYXJ0cyA9IC9eKC0/XFxkKlxcLj9cXGQrKShweHwlKSQvLmV4ZWMobWFyZ2luKTtcbiAgICBpZiAoIXBhcnRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jvb3RNYXJnaW4gbXVzdCBiZSBzcGVjaWZpZWQgaW4gcGl4ZWxzIG9yIHBlcmNlbnQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHt2YWx1ZTogcGFyc2VGbG9hdChwYXJ0c1sxXSksIHVuaXQ6IHBhcnRzWzJdfTtcbiAgfSk7XG5cbiAgLy8gSGFuZGxlcyBzaG9ydGhhbmQuXG4gIG1hcmdpbnNbMV0gPSBtYXJnaW5zWzFdIHx8IG1hcmdpbnNbMF07XG4gIG1hcmdpbnNbMl0gPSBtYXJnaW5zWzJdIHx8IG1hcmdpbnNbMF07XG4gIG1hcmdpbnNbM10gPSBtYXJnaW5zWzNdIHx8IG1hcmdpbnNbMV07XG5cbiAgcmV0dXJuIG1hcmdpbnM7XG59O1xuXG5cbi8qKlxuICogU3RhcnRzIHBvbGxpbmcgZm9yIGludGVyc2VjdGlvbiBjaGFuZ2VzIGlmIHRoZSBwb2xsaW5nIGlzIG5vdCBhbHJlYWR5XG4gKiBoYXBwZW5pbmcsIGFuZCBpZiB0aGUgcGFnZSdzIHZpc2liaWxpdHkgc3RhdGUgaXMgdmlzaWJsZS5cbiAqIEBwcml2YXRlXG4gKi9cbkludGVyc2VjdGlvbk9ic2VydmVyLnByb3RvdHlwZS5fbW9uaXRvckludGVyc2VjdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9tb25pdG9yaW5nSW50ZXJzZWN0aW9ucykge1xuICAgIHRoaXMuX21vbml0b3JpbmdJbnRlcnNlY3Rpb25zID0gdHJ1ZTtcblxuICAgIC8vIElmIGEgcG9sbCBpbnRlcnZhbCBpcyBzZXQsIHVzZSBwb2xsaW5nIGluc3RlYWQgb2YgbGlzdGVuaW5nIHRvXG4gICAgLy8gcmVzaXplIGFuZCBzY3JvbGwgZXZlbnRzIG9yIERPTSBtdXRhdGlvbnMuXG4gICAgaWYgKHRoaXMuUE9MTF9JTlRFUlZBTCkge1xuICAgICAgdGhpcy5fbW9uaXRvcmluZ0ludGVydmFsID0gc2V0SW50ZXJ2YWwoXG4gICAgICAgICAgdGhpcy5fY2hlY2tGb3JJbnRlcnNlY3Rpb25zLCB0aGlzLlBPTExfSU5URVJWQUwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGFkZEV2ZW50KHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX2NoZWNrRm9ySW50ZXJzZWN0aW9ucywgdHJ1ZSk7XG4gICAgICBhZGRFdmVudChkb2N1bWVudCwgJ3Njcm9sbCcsIHRoaXMuX2NoZWNrRm9ySW50ZXJzZWN0aW9ucywgdHJ1ZSk7XG5cbiAgICAgIGlmICh0aGlzLlVTRV9NVVRBVElPTl9PQlNFUlZFUiAmJiAnTXV0YXRpb25PYnNlcnZlcicgaW4gd2luZG93KSB7XG4gICAgICAgIHRoaXMuX2RvbU9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5fY2hlY2tGb3JJbnRlcnNlY3Rpb25zKTtcbiAgICAgICAgdGhpcy5fZG9tT2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwge1xuICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gICAgICAgICAgc3VidHJlZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTdG9wcyBwb2xsaW5nIGZvciBpbnRlcnNlY3Rpb24gY2hhbmdlcy5cbiAqIEBwcml2YXRlXG4gKi9cbkludGVyc2VjdGlvbk9ic2VydmVyLnByb3RvdHlwZS5fdW5tb25pdG9ySW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fbW9uaXRvcmluZ0ludGVyc2VjdGlvbnMpIHtcbiAgICB0aGlzLl9tb25pdG9yaW5nSW50ZXJzZWN0aW9ucyA9IGZhbHNlO1xuXG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9tb25pdG9yaW5nSW50ZXJ2YWwpO1xuICAgIHRoaXMuX21vbml0b3JpbmdJbnRlcnZhbCA9IG51bGw7XG5cbiAgICByZW1vdmVFdmVudCh3aW5kb3csICdyZXNpemUnLCB0aGlzLl9jaGVja0ZvckludGVyc2VjdGlvbnMsIHRydWUpO1xuICAgIHJlbW92ZUV2ZW50KGRvY3VtZW50LCAnc2Nyb2xsJywgdGhpcy5fY2hlY2tGb3JJbnRlcnNlY3Rpb25zLCB0cnVlKTtcblxuICAgIGlmICh0aGlzLl9kb21PYnNlcnZlcikge1xuICAgICAgdGhpcy5fZG9tT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5fZG9tT2JzZXJ2ZXIgPSBudWxsO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIFNjYW5zIGVhY2ggb2JzZXJ2YXRpb24gdGFyZ2V0IGZvciBpbnRlcnNlY3Rpb24gY2hhbmdlcyBhbmQgYWRkcyB0aGVtXG4gKiB0byB0aGUgaW50ZXJuYWwgZW50cmllcyBxdWV1ZS4gSWYgbmV3IGVudHJpZXMgYXJlIGZvdW5kLCBpdFxuICogc2NoZWR1bGVzIHRoZSBjYWxsYmFjayB0byBiZSBpbnZva2VkLlxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLl9jaGVja0ZvckludGVyc2VjdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJvb3RJc0luRG9tID0gdGhpcy5fcm9vdElzSW5Eb20oKTtcbiAgdmFyIHJvb3RSZWN0ID0gcm9vdElzSW5Eb20gPyB0aGlzLl9nZXRSb290UmVjdCgpIDogZ2V0RW1wdHlSZWN0KCk7XG5cbiAgdGhpcy5fb2JzZXJ2YXRpb25UYXJnZXRzLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgIHZhciB0YXJnZXQgPSBpdGVtLmVsZW1lbnQ7XG4gICAgdmFyIHRhcmdldFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QodGFyZ2V0KTtcbiAgICB2YXIgcm9vdENvbnRhaW5zVGFyZ2V0ID0gdGhpcy5fcm9vdENvbnRhaW5zVGFyZ2V0KHRhcmdldCk7XG4gICAgdmFyIG9sZEVudHJ5ID0gaXRlbS5lbnRyeTtcbiAgICB2YXIgaW50ZXJzZWN0aW9uUmVjdCA9IHJvb3RJc0luRG9tICYmIHJvb3RDb250YWluc1RhcmdldCAmJlxuICAgICAgICB0aGlzLl9jb21wdXRlVGFyZ2V0QW5kUm9vdEludGVyc2VjdGlvbih0YXJnZXQsIHJvb3RSZWN0KTtcblxuICAgIHZhciBuZXdFbnRyeSA9IGl0ZW0uZW50cnkgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeSh7XG4gICAgICB0aW1lOiBub3coKSxcbiAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgYm91bmRpbmdDbGllbnRSZWN0OiB0YXJnZXRSZWN0LFxuICAgICAgcm9vdEJvdW5kczogcm9vdFJlY3QsXG4gICAgICBpbnRlcnNlY3Rpb25SZWN0OiBpbnRlcnNlY3Rpb25SZWN0XG4gICAgfSk7XG5cbiAgICBpZiAoIW9sZEVudHJ5KSB7XG4gICAgICB0aGlzLl9xdWV1ZWRFbnRyaWVzLnB1c2gobmV3RW50cnkpO1xuICAgIH0gZWxzZSBpZiAocm9vdElzSW5Eb20gJiYgcm9vdENvbnRhaW5zVGFyZ2V0KSB7XG4gICAgICAvLyBJZiB0aGUgbmV3IGVudHJ5IGludGVyc2VjdGlvbiByYXRpbyBoYXMgY3Jvc3NlZCBhbnkgb2YgdGhlXG4gICAgICAvLyB0aHJlc2hvbGRzLCBhZGQgYSBuZXcgZW50cnkuXG4gICAgICBpZiAodGhpcy5faGFzQ3Jvc3NlZFRocmVzaG9sZChvbGRFbnRyeSwgbmV3RW50cnkpKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlZEVudHJpZXMucHVzaChuZXdFbnRyeSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSByb290IGlzIG5vdCBpbiB0aGUgRE9NIG9yIHRhcmdldCBpcyBub3QgY29udGFpbmVkIHdpdGhpblxuICAgICAgLy8gcm9vdCBidXQgdGhlIHByZXZpb3VzIGVudHJ5IGZvciB0aGlzIHRhcmdldCBoYWQgYW4gaW50ZXJzZWN0aW9uLFxuICAgICAgLy8gYWRkIGEgbmV3IHJlY29yZCBpbmRpY2F0aW5nIHJlbW92YWwuXG4gICAgICBpZiAob2xkRW50cnkgJiYgb2xkRW50cnkuaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgdGhpcy5fcXVldWVkRW50cmllcy5wdXNoKG5ld0VudHJ5KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHRoaXMpO1xuXG4gIGlmICh0aGlzLl9xdWV1ZWRFbnRyaWVzLmxlbmd0aCkge1xuICAgIHRoaXMuX2NhbGxiYWNrKHRoaXMudGFrZVJlY29yZHMoKSwgdGhpcyk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBBY2NlcHRzIGEgdGFyZ2V0IGFuZCByb290IHJlY3QgY29tcHV0ZXMgdGhlIGludGVyc2VjdGlvbiBiZXR3ZWVuIHRoZW5cbiAqIGZvbGxvd2luZyB0aGUgYWxnb3JpdGhtIGluIHRoZSBzcGVjLlxuICogVE9ETyhwaGlsaXB3YWx0b24pOiBhdCB0aGlzIHRpbWUgY2xpcC1wYXRoIGlzIG5vdCBjb25zaWRlcmVkLlxuICogaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ludGVyc2VjdGlvbk9ic2VydmVyLyNjYWxjdWxhdGUtaW50ZXJzZWN0aW9uLXJlY3QtYWxnb1xuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgVGhlIHRhcmdldCBET00gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IHJvb3RSZWN0IFRoZSBib3VuZGluZyByZWN0IG9mIHRoZSByb290IGFmdGVyIGJlaW5nXG4gKiAgICAgZXhwYW5kZWQgYnkgdGhlIHJvb3RNYXJnaW4gdmFsdWUuXG4gKiBAcmV0dXJuIHs/T2JqZWN0fSBUaGUgZmluYWwgaW50ZXJzZWN0aW9uIHJlY3Qgb2JqZWN0IG9yIHVuZGVmaW5lZCBpZiBub1xuICogICAgIGludGVyc2VjdGlvbiBpcyBmb3VuZC5cbiAqIEBwcml2YXRlXG4gKi9cbkludGVyc2VjdGlvbk9ic2VydmVyLnByb3RvdHlwZS5fY29tcHV0ZVRhcmdldEFuZFJvb3RJbnRlcnNlY3Rpb24gPVxuICAgIGZ1bmN0aW9uKHRhcmdldCwgcm9vdFJlY3QpIHtcblxuICAvLyBJZiB0aGUgZWxlbWVudCBpc24ndCBkaXNwbGF5ZWQsIGFuIGludGVyc2VjdGlvbiBjYW4ndCBoYXBwZW4uXG4gIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLmRpc3BsYXkgPT0gJ25vbmUnKSByZXR1cm47XG5cbiAgdmFyIHRhcmdldFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QodGFyZ2V0KTtcbiAgdmFyIGludGVyc2VjdGlvblJlY3QgPSB0YXJnZXRSZWN0O1xuICB2YXIgcGFyZW50ID0gZ2V0UGFyZW50Tm9kZSh0YXJnZXQpO1xuICB2YXIgYXRSb290ID0gZmFsc2U7XG5cbiAgd2hpbGUgKCFhdFJvb3QpIHtcbiAgICB2YXIgcGFyZW50UmVjdCA9IG51bGw7XG4gICAgdmFyIHBhcmVudENvbXB1dGVkU3R5bGUgPSBwYXJlbnQubm9kZVR5cGUgPT0gMSA/XG4gICAgICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudCkgOiB7fTtcblxuICAgIC8vIElmIHRoZSBwYXJlbnQgaXNuJ3QgZGlzcGxheWVkLCBhbiBpbnRlcnNlY3Rpb24gY2FuJ3QgaGFwcGVuLlxuICAgIGlmIChwYXJlbnRDb21wdXRlZFN0eWxlLmRpc3BsYXkgPT0gJ25vbmUnKSByZXR1cm47XG5cbiAgICBpZiAocGFyZW50ID09IHRoaXMucm9vdCB8fCBwYXJlbnQgPT0gZG9jdW1lbnQpIHtcbiAgICAgIGF0Um9vdCA9IHRydWU7XG4gICAgICBwYXJlbnRSZWN0ID0gcm9vdFJlY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIG5vbi12aXNpYmxlIG92ZXJmbG93LCBhbmQgaXQncyBub3QgdGhlIDxib2R5PlxuICAgICAgLy8gb3IgPGh0bWw+IGVsZW1lbnQsIHVwZGF0ZSB0aGUgaW50ZXJzZWN0aW9uIHJlY3QuXG4gICAgICAvLyBOb3RlOiA8Ym9keT4gYW5kIDxodG1sPiBjYW5ub3QgYmUgY2xpcHBlZCB0byBhIHJlY3QgdGhhdCdzIG5vdCBhbHNvXG4gICAgICAvLyB0aGUgZG9jdW1lbnQgcmVjdCwgc28gbm8gbmVlZCB0byBjb21wdXRlIGEgbmV3IGludGVyc2VjdGlvbi5cbiAgICAgIGlmIChwYXJlbnQgIT0gZG9jdW1lbnQuYm9keSAmJlxuICAgICAgICAgIHBhcmVudCAhPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiZcbiAgICAgICAgICBwYXJlbnRDb21wdXRlZFN0eWxlLm92ZXJmbG93ICE9ICd2aXNpYmxlJykge1xuICAgICAgICBwYXJlbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHBhcmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgZWl0aGVyIG9mIHRoZSBhYm92ZSBjb25kaXRpb25hbHMgc2V0IGEgbmV3IHBhcmVudFJlY3QsXG4gICAgLy8gY2FsY3VsYXRlIG5ldyBpbnRlcnNlY3Rpb24gZGF0YS5cbiAgICBpZiAocGFyZW50UmVjdCkge1xuICAgICAgaW50ZXJzZWN0aW9uUmVjdCA9IGNvbXB1dGVSZWN0SW50ZXJzZWN0aW9uKHBhcmVudFJlY3QsIGludGVyc2VjdGlvblJlY3QpO1xuXG4gICAgICBpZiAoIWludGVyc2VjdGlvblJlY3QpIGJyZWFrO1xuICAgIH1cbiAgICBwYXJlbnQgPSBnZXRQYXJlbnROb2RlKHBhcmVudCk7XG4gIH1cbiAgcmV0dXJuIGludGVyc2VjdGlvblJlY3Q7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgcm9vdCByZWN0IGFmdGVyIGJlaW5nIGV4cGFuZGVkIGJ5IHRoZSByb290TWFyZ2luIHZhbHVlLlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZXhwYW5kZWQgcm9vdCByZWN0LlxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLl9nZXRSb290UmVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcm9vdFJlY3Q7XG4gIGlmICh0aGlzLnJvb3QpIHtcbiAgICByb290UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdCh0aGlzLnJvb3QpO1xuICB9IGVsc2Uge1xuICAgIC8vIFVzZSA8aHRtbD4vPGJvZHk+IGluc3RlYWQgb2Ygd2luZG93IHNpbmNlIHNjcm9sbCBiYXJzIGFmZmVjdCBzaXplLlxuICAgIHZhciBodG1sID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICByb290UmVjdCA9IHtcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogaHRtbC5jbGllbnRXaWR0aCB8fCBib2R5LmNsaWVudFdpZHRoLFxuICAgICAgd2lkdGg6IGh0bWwuY2xpZW50V2lkdGggfHwgYm9keS5jbGllbnRXaWR0aCxcbiAgICAgIGJvdHRvbTogaHRtbC5jbGllbnRIZWlnaHQgfHwgYm9keS5jbGllbnRIZWlnaHQsXG4gICAgICBoZWlnaHQ6IGh0bWwuY2xpZW50SGVpZ2h0IHx8IGJvZHkuY2xpZW50SGVpZ2h0XG4gICAgfTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZXhwYW5kUmVjdEJ5Um9vdE1hcmdpbihyb290UmVjdCk7XG59O1xuXG5cbi8qKlxuICogQWNjZXB0cyBhIHJlY3QgYW5kIGV4cGFuZHMgaXQgYnkgdGhlIHJvb3RNYXJnaW4gdmFsdWUuXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjdCBUaGUgcmVjdCBvYmplY3QgdG8gZXhwYW5kLlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZXhwYW5kZWQgcmVjdC5cbiAqIEBwcml2YXRlXG4gKi9cbkludGVyc2VjdGlvbk9ic2VydmVyLnByb3RvdHlwZS5fZXhwYW5kUmVjdEJ5Um9vdE1hcmdpbiA9IGZ1bmN0aW9uKHJlY3QpIHtcbiAgdmFyIG1hcmdpbnMgPSB0aGlzLl9yb290TWFyZ2luVmFsdWVzLm1hcChmdW5jdGlvbihtYXJnaW4sIGkpIHtcbiAgICByZXR1cm4gbWFyZ2luLnVuaXQgPT0gJ3B4JyA/IG1hcmdpbi52YWx1ZSA6XG4gICAgICAgIG1hcmdpbi52YWx1ZSAqIChpICUgMiA/IHJlY3Qud2lkdGggOiByZWN0LmhlaWdodCkgLyAxMDA7XG4gIH0pO1xuICB2YXIgbmV3UmVjdCA9IHtcbiAgICB0b3A6IHJlY3QudG9wIC0gbWFyZ2luc1swXSxcbiAgICByaWdodDogcmVjdC5yaWdodCArIG1hcmdpbnNbMV0sXG4gICAgYm90dG9tOiByZWN0LmJvdHRvbSArIG1hcmdpbnNbMl0sXG4gICAgbGVmdDogcmVjdC5sZWZ0IC0gbWFyZ2luc1szXVxuICB9O1xuICBuZXdSZWN0LndpZHRoID0gbmV3UmVjdC5yaWdodCAtIG5ld1JlY3QubGVmdDtcbiAgbmV3UmVjdC5oZWlnaHQgPSBuZXdSZWN0LmJvdHRvbSAtIG5ld1JlY3QudG9wO1xuXG4gIHJldHVybiBuZXdSZWN0O1xufTtcblxuXG4vKipcbiAqIEFjY2VwdHMgYW4gb2xkIGFuZCBuZXcgZW50cnkgYW5kIHJldHVybnMgdHJ1ZSBpZiBhdCBsZWFzdCBvbmUgb2YgdGhlXG4gKiB0aHJlc2hvbGQgdmFsdWVzIGhhcyBiZWVuIGNyb3NzZWQuXG4gKiBAcGFyYW0gez9JbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5fSBvbGRFbnRyeSBUaGUgcHJldmlvdXMgZW50cnkgZm9yIGFcbiAqICAgIHBhcnRpY3VsYXIgdGFyZ2V0IGVsZW1lbnQgb3IgbnVsbCBpZiBubyBwcmV2aW91cyBlbnRyeSBleGlzdHMuXG4gKiBAcGFyYW0ge0ludGVyc2VjdGlvbk9ic2VydmVyRW50cnl9IG5ld0VudHJ5IFRoZSBjdXJyZW50IGVudHJ5IGZvciBhXG4gKiAgICBwYXJ0aWN1bGFyIHRhcmdldCBlbGVtZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGEgYW55IHRocmVzaG9sZCBoYXMgYmVlbiBjcm9zc2VkLlxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLl9oYXNDcm9zc2VkVGhyZXNob2xkID1cbiAgICBmdW5jdGlvbihvbGRFbnRyeSwgbmV3RW50cnkpIHtcblxuICAvLyBUbyBtYWtlIGNvbXBhcmluZyBlYXNpZXIsIGFuIGVudHJ5IHRoYXQgaGFzIGEgcmF0aW8gb2YgMFxuICAvLyBidXQgZG9lcyBub3QgYWN0dWFsbHkgaW50ZXJzZWN0IGlzIGdpdmVuIGEgdmFsdWUgb2YgLTFcbiAgdmFyIG9sZFJhdGlvID0gb2xkRW50cnkgJiYgb2xkRW50cnkuaXNJbnRlcnNlY3RpbmcgP1xuICAgICAgb2xkRW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gfHwgMCA6IC0xO1xuICB2YXIgbmV3UmF0aW8gPSBuZXdFbnRyeS5pc0ludGVyc2VjdGluZyA/XG4gICAgICBuZXdFbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyB8fCAwIDogLTE7XG5cbiAgLy8gSWdub3JlIHVuY2hhbmdlZCByYXRpb3NcbiAgaWYgKG9sZFJhdGlvID09PSBuZXdSYXRpbykgcmV0dXJuO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50aHJlc2hvbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRocmVzaG9sZCA9IHRoaXMudGhyZXNob2xkc1tpXTtcblxuICAgIC8vIFJldHVybiB0cnVlIGlmIGFuIGVudHJ5IG1hdGNoZXMgYSB0aHJlc2hvbGQgb3IgaWYgdGhlIG5ldyByYXRpb1xuICAgIC8vIGFuZCB0aGUgb2xkIHJhdGlvIGFyZSBvbiB0aGUgb3Bwb3NpdGUgc2lkZXMgb2YgYSB0aHJlc2hvbGQuXG4gICAgaWYgKHRocmVzaG9sZCA9PSBvbGRSYXRpbyB8fCB0aHJlc2hvbGQgPT0gbmV3UmF0aW8gfHxcbiAgICAgICAgdGhyZXNob2xkIDwgb2xkUmF0aW8gIT09IHRocmVzaG9sZCA8IG5ld1JhdGlvKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSByb290IGVsZW1lbnQgaXMgYW4gZWxlbWVudCBhbmQgaXMgaW4gdGhlIERPTS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHJvb3QgZWxlbWVudCBpcyBhbiBlbGVtZW50IGFuZCBpcyBpbiB0aGUgRE9NLlxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLl9yb290SXNJbkRvbSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gIXRoaXMucm9vdCB8fCBjb250YWluc0RlZXAoZG9jdW1lbnQsIHRoaXMucm9vdCk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgYSBjaGlsZCBvZiByb290LlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgVGhlIHRhcmdldCBlbGVtZW50IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgYSBjaGlsZCBvZiByb290LlxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLl9yb290Q29udGFpbnNUYXJnZXQgPSBmdW5jdGlvbih0YXJnZXQpIHtcbiAgcmV0dXJuIGNvbnRhaW5zRGVlcCh0aGlzLnJvb3QgfHwgZG9jdW1lbnQsIHRhcmdldCk7XG59O1xuXG5cbi8qKlxuICogQWRkcyB0aGUgaW5zdGFuY2UgdG8gdGhlIGdsb2JhbCBJbnRlcnNlY3Rpb25PYnNlcnZlciByZWdpc3RyeSBpZiBpdCBpc24ndFxuICogYWxyZWFkeSBwcmVzZW50LlxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLl9yZWdpc3Rlckluc3RhbmNlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChyZWdpc3RyeS5pbmRleE9mKHRoaXMpIDwgMCkge1xuICAgIHJlZ2lzdHJ5LnB1c2godGhpcyk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBpbnN0YW5jZSBmcm9tIHRoZSBnbG9iYWwgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgcmVnaXN0cnkuXG4gKiBAcHJpdmF0ZVxuICovXG5JbnRlcnNlY3Rpb25PYnNlcnZlci5wcm90b3R5cGUuX3VucmVnaXN0ZXJJbnN0YW5jZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaW5kZXggPSByZWdpc3RyeS5pbmRleE9mKHRoaXMpO1xuICBpZiAoaW5kZXggIT0gLTEpIHJlZ2lzdHJ5LnNwbGljZShpbmRleCwgMSk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBwZXJmb3JtYW5jZS5ub3coKSBtZXRob2Qgb3IgbnVsbCBpbiBicm93c2Vyc1xuICogdGhhdCBkb24ndCBzdXBwb3J0IHRoZSBBUEkuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBlbGFwc2VkIHRpbWUgc2luY2UgdGhlIHBhZ2Ugd2FzIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gbm93KCkge1xuICByZXR1cm4gd2luZG93LnBlcmZvcm1hbmNlICYmIHBlcmZvcm1hbmNlLm5vdyAmJiBwZXJmb3JtYW5jZS5ub3coKTtcbn1cblxuXG4vKipcbiAqIFRocm90dGxlcyBhIGZ1bmN0aW9uIGFuZCBkZWxheXMgaXRzIGV4ZWN1dGlvbiwgc28gaXQncyBvbmx5IGNhbGxlZCBhdCBtb3N0XG4gKiBvbmNlIHdpdGhpbiBhIGdpdmVuIHRpbWUgcGVyaW9kLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgbXVzdCBwYXNzIGJlZm9yZSB0aGVcbiAqICAgICBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIGFnYWluLlxuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZuLCB0aW1lb3V0KSB7XG4gIHZhciB0aW1lciA9IG51bGw7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aW1lcikge1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBmbigpO1xuICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICB9LCB0aW1lb3V0KTtcbiAgICB9XG4gIH07XG59XG5cblxuLyoqXG4gKiBBZGRzIGFuIGV2ZW50IGhhbmRsZXIgdG8gYSBET00gbm9kZSBlbnN1cmluZyBjcm9zcy1icm93c2VyIGNvbXBhdGliaWxpdHkuXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIERPTSBub2RlIHRvIGFkZCB0aGUgZXZlbnQgaGFuZGxlciB0by5cbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBldmVudCBoYW5kbGVyIHRvIGFkZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0X3VzZUNhcHR1cmUgT3B0aW9uYWxseSBhZGRzIHRoZSBldmVuIHRvIHRoZSBjYXB0dXJlXG4gKiAgICAgcGhhc2UuIE5vdGU6IHRoaXMgb25seSB3b3JrcyBpbiBtb2Rlcm4gYnJvd3NlcnMuXG4gKi9cbmZ1bmN0aW9uIGFkZEV2ZW50KG5vZGUsIGV2ZW50LCBmbiwgb3B0X3VzZUNhcHR1cmUpIHtcbiAgaWYgKHR5cGVvZiBub2RlLmFkZEV2ZW50TGlzdGVuZXIgPT0gJ2Z1bmN0aW9uJykge1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZm4sIG9wdF91c2VDYXB0dXJlIHx8IGZhbHNlKTtcbiAgfVxuICBlbHNlIGlmICh0eXBlb2Ygbm9kZS5hdHRhY2hFdmVudCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgbm9kZS5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGZuKTtcbiAgfVxufVxuXG5cbi8qKlxuICogUmVtb3ZlcyBhIHByZXZpb3VzbHkgYWRkZWQgZXZlbnQgaGFuZGxlciBmcm9tIGEgRE9NIG5vZGUuXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIERPTSBub2RlIHRvIHJlbW92ZSB0aGUgZXZlbnQgaGFuZGxlciBmcm9tLlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGV2ZW50IGhhbmRsZXIgdG8gcmVtb3ZlLlxuICogQHBhcmFtIHtib29sZWFufSBvcHRfdXNlQ2FwdHVyZSBJZiB0aGUgZXZlbnQgaGFuZGxlciB3YXMgYWRkZWQgd2l0aCB0aGlzXG4gKiAgICAgZmxhZyBzZXQgdG8gdHJ1ZSwgaXQgc2hvdWxkIGJlIHNldCB0byB0cnVlIGhlcmUgaW4gb3JkZXIgdG8gcmVtb3ZlIGl0LlxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudChub2RlLCBldmVudCwgZm4sIG9wdF91c2VDYXB0dXJlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyID09ICdmdW5jdGlvbicpIHtcbiAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGZuLCBvcHRfdXNlQ2FwdHVyZSB8fCBmYWxzZSk7XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIG5vZGUuZGV0YXRjaEV2ZW50ID09ICdmdW5jdGlvbicpIHtcbiAgICBub2RlLmRldGF0Y2hFdmVudCgnb24nICsgZXZlbnQsIGZuKTtcbiAgfVxufVxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdHdvIHJlY3Qgb2JqZWN0cy5cbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MSBUaGUgZmlyc3QgcmVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MiBUaGUgc2Vjb25kIHJlY3QuXG4gKiBAcmV0dXJuIHs/T2JqZWN0fSBUaGUgaW50ZXJzZWN0aW9uIHJlY3Qgb3IgdW5kZWZpbmVkIGlmIG5vIGludGVyc2VjdGlvblxuICogICAgIGlzIGZvdW5kLlxuICovXG5mdW5jdGlvbiBjb21wdXRlUmVjdEludGVyc2VjdGlvbihyZWN0MSwgcmVjdDIpIHtcbiAgdmFyIHRvcCA9IE1hdGgubWF4KHJlY3QxLnRvcCwgcmVjdDIudG9wKTtcbiAgdmFyIGJvdHRvbSA9IE1hdGgubWluKHJlY3QxLmJvdHRvbSwgcmVjdDIuYm90dG9tKTtcbiAgdmFyIGxlZnQgPSBNYXRoLm1heChyZWN0MS5sZWZ0LCByZWN0Mi5sZWZ0KTtcbiAgdmFyIHJpZ2h0ID0gTWF0aC5taW4ocmVjdDEucmlnaHQsIHJlY3QyLnJpZ2h0KTtcbiAgdmFyIHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICB2YXIgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuXG4gIHJldHVybiAod2lkdGggPj0gMCAmJiBoZWlnaHQgPj0gMCkgJiYge1xuICAgIHRvcDogdG9wLFxuICAgIGJvdHRvbTogYm90dG9tLFxuICAgIGxlZnQ6IGxlZnQsXG4gICAgcmlnaHQ6IHJpZ2h0LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufVxuXG5cbi8qKlxuICogU2hpbXMgdGhlIG5hdGl2ZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBvbGRlciBJRS5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWwgVGhlIGVsZW1lbnQgd2hvc2UgYm91bmRpbmcgcmVjdCB0byBnZXQuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSAocG9zc2libHkgc2hpbW1lZCkgcmVjdCBvZiB0aGUgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsKSB7XG4gIHZhciByZWN0O1xuXG4gIHRyeSB7XG4gICAgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBJZ25vcmUgV2luZG93cyA3IElFMTEgXCJVbnNwZWNpZmllZCBlcnJvclwiXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3czYy9JbnRlcnNlY3Rpb25PYnNlcnZlci9wdWxsLzIwNVxuICB9XG5cbiAgaWYgKCFyZWN0KSByZXR1cm4gZ2V0RW1wdHlSZWN0KCk7XG5cbiAgLy8gT2xkZXIgSUVcbiAgaWYgKCEocmVjdC53aWR0aCAmJiByZWN0LmhlaWdodCkpIHtcbiAgICByZWN0ID0ge1xuICAgICAgdG9wOiByZWN0LnRvcCxcbiAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0LFxuICAgICAgYm90dG9tOiByZWN0LmJvdHRvbSxcbiAgICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICAgIHdpZHRoOiByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LFxuICAgICAgaGVpZ2h0OiByZWN0LmJvdHRvbSAtIHJlY3QudG9wXG4gICAgfTtcbiAgfVxuICByZXR1cm4gcmVjdDtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgYW4gZW1wdHkgcmVjdCBvYmplY3QuIEFuIGVtcHR5IHJlY3QgaXMgcmV0dXJuZWQgd2hlbiBhbiBlbGVtZW50XG4gKiBpcyBub3QgaW4gdGhlIERPTS5cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGVtcHR5IHJlY3QuXG4gKi9cbmZ1bmN0aW9uIGdldEVtcHR5UmVjdCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiBhIHBhcmVudCBlbGVtZW50IGNvbnRhaW5zIGEgY2hpbGQgZWxlbWVudCAoaW5jbHVkaW5nIGluc2lkZVxuICogc2hhZG93IERPTSkuXG4gKiBAcGFyYW0ge05vZGV9IHBhcmVudCBUaGUgcGFyZW50IGVsZW1lbnQuXG4gKiBAcGFyYW0ge05vZGV9IGNoaWxkIFRoZSBjaGlsZCBlbGVtZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGFyZW50IG5vZGUgY29udGFpbnMgdGhlIGNoaWxkIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zRGVlcChwYXJlbnQsIGNoaWxkKSB7XG4gIHZhciBub2RlID0gY2hpbGQ7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUgPT0gcGFyZW50KSByZXR1cm4gdHJ1ZTtcblxuICAgIG5vZGUgPSBnZXRQYXJlbnROb2RlKG5vZGUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuXG4vKipcbiAqIEdldHMgdGhlIHBhcmVudCBub2RlIG9mIGFuIGVsZW1lbnQgb3IgaXRzIGhvc3QgZWxlbWVudCBpZiB0aGUgcGFyZW50IG5vZGVcbiAqIGlzIGEgc2hhZG93IHJvb3QuXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgd2hvc2UgcGFyZW50IHRvIGdldC5cbiAqIEByZXR1cm4ge05vZGV8bnVsbH0gVGhlIHBhcmVudCBub2RlIG9yIG51bGwgaWYgbm8gcGFyZW50IGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShub2RlKSB7XG4gIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG5cbiAgaWYgKHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT0gMTEgJiYgcGFyZW50Lmhvc3QpIHtcbiAgICAvLyBJZiB0aGUgcGFyZW50IGlzIGEgc2hhZG93IHJvb3QsIHJldHVybiB0aGUgaG9zdCBlbGVtZW50LlxuICAgIHJldHVybiBwYXJlbnQuaG9zdDtcbiAgfVxuICByZXR1cm4gcGFyZW50O1xufVxuXG5cbi8vIEV4cG9zZXMgdGhlIGNvbnN0cnVjdG9ycyBnbG9iYWxseS5cbndpbmRvdy5JbnRlcnNlY3Rpb25PYnNlcnZlciA9IEludGVyc2VjdGlvbk9ic2VydmVyO1xud2luZG93LkludGVyc2VjdGlvbk9ic2VydmVyRW50cnkgPSBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5O1xuXG59KHdpbmRvdywgZG9jdW1lbnQpKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcblxudmFyIGlzU3RhbmRhcmRBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRpZiAoaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0cmV0dXJuICR0b1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxudmFyIGlzTGVnYWN5QXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGlzU3RhbmRhcmRBcmd1bWVudHModmFsdWUpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIHZhbHVlICE9PSBudWxsICYmXG5cdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0dmFsdWUubGVuZ3RoID49IDAgJiZcblx0XHQkdG9TdHJpbmcodmFsdWUpICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0JHRvU3RyaW5nKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xuXG52YXIgc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA9IChmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBpc1N0YW5kYXJkQXJndW1lbnRzKGFyZ3VtZW50cyk7XG59KCkpO1xuXG5pc1N0YW5kYXJkQXJndW1lbnRzLmlzTGVnYWN5QXJndW1lbnRzID0gaXNMZWdhY3lBcmd1bWVudHM7IC8vIGZvciB0ZXN0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMgPyBpc1N0YW5kYXJkQXJndW1lbnRzIDogaXNMZWdhY3lBcmd1bWVudHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHJlZmxlY3RBcHBseSA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0ICE9PSBudWxsICYmIFJlZmxlY3QuYXBwbHk7XG52YXIgYmFkQXJyYXlMaWtlO1xudmFyIGlzQ2FsbGFibGVNYXJrZXI7XG5pZiAodHlwZW9mIHJlZmxlY3RBcHBseSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG5cdHRyeSB7XG5cdFx0YmFkQXJyYXlMaWtlID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnbGVuZ3RoJywge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRocm93IGlzQ2FsbGFibGVNYXJrZXI7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0aXNDYWxsYWJsZU1hcmtlciA9IHt9O1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG5cdFx0cmVmbGVjdEFwcGx5KGZ1bmN0aW9uICgpIHsgdGhyb3cgNDI7IH0sIG51bGwsIGJhZEFycmF5TGlrZSk7XG5cdH0gY2F0Y2ggKF8pIHtcblx0XHRpZiAoXyAhPT0gaXNDYWxsYWJsZU1hcmtlcikge1xuXHRcdFx0cmVmbGVjdEFwcGx5ID0gbnVsbDtcblx0XHR9XG5cdH1cbn0gZWxzZSB7XG5cdHJlZmxlY3RBcHBseSA9IG51bGw7XG59XG5cbnZhciBjb25zdHJ1Y3RvclJlZ2V4ID0gL15cXHMqY2xhc3NcXGIvO1xudmFyIGlzRVM2Q2xhc3NGbiA9IGZ1bmN0aW9uIGlzRVM2Q2xhc3NGdW5jdGlvbih2YWx1ZSkge1xuXHR0cnkge1xuXHRcdHZhciBmblN0ciA9IGZuVG9TdHIuY2FsbCh2YWx1ZSk7XG5cdFx0cmV0dXJuIGNvbnN0cnVjdG9yUmVnZXgudGVzdChmblN0cik7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7IC8vIG5vdCBhIGZ1bmN0aW9uXG5cdH1cbn07XG5cbnZhciB0cnlGdW5jdGlvbk9iamVjdCA9IGZ1bmN0aW9uIHRyeUZ1bmN0aW9uVG9TdHIodmFsdWUpIHtcblx0dHJ5IHtcblx0XHRpZiAoaXNFUzZDbGFzc0ZuKHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRmblRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmbkNsYXNzID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbnZhciBnZW5DbGFzcyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmICEhU3ltYm9sLnRvU3RyaW5nVGFnOyAvLyBiZXR0ZXI6IHVzZSBgaGFzLXRvc3RyaW5ndGFnYFxuLyogZ2xvYmFscyBkb2N1bWVudDogZmFsc2UgKi9cbnZhciBkb2N1bWVudERvdEFsbCA9IHR5cGVvZiBkb2N1bWVudCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGRvY3VtZW50LmFsbCA9PT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuYWxsICE9PSB1bmRlZmluZWQgPyBkb2N1bWVudC5hbGwgOiB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSByZWZsZWN0QXBwbHlcblx0PyBmdW5jdGlvbiBpc0NhbGxhYmxlKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09PSBkb2N1bWVudERvdEFsbCkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdGlmICghdmFsdWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgIXZhbHVlLnByb3RvdHlwZSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdHRyeSB7XG5cdFx0XHRyZWZsZWN0QXBwbHkodmFsdWUsIG51bGwsIGJhZEFycmF5TGlrZSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0aWYgKGUgIT09IGlzQ2FsbGFibGVNYXJrZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fVxuXHRcdHJldHVybiAhaXNFUzZDbGFzc0ZuKHZhbHVlKTtcblx0fVxuXHQ6IGZ1bmN0aW9uIGlzQ2FsbGFibGUodmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT09IGRvY3VtZW50RG90QWxsKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0aWYgKCF2YWx1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhdmFsdWUucHJvdG90eXBlKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0aWYgKGhhc1RvU3RyaW5nVGFnKSB7IHJldHVybiB0cnlGdW5jdGlvbk9iamVjdCh2YWx1ZSk7IH1cblx0XHRpZiAoaXNFUzZDbGFzc0ZuKHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR2YXIgc3RyQ2xhc3MgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gc3RyQ2xhc3MgPT09IGZuQ2xhc3MgfHwgc3RyQ2xhc3MgPT09IGdlbkNsYXNzO1xuXHR9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0RGF5ID0gRGF0ZS5wcm90b3R5cGUuZ2V0RGF5O1xudmFyIHRyeURhdGVPYmplY3QgPSBmdW5jdGlvbiB0cnlEYXRlR2V0RGF5Q2FsbCh2YWx1ZSkge1xuXHR0cnkge1xuXHRcdGdldERheS5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBkYXRlQ2xhc3MgPSAnW29iamVjdCBEYXRlXSc7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzRGF0ZU9iamVjdCh2YWx1ZSkge1xuXHRpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gaGFzVG9TdHJpbmdUYWcgPyB0cnlEYXRlT2JqZWN0KHZhbHVlKSA6IHRvU3RyLmNhbGwodmFsdWUpID09PSBkYXRlQ2xhc3M7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJE1hcCA9IHR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicgJiYgTWFwLnByb3RvdHlwZSA/IE1hcCA6IG51bGw7XG52YXIgJFNldCA9IHR5cGVvZiBTZXQgPT09ICdmdW5jdGlvbicgJiYgU2V0LnByb3RvdHlwZSA/IFNldCA6IG51bGw7XG5cbnZhciBleHBvcnRlZDtcblxuaWYgKCEkTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuXHRleHBvcnRlZCA9IGZ1bmN0aW9uIGlzTWFwKHgpIHtcblx0XHQvLyBgTWFwYCBpcyBub3QgcHJlc2VudCBpbiB0aGlzIGVudmlyb25tZW50LlxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxudmFyICRtYXBIYXMgPSAkTWFwID8gTWFwLnByb3RvdHlwZS5oYXMgOiBudWxsO1xudmFyICRzZXRIYXMgPSAkU2V0ID8gU2V0LnByb3RvdHlwZS5oYXMgOiBudWxsO1xuaWYgKCFleHBvcnRlZCAmJiAhJG1hcEhhcykge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblx0ZXhwb3J0ZWQgPSBmdW5jdGlvbiBpc01hcCh4KSB7XG5cdFx0Ly8gYE1hcGAgZG9lcyBub3QgaGF2ZSBhIGBoYXNgIG1ldGhvZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRlZCB8fCBmdW5jdGlvbiBpc01hcCh4KSB7XG5cdGlmICgheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0dHJ5IHtcblx0XHQkbWFwSGFzLmNhbGwoeCk7XG5cdFx0aWYgKCRzZXRIYXMpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdCRzZXRIYXMuY2FsbCh4KTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB4IGluc3RhbmNlb2YgJE1hcDsgLy8gY29yZS1qcyB3b3JrYXJvdW5kLCBwcmUtdjIuNS4wXG5cdH0gY2F0Y2ggKGUpIHt9XG5cdHJldHVybiBmYWxzZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xudmFyIGhhcztcbnZhciAkZXhlYztcbnZhciBpc1JlZ2V4TWFya2VyO1xudmFyIGJhZFN0cmluZ2lmaWVyO1xuXG5pZiAoaGFzVG9TdHJpbmdUYWcpIHtcblx0aGFzID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5Jyk7XG5cdCRleGVjID0gY2FsbEJvdW5kKCdSZWdFeHAucHJvdG90eXBlLmV4ZWMnKTtcblx0aXNSZWdleE1hcmtlciA9IHt9O1xuXG5cdHZhciB0aHJvd1JlZ2V4TWFya2VyID0gZnVuY3Rpb24gKCkge1xuXHRcdHRocm93IGlzUmVnZXhNYXJrZXI7XG5cdH07XG5cdGJhZFN0cmluZ2lmaWVyID0ge1xuXHRcdHRvU3RyaW5nOiB0aHJvd1JlZ2V4TWFya2VyLFxuXHRcdHZhbHVlT2Y6IHRocm93UmVnZXhNYXJrZXJcblx0fTtcblxuXHRpZiAodHlwZW9mIFN5bWJvbC50b1ByaW1pdGl2ZSA9PT0gJ3N5bWJvbCcpIHtcblx0XHRiYWRTdHJpbmdpZmllcltTeW1ib2wudG9QcmltaXRpdmVdID0gdGhyb3dSZWdleE1hcmtlcjtcblx0fVxufVxuXG52YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgcmVnZXhDbGFzcyA9ICdbb2JqZWN0IFJlZ0V4cF0nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1RvU3RyaW5nVGFnXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuXHQ/IGZ1bmN0aW9uIGlzUmVnZXgodmFsdWUpIHtcblx0XHRpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgZGVzY3JpcHRvciA9IGdPUEQodmFsdWUsICdsYXN0SW5kZXgnKTtcblx0XHR2YXIgaGFzTGFzdEluZGV4RGF0YVByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBoYXMoZGVzY3JpcHRvciwgJ3ZhbHVlJyk7XG5cdFx0aWYgKCFoYXNMYXN0SW5kZXhEYXRhUHJvcGVydHkpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0JGV4ZWModmFsdWUsIGJhZFN0cmluZ2lmaWVyKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gZSA9PT0gaXNSZWdleE1hcmtlcjtcblx0XHR9XG5cdH1cblx0OiBmdW5jdGlvbiBpc1JlZ2V4KHZhbHVlKSB7XG5cdFx0Ly8gSW4gb2xkZXIgYnJvd3NlcnMsIHR5cGVvZiByZWdleCBpbmNvcnJlY3RseSByZXR1cm5zICdmdW5jdGlvbidcblx0XHRpZiAoIXZhbHVlIHx8ICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gJHRvU3RyaW5nKHZhbHVlKSA9PT0gcmVnZXhDbGFzcztcblx0fTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyICRNYXAgPSB0eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nICYmIE1hcC5wcm90b3R5cGUgPyBNYXAgOiBudWxsO1xudmFyICRTZXQgPSB0eXBlb2YgU2V0ID09PSAnZnVuY3Rpb24nICYmIFNldC5wcm90b3R5cGUgPyBTZXQgOiBudWxsO1xuXG52YXIgZXhwb3J0ZWQ7XG5cbmlmICghJFNldCkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblx0ZXhwb3J0ZWQgPSBmdW5jdGlvbiBpc1NldCh4KSB7XG5cdFx0Ly8gYFNldGAgaXMgbm90IHByZXNlbnQgaW4gdGhpcyBlbnZpcm9ubWVudC5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG59XG5cbnZhciAkbWFwSGFzID0gJE1hcCA/IE1hcC5wcm90b3R5cGUuaGFzIDogbnVsbDtcbnZhciAkc2V0SGFzID0gJFNldCA/IFNldC5wcm90b3R5cGUuaGFzIDogbnVsbDtcbmlmICghZXhwb3J0ZWQgJiYgISRzZXRIYXMpIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cdGV4cG9ydGVkID0gZnVuY3Rpb24gaXNTZXQoeCkge1xuXHRcdC8vIGBTZXRgIGRvZXMgbm90IGhhdmUgYSBgaGFzYCBtZXRob2Rcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0ZWQgfHwgZnVuY3Rpb24gaXNTZXQoeCkge1xuXHRpZiAoIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHRyeSB7XG5cdFx0JHNldEhhcy5jYWxsKHgpO1xuXHRcdGlmICgkbWFwSGFzKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQkbWFwSGFzLmNhbGwoeCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4geCBpbnN0YW5jZW9mICRTZXQ7IC8vIGNvcmUtanMgd29ya2Fyb3VuZCwgcHJlLXYyLjUuMFxuXHR9IGNhdGNoIChlKSB7fVxuXHRyZXR1cm4gZmFsc2U7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyVmFsdWUgPSBTdHJpbmcucHJvdG90eXBlLnZhbHVlT2Y7XG52YXIgdHJ5U3RyaW5nT2JqZWN0ID0gZnVuY3Rpb24gdHJ5U3RyaW5nT2JqZWN0KHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0c3RyVmFsdWUuY2FsbCh2YWx1ZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHN0ckNsYXNzID0gJ1tvYmplY3QgU3RyaW5nXSc7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG5cdGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0cmV0dXJuIGhhc1RvU3RyaW5nVGFnID8gdHJ5U3RyaW5nT2JqZWN0KHZhbHVlKSA6IHRvU3RyLmNhbGwodmFsdWUpID09PSBzdHJDbGFzcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzJykoKTtcblxuaWYgKGhhc1N5bWJvbHMpIHtcblx0dmFyIHN5bVRvU3RyID0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZztcblx0dmFyIHN5bVN0cmluZ1JlZ2V4ID0gL15TeW1ib2xcXCguKlxcKSQvO1xuXHR2YXIgaXNTeW1ib2xPYmplY3QgPSBmdW5jdGlvbiBpc1JlYWxTeW1ib2xPYmplY3QodmFsdWUpIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlLnZhbHVlT2YoKSAhPT0gJ3N5bWJvbCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHN5bVN0cmluZ1JlZ2V4LnRlc3Qoc3ltVG9TdHIuY2FsbCh2YWx1ZSkpO1xuXHR9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdGlmICh0b1N0ci5jYWxsKHZhbHVlKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBpc1N5bWJvbE9iamVjdCh2YWx1ZSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcbn0gZWxzZSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuXHRcdC8vIHRoaXMgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBTeW1ib2xzLlxuXHRcdHJldHVybiBmYWxzZSAmJiB2YWx1ZTtcblx0fTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpdGVyYXRlSXRlcmF0b3IoaXRlcmF0b3IpIHtcblx0aWYgKCFpdGVyYXRvciB8fCB0eXBlb2YgaXRlcmF0b3IubmV4dCAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGFuIG9iamVjdCB3aXRoIGEgYG5leHRgIG1ldGhvZCcpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1sxXTtcblx0XHRpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYGNhbGxiYWNrYCwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXHRcdH1cblx0fVxuXHR2YXIgdmFsdWVzID0gY2FsbGJhY2sgfHwgW107XG5cdHZhciByZXN1bHQ7XG5cdHdoaWxlICgocmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpKSAmJiAhcmVzdWx0LmRvbmUpIHtcblx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdGNhbGxiYWNrKHJlc3VsdC52YWx1ZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FsbGJhY2stcmV0dXJuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhbHVlcy5wdXNoKHJlc3VsdC52YWx1ZSk7XG5cdFx0fVxuXHR9XG5cdGlmICghY2FsbGJhY2spIHtcblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9XG59O1xuIiwiLyohIG1hdGNoTWVkaWEoKSBwb2x5ZmlsbCBhZGRMaXN0ZW5lci9yZW1vdmVMaXN0ZW5lciBleHRlbnNpb24uIEF1dGhvciAmIGNvcHlyaWdodCAoYykgMjAxMjogU2NvdHQgSmVobC4gTUlUIGxpY2Vuc2UgKi9cbihmdW5jdGlvbigpe1xuICAgIC8vIEJhaWwgb3V0IGZvciBicm93c2VycyB0aGF0IGhhdmUgYWRkTGlzdGVuZXIgc3VwcG9ydFxuICAgIGlmICh3aW5kb3cubWF0Y2hNZWRpYSAmJiB3aW5kb3cubWF0Y2hNZWRpYSgnYWxsJykuYWRkTGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBsb2NhbE1hdGNoTWVkaWEgPSB3aW5kb3cubWF0Y2hNZWRpYSxcbiAgICAgICAgaGFzTWVkaWFRdWVyaWVzID0gbG9jYWxNYXRjaE1lZGlhKCdvbmx5IGFsbCcpLm1hdGNoZXMsXG4gICAgICAgIGlzTGlzdGVuaW5nICAgICA9IGZhbHNlLFxuICAgICAgICB0aW1lb3V0SUQgICAgICAgPSAwLCAgICAvLyBzZXRUaW1lb3V0IGZvciBkZWJvdW5jaW5nICdoYW5kbGVDaGFuZ2UnXG4gICAgICAgIHF1ZXJpZXMgICAgICAgICA9IFtdLCAgIC8vIENvbnRhaW5zIGVhY2ggJ21xbCcgYW5kIGFzc29jaWF0ZWQgJ2xpc3RlbmVycycgaWYgJ2FkZExpc3RlbmVyJyBpcyB1c2VkXG4gICAgICAgIGhhbmRsZUNoYW5nZSAgICA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgLy8gRGVib3VuY2VcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SUQpO1xuXG4gICAgICAgICAgICB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHF1ZXJpZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXFsICAgICAgICAgPSBxdWVyaWVzW2ldLm1xbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycyAgID0gcXVlcmllc1tpXS5saXN0ZW5lcnMgfHwgW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzICAgICA9IGxvY2FsTWF0Y2hNZWRpYShtcWwubWVkaWEpLm1hdGNoZXM7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIG1xbC5tYXRjaGVzIHZhbHVlIGFuZCBjYWxsIGxpc3RlbmVyc1xuICAgICAgICAgICAgICAgICAgICAvLyBGaXJlIGxpc3RlbmVycyBvbmx5IGlmIHRyYW5zaXRpb25pbmcgdG8gb3IgZnJvbSBtYXRjaGVkIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzICE9PSBtcWwubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXFsLm1hdGNoZXMgPSBtYXRjaGVzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgamwgPSBsaXN0ZW5lcnMubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tqXS5jYWxsKHdpbmRvdywgbXFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDMwKTtcbiAgICAgICAgfTtcblxuICAgIHdpbmRvdy5tYXRjaE1lZGlhID0gZnVuY3Rpb24obWVkaWEpIHtcbiAgICAgICAgdmFyIG1xbCAgICAgICAgID0gbG9jYWxNYXRjaE1lZGlhKG1lZGlhKSxcbiAgICAgICAgICAgIGxpc3RlbmVycyAgID0gW10sXG4gICAgICAgICAgICBpbmRleCAgICAgICA9IDA7XG5cbiAgICAgICAgbXFsLmFkZExpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICAgICAgICAgIC8vIENoYW5nZXMgd291bGQgbm90IG9jY3VyIHRvIGNzcyBtZWRpYSB0eXBlIHNvIHJldHVybiBub3cgKEFmZmVjdHMgSUUgPD0gOClcbiAgICAgICAgICAgIGlmICghaGFzTWVkaWFRdWVyaWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXQgdXAgJ3Jlc2l6ZScgbGlzdGVuZXIgZm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIG1lZGlhIHF1ZXJpZXMgKE5vdCBmb3IgSUUgPD0gOClcbiAgICAgICAgICAgIC8vIFRoZXJlIHNob3VsZCBvbmx5IGV2ZXIgYmUgMSByZXNpemUgbGlzdGVuZXIgcnVubmluZyBmb3IgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgIGlmICghaXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgICAgICBpc0xpc3RlbmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZUNoYW5nZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFB1c2ggb2JqZWN0IG9ubHkgaWYgaXQgaGFzIG5vdCBiZWVuIHB1c2hlZCBhbHJlYWR5XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHF1ZXJpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1xbCAgICAgICAgIDogbXFsLFxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgICA6IGxpc3RlbmVyc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgbXFsLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBpbDsgaSsrKXtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldID09PSBsaXN0ZW5lcil7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBtcWw7XG4gICAgfTtcbn0oKSk7XG4iLCIvKiEgbWF0Y2hNZWRpYSgpIHBvbHlmaWxsIC0gVGVzdCBhIENTUyBtZWRpYSB0eXBlL3F1ZXJ5IGluIEpTLiBBdXRob3JzICYgY29weXJpZ2h0IChjKSAyMDEyOiBTY290dCBKZWhsLCBQYXVsIElyaXNoLCBOaWNob2xhcyBaYWthcywgRGF2aWQgS25pZ2h0LiBNSVQgbGljZW5zZSAqL1xuXG53aW5kb3cubWF0Y2hNZWRpYSB8fCAod2luZG93Lm1hdGNoTWVkaWEgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIEZvciBicm93c2VycyB0aGF0IHN1cHBvcnQgbWF0Y2hNZWRpdW0gYXBpIHN1Y2ggYXMgSUUgOSBhbmQgd2Via2l0XG4gICAgdmFyIHN0eWxlTWVkaWEgPSAod2luZG93LnN0eWxlTWVkaWEgfHwgd2luZG93Lm1lZGlhKTtcblxuICAgIC8vIEZvciB0aG9zZSB0aGF0IGRvbid0IHN1cHBvcnQgbWF0Y2hNZWRpdW1cbiAgICBpZiAoIXN0eWxlTWVkaWEpIHtcbiAgICAgICAgdmFyIHN0eWxlICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKSxcbiAgICAgICAgICAgIHNjcmlwdCAgICAgID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdLFxuICAgICAgICAgICAgaW5mbyAgICAgICAgPSBudWxsO1xuXG4gICAgICAgIHN0eWxlLnR5cGUgID0gJ3RleHQvY3NzJztcbiAgICAgICAgc3R5bGUuaWQgICAgPSAnbWF0Y2htZWRpYWpzLXRlc3QnO1xuXG4gICAgICAgIGlmICghc2NyaXB0KSB7XG4gICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2NyaXB0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHN0eWxlLCBzY3JpcHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gJ3N0eWxlLmN1cnJlbnRTdHlsZScgaXMgdXNlZCBieSBJRSA8PSA4IGFuZCAnd2luZG93LmdldENvbXB1dGVkU3R5bGUnIGZvciBhbGwgb3RoZXIgYnJvd3NlcnNcbiAgICAgICAgaW5mbyA9ICgnZ2V0Q29tcHV0ZWRTdHlsZScgaW4gd2luZG93KSAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzdHlsZSwgbnVsbCkgfHwgc3R5bGUuY3VycmVudFN0eWxlO1xuXG4gICAgICAgIHN0eWxlTWVkaWEgPSB7XG4gICAgICAgICAgICBtYXRjaE1lZGl1bTogZnVuY3Rpb24obWVkaWEpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9ICdAbWVkaWEgJyArIG1lZGlhICsgJ3sgI21hdGNobWVkaWFqcy10ZXN0IHsgd2lkdGg6IDFweDsgfSB9JztcblxuICAgICAgICAgICAgICAgIC8vICdzdHlsZS5zdHlsZVNoZWV0JyBpcyB1c2VkIGJ5IElFIDw9IDggYW5kICdzdHlsZS50ZXh0Q29udGVudCcgZm9yIGFsbCBvdGhlciBicm93c2Vyc1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHRleHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRlc3QgaWYgbWVkaWEgcXVlcnkgaXMgdHJ1ZSBvciBmYWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmZvLndpZHRoID09PSAnMXB4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24obWVkaWEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1hdGNoZXM6IHN0eWxlTWVkaWEubWF0Y2hNZWRpdW0obWVkaWEgfHwgJ2FsbCcpLFxuICAgICAgICAgICAgbWVkaWE6IG1lZGlhIHx8ICdhbGwnXG4gICAgICAgIH07XG4gICAgfTtcbn0oKSk7XG4iLCJ2YXIgaGFzTWFwID0gdHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBNYXAucHJvdG90eXBlO1xudmFyIG1hcFNpemVEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiBoYXNNYXAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1hcC5wcm90b3R5cGUsICdzaXplJykgOiBudWxsO1xudmFyIG1hcFNpemUgPSBoYXNNYXAgJiYgbWFwU2l6ZURlc2NyaXB0b3IgJiYgdHlwZW9mIG1hcFNpemVEZXNjcmlwdG9yLmdldCA9PT0gJ2Z1bmN0aW9uJyA/IG1hcFNpemVEZXNjcmlwdG9yLmdldCA6IG51bGw7XG52YXIgbWFwRm9yRWFjaCA9IGhhc01hcCAmJiBNYXAucHJvdG90eXBlLmZvckVhY2g7XG52YXIgaGFzU2V0ID0gdHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJyAmJiBTZXQucHJvdG90eXBlO1xudmFyIHNldFNpemVEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiBoYXNTZXQgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFNldC5wcm90b3R5cGUsICdzaXplJykgOiBudWxsO1xudmFyIHNldFNpemUgPSBoYXNTZXQgJiYgc2V0U2l6ZURlc2NyaXB0b3IgJiYgdHlwZW9mIHNldFNpemVEZXNjcmlwdG9yLmdldCA9PT0gJ2Z1bmN0aW9uJyA/IHNldFNpemVEZXNjcmlwdG9yLmdldCA6IG51bGw7XG52YXIgc2V0Rm9yRWFjaCA9IGhhc1NldCAmJiBTZXQucHJvdG90eXBlLmZvckVhY2g7XG52YXIgaGFzV2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nICYmIFdlYWtNYXAucHJvdG90eXBlO1xudmFyIHdlYWtNYXBIYXMgPSBoYXNXZWFrTWFwID8gV2Vha01hcC5wcm90b3R5cGUuaGFzIDogbnVsbDtcbnZhciBoYXNXZWFrU2V0ID0gdHlwZW9mIFdlYWtTZXQgPT09ICdmdW5jdGlvbicgJiYgV2Vha1NldC5wcm90b3R5cGU7XG52YXIgd2Vha1NldEhhcyA9IGhhc1dlYWtTZXQgPyBXZWFrU2V0LnByb3RvdHlwZS5oYXMgOiBudWxsO1xudmFyIGhhc1dlYWtSZWYgPSB0eXBlb2YgV2Vha1JlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBXZWFrUmVmLnByb3RvdHlwZTtcbnZhciB3ZWFrUmVmRGVyZWYgPSBoYXNXZWFrUmVmID8gV2Vha1JlZi5wcm90b3R5cGUuZGVyZWYgOiBudWxsO1xudmFyIGJvb2xlYW5WYWx1ZU9mID0gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZjtcbnZhciBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciBtYXRjaCA9IFN0cmluZy5wcm90b3R5cGUubWF0Y2g7XG52YXIgYmlnSW50VmFsdWVPZiA9IHR5cGVvZiBCaWdJbnQgPT09ICdmdW5jdGlvbicgPyBCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YgOiBudWxsO1xudmFyIGdPUFMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIHN5bVRvU3RyaW5nID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJyA/IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgOiBudWxsO1xudmFyIGhhc1NoYW1tZWRTeW1ib2xzID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnb2JqZWN0JztcbnZhciBpc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG52YXIgZ1BPID0gKHR5cGVvZiBSZWZsZWN0ID09PSAnZnVuY3Rpb24nID8gUmVmbGVjdC5nZXRQcm90b3R5cGVPZiA6IE9iamVjdC5nZXRQcm90b3R5cGVPZikgfHwgKFxuICAgIFtdLl9fcHJvdG9fXyA9PT0gQXJyYXkucHJvdG90eXBlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG9cbiAgICAgICAgPyBmdW5jdGlvbiAoTykge1xuICAgICAgICAgICAgcmV0dXJuIE8uX19wcm90b19fOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvXG4gICAgICAgIH1cbiAgICAgICAgOiBudWxsXG4pO1xuXG52YXIgaW5zcGVjdEN1c3RvbSA9IHJlcXVpcmUoJy4vdXRpbC5pbnNwZWN0JykuY3VzdG9tO1xudmFyIGluc3BlY3RTeW1ib2wgPSBpbnNwZWN0Q3VzdG9tICYmIGlzU3ltYm9sKGluc3BlY3RDdXN0b20pID8gaW5zcGVjdEN1c3RvbSA6IG51bGw7XG52YXIgdG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogbnVsbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbnNwZWN0XyhvYmosIG9wdGlvbnMsIGRlcHRoLCBzZWVuKSB7XG4gICAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKGhhcyhvcHRzLCAncXVvdGVTdHlsZScpICYmIChvcHRzLnF1b3RlU3R5bGUgIT09ICdzaW5nbGUnICYmIG9wdHMucXVvdGVTdHlsZSAhPT0gJ2RvdWJsZScpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBcInF1b3RlU3R5bGVcIiBtdXN0IGJlIFwic2luZ2xlXCIgb3IgXCJkb3VibGVcIicpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAgIGhhcyhvcHRzLCAnbWF4U3RyaW5nTGVuZ3RoJykgJiYgKHR5cGVvZiBvcHRzLm1heFN0cmluZ0xlbmd0aCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgID8gb3B0cy5tYXhTdHJpbmdMZW5ndGggPCAwICYmIG9wdHMubWF4U3RyaW5nTGVuZ3RoICE9PSBJbmZpbml0eVxuICAgICAgICAgICAgOiBvcHRzLm1heFN0cmluZ0xlbmd0aCAhPT0gbnVsbFxuICAgICAgICApXG4gICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBcIm1heFN0cmluZ0xlbmd0aFwiLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIEluZmluaXR5LCBvciBgbnVsbGAnKTtcbiAgICB9XG4gICAgdmFyIGN1c3RvbUluc3BlY3QgPSBoYXMob3B0cywgJ2N1c3RvbUluc3BlY3QnKSA/IG9wdHMuY3VzdG9tSW5zcGVjdCA6IHRydWU7XG4gICAgaWYgKHR5cGVvZiBjdXN0b21JbnNwZWN0ICE9PSAnYm9vbGVhbicgJiYgY3VzdG9tSW5zcGVjdCAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIFwiY3VzdG9tSW5zcGVjdFwiLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBgdHJ1ZWAsIGBmYWxzZWAsIG9yIGBcXCdzeW1ib2xcXCdgJyk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgICBoYXMob3B0cywgJ2luZGVudCcpXG4gICAgICAgICYmIG9wdHMuaW5kZW50ICE9PSBudWxsXG4gICAgICAgICYmIG9wdHMuaW5kZW50ICE9PSAnXFx0J1xuICAgICAgICAmJiAhKHBhcnNlSW50KG9wdHMuaW5kZW50LCAxMCkgPT09IG9wdHMuaW5kZW50ICYmIG9wdHMuaW5kZW50ID4gMClcbiAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBcImluZGVudFwiIG11c3QgYmUgXCJcXFxcdFwiLCBhbiBpbnRlZ2VyID4gMCwgb3IgYG51bGxgJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICB9XG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBvYmogPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaW5zcGVjdFN0cmluZyhvYmosIG9wdHMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKG9iaiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5IC8gb2JqID4gMCA/ICcwJyA6ICctMCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZyhvYmopO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhvYmopICsgJ24nO1xuICAgIH1cblxuICAgIHZhciBtYXhEZXB0aCA9IHR5cGVvZiBvcHRzLmRlcHRoID09PSAndW5kZWZpbmVkJyA/IDUgOiBvcHRzLmRlcHRoO1xuICAgIGlmICh0eXBlb2YgZGVwdGggPT09ICd1bmRlZmluZWQnKSB7IGRlcHRoID0gMDsgfVxuICAgIGlmIChkZXB0aCA+PSBtYXhEZXB0aCAmJiBtYXhEZXB0aCA+IDAgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkob2JqKSA/ICdbQXJyYXldJyA6ICdbT2JqZWN0XSc7XG4gICAgfVxuXG4gICAgdmFyIGluZGVudCA9IGdldEluZGVudChvcHRzLCBkZXB0aCk7XG5cbiAgICBpZiAodHlwZW9mIHNlZW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNlZW4gPSBbXTtcbiAgICB9IGVsc2UgaWYgKGluZGV4T2Yoc2Vlbiwgb2JqKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zcGVjdCh2YWx1ZSwgZnJvbSwgbm9JbmRlbnQpIHtcbiAgICAgICAgaWYgKGZyb20pIHtcbiAgICAgICAgICAgIHNlZW4gPSBzZWVuLnNsaWNlKCk7XG4gICAgICAgICAgICBzZWVuLnB1c2goZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vSW5kZW50KSB7XG4gICAgICAgICAgICB2YXIgbmV3T3B0cyA9IHtcbiAgICAgICAgICAgICAgICBkZXB0aDogb3B0cy5kZXB0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChoYXMob3B0cywgJ3F1b3RlU3R5bGUnKSkge1xuICAgICAgICAgICAgICAgIG5ld09wdHMucXVvdGVTdHlsZSA9IG9wdHMucXVvdGVTdHlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnNwZWN0Xyh2YWx1ZSwgbmV3T3B0cywgZGVwdGggKyAxLCBzZWVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zcGVjdF8odmFsdWUsIG9wdHMsIGRlcHRoICsgMSwgc2Vlbik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBuYW1lT2Yob2JqKTtcbiAgICAgICAgdmFyIGtleXMgPSBhcnJPYmpLZXlzKG9iaiwgaW5zcGVjdCk7XG4gICAgICAgIHJldHVybiAnW0Z1bmN0aW9uJyArIChuYW1lID8gJzogJyArIG5hbWUgOiAnIChhbm9ueW1vdXMpJykgKyAnXScgKyAoa2V5cy5sZW5ndGggPiAwID8gJyB7ICcgKyBrZXlzLmpvaW4oJywgJykgKyAnIH0nIDogJycpO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wob2JqKSkge1xuICAgICAgICB2YXIgc3ltU3RyaW5nID0gaGFzU2hhbW1lZFN5bWJvbHMgPyBTdHJpbmcob2JqKS5yZXBsYWNlKC9eKFN5bWJvbFxcKC4qXFwpKV9bXildKiQvLCAnJDEnKSA6IHN5bVRvU3RyaW5nLmNhbGwob2JqKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmICFoYXNTaGFtbWVkU3ltYm9scyA/IG1hcmtCb3hlZChzeW1TdHJpbmcpIDogc3ltU3RyaW5nO1xuICAgIH1cbiAgICBpZiAoaXNFbGVtZW50KG9iaikpIHtcbiAgICAgICAgdmFyIHMgPSAnPCcgKyBTdHJpbmcob2JqLm5vZGVOYW1lKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgYXR0cnMgPSBvYmouYXR0cmlidXRlcyB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcyArPSAnICcgKyBhdHRyc1tpXS5uYW1lICsgJz0nICsgd3JhcFF1b3RlcyhxdW90ZShhdHRyc1tpXS52YWx1ZSksICdkb3VibGUnLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBzICs9ICc+JztcbiAgICAgICAgaWYgKG9iai5jaGlsZE5vZGVzICYmIG9iai5jaGlsZE5vZGVzLmxlbmd0aCkgeyBzICs9ICcuLi4nOyB9XG4gICAgICAgIHMgKz0gJzwvJyArIFN0cmluZyhvYmoubm9kZU5hbWUpLnRvTG93ZXJDYXNlKCkgKyAnPic7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICAgIGlmIChvYmoubGVuZ3RoID09PSAwKSB7IHJldHVybiAnW10nOyB9XG4gICAgICAgIHZhciB4cyA9IGFyck9iaktleXMob2JqLCBpbnNwZWN0KTtcbiAgICAgICAgaWYgKGluZGVudCAmJiAhc2luZ2xlTGluZVZhbHVlcyh4cykpIHtcbiAgICAgICAgICAgIHJldHVybiAnWycgKyBpbmRlbnRlZEpvaW4oeHMsIGluZGVudCkgKyAnXSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdbICcgKyB4cy5qb2luKCcsICcpICsgJyBdJztcbiAgICB9XG4gICAgaWYgKGlzRXJyb3Iob2JqKSkge1xuICAgICAgICB2YXIgcGFydHMgPSBhcnJPYmpLZXlzKG9iaiwgaW5zcGVjdCk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDApIHsgcmV0dXJuICdbJyArIFN0cmluZyhvYmopICsgJ10nOyB9XG4gICAgICAgIHJldHVybiAneyBbJyArIFN0cmluZyhvYmopICsgJ10gJyArIHBhcnRzLmpvaW4oJywgJykgKyAnIH0nO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgY3VzdG9tSW5zcGVjdCkge1xuICAgICAgICBpZiAoaW5zcGVjdFN5bWJvbCAmJiB0eXBlb2Ygb2JqW2luc3BlY3RTeW1ib2xdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqW2luc3BlY3RTeW1ib2xdKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VzdG9tSW5zcGVjdCAhPT0gJ3N5bWJvbCcgJiYgdHlwZW9mIG9iai5pbnNwZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLmluc3BlY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNNYXAob2JqKSkge1xuICAgICAgICB2YXIgbWFwUGFydHMgPSBbXTtcbiAgICAgICAgbWFwRm9yRWFjaC5jYWxsKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIG1hcFBhcnRzLnB1c2goaW5zcGVjdChrZXksIG9iaiwgdHJ1ZSkgKyAnID0+ICcgKyBpbnNwZWN0KHZhbHVlLCBvYmopKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uT2YoJ01hcCcsIG1hcFNpemUuY2FsbChvYmopLCBtYXBQYXJ0cywgaW5kZW50KTtcbiAgICB9XG4gICAgaWYgKGlzU2V0KG9iaikpIHtcbiAgICAgICAgdmFyIHNldFBhcnRzID0gW107XG4gICAgICAgIHNldEZvckVhY2guY2FsbChvYmosIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgc2V0UGFydHMucHVzaChpbnNwZWN0KHZhbHVlLCBvYmopKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uT2YoJ1NldCcsIHNldFNpemUuY2FsbChvYmopLCBzZXRQYXJ0cywgaW5kZW50KTtcbiAgICB9XG4gICAgaWYgKGlzV2Vha01hcChvYmopKSB7XG4gICAgICAgIHJldHVybiB3ZWFrQ29sbGVjdGlvbk9mKCdXZWFrTWFwJyk7XG4gICAgfVxuICAgIGlmIChpc1dlYWtTZXQob2JqKSkge1xuICAgICAgICByZXR1cm4gd2Vha0NvbGxlY3Rpb25PZignV2Vha1NldCcpO1xuICAgIH1cbiAgICBpZiAoaXNXZWFrUmVmKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIHdlYWtDb2xsZWN0aW9uT2YoJ1dlYWtSZWYnKTtcbiAgICB9XG4gICAgaWYgKGlzTnVtYmVyKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtCb3hlZChpbnNwZWN0KE51bWJlcihvYmopKSk7XG4gICAgfVxuICAgIGlmIChpc0JpZ0ludChvYmopKSB7XG4gICAgICAgIHJldHVybiBtYXJrQm94ZWQoaW5zcGVjdChiaWdJbnRWYWx1ZU9mLmNhbGwob2JqKSkpO1xuICAgIH1cbiAgICBpZiAoaXNCb29sZWFuKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtCb3hlZChib29sZWFuVmFsdWVPZi5jYWxsKG9iaikpO1xuICAgIH1cbiAgICBpZiAoaXNTdHJpbmcob2JqKSkge1xuICAgICAgICByZXR1cm4gbWFya0JveGVkKGluc3BlY3QoU3RyaW5nKG9iaikpKTtcbiAgICB9XG4gICAgaWYgKCFpc0RhdGUob2JqKSAmJiAhaXNSZWdFeHAob2JqKSkge1xuICAgICAgICB2YXIgeXMgPSBhcnJPYmpLZXlzKG9iaiwgaW5zcGVjdCk7XG4gICAgICAgIHZhciBpc1BsYWluT2JqZWN0ID0gZ1BPID8gZ1BPKG9iaikgPT09IE9iamVjdC5wcm90b3R5cGUgOiBvYmogaW5zdGFuY2VvZiBPYmplY3QgfHwgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG4gICAgICAgIHZhciBwcm90b1RhZyA9IG9iaiBpbnN0YW5jZW9mIE9iamVjdCA/ICcnIDogJ251bGwgcHJvdG90eXBlJztcbiAgICAgICAgdmFyIHN0cmluZ1RhZyA9ICFpc1BsYWluT2JqZWN0ICYmIHRvU3RyaW5nVGFnICYmIE9iamVjdChvYmopID09PSBvYmogJiYgdG9TdHJpbmdUYWcgaW4gb2JqID8gdG9TdHIob2JqKS5zbGljZSg4LCAtMSkgOiBwcm90b1RhZyA/ICdPYmplY3QnIDogJyc7XG4gICAgICAgIHZhciBjb25zdHJ1Y3RvclRhZyA9IGlzUGxhaW5PYmplY3QgfHwgdHlwZW9mIG9iai5jb25zdHJ1Y3RvciAhPT0gJ2Z1bmN0aW9uJyA/ICcnIDogb2JqLmNvbnN0cnVjdG9yLm5hbWUgPyBvYmouY29uc3RydWN0b3IubmFtZSArICcgJyA6ICcnO1xuICAgICAgICB2YXIgdGFnID0gY29uc3RydWN0b3JUYWcgKyAoc3RyaW5nVGFnIHx8IHByb3RvVGFnID8gJ1snICsgW10uY29uY2F0KHN0cmluZ1RhZyB8fCBbXSwgcHJvdG9UYWcgfHwgW10pLmpvaW4oJzogJykgKyAnXSAnIDogJycpO1xuICAgICAgICBpZiAoeXMubGVuZ3RoID09PSAwKSB7IHJldHVybiB0YWcgKyAne30nOyB9XG4gICAgICAgIGlmIChpbmRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0YWcgKyAneycgKyBpbmRlbnRlZEpvaW4oeXMsIGluZGVudCkgKyAnfSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZyArICd7ICcgKyB5cy5qb2luKCcsICcpICsgJyB9JztcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZyhvYmopO1xufTtcblxuZnVuY3Rpb24gd3JhcFF1b3RlcyhzLCBkZWZhdWx0U3R5bGUsIG9wdHMpIHtcbiAgICB2YXIgcXVvdGVDaGFyID0gKG9wdHMucXVvdGVTdHlsZSB8fCBkZWZhdWx0U3R5bGUpID09PSAnZG91YmxlJyA/ICdcIicgOiBcIidcIjtcbiAgICByZXR1cm4gcXVvdGVDaGFyICsgcyArIHF1b3RlQ2hhcjtcbn1cblxuZnVuY3Rpb24gcXVvdGUocykge1xuICAgIHJldHVybiBTdHJpbmcocykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5KG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cbmZ1bmN0aW9uIGlzRGF0ZShvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cbmZ1bmN0aW9uIGlzUmVnRXhwKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXScgJiYgKCF0b1N0cmluZ1RhZyB8fCAhKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nVGFnIGluIG9iaikpOyB9XG5mdW5jdGlvbiBpc0Vycm9yKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cbmZ1bmN0aW9uIGlzU3RyaW5nKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXScgJiYgKCF0b1N0cmluZ1RhZyB8fCAhKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nVGFnIGluIG9iaikpOyB9XG5mdW5jdGlvbiBpc051bWJlcihvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxuZnVuY3Rpb24gaXNCb29sZWFuKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxuXG4vLyBTeW1ib2wgYW5kIEJpZ0ludCBkbyBoYXZlIFN5bWJvbC50b1N0cmluZ1RhZyBieSBzcGVjLCBzbyB0aGF0IGNhbid0IGJlIHVzZWQgdG8gZWxpbWluYXRlIGZhbHNlIHBvc2l0aXZlc1xuZnVuY3Rpb24gaXNTeW1ib2wob2JqKSB7XG4gICAgaWYgKGhhc1NoYW1tZWRTeW1ib2xzKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqIGluc3RhbmNlb2YgU3ltYm9sO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8ICFzeW1Ub1N0cmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHN5bVRvU3RyaW5nLmNhbGwob2JqKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQmlnSW50KG9iaikge1xuICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8ICFiaWdJbnRWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgYmlnSW50VmFsdWVPZi5jYWxsKG9iaik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSB8fCBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBrZXkgaW4gdGhpczsgfTtcbmZ1bmN0aW9uIGhhcyhvYmosIGtleSkge1xuICAgIHJldHVybiBoYXNPd24uY2FsbChvYmosIGtleSk7XG59XG5cbmZ1bmN0aW9uIHRvU3RyKG9iaikge1xuICAgIHJldHVybiBvYmplY3RUb1N0cmluZy5jYWxsKG9iaik7XG59XG5cbmZ1bmN0aW9uIG5hbWVPZihmKSB7XG4gICAgaWYgKGYubmFtZSkgeyByZXR1cm4gZi5uYW1lOyB9XG4gICAgdmFyIG0gPSBtYXRjaC5jYWxsKGZ1bmN0aW9uVG9TdHJpbmcuY2FsbChmKSwgL15mdW5jdGlvblxccyooW1xcdyRdKykvKTtcbiAgICBpZiAobSkgeyByZXR1cm4gbVsxXTsgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gICAgaWYgKHhzLmluZGV4T2YpIHsgcmV0dXJuIHhzLmluZGV4T2YoeCk7IH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoeHNbaV0gPT09IHgpIHsgcmV0dXJuIGk7IH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBpc01hcCh4KSB7XG4gICAgaWYgKCFtYXBTaXplIHx8ICF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIG1hcFNpemUuY2FsbCh4KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNldFNpemUuY2FsbCh4KTtcbiAgICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBNYXA7IC8vIGNvcmUtanMgd29ya2Fyb3VuZCwgcHJlLXYyLjUuMFxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1dlYWtNYXAoeCkge1xuICAgIGlmICghd2Vha01hcEhhcyB8fCAheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB3ZWFrTWFwSGFzLmNhbGwoeCwgd2Vha01hcEhhcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3ZWFrU2V0SGFzLmNhbGwoeCwgd2Vha1NldEhhcyk7XG4gICAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgV2Vha01hcDsgLy8gY29yZS1qcyB3b3JrYXJvdW5kLCBwcmUtdjIuNS4wXG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzV2Vha1JlZih4KSB7XG4gICAgaWYgKCF3ZWFrUmVmRGVyZWYgfHwgIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgd2Vha1JlZkRlcmVmLmNhbGwoeCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1NldCh4KSB7XG4gICAgaWYgKCFzZXRTaXplIHx8ICF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHNldFNpemUuY2FsbCh4KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1hcFNpemUuY2FsbCh4KTtcbiAgICAgICAgfSBjYXRjaCAobSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBTZXQ7IC8vIGNvcmUtanMgd29ya2Fyb3VuZCwgcHJlLXYyLjUuMFxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1dlYWtTZXQoeCkge1xuICAgIGlmICghd2Vha1NldEhhcyB8fCAheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB3ZWFrU2V0SGFzLmNhbGwoeCwgd2Vha1NldEhhcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3ZWFrTWFwSGFzLmNhbGwoeCwgd2Vha01hcEhhcyk7XG4gICAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgV2Vha1NldDsgLy8gY29yZS1qcyB3b3JrYXJvdW5kLCBwcmUtdjIuNS4wXG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRWxlbWVudCh4KSB7XG4gICAgaWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB4IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgeC5ub2RlTmFtZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHguZ2V0QXR0cmlidXRlID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpbnNwZWN0U3RyaW5nKHN0ciwgb3B0cykge1xuICAgIGlmIChzdHIubGVuZ3RoID4gb3B0cy5tYXhTdHJpbmdMZW5ndGgpIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IHN0ci5sZW5ndGggLSBvcHRzLm1heFN0cmluZ0xlbmd0aDtcbiAgICAgICAgdmFyIHRyYWlsZXIgPSAnLi4uICcgKyByZW1haW5pbmcgKyAnIG1vcmUgY2hhcmFjdGVyJyArIChyZW1haW5pbmcgPiAxID8gJ3MnIDogJycpO1xuICAgICAgICByZXR1cm4gaW5zcGVjdFN0cmluZyhzdHIuc2xpY2UoMCwgb3B0cy5tYXhTdHJpbmdMZW5ndGgpLCBvcHRzKSArIHRyYWlsZXI7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG4gICAgdmFyIHMgPSBzdHIucmVwbGFjZSgvKFsnXFxcXF0pL2csICdcXFxcJDEnKS5yZXBsYWNlKC9bXFx4MDAtXFx4MWZdL2csIGxvd2J5dGUpO1xuICAgIHJldHVybiB3cmFwUXVvdGVzKHMsICdzaW5nbGUnLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gbG93Ynl0ZShjKSB7XG4gICAgdmFyIG4gPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIHggPSB7XG4gICAgICAgIDg6ICdiJyxcbiAgICAgICAgOTogJ3QnLFxuICAgICAgICAxMDogJ24nLFxuICAgICAgICAxMjogJ2YnLFxuICAgICAgICAxMzogJ3InXG4gICAgfVtuXTtcbiAgICBpZiAoeCkgeyByZXR1cm4gJ1xcXFwnICsgeDsgfVxuICAgIHJldHVybiAnXFxcXHgnICsgKG4gPCAweDEwID8gJzAnIDogJycpICsgbi50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbn1cblxuZnVuY3Rpb24gbWFya0JveGVkKHN0cikge1xuICAgIHJldHVybiAnT2JqZWN0KCcgKyBzdHIgKyAnKSc7XG59XG5cbmZ1bmN0aW9uIHdlYWtDb2xsZWN0aW9uT2YodHlwZSkge1xuICAgIHJldHVybiB0eXBlICsgJyB7ID8gfSc7XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3Rpb25PZih0eXBlLCBzaXplLCBlbnRyaWVzLCBpbmRlbnQpIHtcbiAgICB2YXIgam9pbmVkRW50cmllcyA9IGluZGVudCA/IGluZGVudGVkSm9pbihlbnRyaWVzLCBpbmRlbnQpIDogZW50cmllcy5qb2luKCcsICcpO1xuICAgIHJldHVybiB0eXBlICsgJyAoJyArIHNpemUgKyAnKSB7JyArIGpvaW5lZEVudHJpZXMgKyAnfSc7XG59XG5cbmZ1bmN0aW9uIHNpbmdsZUxpbmVWYWx1ZXMoeHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpbmRleE9mKHhzW2ldLCAnXFxuJykgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXRJbmRlbnQob3B0cywgZGVwdGgpIHtcbiAgICB2YXIgYmFzZUluZGVudDtcbiAgICBpZiAob3B0cy5pbmRlbnQgPT09ICdcXHQnKSB7XG4gICAgICAgIGJhc2VJbmRlbnQgPSAnXFx0JztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRzLmluZGVudCA9PT0gJ251bWJlcicgJiYgb3B0cy5pbmRlbnQgPiAwKSB7XG4gICAgICAgIGJhc2VJbmRlbnQgPSBBcnJheShvcHRzLmluZGVudCArIDEpLmpvaW4oJyAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmFzZTogYmFzZUluZGVudCxcbiAgICAgICAgcHJldjogQXJyYXkoZGVwdGggKyAxKS5qb2luKGJhc2VJbmRlbnQpXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaW5kZW50ZWRKb2luKHhzLCBpbmRlbnQpIHtcbiAgICBpZiAoeHMubGVuZ3RoID09PSAwKSB7IHJldHVybiAnJzsgfVxuICAgIHZhciBsaW5lSm9pbmVyID0gJ1xcbicgKyBpbmRlbnQucHJldiArIGluZGVudC5iYXNlO1xuICAgIHJldHVybiBsaW5lSm9pbmVyICsgeHMuam9pbignLCcgKyBsaW5lSm9pbmVyKSArICdcXG4nICsgaW5kZW50LnByZXY7XG59XG5cbmZ1bmN0aW9uIGFyck9iaktleXMob2JqLCBpbnNwZWN0KSB7XG4gICAgdmFyIGlzQXJyID0gaXNBcnJheShvYmopO1xuICAgIHZhciB4cyA9IFtdO1xuICAgIGlmIChpc0Fycikge1xuICAgICAgICB4cy5sZW5ndGggPSBvYmoubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgeHNbaV0gPSBoYXMob2JqLCBpKSA/IGluc3BlY3Qob2JqW2ldLCBvYmopIDogJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHN5bXMgPSB0eXBlb2YgZ09QUyA9PT0gJ2Z1bmN0aW9uJyA/IGdPUFMob2JqKSA6IFtdO1xuICAgIHZhciBzeW1NYXA7XG4gICAgaWYgKGhhc1NoYW1tZWRTeW1ib2xzKSB7XG4gICAgICAgIHN5bU1hcCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHN5bXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHN5bU1hcFsnJCcgKyBzeW1zW2tdXSA9IHN5bXNba107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgICAgaWYgKCFoYXMob2JqLCBrZXkpKSB7IGNvbnRpbnVlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLWNvbnRpbnVlXG4gICAgICAgIGlmIChpc0FyciAmJiBTdHJpbmcoTnVtYmVyKGtleSkpID09PSBrZXkgJiYga2V5IDwgb2JqLmxlbmd0aCkgeyBjb250aW51ZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby1jb250aW51ZVxuICAgICAgICBpZiAoaGFzU2hhbW1lZFN5bWJvbHMgJiYgc3ltTWFwWyckJyArIGtleV0gaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gcHJldmVudCBzaGFtbWVkIFN5bWJvbHMsIHdoaWNoIGFyZSBzdG9yZWQgYXMgc3RyaW5ncywgZnJvbSBiZWluZyBpbmNsdWRlZCBpbiB0aGUgc3RyaW5nIGtleSBzZWN0aW9uXG4gICAgICAgICAgICBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmICgoL1teXFx3JF0vKS50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgIHhzLnB1c2goaW5zcGVjdChrZXksIG9iaikgKyAnOiAnICsgaW5zcGVjdChvYmpba2V5XSwgb2JqKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4cy5wdXNoKGtleSArICc6ICcgKyBpbnNwZWN0KG9ialtrZXldLCBvYmopKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGdPUFMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzeW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoaXNFbnVtZXJhYmxlLmNhbGwob2JqLCBzeW1zW2pdKSkge1xuICAgICAgICAgICAgICAgIHhzLnB1c2goJ1snICsgaW5zcGVjdChzeW1zW2pdKSArICddOiAnICsgaW5zcGVjdChvYmpbc3ltc1tqXV0sIG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB4cztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtleXNTaGltO1xuaWYgKCFPYmplY3Qua2V5cykge1xuXHQvLyBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxuXHR2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblx0dmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblx0dmFyIGlzQXJncyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBnbG9iYWwtcmVxdWlyZVxuXHR2YXIgaXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblx0dmFyIGhhc0RvbnRFbnVtQnVnID0gIWlzRW51bWVyYWJsZS5jYWxsKHsgdG9TdHJpbmc6IG51bGwgfSwgJ3RvU3RyaW5nJyk7XG5cdHZhciBoYXNQcm90b0VudW1CdWcgPSBpc0VudW1lcmFibGUuY2FsbChmdW5jdGlvbiAoKSB7fSwgJ3Byb3RvdHlwZScpO1xuXHR2YXIgZG9udEVudW1zID0gW1xuXHRcdCd0b1N0cmluZycsXG5cdFx0J3RvTG9jYWxlU3RyaW5nJyxcblx0XHQndmFsdWVPZicsXG5cdFx0J2hhc093blByb3BlcnR5Jyxcblx0XHQnaXNQcm90b3R5cGVPZicsXG5cdFx0J3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcblx0XHQnY29uc3RydWN0b3InXG5cdF07XG5cdHZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSA9IGZ1bmN0aW9uIChvKSB7XG5cdFx0dmFyIGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiBjdG9yICYmIGN0b3IucHJvdG90eXBlID09PSBvO1xuXHR9O1xuXHR2YXIgZXhjbHVkZWRLZXlzID0ge1xuXHRcdCRhcHBsaWNhdGlvbkNhY2hlOiB0cnVlLFxuXHRcdCRjb25zb2xlOiB0cnVlLFxuXHRcdCRleHRlcm5hbDogdHJ1ZSxcblx0XHQkZnJhbWU6IHRydWUsXG5cdFx0JGZyYW1lRWxlbWVudDogdHJ1ZSxcblx0XHQkZnJhbWVzOiB0cnVlLFxuXHRcdCRpbm5lckhlaWdodDogdHJ1ZSxcblx0XHQkaW5uZXJXaWR0aDogdHJ1ZSxcblx0XHQkb25tb3pmdWxsc2NyZWVuY2hhbmdlOiB0cnVlLFxuXHRcdCRvbm1vemZ1bGxzY3JlZW5lcnJvcjogdHJ1ZSxcblx0XHQkb3V0ZXJIZWlnaHQ6IHRydWUsXG5cdFx0JG91dGVyV2lkdGg6IHRydWUsXG5cdFx0JHBhZ2VYT2Zmc2V0OiB0cnVlLFxuXHRcdCRwYWdlWU9mZnNldDogdHJ1ZSxcblx0XHQkcGFyZW50OiB0cnVlLFxuXHRcdCRzY3JvbGxMZWZ0OiB0cnVlLFxuXHRcdCRzY3JvbGxUb3A6IHRydWUsXG5cdFx0JHNjcm9sbFg6IHRydWUsXG5cdFx0JHNjcm9sbFk6IHRydWUsXG5cdFx0JHNlbGY6IHRydWUsXG5cdFx0JHdlYmtpdEluZGV4ZWREQjogdHJ1ZSxcblx0XHQkd2Via2l0U3RvcmFnZUluZm86IHRydWUsXG5cdFx0JHdpbmRvdzogdHJ1ZVxuXHR9O1xuXHR2YXIgaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnID0gKGZ1bmN0aW9uICgpIHtcblx0XHQvKiBnbG9iYWwgd2luZG93ICovXG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGZvciAodmFyIGsgaW4gd2luZG93KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoIWV4Y2x1ZGVkS2V5c1snJCcgKyBrXSAmJiBoYXMuY2FsbCh3aW5kb3csIGspICYmIHdpbmRvd1trXSAhPT0gbnVsbCAmJiB0eXBlb2Ygd2luZG93W2tdID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSh3aW5kb3dba10pO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9KCkpO1xuXHR2YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5ID0gZnVuY3Rpb24gKG8pIHtcblx0XHQvKiBnbG9iYWwgd2luZG93ICovXG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcpIHtcblx0XHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdGtleXNTaGltID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcblx0XHR2YXIgaXNPYmplY3QgPSBvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCc7XG5cdFx0dmFyIGlzRnVuY3Rpb24gPSB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdFx0dmFyIGlzQXJndW1lbnRzID0gaXNBcmdzKG9iamVjdCk7XG5cdFx0dmFyIGlzU3RyaW5nID0gaXNPYmplY3QgJiYgdG9TdHIuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBTdHJpbmddJztcblx0XHR2YXIgdGhlS2V5cyA9IFtdO1xuXG5cdFx0aWYgKCFpc09iamVjdCAmJiAhaXNGdW5jdGlvbiAmJiAhaXNBcmd1bWVudHMpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5rZXlzIGNhbGxlZCBvbiBhIG5vbi1vYmplY3QnKTtcblx0XHR9XG5cblx0XHR2YXIgc2tpcFByb3RvID0gaGFzUHJvdG9FbnVtQnVnICYmIGlzRnVuY3Rpb247XG5cdFx0aWYgKGlzU3RyaW5nICYmIG9iamVjdC5sZW5ndGggPiAwICYmICFoYXMuY2FsbChvYmplY3QsIDApKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKGkpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXNBcmd1bWVudHMgJiYgb2JqZWN0Lmxlbmd0aCA+IDApIHtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgb2JqZWN0Lmxlbmd0aDsgKytqKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaikpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuXHRcdFx0XHRpZiAoIShza2lwUHJvdG8gJiYgbmFtZSA9PT0gJ3Byb3RvdHlwZScpICYmIGhhcy5jYWxsKG9iamVjdCwgbmFtZSkpIHtcblx0XHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKG5hbWUpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChoYXNEb250RW51bUJ1Zykge1xuXHRcdFx0dmFyIHNraXBDb25zdHJ1Y3RvciA9IGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneShvYmplY3QpO1xuXG5cdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IGRvbnRFbnVtcy5sZW5ndGg7ICsraykge1xuXHRcdFx0XHRpZiAoIShza2lwQ29uc3RydWN0b3IgJiYgZG9udEVudW1zW2tdID09PSAnY29uc3RydWN0b3InKSAmJiBoYXMuY2FsbChvYmplY3QsIGRvbnRFbnVtc1trXSkpIHtcblx0XHRcdFx0XHR0aGVLZXlzLnB1c2goZG9udEVudW1zW2tdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhlS2V5cztcblx0fTtcbn1cbm1vZHVsZS5leHBvcnRzID0ga2V5c1NoaW07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpc0FyZ3MgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyk7XG5cbnZhciBvcmlnS2V5cyA9IE9iamVjdC5rZXlzO1xudmFyIGtleXNTaGltID0gb3JpZ0tleXMgPyBmdW5jdGlvbiBrZXlzKG8pIHsgcmV0dXJuIG9yaWdLZXlzKG8pOyB9IDogcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG52YXIgb3JpZ2luYWxLZXlzID0gT2JqZWN0LmtleXM7XG5cbmtleXNTaGltLnNoaW0gPSBmdW5jdGlvbiBzaGltT2JqZWN0S2V5cygpIHtcblx0aWYgKE9iamVjdC5rZXlzKSB7XG5cdFx0dmFyIGtleXNXb3Jrc1dpdGhBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gU2FmYXJpIDUuMCBidWdcblx0XHRcdHZhciBhcmdzID0gT2JqZWN0LmtleXMoYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBhcmdzICYmIGFyZ3MubGVuZ3RoID09PSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdH0oMSwgMikpO1xuXHRcdGlmICgha2V5c1dvcmtzV2l0aEFyZ3VtZW50cykge1xuXHRcdFx0T2JqZWN0LmtleXMgPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuXHRcdFx0XHRpZiAoaXNBcmdzKG9iamVjdCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKHNsaWNlLmNhbGwob2JqZWN0KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhvYmplY3QpO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0T2JqZWN0LmtleXMgPSBrZXlzU2hpbTtcblx0fVxuXHRyZXR1cm4gT2JqZWN0LmtleXMgfHwga2V5c1NoaW07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNTaGltO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdHZhciBzdHIgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0dmFyIGlzQXJncyA9IHN0ciA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cdGlmICghaXNBcmdzKSB7XG5cdFx0aXNBcmdzID0gc3RyICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0XHR2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHRcdHZhbHVlLmxlbmd0aCA+PSAwICYmXG5cdFx0XHR0b1N0ci5jYWxsKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdH1cblx0cmV0dXJuIGlzQXJncztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvMjAyMS9SZXF1aXJlT2JqZWN0Q29lcmNpYmxlJyk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xudmFyICRpc0VudW1lcmFibGUgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUnKTtcbnZhciAkcHVzaCA9IGNhbGxCb3VuZCgnQXJyYXkucHJvdG90eXBlLnB1c2gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlbnRyaWVzKE8pIHtcblx0dmFyIG9iaiA9IFJlcXVpcmVPYmplY3RDb2VyY2libGUoTyk7XG5cdHZhciBlbnRyeXMgPSBbXTtcblx0Zm9yICh2YXIga2V5IGluIG9iaikge1xuXHRcdGlmICgkaXNFbnVtZXJhYmxlKG9iaiwga2V5KSkgeyAvLyBjaGVja3Mgb3duLW5lc3MgYXMgd2VsbFxuXHRcdFx0JHB1c2goZW50cnlzLCBba2V5LCBvYmpba2V5XV0pO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZW50cnlzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRyZXR1cm4gdHlwZW9mIE9iamVjdC5lbnRyaWVzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmVudHJpZXMgOiBpbXBsZW1lbnRhdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1FbnRyaWVzKCkge1xuXHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRkZWZpbmUoT2JqZWN0LCB7IGVudHJpZXM6IHBvbHlmaWxsIH0sIHtcblx0XHRlbnRyaWVzOiBmdW5jdGlvbiB0ZXN0RW50cmllcygpIHtcblx0XHRcdHJldHVybiBPYmplY3QuZW50cmllcyAhPT0gcG9seWZpbGw7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIHBvbHlmaWxsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi9zaGltJykoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEFkZEVudHJpZXNGcm9tSXRlcmFibGUgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL0FkZEVudHJpZXNGcm9tSXRlcmFibGUnKTtcbnZhciBDcmVhdGVEYXRhUHJvcGVydHlPclRocm93ID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvMjAyMS9DcmVhdGVEYXRhUHJvcGVydHlPclRocm93Jyk7XG52YXIgUmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMjEvUmVxdWlyZU9iamVjdENvZXJjaWJsZScpO1xudmFyIFRvUHJvcGVydHlLZXkgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL1RvUHJvcGVydHlLZXknKTtcblxudmFyIGFkZGVyID0gZnVuY3Rpb24gYWRkRGF0YVByb3BlcnR5KGtleSwgdmFsdWUpIHtcblx0dmFyIE8gPSB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWludmFsaWQtdGhpc1xuXHR2YXIgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KGtleSk7XG5cdENyZWF0ZURhdGFQcm9wZXJ0eU9yVGhyb3coTywgcHJvcGVydHlLZXksIHZhbHVlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZnJvbUVudHJpZXMoaXRlcmFibGUpIHtcblx0UmVxdWlyZU9iamVjdENvZXJjaWJsZShpdGVyYWJsZSk7XG5cblx0cmV0dXJuIEFkZEVudHJpZXNGcm9tSXRlcmFibGUoe30sIGl0ZXJhYmxlLCBhZGRlcik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XG5cdHJldHVybiB0eXBlb2YgT2JqZWN0LmZyb21FbnRyaWVzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmZyb21FbnRyaWVzIDogaW1wbGVtZW50YXRpb247XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGltRW50cmllcygpIHtcblx0dmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcblx0ZGVmaW5lKE9iamVjdCwgeyBmcm9tRW50cmllczogcG9seWZpbGwgfSwge1xuXHRcdGZyb21FbnRyaWVzOiBmdW5jdGlvbiB0ZXN0RW50cmllcygpIHtcblx0XHRcdHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMgIT09IHBvbHlmaWxsO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDcmVhdGVEYXRhUHJvcGVydHkgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL0NyZWF0ZURhdGFQcm9wZXJ0eScpO1xudmFyIElzQ2FsbGFibGUgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL0lzQ2FsbGFibGUnKTtcbnZhciBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvMjAyMS9SZXF1aXJlT2JqZWN0Q29lcmNpYmxlJyk7XG52YXIgVG9PYmplY3QgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL1RvT2JqZWN0Jyk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xuXG52YXIgJGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyICRnZXRPd25OYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyICRnZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciAkY29uY2F0ID0gY2FsbEJvdW5kKCdBcnJheS5wcm90b3R5cGUuY29uY2F0Jyk7XG52YXIgJHJlZHVjZSA9IGNhbGxCb3VuZCgnQXJyYXkucHJvdG90eXBlLnJlZHVjZScpO1xudmFyIGdldEFsbCA9ICRnZXRTeW1ib2xzID8gZnVuY3Rpb24gKG9iaikge1xuXHRyZXR1cm4gJGNvbmNhdCgkZ2V0T3duTmFtZXMob2JqKSwgJGdldFN5bWJvbHMob2JqKSk7XG59IDogJGdldE93bk5hbWVzO1xuXG52YXIgaXNFUzUgPSBJc0NhbGxhYmxlKCRnT1BEKSAmJiBJc0NhbGxhYmxlKCRnZXRPd25OYW1lcyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh2YWx1ZSkge1xuXHRSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHZhbHVlKTtcblx0aWYgKCFpc0VTNSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcnMgcmVxdWlyZXMgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcicpO1xuXHR9XG5cblx0dmFyIE8gPSBUb09iamVjdCh2YWx1ZSk7XG5cdHJldHVybiAkcmVkdWNlKFxuXHRcdGdldEFsbChPKSxcblx0XHRmdW5jdGlvbiAoYWNjLCBrZXkpIHtcblx0XHRcdHZhciBkZXNjcmlwdG9yID0gJGdPUEQoTywga2V5KTtcblx0XHRcdGlmICh0eXBlb2YgZGVzY3JpcHRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0Q3JlYXRlRGF0YVByb3BlcnR5KGFjYywga2V5LCBkZXNjcmlwdG9yKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhY2M7XG5cdFx0fSxcblx0XHR7fVxuXHQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRyZXR1cm4gdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgOiBpbXBsZW1lbnRhdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1HZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKCkge1xuXHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRkZWZpbmUoXG5cdFx0T2JqZWN0LFxuXHRcdHsgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogcG9seWZpbGwgfSxcblx0XHR7IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzICE9PSBwb2x5ZmlsbDsgfSB9XG5cdCk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvMjAyMS9SZXF1aXJlT2JqZWN0Q29lcmNpYmxlJyk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xuXG52YXIgJGlzRW51bWVyYWJsZSA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZScpO1xudmFyICRwdXNoID0gY2FsbEJvdW5kKCdBcnJheS5wcm90b3R5cGUucHVzaCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHZhbHVlcyhPKSB7XG5cdHZhciBvYmogPSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKE8pO1xuXHR2YXIgdmFscyA9IFtdO1xuXHRmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG5cdFx0aWYgKCRpc0VudW1lcmFibGUob2JqLCBrZXkpKSB7IC8vIGNoZWNrcyBvd24tbmVzcyBhcyB3ZWxsXG5cdFx0XHQkcHVzaCh2YWxzLCBvYmpba2V5XSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB2YWxzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRyZXR1cm4gdHlwZW9mIE9iamVjdC52YWx1ZXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QudmFsdWVzIDogaW1wbGVtZW50YXRpb247XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGltVmFsdWVzKCkge1xuXHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRkZWZpbmUoT2JqZWN0LCB7IHZhbHVlczogcG9seWZpbGwgfSwge1xuXHRcdHZhbHVlczogZnVuY3Rpb24gdGVzdFZhbHVlcygpIHtcblx0XHRcdHJldHVybiBPYmplY3QudmFsdWVzICE9PSBwb2x5ZmlsbDtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gcG9seWZpbGw7XG59O1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjJcbihmdW5jdGlvbigpIHtcbiAgdmFyIGdldE5hbm9TZWNvbmRzLCBocnRpbWUsIGxvYWRUaW1lLCBtb2R1bGVMb2FkVGltZSwgbm9kZUxvYWRUaW1lLCB1cFRpbWU7XG5cbiAgaWYgKCh0eXBlb2YgcGVyZm9ybWFuY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcGVyZm9ybWFuY2UgIT09IG51bGwpICYmIHBlcmZvcm1hbmNlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICgodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2VzcyAhPT0gbnVsbCkgJiYgcHJvY2Vzcy5ocnRpbWUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChnZXROYW5vU2Vjb25kcygpIC0gbm9kZUxvYWRUaW1lKSAvIDFlNjtcbiAgICB9O1xuICAgIGhydGltZSA9IHByb2Nlc3MuaHJ0aW1lO1xuICAgIGdldE5hbm9TZWNvbmRzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaHI7XG4gICAgICBociA9IGhydGltZSgpO1xuICAgICAgcmV0dXJuIGhyWzBdICogMWU5ICsgaHJbMV07XG4gICAgfTtcbiAgICBtb2R1bGVMb2FkVGltZSA9IGdldE5hbm9TZWNvbmRzKCk7XG4gICAgdXBUaW1lID0gcHJvY2Vzcy51cHRpbWUoKSAqIDFlOTtcbiAgICBub2RlTG9hZFRpbWUgPSBtb2R1bGVMb2FkVGltZSAtIHVwVGltZTtcbiAgfSBlbHNlIGlmIChEYXRlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIGxvYWRUaW1lO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBEYXRlLm5vdygpO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBsb2FkVGltZTtcbiAgICB9O1xuICAgIGxvYWRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH1cblxufSkuY2FsbCh0aGlzKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGVyZm9ybWFuY2Utbm93LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL3NoaW0nKSgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVxdWlyZVByb21pc2UgPSByZXF1aXJlKCcuL3JlcXVpcmVQcm9taXNlJyk7XG5cbnJlcXVpcmVQcm9taXNlKCk7XG5cbnZhciBQcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMjEvUHJvbWlzZVJlc29sdmUnKTtcbnZhciBUeXBlID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvMjAyMS9UeXBlJyk7XG52YXIgaXRlcmF0ZSA9IHJlcXVpcmUoJ2l0ZXJhdGUtdmFsdWUnKTtcbnZhciBtYXAgPSByZXF1aXJlKCdhcnJheS5wcm90b3R5cGUubWFwJyk7XG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xudmFyIGNhbGxCaW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kJyk7XG5cbnZhciBhbGwgPSBjYWxsQmluZChHZXRJbnRyaW5zaWMoJyVQcm9taXNlLmFsbCUnKSk7XG52YXIgcmVqZWN0ID0gY2FsbEJpbmQoR2V0SW50cmluc2ljKCclUHJvbWlzZS5yZWplY3QlJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFsbFNldHRsZWQoaXRlcmFibGUpIHtcblx0dmFyIEMgPSB0aGlzO1xuXHRpZiAoVHlwZShDKSAhPT0gJ09iamVjdCcpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdgdGhpc2AgdmFsdWUgbXVzdCBiZSBhbiBvYmplY3QnKTtcblx0fVxuXHR2YXIgdmFsdWVzID0gaXRlcmF0ZShpdGVyYWJsZSk7XG5cdHJldHVybiBhbGwoQywgbWFwKHZhbHVlcywgZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHR2YXIgb25GdWxmaWxsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4geyBzdGF0dXM6ICdmdWxmaWxsZWQnLCB2YWx1ZTogdmFsdWUgfTtcblx0XHR9O1xuXHRcdHZhciBvblJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcblx0XHRcdHJldHVybiB7IHN0YXR1czogJ3JlamVjdGVkJywgcmVhc29uOiByZWFzb24gfTtcblx0XHR9O1xuXHRcdHZhciBpdGVtUHJvbWlzZSA9IFByb21pc2VSZXNvbHZlKEMsIGl0ZW0pO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gaXRlbVByb21pc2UudGhlbihvbkZ1bGZpbGwsIG9uUmVqZWN0KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gcmVqZWN0KEMsIGUpO1xuXHRcdH1cblx0fSkpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlcXVpcmVQcm9taXNlID0gcmVxdWlyZSgnLi9yZXF1aXJlUHJvbWlzZScpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XG5cdHJlcXVpcmVQcm9taXNlKCk7XG5cdHJldHVybiB0eXBlb2YgUHJvbWlzZS5hbGxTZXR0bGVkID09PSAnZnVuY3Rpb24nID8gUHJvbWlzZS5hbGxTZXR0bGVkIDogaW1wbGVtZW50YXRpb247XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcXVpcmVQcm9taXNlKCkge1xuXHRpZiAodHlwZW9mIFByb21pc2UgIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdgUHJvbWlzZS5hbGxTZXR0bGVkYCByZXF1aXJlcyBhIGdsb2JhbCBgUHJvbWlzZWAgYmUgYXZhaWxhYmxlLicpO1xuXHR9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVxdWlyZVByb21pc2UgPSByZXF1aXJlKCcuL3JlcXVpcmVQcm9taXNlJyk7XG5cbnZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1BbGxTZXR0bGVkKCkge1xuXHRyZXF1aXJlUHJvbWlzZSgpO1xuXG5cdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG5cdGRlZmluZShQcm9taXNlLCB7IGFsbFNldHRsZWQ6IHBvbHlmaWxsIH0sIHtcblx0XHRhbGxTZXR0bGVkOiBmdW5jdGlvbiB0ZXN0QWxsU2V0dGxlZCgpIHtcblx0XHRcdHJldHVybiBQcm9taXNlLmFsbFNldHRsZWQgIT09IHBvbHlmaWxsO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4vc2hpbScpKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZXF1aXJlUHJvbWlzZSA9IHJlcXVpcmUoJy4vcmVxdWlyZVByb21pc2UnKTtcblxucmVxdWlyZVByb21pc2UoKTtcblxudmFyIElzQ2FsbGFibGUgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL0lzQ2FsbGFibGUnKTtcbnZhciBTcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL1NwZWNpZXNDb25zdHJ1Y3RvcicpO1xudmFyIFR5cGUgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL1R5cGUnKTtcblxudmFyIHByb21pc2VSZXNvbHZlID0gZnVuY3Rpb24gUHJvbWlzZVJlc29sdmUoQywgdmFsdWUpIHtcblx0cmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cdFx0cmVzb2x2ZSh2YWx1ZSk7XG5cdH0pO1xufTtcblxudmFyIE9yaWdpbmFsUHJvbWlzZSA9IFByb21pc2U7XG5cbnZhciBjcmVhdGVUaGVuRmluYWxseSA9IGZ1bmN0aW9uIENyZWF0ZVRoZW5GaW5hbGx5KEMsIG9uRmluYWxseSkge1xuXHRyZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0dmFyIHJlc3VsdCA9IG9uRmluYWxseSgpO1xuXHRcdHZhciBwcm9taXNlID0gcHJvbWlzZVJlc29sdmUoQywgcmVzdWx0KTtcblx0XHR2YXIgdmFsdWVUaHVuayA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9O1xuXHRcdHJldHVybiBwcm9taXNlLnRoZW4odmFsdWVUaHVuayk7XG5cdH07XG59O1xuXG52YXIgY3JlYXRlQ2F0Y2hGaW5hbGx5ID0gZnVuY3Rpb24gQ3JlYXRlQ2F0Y2hGaW5hbGx5KEMsIG9uRmluYWxseSkge1xuXHRyZXR1cm4gZnVuY3Rpb24gKHJlYXNvbikge1xuXHRcdHZhciByZXN1bHQgPSBvbkZpbmFsbHkoKTtcblx0XHR2YXIgcHJvbWlzZSA9IHByb21pc2VSZXNvbHZlKEMsIHJlc3VsdCk7XG5cdFx0dmFyIHRocm93ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aHJvdyByZWFzb247XG5cdFx0fTtcblx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKHRocm93ZXIpO1xuXHR9O1xufTtcblxudmFyIHByb21pc2VGaW5hbGx5ID0gZnVuY3Rpb24gZmluYWxseV8ob25GaW5hbGx5KSB7XG5cdC8qIGVzbGludCBuby1pbnZhbGlkLXRoaXM6IDAgKi9cblxuXHR2YXIgcHJvbWlzZSA9IHRoaXM7XG5cblx0aWYgKFR5cGUocHJvbWlzZSkgIT09ICdPYmplY3QnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcigncmVjZWl2ZXIgaXMgbm90IGFuIE9iamVjdCcpO1xuXHR9XG5cblx0dmFyIEMgPSBTcGVjaWVzQ29uc3RydWN0b3IocHJvbWlzZSwgT3JpZ2luYWxQcm9taXNlKTsgLy8gbWF5IHRocm93XG5cblx0dmFyIHRoZW5GaW5hbGx5ID0gb25GaW5hbGx5O1xuXHR2YXIgY2F0Y2hGaW5hbGx5ID0gb25GaW5hbGx5O1xuXHRpZiAoSXNDYWxsYWJsZShvbkZpbmFsbHkpKSB7XG5cdFx0dGhlbkZpbmFsbHkgPSBjcmVhdGVUaGVuRmluYWxseShDLCBvbkZpbmFsbHkpO1xuXHRcdGNhdGNoRmluYWxseSA9IGNyZWF0ZUNhdGNoRmluYWxseShDLCBvbkZpbmFsbHkpO1xuXHR9XG5cblx0cmV0dXJuIHByb21pc2UudGhlbih0aGVuRmluYWxseSwgY2F0Y2hGaW5hbGx5KTtcbn07XG5cbmlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKSB7XG5cdHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm9taXNlRmluYWxseSwgJ25hbWUnKTtcblx0aWYgKGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZUZpbmFsbHksICduYW1lJywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiAnZmluYWxseScgfSk7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9taXNlRmluYWxseTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlcXVpcmVQcm9taXNlID0gcmVxdWlyZSgnLi9yZXF1aXJlUHJvbWlzZScpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XG5cdHJlcXVpcmVQcm9taXNlKCk7XG5cdHJldHVybiB0eXBlb2YgUHJvbWlzZS5wcm90b3R5cGVbJ2ZpbmFsbHknXSA9PT0gJ2Z1bmN0aW9uJyA/IFByb21pc2UucHJvdG90eXBlWydmaW5hbGx5J10gOiBpbXBsZW1lbnRhdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVxdWlyZVByb21pc2UoKSB7XG5cdGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2BQcm9taXNlLnByb3RvdHlwZS5maW5hbGx5YCByZXF1aXJlcyBhIGdsb2JhbCBgUHJvbWlzZWAgYmUgYXZhaWxhYmxlLicpO1xuXHR9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVxdWlyZVByb21pc2UgPSByZXF1aXJlKCcuL3JlcXVpcmVQcm9taXNlJyk7XG5cbnZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1Qcm9taXNlRmluYWxseSgpIHtcblx0cmVxdWlyZVByb21pc2UoKTtcblxuXHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRkZWZpbmUoUHJvbWlzZS5wcm90b3R5cGUsIHsgJ2ZpbmFsbHknOiBwb2x5ZmlsbCB9LCB7XG5cdFx0J2ZpbmFsbHknOiBmdW5jdGlvbiB0ZXN0RmluYWxseSgpIHtcblx0XHRcdHJldHVybiBQcm9taXNlLnByb3RvdHlwZVsnZmluYWxseSddICE9PSBwb2x5ZmlsbDtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gcG9seWZpbGw7XG59O1xuIiwidmFyIG5vdyA9IHJlcXVpcmUoJ3BlcmZvcm1hbmNlLW5vdycpXG4gICwgcm9vdCA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogd2luZG93XG4gICwgdmVuZG9ycyA9IFsnbW96JywgJ3dlYmtpdCddXG4gICwgc3VmZml4ID0gJ0FuaW1hdGlvbkZyYW1lJ1xuICAsIHJhZiA9IHJvb3RbJ3JlcXVlc3QnICsgc3VmZml4XVxuICAsIGNhZiA9IHJvb3RbJ2NhbmNlbCcgKyBzdWZmaXhdIHx8IHJvb3RbJ2NhbmNlbFJlcXVlc3QnICsgc3VmZml4XVxuXG5mb3IodmFyIGkgPSAwOyAhcmFmICYmIGkgPCB2ZW5kb3JzLmxlbmd0aDsgaSsrKSB7XG4gIHJhZiA9IHJvb3RbdmVuZG9yc1tpXSArICdSZXF1ZXN0JyArIHN1ZmZpeF1cbiAgY2FmID0gcm9vdFt2ZW5kb3JzW2ldICsgJ0NhbmNlbCcgKyBzdWZmaXhdXG4gICAgICB8fCByb290W3ZlbmRvcnNbaV0gKyAnQ2FuY2VsUmVxdWVzdCcgKyBzdWZmaXhdXG59XG5cbi8vIFNvbWUgdmVyc2lvbnMgb2YgRkYgaGF2ZSByQUYgYnV0IG5vdCBjQUZcbmlmKCFyYWYgfHwgIWNhZikge1xuICB2YXIgbGFzdCA9IDBcbiAgICAsIGlkID0gMFxuICAgICwgcXVldWUgPSBbXVxuICAgICwgZnJhbWVEdXJhdGlvbiA9IDEwMDAgLyA2MFxuXG4gIHJhZiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYocXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICB2YXIgX25vdyA9IG5vdygpXG4gICAgICAgICwgbmV4dCA9IE1hdGgubWF4KDAsIGZyYW1lRHVyYXRpb24gLSAoX25vdyAtIGxhc3QpKVxuICAgICAgbGFzdCA9IG5leHQgKyBfbm93XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3AgPSBxdWV1ZS5zbGljZSgwKVxuICAgICAgICAvLyBDbGVhciBxdWV1ZSBoZXJlIHRvIHByZXZlbnRcbiAgICAgICAgLy8gY2FsbGJhY2tzIGZyb20gYXBwZW5kaW5nIGxpc3RlbmVyc1xuICAgICAgICAvLyB0byB0aGUgY3VycmVudCBmcmFtZSdzIHF1ZXVlXG4gICAgICAgIHF1ZXVlLmxlbmd0aCA9IDBcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYoIWNwW2ldLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICBjcFtpXS5jYWxsYmFjayhsYXN0KVxuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRocm93IGUgfSwgMClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIE1hdGgucm91bmQobmV4dCkpXG4gICAgfVxuICAgIHF1ZXVlLnB1c2goe1xuICAgICAgaGFuZGxlOiArK2lkLFxuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgY2FuY2VsbGVkOiBmYWxzZVxuICAgIH0pXG4gICAgcmV0dXJuIGlkXG4gIH1cblxuICBjYWYgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmKHF1ZXVlW2ldLmhhbmRsZSA9PT0gaGFuZGxlKSB7XG4gICAgICAgIHF1ZXVlW2ldLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbikge1xuICAvLyBXcmFwIGluIGEgbmV3IGZ1bmN0aW9uIHRvIHByZXZlbnRcbiAgLy8gYGNhbmNlbGAgcG90ZW50aWFsbHkgYmVpbmcgYXNzaWduZWRcbiAgLy8gdG8gdGhlIG5hdGl2ZSByQUYgZnVuY3Rpb25cbiAgcmV0dXJuIHJhZi5jYWxsKHJvb3QsIGZuKVxufVxubW9kdWxlLmV4cG9ydHMuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gIGNhZi5hcHBseShyb290LCBhcmd1bWVudHMpXG59XG5tb2R1bGUuZXhwb3J0cy5wb2x5ZmlsbCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAoIW9iamVjdCkge1xuICAgIG9iamVjdCA9IHJvb3Q7XG4gIH1cbiAgb2JqZWN0LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJhZlxuICBvYmplY3QuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBjYWZcbn1cbiIsInJlcXVpcmUoJy4vJykucG9seWZpbGwoKVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJE9iamVjdCA9IE9iamVjdDtcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZsYWdzKCkge1xuXHRpZiAodGhpcyAhPSBudWxsICYmIHRoaXMgIT09ICRPYmplY3QodGhpcykpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignUmVnRXhwLnByb3RvdHlwZS5mbGFncyBnZXR0ZXIgY2FsbGVkIG9uIG5vbi1vYmplY3QnKTtcblx0fVxuXHR2YXIgcmVzdWx0ID0gJyc7XG5cdGlmICh0aGlzLmdsb2JhbCkge1xuXHRcdHJlc3VsdCArPSAnZyc7XG5cdH1cblx0aWYgKHRoaXMuaWdub3JlQ2FzZSkge1xuXHRcdHJlc3VsdCArPSAnaSc7XG5cdH1cblx0aWYgKHRoaXMubXVsdGlsaW5lKSB7XG5cdFx0cmVzdWx0ICs9ICdtJztcblx0fVxuXHRpZiAodGhpcy5kb3RBbGwpIHtcblx0XHRyZXN1bHQgKz0gJ3MnO1xuXHR9XG5cdGlmICh0aGlzLnVuaWNvZGUpIHtcblx0XHRyZXN1bHQgKz0gJ3UnO1xuXHR9XG5cdGlmICh0aGlzLnN0aWNreSkge1xuXHRcdHJlc3VsdCArPSAneSc7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xudmFyIGNhbGxCaW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kJyk7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcbnZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcbnZhciBzaGltID0gcmVxdWlyZSgnLi9zaGltJyk7XG5cbnZhciBmbGFnc0JvdW5kID0gY2FsbEJpbmQoaW1wbGVtZW50YXRpb24pO1xuXG5kZWZpbmUoZmxhZ3NCb3VuZCwge1xuXHRnZXRQb2x5ZmlsbDogZ2V0UG9seWZpbGwsXG5cdGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvbixcblx0c2hpbTogc2hpbVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhZ3NCb3VuZDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG52YXIgc3VwcG9ydHNEZXNjcmlwdG9ycyA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJykuc3VwcG9ydHNEZXNjcmlwdG9ycztcbnZhciAkZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcblx0aWYgKCFzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1JlZ0V4cC5wcm90b3R5cGUuZmxhZ3MgcmVxdWlyZXMgYSB0cnVlIEVTNSBlbnZpcm9ubWVudCB0aGF0IHN1cHBvcnRzIHByb3BlcnR5IGRlc2NyaXB0b3JzJyk7XG5cdH1cblx0aWYgKCgvYS9taWcpLmZsYWdzID09PSAnZ2ltJykge1xuXHRcdHZhciBkZXNjcmlwdG9yID0gJGdPUEQoUmVnRXhwLnByb3RvdHlwZSwgJ2ZsYWdzJyk7XG5cdFx0aWYgKGRlc2NyaXB0b3IgJiYgdHlwZW9mIGRlc2NyaXB0b3IuZ2V0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiAoL2EvKS5kb3RBbGwgPT09ICdib29sZWFuJykge1xuXHRcdFx0cmV0dXJuIGRlc2NyaXB0b3IuZ2V0O1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gaW1wbGVtZW50YXRpb247XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3VwcG9ydHNEZXNjcmlwdG9ycyA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJykuc3VwcG9ydHNEZXNjcmlwdG9ycztcbnZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcbnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBUeXBlRXJyID0gVHlwZUVycm9yO1xudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIHJlZ2V4ID0gL2EvO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1GbGFncygpIHtcblx0aWYgKCFzdXBwb3J0c0Rlc2NyaXB0b3JzIHx8ICFnZXRQcm90bykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyKCdSZWdFeHAucHJvdG90eXBlLmZsYWdzIHJlcXVpcmVzIGEgdHJ1ZSBFUzUgZW52aXJvbm1lbnQgdGhhdCBzdXBwb3J0cyBwcm9wZXJ0eSBkZXNjcmlwdG9ycycpO1xuXHR9XG5cdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG5cdHZhciBwcm90byA9IGdldFByb3RvKHJlZ2V4KTtcblx0dmFyIGRlc2NyaXB0b3IgPSBnT1BEKHByb3RvLCAnZmxhZ3MnKTtcblx0aWYgKCFkZXNjcmlwdG9yIHx8IGRlc2NyaXB0b3IuZ2V0ICE9PSBwb2x5ZmlsbCkge1xuXHRcdGRlZmluZVByb3BlcnR5KHByb3RvLCAnZmxhZ3MnLCB7XG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdGdldDogcG9seWZpbGxcblx0XHR9KTtcblx0fVxuXHRyZXR1cm4gcG9seWZpbGw7XG59O1xuIiwiLyogZ2xvYmFscyByZXF1ZXN0SWRsZUNhbGxiYWNrLCBjYW5jZWxJZGxlQ2FsbGJhY2sgKi9cbnZhciBmYWxsYmFjayA9IGZ1bmN0aW9uIChjYikge1xuICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gRGF0ZS5ub3coKVxuICAgIGNiKHtcbiAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgNTAgLSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSlcbiAgICAgIH1cbiAgICB9KVxuICB9LCAxKVxufVxuXG52YXIgaXNTdXBwb3J0ZWQgPSAodHlwZW9mIHJlcXVlc3RJZGxlQ2FsbGJhY2sgIT09ICd1bmRlZmluZWQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3VwcG9ydGVkID8gcmVxdWVzdElkbGVDYWxsYmFjayA6IGZhbGxiYWNrXG5tb2R1bGUuZXhwb3J0cy5jYW5jZWxJZGxlQ2FsbGJhY2sgPSBpc1N1cHBvcnRlZCA/IGNhbmNlbElkbGVDYWxsYmFjayA6IGNsZWFyVGltZW91dFxuIiwiKGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIlxuXG4gIGlmICghc2VsZi5kb2N1bWVudCkgcmV0dXJuXG5cbiAgdmFyIGV2ZW50ID0gS2V5Ym9hcmRFdmVudC5wcm90b3R5cGVcbiAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGV2ZW50LCBcImtleVwiKVxuICBpZiAoIWRlc2MpIHJldHVyblxuXG4gIHZhciBrZXlzID0ge1xuICAgIFdpbjogXCJNZXRhXCIsXG4gICAgU2Nyb2xsOiBcIlNjcm9sbExvY2tcIixcbiAgICBTcGFjZWJhcjogXCIgXCIsXG5cbiAgICBEb3duOiBcIkFycm93RG93blwiLFxuICAgIExlZnQ6IFwiQXJyb3dMZWZ0XCIsXG4gICAgUmlnaHQ6IFwiQXJyb3dSaWdodFwiLFxuICAgIFVwOiBcIkFycm93VXBcIixcblxuICAgIERlbDogXCJEZWxldGVcIixcbiAgICBBcHBzOiBcIkNvbnRleHRNZW51XCIsXG4gICAgRXNjOiBcIkVzY2FwZVwiLFxuXG4gICAgTXVsdGlwbHk6IFwiKlwiLFxuICAgIEFkZDogXCIrXCIsXG4gICAgU3VidHJhY3Q6IFwiLVwiLFxuICAgIERlY2ltYWw6IFwiLlwiLFxuICAgIERpdmlkZTogXCIvXCIsXG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXZlbnQsIFwia2V5XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGtleSA9IGRlc2MuZ2V0LmNhbGwodGhpcylcblxuICAgICAgcmV0dXJuIGtleXMuaGFzT3duUHJvcGVydHkoa2V5KSA/IGtleXNba2V5XSA6IGtleVxuICAgIH0sXG4gIH0pXG59KSgpXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xudmFyIGluc3BlY3QgPSByZXF1aXJlKCdvYmplY3QtaW5zcGVjdCcpO1xuXG52YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYygnJVR5cGVFcnJvciUnKTtcbnZhciAkV2Vha01hcCA9IEdldEludHJpbnNpYygnJVdlYWtNYXAlJywgdHJ1ZSk7XG52YXIgJE1hcCA9IEdldEludHJpbnNpYygnJU1hcCUnLCB0cnVlKTtcblxudmFyICR3ZWFrTWFwR2V0ID0gY2FsbEJvdW5kKCdXZWFrTWFwLnByb3RvdHlwZS5nZXQnLCB0cnVlKTtcbnZhciAkd2Vha01hcFNldCA9IGNhbGxCb3VuZCgnV2Vha01hcC5wcm90b3R5cGUuc2V0JywgdHJ1ZSk7XG52YXIgJHdlYWtNYXBIYXMgPSBjYWxsQm91bmQoJ1dlYWtNYXAucHJvdG90eXBlLmhhcycsIHRydWUpO1xudmFyICRtYXBHZXQgPSBjYWxsQm91bmQoJ01hcC5wcm90b3R5cGUuZ2V0JywgdHJ1ZSk7XG52YXIgJG1hcFNldCA9IGNhbGxCb3VuZCgnTWFwLnByb3RvdHlwZS5zZXQnLCB0cnVlKTtcbnZhciAkbWFwSGFzID0gY2FsbEJvdW5kKCdNYXAucHJvdG90eXBlLmhhcycsIHRydWUpO1xuXG4vKlxuICogVGhpcyBmdW5jdGlvbiB0cmF2ZXJzZXMgdGhlIGxpc3QgcmV0dXJuaW5nIHRoZSBub2RlIGNvcnJlc3BvbmRpbmcgdG8gdGhlXG4gKiBnaXZlbiBrZXkuXG4gKlxuICogVGhhdCBub2RlIGlzIGFsc28gbW92ZWQgdG8gdGhlIGhlYWQgb2YgdGhlIGxpc3QsIHNvIHRoYXQgaWYgaXQncyBhY2Nlc3NlZFxuICogYWdhaW4gd2UgZG9uJ3QgbmVlZCB0byB0cmF2ZXJzZSB0aGUgd2hvbGUgbGlzdC4gQnkgZG9pbmcgc28sIGFsbCB0aGUgcmVjZW50bHlcbiAqIHVzZWQgbm9kZXMgY2FuIGJlIGFjY2Vzc2VkIHJlbGF0aXZlbHkgcXVpY2tseS5cbiAqL1xudmFyIGxpc3RHZXROb2RlID0gZnVuY3Rpb24gKGxpc3QsIGtleSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG5cdGZvciAodmFyIHByZXYgPSBsaXN0LCBjdXJyOyAoY3VyciA9IHByZXYubmV4dCkgIT09IG51bGw7IHByZXYgPSBjdXJyKSB7XG5cdFx0aWYgKGN1cnIua2V5ID09PSBrZXkpIHtcblx0XHRcdHByZXYubmV4dCA9IGN1cnIubmV4dDtcblx0XHRcdGN1cnIubmV4dCA9IGxpc3QubmV4dDtcblx0XHRcdGxpc3QubmV4dCA9IGN1cnI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cblx0XHRcdHJldHVybiBjdXJyO1xuXHRcdH1cblx0fVxufTtcblxudmFyIGxpc3RHZXQgPSBmdW5jdGlvbiAob2JqZWN0cywga2V5KSB7XG5cdHZhciBub2RlID0gbGlzdEdldE5vZGUob2JqZWN0cywga2V5KTtcblx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZTtcbn07XG52YXIgbGlzdFNldCA9IGZ1bmN0aW9uIChvYmplY3RzLCBrZXksIHZhbHVlKSB7XG5cdHZhciBub2RlID0gbGlzdEdldE5vZGUob2JqZWN0cywga2V5KTtcblx0aWYgKG5vZGUpIHtcblx0XHRub2RlLnZhbHVlID0gdmFsdWU7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gUHJlcGVuZCB0aGUgbmV3IG5vZGUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdFxuXHRcdG9iamVjdHMubmV4dCA9IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuXHRcdFx0a2V5OiBrZXksXG5cdFx0XHRuZXh0OiBvYmplY3RzLm5leHQsXG5cdFx0XHR2YWx1ZTogdmFsdWVcblx0XHR9O1xuXHR9XG59O1xudmFyIGxpc3RIYXMgPSBmdW5jdGlvbiAob2JqZWN0cywga2V5KSB7XG5cdHJldHVybiAhIWxpc3RHZXROb2RlKG9iamVjdHMsIGtleSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFNpZGVDaGFubmVsKCkge1xuXHR2YXIgJHdtO1xuXHR2YXIgJG07XG5cdHZhciAkbztcblx0dmFyIGNoYW5uZWwgPSB7XG5cdFx0YXNzZXJ0OiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRpZiAoIWNoYW5uZWwuaGFzKGtleSkpIHtcblx0XHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1NpZGUgY2hhbm5lbCBkb2VzIG5vdCBjb250YWluICcgKyBpbnNwZWN0KGtleSkpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Z2V0OiBmdW5jdGlvbiAoa2V5KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cblx0XHRcdGlmICgkV2Vha01hcCAmJiBrZXkgJiYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBrZXkgPT09ICdmdW5jdGlvbicpKSB7XG5cdFx0XHRcdGlmICgkd20pIHtcblx0XHRcdFx0XHRyZXR1cm4gJHdlYWtNYXBHZXQoJHdtLCBrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCRNYXApIHtcblx0XHRcdFx0aWYgKCRtKSB7XG5cdFx0XHRcdFx0cmV0dXJuICRtYXBHZXQoJG0sIGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICgkbykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWxvbmVseS1pZlxuXHRcdFx0XHRcdHJldHVybiBsaXN0R2V0KCRvLCBrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRoYXM6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdGlmICgkV2Vha01hcCAmJiBrZXkgJiYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBrZXkgPT09ICdmdW5jdGlvbicpKSB7XG5cdFx0XHRcdGlmICgkd20pIHtcblx0XHRcdFx0XHRyZXR1cm4gJHdlYWtNYXBIYXMoJHdtLCBrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCRNYXApIHtcblx0XHRcdFx0aWYgKCRtKSB7XG5cdFx0XHRcdFx0cmV0dXJuICRtYXBIYXMoJG0sIGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICgkbykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWxvbmVseS1pZlxuXHRcdFx0XHRcdHJldHVybiBsaXN0SGFzKCRvLCBrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdFx0XHRpZiAoJFdlYWtNYXAgJiYga2V5ICYmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyB8fCB0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSkge1xuXHRcdFx0XHRpZiAoISR3bSkge1xuXHRcdFx0XHRcdCR3bSA9IG5ldyAkV2Vha01hcCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCR3ZWFrTWFwU2V0KCR3bSwga2V5LCB2YWx1ZSk7XG5cdFx0XHR9IGVsc2UgaWYgKCRNYXApIHtcblx0XHRcdFx0aWYgKCEkbSkge1xuXHRcdFx0XHRcdCRtID0gbmV3ICRNYXAoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQkbWFwU2V0KCRtLCBrZXksIHZhbHVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICghJG8pIHtcblx0XHRcdFx0XHQvKlxuXHRcdFx0XHRcdCAqIEluaXRpYWxpemUgdGhlIGxpbmtlZCBsaXN0IGFzIGFuIGVtcHR5IG5vZGUsIHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZVxuXHRcdFx0XHRcdCAqIHRvIHNwZWNpYWwtY2FzZSBoYW5kbGluZyBvZiB0aGUgZmlyc3Qgbm9kZTogd2UgY2FuIGFsd2F5cyByZWZlciB0b1xuXHRcdFx0XHRcdCAqIGl0IGFzIChwcmV2aW91cyBub2RlKS5uZXh0LCBpbnN0ZWFkIG9mIHNvbWV0aGluZyBsaWtlIChsaXN0KS5oZWFkXG5cdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0JG8gPSB7IGtleToge30sIG5leHQ6IG51bGwgfTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0U2V0KCRvLCBrZXksIHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBjaGFubmVsO1xufTtcbiIsIi8qXG4gKiBzbW9vdGhzY3JvbGwgcG9seWZpbGwgLSB2MC4zLjVcbiAqIGh0dHBzOi8vaWFtZHVzdGFuLmdpdGh1Yi5pby9zbW9vdGhzY3JvbGxcbiAqIDIwMTYgKGMpIER1c3RhbiBLYXN0ZW4sIEplcmVtaWFzIE1lbmljaGVsbGkgLSBNSVQgTGljZW5zZVxuICovXG5cbihmdW5jdGlvbih3LCBkLCB1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qXG4gICAqIGFsaWFzZXNcbiAgICogdzogd2luZG93IGdsb2JhbCBvYmplY3RcbiAgICogZDogZG9jdW1lbnRcbiAgICogdW5kZWZpbmVkOiB1bmRlZmluZWRcbiAgICovXG5cbiAgLy8gcG9seWZpbGxcbiAgZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gICAgLy8gcmV0dXJuIHdoZW4gc2Nyb2xsQmVoYXZpb3IgaW50ZXJmYWNlIGlzIHN1cHBvcnRlZFxuICAgIGlmICgnc2Nyb2xsQmVoYXZpb3InIGluIGQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBnbG9iYWxzXG4gICAgICovXG4gICAgdmFyIEVsZW1lbnQgPSB3LkhUTUxFbGVtZW50IHx8IHcuRWxlbWVudDtcbiAgICB2YXIgU0NST0xMX1RJTUUgPSA0Njg7XG5cbiAgICAvKlxuICAgICAqIG9iamVjdCBnYXRoZXJpbmcgb3JpZ2luYWwgc2Nyb2xsIG1ldGhvZHNcbiAgICAgKi9cbiAgICB2YXIgb3JpZ2luYWwgPSB7XG4gICAgICBzY3JvbGw6IHcuc2Nyb2xsIHx8IHcuc2Nyb2xsVG8sXG4gICAgICBzY3JvbGxCeTogdy5zY3JvbGxCeSxcbiAgICAgIGVsU2Nyb2xsOiBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGwgfHwgc2Nyb2xsRWxlbWVudCxcbiAgICAgIHNjcm9sbEludG9WaWV3OiBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxJbnRvVmlld1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIGRlZmluZSB0aW1pbmcgbWV0aG9kXG4gICAgICovXG4gICAgdmFyIG5vdyA9IHcucGVyZm9ybWFuY2UgJiYgdy5wZXJmb3JtYW5jZS5ub3dcbiAgICAgID8gdy5wZXJmb3JtYW5jZS5ub3cuYmluZCh3LnBlcmZvcm1hbmNlKSA6IERhdGUubm93O1xuXG4gICAgLyoqXG4gICAgICogY2hhbmdlcyBzY3JvbGwgcG9zaXRpb24gaW5zaWRlIGFuIGVsZW1lbnRcbiAgICAgKiBAbWV0aG9kIHNjcm9sbEVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2Nyb2xsRWxlbWVudCh4LCB5KSB7XG4gICAgICB0aGlzLnNjcm9sbExlZnQgPSB4O1xuICAgICAgdGhpcy5zY3JvbGxUb3AgPSB5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgcmVzdWx0IG9mIGFwcGx5aW5nIGVhc2UgbWF0aCBmdW5jdGlvbiB0byBhIG51bWJlclxuICAgICAqIEBtZXRob2QgZWFzZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBrXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlYXNlKGspIHtcbiAgICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIGlmIGEgc21vb3RoIGJlaGF2aW9yIHNob3VsZCBiZSBhcHBsaWVkXG4gICAgICogQG1ldGhvZCBzaG91bGRCYWlsT3V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSB4XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hvdWxkQmFpbE91dCh4KSB7XG4gICAgICBpZiAodHlwZW9mIHggIT09ICdvYmplY3QnXG4gICAgICAgICAgICB8fCB4ID09PSBudWxsXG4gICAgICAgICAgICB8fCB4LmJlaGF2aW9yID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgIHx8IHguYmVoYXZpb3IgPT09ICdhdXRvJ1xuICAgICAgICAgICAgfHwgeC5iZWhhdmlvciA9PT0gJ2luc3RhbnQnKSB7XG4gICAgICAgIC8vIGZpcnN0IGFyZyBub3QgYW4gb2JqZWN0L251bGxcbiAgICAgICAgLy8gb3IgYmVoYXZpb3IgaXMgYXV0bywgaW5zdGFudCBvciB1bmRlZmluZWRcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICYmIHguYmVoYXZpb3IgPT09ICdzbW9vdGgnKSB7XG4gICAgICAgIC8vIGZpcnN0IGFyZ3VtZW50IGlzIGFuIG9iamVjdCBhbmQgYmVoYXZpb3IgaXMgc21vb3RoXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gdGhyb3cgZXJyb3Igd2hlbiBiZWhhdmlvciBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdiZWhhdmlvciBub3QgdmFsaWQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmaW5kcyBzY3JvbGxhYmxlIHBhcmVudCBvZiBhbiBlbGVtZW50XG4gICAgICogQG1ldGhvZCBmaW5kU2Nyb2xsYWJsZVBhcmVudFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICAgKiBAcmV0dXJucyB7Tm9kZX0gZWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kU2Nyb2xsYWJsZVBhcmVudChlbCkge1xuICAgICAgdmFyIGlzQm9keTtcbiAgICAgIHZhciBoYXNTY3JvbGxhYmxlU3BhY2U7XG4gICAgICB2YXIgaGFzVmlzaWJsZU92ZXJmbG93O1xuXG4gICAgICBkbyB7XG4gICAgICAgIGVsID0gZWwucGFyZW50Tm9kZTtcblxuICAgICAgICAvLyBzZXQgY29uZGl0aW9uIHZhcmlhYmxlc1xuICAgICAgICBpc0JvZHkgPSBlbCA9PT0gZC5ib2R5O1xuICAgICAgICBoYXNTY3JvbGxhYmxlU3BhY2UgPVxuICAgICAgICAgIGVsLmNsaWVudEhlaWdodCA8IGVsLnNjcm9sbEhlaWdodCB8fFxuICAgICAgICAgIGVsLmNsaWVudFdpZHRoIDwgZWwuc2Nyb2xsV2lkdGg7XG4gICAgICAgIGhhc1Zpc2libGVPdmVyZmxvdyA9XG4gICAgICAgICAgdy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKS5vdmVyZmxvdyA9PT0gJ3Zpc2libGUnO1xuICAgICAgfSB3aGlsZSAoIWlzQm9keSAmJiAhKGhhc1Njcm9sbGFibGVTcGFjZSAmJiAhaGFzVmlzaWJsZU92ZXJmbG93KSk7XG5cbiAgICAgIGlzQm9keSA9IGhhc1Njcm9sbGFibGVTcGFjZSA9IGhhc1Zpc2libGVPdmVyZmxvdyA9IG51bGw7XG5cbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZWxmIGludm9rZWQgZnVuY3Rpb24gdGhhdCwgZ2l2ZW4gYSBjb250ZXh0LCBzdGVwcyB0aHJvdWdoIHNjcm9sbGluZ1xuICAgICAqIEBtZXRob2Qgc3RlcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RlcChjb250ZXh0KSB7XG4gICAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgdmFyIGN1cnJlbnRYO1xuICAgICAgdmFyIGN1cnJlbnRZO1xuICAgICAgdmFyIGVsYXBzZWQgPSAodGltZSAtIGNvbnRleHQuc3RhcnRUaW1lKSAvIFNDUk9MTF9USU1FO1xuXG4gICAgICAvLyBhdm9pZCBlbGFwc2VkIHRpbWVzIGhpZ2hlciB0aGFuIG9uZVxuICAgICAgZWxhcHNlZCA9IGVsYXBzZWQgPiAxID8gMSA6IGVsYXBzZWQ7XG5cbiAgICAgIC8vIGFwcGx5IGVhc2luZyB0byBlbGFwc2VkIHRpbWVcbiAgICAgIHZhbHVlID0gZWFzZShlbGFwc2VkKTtcblxuICAgICAgY3VycmVudFggPSBjb250ZXh0LnN0YXJ0WCArIChjb250ZXh0LnggLSBjb250ZXh0LnN0YXJ0WCkgKiB2YWx1ZTtcbiAgICAgIGN1cnJlbnRZID0gY29udGV4dC5zdGFydFkgKyAoY29udGV4dC55IC0gY29udGV4dC5zdGFydFkpICogdmFsdWU7XG5cbiAgICAgIGNvbnRleHQubWV0aG9kLmNhbGwoY29udGV4dC5zY3JvbGxhYmxlLCBjdXJyZW50WCwgY3VycmVudFkpO1xuXG4gICAgICAvLyBzY3JvbGwgbW9yZSBpZiB3ZSBoYXZlIG5vdCByZWFjaGVkIG91ciBkZXN0aW5hdGlvblxuICAgICAgaWYgKGN1cnJlbnRYICE9PSBjb250ZXh0LnggfHwgY3VycmVudFkgIT09IGNvbnRleHQueSkge1xuICAgICAgICB3LnJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwLmJpbmQodywgY29udGV4dCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNjcm9sbHMgd2luZG93IHdpdGggYSBzbW9vdGggYmVoYXZpb3JcbiAgICAgKiBAbWV0aG9kIHNtb290aFNjcm9sbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE5vZGV9IGVsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNtb290aFNjcm9sbChlbCwgeCwgeSkge1xuICAgICAgdmFyIHNjcm9sbGFibGU7XG4gICAgICB2YXIgc3RhcnRYO1xuICAgICAgdmFyIHN0YXJ0WTtcbiAgICAgIHZhciBtZXRob2Q7XG4gICAgICB2YXIgc3RhcnRUaW1lID0gbm93KCk7XG5cbiAgICAgIC8vIGRlZmluZSBzY3JvbGwgY29udGV4dFxuICAgICAgaWYgKGVsID09PSBkLmJvZHkpIHtcbiAgICAgICAgc2Nyb2xsYWJsZSA9IHc7XG4gICAgICAgIHN0YXJ0WCA9IHcuc2Nyb2xsWCB8fCB3LnBhZ2VYT2Zmc2V0O1xuICAgICAgICBzdGFydFkgPSB3LnNjcm9sbFkgfHwgdy5wYWdlWU9mZnNldDtcbiAgICAgICAgbWV0aG9kID0gb3JpZ2luYWwuc2Nyb2xsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Nyb2xsYWJsZSA9IGVsO1xuICAgICAgICBzdGFydFggPSBlbC5zY3JvbGxMZWZ0O1xuICAgICAgICBzdGFydFkgPSBlbC5zY3JvbGxUb3A7XG4gICAgICAgIG1ldGhvZCA9IHNjcm9sbEVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIHNjcm9sbCBsb29waW5nIG92ZXIgYSBmcmFtZVxuICAgICAgc3RlcCh7XG4gICAgICAgIHNjcm9sbGFibGU6IHNjcm9sbGFibGUsXG4gICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSxcbiAgICAgICAgc3RhcnRYOiBzdGFydFgsXG4gICAgICAgIHN0YXJ0WTogc3RhcnRZLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIE9SSUdJTkFMIE1FVEhPRFMgT1ZFUlJJREVTXG4gICAgICovXG5cbiAgICAvLyB3LnNjcm9sbCBhbmQgdy5zY3JvbGxUb1xuICAgIHcuc2Nyb2xsID0gdy5zY3JvbGxUbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gYXZvaWQgc21vb3RoIGJlaGF2aW9yIGlmIG5vdCByZXF1aXJlZFxuICAgICAgaWYgKHNob3VsZEJhaWxPdXQoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICBvcmlnaW5hbC5zY3JvbGwuY2FsbChcbiAgICAgICAgICB3LFxuICAgICAgICAgIGFyZ3VtZW50c1swXS5sZWZ0IHx8IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICBhcmd1bWVudHNbMF0udG9wIHx8IGFyZ3VtZW50c1sxXVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIExFVCBUSEUgU01PT1RITkVTUyBCRUdJTiFcbiAgICAgIHNtb290aFNjcm9sbC5jYWxsKFxuICAgICAgICB3LFxuICAgICAgICBkLmJvZHksXG4gICAgICAgIH5+YXJndW1lbnRzWzBdLmxlZnQsXG4gICAgICAgIH5+YXJndW1lbnRzWzBdLnRvcFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgLy8gdy5zY3JvbGxCeVxuICAgIHcuc2Nyb2xsQnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgb3JpZ2luYWwuc2Nyb2xsQnkuY2FsbChcbiAgICAgICAgICB3LFxuICAgICAgICAgIGFyZ3VtZW50c1swXS5sZWZ0IHx8IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICBhcmd1bWVudHNbMF0udG9wIHx8IGFyZ3VtZW50c1sxXVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIExFVCBUSEUgU01PT1RITkVTUyBCRUdJTiFcbiAgICAgIHNtb290aFNjcm9sbC5jYWxsKFxuICAgICAgICB3LFxuICAgICAgICBkLmJvZHksXG4gICAgICAgIH5+YXJndW1lbnRzWzBdLmxlZnQgKyAody5zY3JvbGxYIHx8IHcucGFnZVhPZmZzZXQpLFxuICAgICAgICB+fmFyZ3VtZW50c1swXS50b3AgKyAody5zY3JvbGxZIHx8IHcucGFnZVlPZmZzZXQpXG4gICAgICApO1xuICAgIH07XG5cbiAgICAvLyBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGwgYW5kIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbFRvXG4gICAgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsID0gRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsVG8gPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgb3JpZ2luYWwuZWxTY3JvbGwuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCB8fCBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgICBhcmd1bWVudHNbMF0udG9wIHx8IGFyZ3VtZW50c1sxXVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBsZWZ0ID0gYXJndW1lbnRzWzBdLmxlZnQ7XG4gICAgICB2YXIgdG9wID0gYXJndW1lbnRzWzBdLnRvcDtcblxuICAgICAgLy8gTEVUIFRIRSBTTU9PVEhORVNTIEJFR0lOIVxuICAgICAgc21vb3RoU2Nyb2xsLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIHR5cGVvZiBsZWZ0ID09PSAnbnVtYmVyJyA/IGxlZnQgOiB0aGlzLnNjcm9sbExlZnQsXG4gICAgICAgICAgdHlwZW9mIHRvcCA9PT0gJ251bWJlcicgPyB0b3AgOiB0aGlzLnNjcm9sbFRvcFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgLy8gRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsQnlcbiAgICBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxCeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZzAgPSBhcmd1bWVudHNbMF07XG5cbiAgICAgIGlmICh0eXBlb2YgYXJnMCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhpcy5zY3JvbGwoe1xuICAgICAgICAgIGxlZnQ6IGFyZzAubGVmdCArIHRoaXMuc2Nyb2xsTGVmdCxcbiAgICAgICAgICB0b3A6IGFyZzAudG9wICsgdGhpcy5zY3JvbGxUb3AsXG4gICAgICAgICAgYmVoYXZpb3I6IGFyZzAuYmVoYXZpb3JcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNjcm9sbChcbiAgICAgICAgICB0aGlzLnNjcm9sbExlZnQgKyBhcmcwLFxuICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wICsgYXJndW1lbnRzWzFdXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEludG9WaWV3XG4gICAgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXcgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgb3JpZ2luYWwuc2Nyb2xsSW50b1ZpZXcuY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1swXVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIExFVCBUSEUgU01PT1RITkVTUyBCRUdJTiFcbiAgICAgIHZhciBzY3JvbGxhYmxlUGFyZW50ID0gZmluZFNjcm9sbGFibGVQYXJlbnQodGhpcyk7XG4gICAgICB2YXIgcGFyZW50UmVjdHMgPSBzY3JvbGxhYmxlUGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIGNsaWVudFJlY3RzID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgaWYgKHNjcm9sbGFibGVQYXJlbnQgIT09IGQuYm9keSkge1xuICAgICAgICAvLyByZXZlYWwgZWxlbWVudCBpbnNpZGUgcGFyZW50XG4gICAgICAgIHNtb290aFNjcm9sbC5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgc2Nyb2xsYWJsZVBhcmVudCxcbiAgICAgICAgICBzY3JvbGxhYmxlUGFyZW50LnNjcm9sbExlZnQgKyBjbGllbnRSZWN0cy5sZWZ0IC0gcGFyZW50UmVjdHMubGVmdCxcbiAgICAgICAgICBzY3JvbGxhYmxlUGFyZW50LnNjcm9sbFRvcCArIGNsaWVudFJlY3RzLnRvcCAtIHBhcmVudFJlY3RzLnRvcFxuICAgICAgICApO1xuICAgICAgICAvLyByZXZlYWwgcGFyZW50IGluIHZpZXdwb3J0XG4gICAgICAgIHcuc2Nyb2xsQnkoe1xuICAgICAgICAgIGxlZnQ6IHBhcmVudFJlY3RzLmxlZnQsXG4gICAgICAgICAgdG9wOiBwYXJlbnRSZWN0cy50b3AsXG4gICAgICAgICAgYmVoYXZpb3I6ICdzbW9vdGgnXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmV2ZWFsIGVsZW1lbnQgaW4gdmlld3BvcnRcbiAgICAgICAgdy5zY3JvbGxCeSh7XG4gICAgICAgICAgbGVmdDogY2xpZW50UmVjdHMubGVmdCxcbiAgICAgICAgICB0b3A6IGNsaWVudFJlY3RzLnRvcCxcbiAgICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBjb21tb25qc1xuICAgIG1vZHVsZS5leHBvcnRzID0geyBwb2x5ZmlsbDogcG9seWZpbGwgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBnbG9iYWxcbiAgICBwb2x5ZmlsbCgpO1xuICB9XG59KSh3aW5kb3csIGRvY3VtZW50KTtcbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi9zaGltJykoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENhbGwgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL0NhbGwnKTtcbnZhciBHZXQgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL0dldCcpO1xudmFyIEdldE1ldGhvZCA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMjEvR2V0TWV0aG9kJyk7XG52YXIgSXNSZWdFeHAgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL0lzUmVnRXhwJyk7XG52YXIgVG9TdHJpbmcgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL1RvU3RyaW5nJyk7XG52YXIgUmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMjEvUmVxdWlyZU9iamVjdENvZXJjaWJsZScpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMnKSgpO1xudmFyIGZsYWdzR2V0dGVyID0gcmVxdWlyZSgncmVnZXhwLnByb3RvdHlwZS5mbGFncycpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuaW5kZXhPZicpO1xuXG52YXIgcmVnZXhwTWF0Y2hBbGxQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwtcmVnZXhwLW1hdGNoYWxsJyk7XG5cbnZhciBnZXRNYXRjaGVyID0gZnVuY3Rpb24gZ2V0TWF0Y2hlcihyZWdleHApIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuXHR2YXIgbWF0Y2hlclBvbHlmaWxsID0gcmVnZXhwTWF0Y2hBbGxQb2x5ZmlsbCgpO1xuXHRpZiAoaGFzU3ltYm9scyAmJiB0eXBlb2YgU3ltYm9sLm1hdGNoQWxsID09PSAnc3ltYm9sJykge1xuXHRcdHZhciBtYXRjaGVyID0gR2V0TWV0aG9kKHJlZ2V4cCwgU3ltYm9sLm1hdGNoQWxsKTtcblx0XHRpZiAobWF0Y2hlciA9PT0gUmVnRXhwLnByb3RvdHlwZVtTeW1ib2wubWF0Y2hBbGxdICYmIG1hdGNoZXIgIT09IG1hdGNoZXJQb2x5ZmlsbCkge1xuXHRcdFx0cmV0dXJuIG1hdGNoZXJQb2x5ZmlsbDtcblx0XHR9XG5cdFx0cmV0dXJuIG1hdGNoZXI7XG5cdH1cblx0Ly8gZmFsbGJhY2sgZm9yIHByZS1TeW1ib2wubWF0Y2hBbGwgZW52aXJvbm1lbnRzXG5cdGlmIChJc1JlZ0V4cChyZWdleHApKSB7XG5cdFx0cmV0dXJuIG1hdGNoZXJQb2x5ZmlsbDtcblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYXRjaEFsbChyZWdleHApIHtcblx0dmFyIE8gPSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpO1xuXG5cdGlmICh0eXBlb2YgcmVnZXhwICE9PSAndW5kZWZpbmVkJyAmJiByZWdleHAgIT09IG51bGwpIHtcblx0XHR2YXIgaXNSZWdFeHAgPSBJc1JlZ0V4cChyZWdleHApO1xuXHRcdGlmIChpc1JlZ0V4cCkge1xuXHRcdFx0Ly8gd29ya2Fyb3VuZCBmb3Igb2xkZXIgZW5naW5lcyB0aGF0IGxhY2sgUmVnRXhwLnByb3RvdHlwZS5mbGFnc1xuXHRcdFx0dmFyIGZsYWdzID0gJ2ZsYWdzJyBpbiByZWdleHAgPyBHZXQocmVnZXhwLCAnZmxhZ3MnKSA6IGZsYWdzR2V0dGVyKHJlZ2V4cCk7XG5cdFx0XHRSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGZsYWdzKTtcblx0XHRcdGlmICgkaW5kZXhPZihUb1N0cmluZyhmbGFncyksICdnJykgPCAwKSB7XG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ21hdGNoQWxsIHJlcXVpcmVzIGEgZ2xvYmFsIHJlZ3VsYXIgZXhwcmVzc2lvbicpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBtYXRjaGVyID0gZ2V0TWF0Y2hlcihyZWdleHApO1xuXHRcdGlmICh0eXBlb2YgbWF0Y2hlciAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiBDYWxsKG1hdGNoZXIsIHJlZ2V4cCwgW09dKTtcblx0XHR9XG5cdH1cblxuXHR2YXIgUyA9IFRvU3RyaW5nKE8pO1xuXHQvLyB2YXIgcnggPSBSZWdFeHBDcmVhdGUocmVnZXhwLCAnZycpO1xuXHR2YXIgcnggPSBuZXcgUmVnRXhwKHJlZ2V4cCwgJ2cnKTtcblx0cmV0dXJuIENhbGwoZ2V0TWF0Y2hlcihyeCksIHJ4LCBbU10pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scycpKCk7XG52YXIgcmVnZXhwTWF0Y2hBbGwgPSByZXF1aXJlKCcuL3JlZ2V4cC1tYXRjaGFsbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFJlZ0V4cE1hdGNoQWxsUG9seWZpbGwoKSB7XG5cdGlmICghaGFzU3ltYm9scyB8fCB0eXBlb2YgU3ltYm9sLm1hdGNoQWxsICE9PSAnc3ltYm9sJyB8fCB0eXBlb2YgUmVnRXhwLnByb3RvdHlwZVtTeW1ib2wubWF0Y2hBbGxdICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIHJlZ2V4cE1hdGNoQWxsO1xuXHR9XG5cdHJldHVybiBSZWdFeHAucHJvdG90eXBlW1N5bWJvbC5tYXRjaEFsbF07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XG5cdGlmIChTdHJpbmcucHJvdG90eXBlLm1hdGNoQWxsKSB7XG5cdFx0dHJ5IHtcblx0XHRcdCcnLm1hdGNoQWxsKFJlZ0V4cC5wcm90b3R5cGUpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBTdHJpbmcucHJvdG90eXBlLm1hdGNoQWxsO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gaW1wbGVtZW50YXRpb247XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyB2YXIgQ29uc3RydWN0ID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvMjAyMS9Db25zdHJ1Y3QnKTtcbnZhciBDcmVhdGVSZWdFeHBTdHJpbmdJdGVyYXRvciA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMjEvQ3JlYXRlUmVnRXhwU3RyaW5nSXRlcmF0b3InKTtcbnZhciBHZXQgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL0dldCcpO1xudmFyIFNldCA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMjEvU2V0Jyk7XG52YXIgU3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvMjAyMS9TcGVjaWVzQ29uc3RydWN0b3InKTtcbnZhciBUb0xlbmd0aCA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMjEvVG9MZW5ndGgnKTtcbnZhciBUb1N0cmluZyA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMjEvVG9TdHJpbmcnKTtcbnZhciBUeXBlID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvMjAyMS9UeXBlJyk7XG52YXIgZmxhZ3NHZXR0ZXIgPSByZXF1aXJlKCdyZWdleHAucHJvdG90eXBlLmZsYWdzJyk7XG5cbnZhciBPcmlnUmVnRXhwID0gUmVnRXhwO1xuXG52YXIgc3VwcG9ydHNDb25zdHJ1Y3RpbmdXaXRoRmxhZ3MgPSAnZmxhZ3MnIGluIFJlZ0V4cC5wcm90b3R5cGU7XG5cbnZhciBjb25zdHJ1Y3RSZWdleFdpdGhGbGFncyA9IGZ1bmN0aW9uIGNvbnN0cnVjdFJlZ2V4KEMsIFIpIHtcblx0dmFyIG1hdGNoZXI7XG5cdC8vIHdvcmthcm91bmQgZm9yIG9sZGVyIGVuZ2luZXMgdGhhdCBsYWNrIFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3Ncblx0dmFyIGZsYWdzID0gJ2ZsYWdzJyBpbiBSID8gR2V0KFIsICdmbGFncycpIDogVG9TdHJpbmcoZmxhZ3NHZXR0ZXIoUikpO1xuXHRpZiAoc3VwcG9ydHNDb25zdHJ1Y3RpbmdXaXRoRmxhZ3MgJiYgdHlwZW9mIGZsYWdzID09PSAnc3RyaW5nJykge1xuXHRcdG1hdGNoZXIgPSBuZXcgQyhSLCBmbGFncyk7XG5cdH0gZWxzZSBpZiAoQyA9PT0gT3JpZ1JlZ0V4cCkge1xuXHRcdC8vIHdvcmthcm91bmQgZm9yIG9sZGVyIGVuZ2luZXMgdGhhdCBjYW4gbm90IGNvbnN0cnVjdCBhIFJlZ0V4cCB3aXRoIGZsYWdzXG5cdFx0bWF0Y2hlciA9IG5ldyBDKFIuc291cmNlLCBmbGFncyk7XG5cdH0gZWxzZSB7XG5cdFx0bWF0Y2hlciA9IG5ldyBDKFIsIGZsYWdzKTtcblx0fVxuXHRyZXR1cm4geyBmbGFnczogZmxhZ3MsIG1hdGNoZXI6IG1hdGNoZXIgfTtcbn07XG5cbnZhciByZWdleE1hdGNoQWxsID0gZnVuY3Rpb24gU3ltYm9sTWF0Y2hBbGwoc3RyaW5nKSB7XG5cdHZhciBSID0gdGhpcztcblx0aWYgKFR5cGUoUikgIT09ICdPYmplY3QnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignXCJ0aGlzXCIgdmFsdWUgbXVzdCBiZSBhbiBPYmplY3QnKTtcblx0fVxuXHR2YXIgUyA9IFRvU3RyaW5nKHN0cmluZyk7XG5cdHZhciBDID0gU3BlY2llc0NvbnN0cnVjdG9yKFIsIE9yaWdSZWdFeHApO1xuXG5cdHZhciB0bXAgPSBjb25zdHJ1Y3RSZWdleFdpdGhGbGFncyhDLCBSKTtcblx0Ly8gdmFyIGZsYWdzID0gVG9TdHJpbmcoR2V0KFIsICdmbGFncycpKTtcblx0dmFyIGZsYWdzID0gdG1wLmZsYWdzO1xuXHQvLyB2YXIgbWF0Y2hlciA9IENvbnN0cnVjdChDLCBbUiwgZmxhZ3NdKTtcblx0dmFyIG1hdGNoZXIgPSB0bXAubWF0Y2hlcjtcblxuXHR2YXIgbGFzdEluZGV4ID0gVG9MZW5ndGgoR2V0KFIsICdsYXN0SW5kZXgnKSk7XG5cdFNldChtYXRjaGVyLCAnbGFzdEluZGV4JywgbGFzdEluZGV4LCB0cnVlKTtcblx0dmFyIGdsb2JhbCA9IGZsYWdzLmluZGV4T2YoJ2cnKSA+IC0xO1xuXHR2YXIgZnVsbFVuaWNvZGUgPSBmbGFncy5pbmRleE9mKCd1JykgPiAtMTtcblx0cmV0dXJuIENyZWF0ZVJlZ0V4cFN0cmluZ0l0ZXJhdG9yKG1hdGNoZXIsIFMsIGdsb2JhbCwgZnVsbFVuaWNvZGUpO1xufTtcblxudmFyIGRlZmluZVAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmlmIChkZWZpbmVQICYmIGdPUEQpIHtcblx0dmFyIGRlc2MgPSBnT1BEKHJlZ2V4TWF0Y2hBbGwsICduYW1lJyk7XG5cdGlmIChkZXNjICYmIGRlc2MuY29uZmlndXJhYmxlKSB7XG5cdFx0ZGVmaW5lUChyZWdleE1hdGNoQWxsLCAnbmFtZScsIHsgdmFsdWU6ICdbU3ltYm9sLm1hdGNoQWxsXScgfSk7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWdleE1hdGNoQWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMnKSgpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xudmFyIHJlZ2V4cE1hdGNoQWxsUG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsLXJlZ2V4cC1tYXRjaGFsbCcpO1xuXG52YXIgZGVmaW5lUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGltTWF0Y2hBbGwoKSB7XG5cdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG5cdGRlZmluZShcblx0XHRTdHJpbmcucHJvdG90eXBlLFxuXHRcdHsgbWF0Y2hBbGw6IHBvbHlmaWxsIH0sXG5cdFx0eyBtYXRjaEFsbDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU3RyaW5nLnByb3RvdHlwZS5tYXRjaEFsbCAhPT0gcG9seWZpbGw7IH0gfVxuXHQpO1xuXHRpZiAoaGFzU3ltYm9scykge1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcblx0XHR2YXIgc3ltYm9sID0gU3ltYm9sLm1hdGNoQWxsIHx8IChTeW1ib2xbJ2ZvciddID8gU3ltYm9sWydmb3InXSgnU3ltYm9sLm1hdGNoQWxsJykgOiBTeW1ib2woJ1N5bWJvbC5tYXRjaEFsbCcpKTtcblx0XHRkZWZpbmUoXG5cdFx0XHRTeW1ib2wsXG5cdFx0XHR7IG1hdGNoQWxsOiBzeW1ib2wgfSxcblx0XHRcdHsgbWF0Y2hBbGw6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN5bWJvbC5tYXRjaEFsbCAhPT0gc3ltYm9sOyB9IH1cblx0XHQpO1xuXG5cdFx0aWYgKGRlZmluZVAgJiYgZ09QRCkge1xuXHRcdFx0dmFyIGRlc2MgPSBnT1BEKFN5bWJvbCwgc3ltYm9sKTtcblx0XHRcdGlmICghZGVzYyB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0XHRkZWZpbmVQKFN5bWJvbCwgc3ltYm9sLCB7XG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdFx0XHR2YWx1ZTogc3ltYm9sLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiBmYWxzZVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgcmVnZXhwTWF0Y2hBbGwgPSByZWdleHBNYXRjaEFsbFBvbHlmaWxsKCk7XG5cdFx0dmFyIGZ1bmMgPSB7fTtcblx0XHRmdW5jW3N5bWJvbF0gPSByZWdleHBNYXRjaEFsbDtcblx0XHR2YXIgcHJlZGljYXRlID0ge307XG5cdFx0cHJlZGljYXRlW3N5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gUmVnRXhwLnByb3RvdHlwZVtzeW1ib2xdICE9PSByZWdleHBNYXRjaEFsbDtcblx0XHR9O1xuXHRcdGRlZmluZShSZWdFeHAucHJvdG90eXBlLCBmdW5jLCBwcmVkaWNhdGUpO1xuXHR9XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUb0xlbmd0aCA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMjEvVG9MZW5ndGgnKTtcbnZhciBUb1N0cmluZyA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMjEvVG9TdHJpbmcnKTtcbnZhciBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvMjAyMS9SZXF1aXJlT2JqZWN0Q29lcmNpYmxlJyk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xuXG52YXIgJHNsaWNlID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLnNsaWNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFkRW5kKG1heExlbmd0aCkge1xuXHR2YXIgTyA9IFJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcyk7XG5cdHZhciBTID0gVG9TdHJpbmcoTyk7XG5cdHZhciBzdHJpbmdMZW5ndGggPSBUb0xlbmd0aChTLmxlbmd0aCk7XG5cdHZhciBmaWxsU3RyaW5nO1xuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRmaWxsU3RyaW5nID0gYXJndW1lbnRzWzFdO1xuXHR9XG5cdHZhciBmaWxsZXIgPSB0eXBlb2YgZmlsbFN0cmluZyA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6IFRvU3RyaW5nKGZpbGxTdHJpbmcpO1xuXHRpZiAoZmlsbGVyID09PSAnJykge1xuXHRcdGZpbGxlciA9ICcgJztcblx0fVxuXHR2YXIgaW50TWF4TGVuZ3RoID0gVG9MZW5ndGgobWF4TGVuZ3RoKTtcblx0aWYgKGludE1heExlbmd0aCA8PSBzdHJpbmdMZW5ndGgpIHtcblx0XHRyZXR1cm4gUztcblx0fVxuXHR2YXIgZmlsbExlbiA9IGludE1heExlbmd0aCAtIHN0cmluZ0xlbmd0aDtcblx0d2hpbGUgKGZpbGxlci5sZW5ndGggPCBmaWxsTGVuKSB7XG5cdFx0dmFyIGZMZW4gPSBmaWxsZXIubGVuZ3RoO1xuXHRcdHZhciByZW1haW5pbmdDb2RlVW5pdHMgPSBmaWxsTGVuIC0gZkxlbjtcblx0XHRmaWxsZXIgKz0gZkxlbiA+IHJlbWFpbmluZ0NvZGVVbml0cyA/ICRzbGljZShmaWxsZXIsIDAsIHJlbWFpbmluZ0NvZGVVbml0cykgOiBmaWxsZXI7XG5cdH1cblxuXHR2YXIgdHJ1bmNhdGVkU3RyaW5nRmlsbGVyID0gZmlsbGVyLmxlbmd0aCA+IGZpbGxMZW4gPyAkc2xpY2UoZmlsbGVyLCAwLCBmaWxsTGVuKSA6IGZpbGxlcjtcblx0cmV0dXJuIFMgKyB0cnVuY2F0ZWRTdHJpbmdGaWxsZXI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XG5cdHJldHVybiB0eXBlb2YgU3RyaW5nLnByb3RvdHlwZS5wYWRFbmQgPT09ICdmdW5jdGlvbicgPyBTdHJpbmcucHJvdG90eXBlLnBhZEVuZCA6IGltcGxlbWVudGF0aW9uO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbVBhZEVuZCgpIHtcblx0dmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcblx0ZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIHsgcGFkRW5kOiBwb2x5ZmlsbCB9LCB7XG5cdFx0cGFkRW5kOiBmdW5jdGlvbiB0ZXN0UGFkRW5kKCkge1xuXHRcdFx0cmV0dXJuIFN0cmluZy5wcm90b3R5cGUucGFkRW5kICE9PSBwb2x5ZmlsbDtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gcG9seWZpbGw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVG9MZW5ndGggPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL1RvTGVuZ3RoJyk7XG52YXIgVG9TdHJpbmcgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL1RvU3RyaW5nJyk7XG52YXIgUmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMjEvUmVxdWlyZU9iamVjdENvZXJjaWJsZScpO1xuXG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xudmFyICRzbGljZSA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5zbGljZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhZFN0YXJ0KG1heExlbmd0aCkge1xuXHR2YXIgTyA9IFJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcyk7XG5cdHZhciBTID0gVG9TdHJpbmcoTyk7XG5cdHZhciBzdHJpbmdMZW5ndGggPSBUb0xlbmd0aChTLmxlbmd0aCk7XG5cdHZhciBmaWxsU3RyaW5nO1xuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRmaWxsU3RyaW5nID0gYXJndW1lbnRzWzFdO1xuXHR9XG5cdHZhciBmaWxsZXIgPSB0eXBlb2YgZmlsbFN0cmluZyA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6IFRvU3RyaW5nKGZpbGxTdHJpbmcpO1xuXHRpZiAoZmlsbGVyID09PSAnJykge1xuXHRcdGZpbGxlciA9ICcgJztcblx0fVxuXHR2YXIgaW50TWF4TGVuZ3RoID0gVG9MZW5ndGgobWF4TGVuZ3RoKTtcblx0aWYgKGludE1heExlbmd0aCA8PSBzdHJpbmdMZW5ndGgpIHtcblx0XHRyZXR1cm4gUztcblx0fVxuXHR2YXIgZmlsbExlbiA9IGludE1heExlbmd0aCAtIHN0cmluZ0xlbmd0aDtcblx0d2hpbGUgKGZpbGxlci5sZW5ndGggPCBmaWxsTGVuKSB7XG5cdFx0dmFyIGZMZW4gPSBmaWxsZXIubGVuZ3RoO1xuXHRcdHZhciByZW1haW5pbmdDb2RlVW5pdHMgPSBmaWxsTGVuIC0gZkxlbjtcblx0XHRmaWxsZXIgKz0gZkxlbiA+IHJlbWFpbmluZ0NvZGVVbml0cyA/ICRzbGljZShmaWxsZXIsIDAsIHJlbWFpbmluZ0NvZGVVbml0cykgOiBmaWxsZXI7XG5cdH1cblxuXHR2YXIgdHJ1bmNhdGVkU3RyaW5nRmlsbGVyID0gZmlsbGVyLmxlbmd0aCA+IGZpbGxMZW4gPyAkc2xpY2UoZmlsbGVyLCAwLCBmaWxsTGVuKSA6IGZpbGxlcjtcblx0cmV0dXJuIHRydW5jYXRlZFN0cmluZ0ZpbGxlciArIFM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XG5cdHJldHVybiB0eXBlb2YgU3RyaW5nLnByb3RvdHlwZS5wYWRTdGFydCA9PT0gJ2Z1bmN0aW9uJyA/IFN0cmluZy5wcm90b3R5cGUucGFkU3RhcnQgOiBpbXBsZW1lbnRhdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1QYWRTdGFydCgpIHtcblx0dmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcblx0ZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIHsgcGFkU3RhcnQ6IHBvbHlmaWxsIH0sIHtcblx0XHRwYWRTdGFydDogZnVuY3Rpb24gdGVzdFBhZFN0YXJ0KCkge1xuXHRcdFx0cmV0dXJuIFN0cmluZy5wcm90b3R5cGUucGFkU3RhcnQgIT09IHBvbHlmaWxsO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG4iLCJcbiAgICAgIGltcG9ydCBBUEkgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgIGltcG9ydCBkb21BUEkgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydEZuIGZyb20gXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qc1wiO1xuICAgICAgaW1wb3J0IHNldEF0dHJpYnV0ZXMgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRTdHlsZUVsZW1lbnQgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanNcIjtcbiAgICAgIGltcG9ydCBzdHlsZVRhZ1RyYW5zZm9ybUZuIGZyb20gXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanNcIjtcbiAgICAgIGltcG9ydCBjb250ZW50LCAqIGFzIG5hbWVkRXhwb3J0IGZyb20gXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3R5bGVzLmNzc1wiO1xuICAgICAgXG4gICAgICBcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybSA9IHN0eWxlVGFnVHJhbnNmb3JtRm47XG5vcHRpb25zLnNldEF0dHJpYnV0ZXMgPSBzZXRBdHRyaWJ1dGVzO1xuXG4gICAgICBvcHRpb25zLmluc2VydCA9IGluc2VydEZuLmJpbmQobnVsbCwgXCJoZWFkXCIpO1xuICAgIFxub3B0aW9ucy5kb21BUEkgPSBkb21BUEk7XG5vcHRpb25zLmluc2VydFN0eWxlRWxlbWVudCA9IGluc2VydFN0eWxlRWxlbWVudDtcblxudmFyIHVwZGF0ZSA9IEFQSShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCAqIGZyb20gXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3R5bGVzLmNzc1wiO1xuICAgICAgIGV4cG9ydCBkZWZhdWx0IGNvbnRlbnQgJiYgY29udGVudC5sb2NhbHMgPyBjb250ZW50LmxvY2FscyA6IHVuZGVmaW5lZDtcbiIsIlxuICAgICAgaW1wb3J0IEFQSSBmcm9tIFwiIS4uLy4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICBpbXBvcnQgZG9tQVBJIGZyb20gXCIhLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydEZuIGZyb20gXCIhLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzXCI7XG4gICAgICBpbXBvcnQgc2V0QXR0cmlidXRlcyBmcm9tIFwiIS4uLy4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0U3R5bGVFbGVtZW50IGZyb20gXCIhLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanNcIjtcbiAgICAgIGltcG9ydCBzdHlsZVRhZ1RyYW5zZm9ybUZuIGZyb20gXCIhLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qc1wiO1xuICAgICAgaW1wb3J0IGNvbnRlbnQsICogYXMgbmFtZWRFeHBvcnQgZnJvbSBcIiEhLi4vLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3Jlc2V0LmNzc1wiO1xuICAgICAgXG4gICAgICBcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybSA9IHN0eWxlVGFnVHJhbnNmb3JtRm47XG5vcHRpb25zLnNldEF0dHJpYnV0ZXMgPSBzZXRBdHRyaWJ1dGVzO1xuXG4gICAgICBvcHRpb25zLmluc2VydCA9IGluc2VydEZuLmJpbmQobnVsbCwgXCJoZWFkXCIpO1xuICAgIFxub3B0aW9ucy5kb21BUEkgPSBkb21BUEk7XG5vcHRpb25zLmluc2VydFN0eWxlRWxlbWVudCA9IGluc2VydFN0eWxlRWxlbWVudDtcblxudmFyIHVwZGF0ZSA9IEFQSShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCAqIGZyb20gXCIhIS4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9yZXNldC5jc3NcIjtcbiAgICAgICBleHBvcnQgZGVmYXVsdCBjb250ZW50ICYmIGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB1bmRlZmluZWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHN0eWxlc0luRE9NID0gW107XG5cbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5ET00ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5ET01baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleEJ5SWRlbnRpZmllciA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXSxcbiAgICAgIHN1cHBvcnRzOiBpdGVtWzRdLFxuICAgICAgbGF5ZXI6IGl0ZW1bNV1cbiAgICB9O1xuXG4gICAgaWYgKGluZGV4QnlJZGVudGlmaWVyICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB1cGRhdGVyID0gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLmJ5SW5kZXggPSBpO1xuICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKGksIDAsIHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogdXBkYXRlcixcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuXG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cblxuZnVuY3Rpb24gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgYXBpID0gb3B0aW9ucy5kb21BUEkob3B0aW9ucyk7XG4gIGFwaS51cGRhdGUob2JqKTtcblxuICB2YXIgdXBkYXRlciA9IGZ1bmN0aW9uIHVwZGF0ZXIobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCAmJiBuZXdPYmouc3VwcG9ydHMgPT09IG9iai5zdXBwb3J0cyAmJiBuZXdPYmoubGF5ZXIgPT09IG9iai5sYXllcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGFwaS51cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbW92ZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdXBkYXRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cblxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcblxuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcblxuICAgICAgaWYgKHN0eWxlc0luRE9NW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRPTVtfaW5kZXhdLnVwZGF0ZXIoKTtcblxuICAgICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgbWVtbyA9IHt9O1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cbmZ1bmN0aW9uIGdldFRhcmdldCh0YXJnZXQpIHtcbiAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gIH1cblxuICByZXR1cm4gbWVtb1t0YXJnZXRdO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxuZnVuY3Rpb24gaW5zZXJ0QnlTZWxlY3RvcihpbnNlcnQsIHN0eWxlKSB7XG4gIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQoaW5zZXJ0KTtcblxuICBpZiAoIXRhcmdldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gIH1cblxuICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydEJ5U2VsZWN0b3I7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIG9wdGlvbnMuc2V0QXR0cmlidXRlcyhlbGVtZW50LCBvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICBvcHRpb25zLmluc2VydChlbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xuICByZXR1cm4gZWxlbWVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzKHN0eWxlRWxlbWVudCkge1xuICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG5cbiAgaWYgKG5vbmNlKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlczsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gXCJcIjtcblxuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQob2JqLnN1cHBvcnRzLCBcIikge1wiKTtcbiAgfVxuXG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKTtcbiAgfVxuXG4gIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2Ygb2JqLmxheWVyICE9PSBcInVuZGVmaW5lZFwiO1xuXG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJAbGF5ZXJcIi5jb25jYXQob2JqLmxheWVyLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQob2JqLmxheWVyKSA6IFwiXCIsIFwiIHtcIik7XG4gIH1cblxuICBjc3MgKz0gb2JqLmNzcztcblxuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG5cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuXG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cblxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIG9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZUVsZW1lbnQucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG5mdW5jdGlvbiBkb21BUEkob3B0aW9ucykge1xuICB2YXIgc3R5bGVFbGVtZW50ID0gb3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUob2JqKSB7XG4gICAgICBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaik7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkb21BUEk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQpIHtcbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVUYWdUcmFuc2Zvcm07IiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL3NoaW0nKSgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0U3ltYm9sRGVzY3JpcHRpb24gPSByZXF1aXJlKCdnZXQtc3ltYm9sLWRlc2NyaXB0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVzY3JpcHRpb24oKSB7XG5cdHJldHVybiBnZXRTeW1ib2xEZXNjcmlwdGlvbih0aGlzKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMnKSgpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVzY3JpcHRpb25Qb2x5ZmlsbCgpIHtcblx0aWYgKCFoYXNTeW1ib2xzIHx8IHR5cGVvZiBnT1BEICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHR2YXIgZGVzYyA9IGdPUEQoU3ltYm9sLnByb3RvdHlwZSwgJ2Rlc2NyaXB0aW9uJyk7XG5cdGlmICghZGVzYyB8fCB0eXBlb2YgZGVzYy5nZXQgIT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gaW1wbGVtZW50YXRpb247XG5cdH1cblxuXHR2YXIgZW1wdHlTeW1ib2xEZXNjID0gZGVzYy5nZXQuY2FsbChTeW1ib2woKSk7XG5cdHZhciBlbXB0eURlc2NWYWxpZCA9IHR5cGVvZiBlbXB0eVN5bWJvbERlc2MgPT09ICd1bmRlZmluZWQnIHx8IGVtcHR5U3ltYm9sRGVzYyA9PT0gJyc7XG5cdGlmICghZW1wdHlEZXNjVmFsaWQgfHwgZGVzYy5nZXQuY2FsbChTeW1ib2woJ2EnKSkgIT09ICdhJykge1xuXHRcdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcblx0fVxuXHRyZXR1cm4gZGVzYy5nZXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzJykoKTtcbnZhciBwb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcbnZhciBnZXRJbmZlcnJlZE5hbWUgPSByZXF1aXJlKCdnZXQtc3ltYm9sLWRlc2NyaXB0aW9uL2dldEluZmVycmVkTmFtZScpO1xuXG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZ09QRHMgPSByZXF1aXJlKCdvYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9ycy9wb2x5ZmlsbCcpKCk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgZFBzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgc2V0UHJvdG8gPSBPYmplY3Quc2V0UHJvdG90eXBlT2Y7XG5cbnZhciBkZWZpbmUgPSBmdW5jdGlvbiBkZWZpbmVHZXR0ZXIoZ2V0dGVyKSB7XG5cdGRQKFN5bWJvbC5wcm90b3R5cGUsICdkZXNjcmlwdGlvbicsIHtcblx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0Z2V0OiBnZXR0ZXJcblx0fSk7XG59O1xuXG52YXIgc2hpbUdsb2JhbCA9IGZ1bmN0aW9uIHNoaW1HbG9iYWxTeW1ib2woZ2V0dGVyKSB7XG5cdHZhciBvcmlnU3ltID0gRnVuY3Rpb24uYXBwbHkuYmluZChTeW1ib2wpO1xuXHR2YXIgZW1wdHlTdHJpbmdzID0gT2JqZWN0LmNyZWF0ZSA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcblx0dmFyIFN5bU5ldyA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcblx0XHR2YXIgc3ltID0gb3JpZ1N5bSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gPT09ICcnKSB7XG5cdFx0XHRlbXB0eVN0cmluZ3Nbc3ltXSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBzeW07XG5cdH07XG5cdFN5bU5ldy5wcm90b3R5cGUgPSBTeW1ib2wucHJvdG90eXBlO1xuXHRzZXRQcm90byhTeW1OZXcsIFN5bWJvbCk7XG5cdHZhciBwcm9wcyA9IGdPUERzKFN5bWJvbCk7XG5cdGRlbGV0ZSBwcm9wcy5sZW5ndGg7XG5cdGRlbGV0ZSBwcm9wcy5hcmd1bWVudHM7XG5cdGRlbGV0ZSBwcm9wcy5jYWxsZXI7XG5cdGRQcyhTeW1OZXcsIHByb3BzKTtcblx0U3ltYm9sID0gU3ltTmV3OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5hdGl2ZS1yZWFzc2lnbiwgbm8tZ2xvYmFsLWFzc2lnblxuXG5cdHZhciBib3VuZEdldHRlciA9IEZ1bmN0aW9uLmNhbGwuYmluZChnZXR0ZXIpO1xuXHR2YXIgd3JhcHBlZEdldHRlciA9IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkge1xuXHRcdC8qIGVzbGludCBuby1pbnZhbGlkLXRoaXM6IDAgKi9cblx0XHR2YXIgc3ltYm9sRGVzY3JpcHRpb24gPSBib3VuZEdldHRlcih0aGlzKTtcblx0XHRpZiAoZW1wdHlTdHJpbmdzW3RoaXNdKSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXHRcdHJldHVybiBzeW1ib2xEZXNjcmlwdGlvbjtcblx0fTtcblx0ZGVmaW5lKHdyYXBwZWRHZXR0ZXIpO1xuXHRyZXR1cm4gd3JhcHBlZEdldHRlcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbVN5bWJvbERlc2NyaXB0aW9uKCkge1xuXHRpZiAoIWhhc1N5bWJvbHMpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0dmFyIGRlc2MgPSBnT1BEKFN5bWJvbC5wcm90b3R5cGUsICdkZXNjcmlwdGlvbicpO1xuXHR2YXIgZ2V0dGVyID0gcG9seWZpbGwoKTtcblx0dmFyIGlzTWlzc2luZyA9ICFkZXNjIHx8IHR5cGVvZiBkZXNjLmdldCAhPT0gJ2Z1bmN0aW9uJztcblx0dmFyIGlzQnJva2VuID0gIWlzTWlzc2luZyAmJiAodHlwZW9mIFN5bWJvbCgpLmRlc2NyaXB0aW9uICE9PSAndW5kZWZpbmVkJyB8fCBTeW1ib2woJycpLmRlc2NyaXB0aW9uICE9PSAnJyk7XG5cdGlmIChpc01pc3NpbmcgfHwgaXNCcm9rZW4pIHtcblx0XHRpZiAoIWdldEluZmVycmVkTmFtZSkge1xuXHRcdFx0cmV0dXJuIHNoaW1HbG9iYWwoZ2V0dGVyKTtcblx0XHR9XG5cdFx0ZGVmaW5lKGdldHRlcik7XG5cdH1cblx0cmV0dXJuIGdldHRlcjtcbn07XG4iLCIoZnVuY3Rpb24oc2VsZikge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHNlbGYuZmV0Y2gpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSlcbiAgICB9XG4gICAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXFxeX2B8fl0vaS50ZXN0KG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZScpXG4gICAgfVxuICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xuICAgIHRoaXMubWFwID0ge31cblxuICAgIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIHZhbHVlKVxuICAgICAgfSwgdGhpcylcblxuICAgIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pXG4gICAgICB9LCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSlcbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKVxuICAgIHZhciBsaXN0ID0gdGhpcy5tYXBbbmFtZV1cbiAgICBpZiAoIWxpc3QpIHtcbiAgICAgIGxpc3QgPSBbXVxuICAgICAgdGhpcy5tYXBbbmFtZV0gPSBsaXN0XG4gICAgfVxuICAgIGxpc3QucHVzaCh2YWx1ZSlcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgdmFsdWVzID0gdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV1cbiAgICByZXR1cm4gdmFsdWVzID8gdmFsdWVzWzBdIDogbnVsbFxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZ2V0QWxsID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSB8fCBbXVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVOYW1lKG5hbWUpKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IFtub3JtYWxpemVWYWx1ZSh2YWx1ZSldXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLm1hcCkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICB0aGlzLm1hcFtuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdmFsdWUsIG5hbWUsIHRoaXMpXG4gICAgICB9LCB0aGlzKVxuICAgIH0sIHRoaXMpXG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdClcbiAgICAgIH1cbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYilcbiAgICByZXR1cm4gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgIHJlYWRlci5yZWFkQXNUZXh0KGJsb2IpXG4gICAgcmV0dXJuIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gIH1cblxuICB2YXIgc3VwcG9ydCA9IHtcbiAgICBibG9iOiAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJiAnQmxvYicgaW4gc2VsZiAmJiAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgQmxvYigpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlXG5cblxuICAgIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgdGhpcy5fYm9keUluaXQgPSBib2R5XG4gICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5mb3JtRGF0YSAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKCFib2R5KSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gJydcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAvLyBPbmx5IHN1cHBvcnQgQXJyYXlCdWZmZXJzIGZvciBQT1NUIG1ldGhvZC5cbiAgICAgICAgLy8gUmVjZWl2aW5nIEFycmF5QnVmZmVycyBoYXBwZW5zIHZpYSBCbG9icywgaW5zdGVhZC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgQm9keUluaXQgdHlwZScpXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgdGhpcy5ibG9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QmxvYilcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgYmxvYicpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keVRleHRdKSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmFycmF5QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgIH1cblxuICAgICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgICByZXR1cm4gcmVqZWN0ZWQgPyByZWplY3RlZCA6IFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydC5mb3JtRGF0YSkge1xuICAgICAgdGhpcy5mb3JtRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihkZWNvZGUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBIVFRQIG1ldGhvZHMgd2hvc2UgY2FwaXRhbGl6YXRpb24gc2hvdWxkIGJlIG5vcm1hbGl6ZWRcbiAgdmFyIG1ldGhvZHMgPSBbJ0RFTEVURScsICdHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BPU1QnLCAnUFVUJ11cblxuICBmdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gICAgdmFyIHVwY2FzZWQgPSBtZXRob2QudG9VcHBlckNhc2UoKVxuICAgIHJldHVybiAobWV0aG9kcy5pbmRleE9mKHVwY2FzZWQpID4gLTEpID8gdXBjYXNlZCA6IG1ldGhvZFxuICB9XG5cbiAgZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHlcbiAgICBpZiAoUmVxdWVzdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihpbnB1dCkpIHtcbiAgICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSBpbnB1dC51cmxcbiAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBpbnB1dC5jcmVkZW50aWFsc1xuICAgICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5wdXQuaGVhZGVycylcbiAgICAgIH1cbiAgICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kXG4gICAgICB0aGlzLm1vZGUgPSBpbnB1dC5tb2RlXG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgYm9keSA9IGlucHV0Ll9ib2R5SW5pdFxuICAgICAgICBpbnB1dC5ib2R5VXNlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cmwgPSBpbnB1dFxuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ29taXQnXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKVxuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbFxuICAgIHRoaXMucmVmZXJyZXIgPSBudWxsXG5cbiAgICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gICAgfVxuICAgIHRoaXMuX2luaXRCb2R5KGJvZHkpXG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzKVxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHtcbiAgICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpXG4gICAgYm9keS50cmltKCkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKVxuICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBmb3JtXG4gIH1cblxuICBmdW5jdGlvbiBoZWFkZXJzKHhocikge1xuICAgIHZhciBoZWFkID0gbmV3IEhlYWRlcnMoKVxuICAgIHZhciBwYWlycyA9ICh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpLnRyaW0oKS5zcGxpdCgnXFxuJylcbiAgICBwYWlycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgdmFyIHNwbGl0ID0gaGVhZGVyLnRyaW0oKS5zcGxpdCgnOicpXG4gICAgICB2YXIga2V5ID0gc3BsaXQuc2hpZnQoKS50cmltKClcbiAgICAgIHZhciB2YWx1ZSA9IHNwbGl0LmpvaW4oJzonKS50cmltKClcbiAgICAgIGhlYWQuYXBwZW5kKGtleSwgdmFsdWUpXG4gICAgfSlcbiAgICByZXR1cm4gaGVhZFxuICB9XG5cbiAgQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKVxuXG4gIGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSAnZGVmYXVsdCdcbiAgICB0aGlzLnN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzXG4gICAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMFxuICAgIHRoaXMuc3RhdHVzVGV4dCA9IG9wdGlvbnMuc3RhdHVzVGV4dFxuICAgIHRoaXMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMgPyBvcHRpb25zLmhlYWRlcnMgOiBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJ1xuICAgIHRoaXMuX2luaXRCb2R5KGJvZHlJbml0KVxuICB9XG5cbiAgQm9keS5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSlcblxuICBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9KVxuICB9XG5cbiAgUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMCwgc3RhdHVzVGV4dDogJyd9KVxuICAgIHJlc3BvbnNlLnR5cGUgPSAnZXJyb3InXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICB2YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF1cblxuICBSZXNwb25zZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKHVybCwgc3RhdHVzKSB7XG4gICAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUnKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxuICB9XG5cbiAgc2VsZi5IZWFkZXJzID0gSGVhZGVyc1xuICBzZWxmLlJlcXVlc3QgPSBSZXF1ZXN0XG4gIHNlbGYuUmVzcG9uc2UgPSBSZXNwb25zZVxuXG4gIHNlbGYuZmV0Y2ggPSBmdW5jdGlvbihpbnB1dCwgaW5pdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZXF1ZXN0XG4gICAgICBpZiAoUmVxdWVzdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihpbnB1dCkgJiYgIWluaXQpIHtcbiAgICAgICAgcmVxdWVzdCA9IGlucHV0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpXG4gICAgICB9XG5cbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuXG4gICAgICBmdW5jdGlvbiByZXNwb25zZVVSTCgpIHtcbiAgICAgICAgaWYgKCdyZXNwb25zZVVSTCcgaW4geGhyKSB7XG4gICAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVVSTFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXZvaWQgc2VjdXJpdHkgd2FybmluZ3Mgb24gZ2V0UmVzcG9uc2VIZWFkZXIgd2hlbiBub3QgYWxsb3dlZCBieSBDT1JTXG4gICAgICAgIGlmICgvXlgtUmVxdWVzdC1VUkw6L20udGVzdCh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKSB7XG4gICAgICAgICAgcmV0dXJuIHhoci5nZXRSZXNwb25zZUhlYWRlcignWC1SZXF1ZXN0LVVSTCcpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhdHVzID0gKHhoci5zdGF0dXMgPT09IDEyMjMpID8gMjA0IDogeGhyLnN0YXR1c1xuICAgICAgICBpZiAoc3RhdHVzIDwgMTAwIHx8IHN0YXR1cyA+IDU5OSkge1xuICAgICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogaGVhZGVycyh4aHIpLFxuICAgICAgICAgIHVybDogcmVzcG9uc2VVUkwoKVxuICAgICAgICB9XG4gICAgICAgIHZhciBib2R5ID0gJ3Jlc3BvbnNlJyBpbiB4aHIgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKVxuICAgICAgfVxuXG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgfVxuXG4gICAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICB9XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSlcblxuICAgICAgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdpbmNsdWRlJykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyICYmIHN1cHBvcnQuYmxvYikge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InXG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKVxuICAgICAgfSlcblxuICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdClcbiAgICB9KVxuICB9XG4gIHNlbGYuZmV0Y2gucG9seWZpbGwgPSB0cnVlXG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcyk7XG4iLCIvKiBqc2hpbnQgYnJvd3Nlcjp0cnVlXG4gKlxuICogd2luZG93LWxvY2F0aW9uLW9yaWdpbiAtIHZlcnNpb24gMC4wLjFcbiAqIEFkZCBzdXBwb3J0IGZvciBicm93c2VycyB0aGF0IGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgd2luZG93LmxvY2F0aW9uLm9yaWdpblxuICpcbiAqIEF1dGhyb3I6IEt5bGUgV2Vsc2J5IDxreWxlQG1la3lsZS5jb20+XG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuXG4oZnVuY3Rpb24obG9jYXRpb24pe1xuICAndXNlIHN0cmljdCc7XG4gIGlmICghbG9jYXRpb24ub3JpZ2luKSB7XG4gICAgdmFyIG9yaWdpbiA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdG5hbWUgKyAobG9jYXRpb24ucG9ydCAmJiBcIjpcIiArIGxvY2F0aW9uLnBvcnQpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBNYWtlIGl0IG5vbiBlZGl0YWJsZVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxvY2F0aW9uLCBcIm9yaWdpblwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBvcmlnaW5cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgLy8gSUUgPCA4XG4gICAgICBsb2NhdGlvbi5vcmlnaW4gPSBvcmlnaW47XG4gICAgfVxuICB9XG59KSh3aW5kb3cubG9jYXRpb24pO1xuIiwiLyogKGlnbm9yZWQpICovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJEFycmF5ID0gR2V0SW50cmluc2ljKCclQXJyYXklJyk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnbG9iYWwtcmVxdWlyZVxudmFyIHRvU3RyID0gISRBcnJheS5pc0FycmF5ICYmIHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKSgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xuXG4vLyBodHRwczovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtaXNhcnJheVxuXG5tb2R1bGUuZXhwb3J0cyA9ICRBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIElzQXJyYXkoYXJndW1lbnQpIHtcblx0cmV0dXJuIHRvU3RyKGFyZ3VtZW50KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbnNwZWN0ID0gcmVxdWlyZSgnb2JqZWN0LWluc3BlY3QnKTtcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG5cbnZhciBDYWxsID0gcmVxdWlyZSgnLi9DYWxsJyk7XG52YXIgR2V0ID0gcmVxdWlyZSgnLi9HZXQnKTtcbnZhciBHZXRJdGVyYXRvciA9IHJlcXVpcmUoJy4vR2V0SXRlcmF0b3InKTtcbnZhciBJc0NhbGxhYmxlID0gcmVxdWlyZSgnLi9Jc0NhbGxhYmxlJyk7XG52YXIgSXRlcmF0b3JDbG9zZSA9IHJlcXVpcmUoJy4vSXRlcmF0b3JDbG9zZScpO1xudmFyIEl0ZXJhdG9yU3RlcCA9IHJlcXVpcmUoJy4vSXRlcmF0b3JTdGVwJyk7XG52YXIgSXRlcmF0b3JWYWx1ZSA9IHJlcXVpcmUoJy4vSXRlcmF0b3JWYWx1ZScpO1xudmFyIFR5cGUgPSByZXF1aXJlKCcuL1R5cGUnKTtcblxuLy8gaHR0cHM6Ly8yNjIuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy8xMC4wLy8jc2VjLWFkZC1lbnRyaWVzLWZyb20taXRlcmFibGVcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBBZGRFbnRyaWVzRnJvbUl0ZXJhYmxlKHRhcmdldCwgaXRlcmFibGUsIGFkZGVyKSB7XG5cdGlmICghSXNDYWxsYWJsZShhZGRlcikpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogYGFkZGVyYCBpcyBub3QgY2FsbGFibGUnKTtcblx0fVxuXHRpZiAoaXRlcmFibGUgPT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdBc3NlcnRpb24gZmFpbGVkOiBgaXRlcmFibGVgIGlzIHByZXNlbnQsIGFuZCBub3QgbnVsbGlzaCcpO1xuXHR9XG5cdHZhciBpdGVyYXRvclJlY29yZCA9IEdldEl0ZXJhdG9yKGl0ZXJhYmxlKTtcblx0d2hpbGUgKHRydWUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cblx0XHR2YXIgbmV4dCA9IEl0ZXJhdG9yU3RlcChpdGVyYXRvclJlY29yZCk7XG5cdFx0aWYgKCFuZXh0KSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXHRcdH1cblx0XHR2YXIgbmV4dEl0ZW0gPSBJdGVyYXRvclZhbHVlKG5leHQpO1xuXHRcdGlmIChUeXBlKG5leHRJdGVtKSAhPT0gJ09iamVjdCcpIHtcblx0XHRcdHZhciBlcnJvciA9IG5ldyAkVHlwZUVycm9yKCdpdGVyYXRvciBuZXh0IG11c3QgcmV0dXJuIGFuIE9iamVjdCwgZ290ICcgKyBpbnNwZWN0KG5leHRJdGVtKSk7XG5cdFx0XHRyZXR1cm4gSXRlcmF0b3JDbG9zZShcblx0XHRcdFx0aXRlcmF0b3JSZWNvcmQsXG5cdFx0XHRcdGZ1bmN0aW9uICgpIHsgdGhyb3cgZXJyb3I7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sb29wLWZ1bmNcblx0XHRcdCk7XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgayA9IEdldChuZXh0SXRlbSwgJzAnKTtcblx0XHRcdHZhciB2ID0gR2V0KG5leHRJdGVtLCAnMScpO1xuXHRcdFx0Q2FsbChhZGRlciwgdGFyZ2V0LCBbaywgdl0pO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBJdGVyYXRvckNsb3NlKFxuXHRcdFx0XHRpdGVyYXRvclJlY29yZCxcblx0XHRcdFx0ZnVuY3Rpb24gKCkgeyB0aHJvdyBlOyB9XG5cdFx0XHQpO1xuXHRcdH1cblx0fVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyIENvZGVQb2ludEF0ID0gcmVxdWlyZSgnLi9Db2RlUG9pbnRBdCcpO1xudmFyIElzSW50ZWdyYWxOdW1iZXIgPSByZXF1aXJlKCcuL0lzSW50ZWdyYWxOdW1iZXInKTtcbnZhciBUeXBlID0gcmVxdWlyZSgnLi9UeXBlJyk7XG5cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gcmVxdWlyZSgnLi4vaGVscGVycy9tYXhTYWZlSW50ZWdlcicpO1xuXG52YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYygnJVR5cGVFcnJvciUnKTtcblxuLy8gaHR0cHM6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzEyLjAvI3NlYy1hZHZhbmNlc3RyaW5naW5kZXhcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBBZHZhbmNlU3RyaW5nSW5kZXgoUywgaW5kZXgsIHVuaWNvZGUpIHtcblx0aWYgKFR5cGUoUykgIT09ICdTdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IGBTYCBtdXN0IGJlIGEgU3RyaW5nJyk7XG5cdH1cblx0aWYgKCFJc0ludGVncmFsTnVtYmVyKGluZGV4KSB8fCBpbmRleCA8IDAgfHwgaW5kZXggPiBNQVhfU0FGRV9JTlRFR0VSKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IGBsZW5ndGhgIG11c3QgYmUgYW4gaW50ZWdlciA+PSAwIGFuZCA8PSAyKio1MycpO1xuXHR9XG5cdGlmIChUeXBlKHVuaWNvZGUpICE9PSAnQm9vbGVhbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogYHVuaWNvZGVgIG11c3QgYmUgYSBCb29sZWFuJyk7XG5cdH1cblx0aWYgKCF1bmljb2RlKSB7XG5cdFx0cmV0dXJuIGluZGV4ICsgMTtcblx0fVxuXHR2YXIgbGVuZ3RoID0gUy5sZW5ndGg7XG5cdGlmICgoaW5kZXggKyAxKSA+PSBsZW5ndGgpIHtcblx0XHRyZXR1cm4gaW5kZXggKyAxO1xuXHR9XG5cdHZhciBjcCA9IENvZGVQb2ludEF0KFMsIGluZGV4KTtcblx0cmV0dXJuIGluZGV4ICsgY3BbJ1tbQ29kZVVuaXRDb3VudF1dJ107XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJEFycmF5UHJvdG90eXBlID0gR2V0SW50cmluc2ljKCclQXJyYXkucHJvdG90eXBlJScpO1xudmFyICRSYW5nZUVycm9yID0gR2V0SW50cmluc2ljKCclUmFuZ2VFcnJvciUnKTtcbnZhciAkU3ludGF4RXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVTeW50YXhFcnJvciUnKTtcbnZhciAkVHlwZUVycm9yID0gR2V0SW50cmluc2ljKCclVHlwZUVycm9yJScpO1xuXG52YXIgSXNJbnRlZ3JhbE51bWJlciA9IHJlcXVpcmUoJy4vSXNJbnRlZ3JhbE51bWJlcicpO1xuXG52YXIgTUFYX0FSUkFZX0xFTkdUSCA9IE1hdGgucG93KDIsIDMyKSAtIDE7XG5cbnZhciAkc2V0UHJvdG8gPSBHZXRJbnRyaW5zaWMoJyVPYmplY3Quc2V0UHJvdG90eXBlT2YlJywgdHJ1ZSkgfHwgKFxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG8sIG5vLW5lZ2F0ZWQtY29uZGl0aW9uXG5cdFtdLl9fcHJvdG9fXyAhPT0gJEFycmF5UHJvdG90eXBlXG5cdFx0PyBudWxsXG5cdFx0OiBmdW5jdGlvbiAoTywgcHJvdG8pIHtcblx0XHRcdE8uX19wcm90b19fID0gcHJvdG87IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG8sIG5vLXBhcmFtLXJlYXNzaWduXG5cdFx0XHRyZXR1cm4gTztcblx0XHR9XG4pO1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzEyLjAvI3NlYy1hcnJheWNyZWF0ZVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEFycmF5Q3JlYXRlKGxlbmd0aCkge1xuXHRpZiAoIUlzSW50ZWdyYWxOdW1iZXIobGVuZ3RoKSB8fCBsZW5ndGggPCAwKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IGBsZW5ndGhgIG11c3QgYmUgYW4gaW50ZWdlciBOdW1iZXIgPj0gMCcpO1xuXHR9XG5cdGlmIChsZW5ndGggPiBNQVhfQVJSQVlfTEVOR1RIKSB7XG5cdFx0dGhyb3cgbmV3ICRSYW5nZUVycm9yKCdsZW5ndGggaXMgZ3JlYXRlciB0aGFuICgyKiozMiAtIDEpJyk7XG5cdH1cblx0dmFyIHByb3RvID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiAkQXJyYXlQcm90b3R5cGU7XG5cdHZhciBBID0gW107IC8vIHN0ZXBzIDMsIDVcblx0aWYgKHByb3RvICE9PSAkQXJyYXlQcm90b3R5cGUpIHsgLy8gc3RlcCA0XG5cdFx0aWYgKCEkc2V0UHJvdG8pIHtcblx0XHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ0FycmF5Q3JlYXRlOiBhIGBwcm90b2AgYXJndW1lbnQgdGhhdCBpcyBub3QgYEFycmF5LnByb3RvdHlwZWAgaXMgbm90IHN1cHBvcnRlZCBpbiBhbiBlbnZpcm9ubWVudCB0aGF0IGRvZXMgbm90IHN1cHBvcnQgc2V0dGluZyB0aGUgW1tQcm90b3R5cGVdXScpO1xuXHRcdH1cblx0XHQkc2V0UHJvdG8oQSwgcHJvdG8pO1xuXHR9XG5cdGlmIChsZW5ndGggIT09IDApIHsgLy8gYnlwYXNzZXMgdGhlIG5lZWQgZm9yIHN0ZXAgNlxuXHRcdEEubGVuZ3RoID0gbGVuZ3RoO1xuXHR9XG5cdC8qIHN0ZXAgNiwgdGhlIGFib3ZlIGFzIGEgc2hvcnRjdXQgZm9yIHRoZSBiZWxvd1xuICAgIE9yZGluYXJ5RGVmaW5lT3duUHJvcGVydHkoQSwgJ2xlbmd0aCcsIHtcbiAgICAgICAgJ1tbQ29uZmlndXJhYmxlXV0nOiBmYWxzZSxcbiAgICAgICAgJ1tbRW51bWVyYWJsZV1dJzogZmFsc2UsXG4gICAgICAgICdbW1ZhbHVlXV0nOiBsZW5ndGgsXG4gICAgICAgICdbW1dyaXRhYmxlXV0nOiB0cnVlXG4gICAgfSk7XG4gICAgKi9cblx0cmV0dXJuIEE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJHNwZWNpZXMgPSBHZXRJbnRyaW5zaWMoJyVTeW1ib2wuc3BlY2llcyUnLCB0cnVlKTtcbnZhciAkVHlwZUVycm9yID0gR2V0SW50cmluc2ljKCclVHlwZUVycm9yJScpO1xuXG52YXIgQXJyYXlDcmVhdGUgPSByZXF1aXJlKCcuL0FycmF5Q3JlYXRlJyk7XG52YXIgR2V0ID0gcmVxdWlyZSgnLi9HZXQnKTtcbnZhciBJc0FycmF5ID0gcmVxdWlyZSgnLi9Jc0FycmF5Jyk7XG52YXIgSXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vSXNDb25zdHJ1Y3RvcicpO1xudmFyIElzSW50ZWdyYWxOdW1iZXIgPSByZXF1aXJlKCcuL0lzSW50ZWdyYWxOdW1iZXInKTtcbnZhciBUeXBlID0gcmVxdWlyZSgnLi9UeXBlJyk7XG5cbi8vIGh0dHBzOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi8xMi4wLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gQXJyYXlTcGVjaWVzQ3JlYXRlKG9yaWdpbmFsQXJyYXksIGxlbmd0aCkge1xuXHRpZiAoIUlzSW50ZWdyYWxOdW1iZXIobGVuZ3RoKSB8fCBsZW5ndGggPCAwKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IGxlbmd0aCBtdXN0IGJlIGFuIGludGVnZXIgPj0gMCcpO1xuXHR9XG5cblx0dmFyIGlzQXJyYXkgPSBJc0FycmF5KG9yaWdpbmFsQXJyYXkpO1xuXHRpZiAoIWlzQXJyYXkpIHtcblx0XHRyZXR1cm4gQXJyYXlDcmVhdGUobGVuZ3RoKTtcblx0fVxuXG5cdHZhciBDID0gR2V0KG9yaWdpbmFsQXJyYXksICdjb25zdHJ1Y3RvcicpO1xuXHQvLyBUT0RPOiBmaWd1cmUgb3V0IGhvdyB0byBtYWtlIGEgY3Jvc3MtcmVhbG0gbm9ybWFsIEFycmF5LCBhIHNhbWUtcmVhbG0gQXJyYXlcblx0Ly8gaWYgKElzQ29uc3RydWN0b3IoQykpIHtcblx0Ly8gXHRpZiBDIGlzIGFub3RoZXIgcmVhbG0ncyBBcnJheSwgQyA9IHVuZGVmaW5lZFxuXHQvLyBcdE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmdldFByb3RvdHlwZU9mKEFycmF5KSkpID09PSBudWxsID9cblx0Ly8gfVxuXHRpZiAoJHNwZWNpZXMgJiYgVHlwZShDKSA9PT0gJ09iamVjdCcpIHtcblx0XHRDID0gR2V0KEMsICRzcGVjaWVzKTtcblx0XHRpZiAoQyA9PT0gbnVsbCkge1xuXHRcdFx0QyA9IHZvaWQgMDtcblx0XHR9XG5cdH1cblxuXHRpZiAodHlwZW9mIEMgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0cmV0dXJuIEFycmF5Q3JlYXRlKGxlbmd0aCk7XG5cdH1cblx0aWYgKCFJc0NvbnN0cnVjdG9yKEMpKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0MgbXVzdCBiZSBhIGNvbnN0cnVjdG9yJyk7XG5cdH1cblx0cmV0dXJuIG5ldyBDKGxlbmd0aCk7IC8vIENvbnN0cnVjdChDLCBsZW5ndGgpO1xufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG5cbnZhciBJc0FycmF5ID0gcmVxdWlyZSgnLi9Jc0FycmF5Jyk7XG5cbnZhciAkYXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVSZWZsZWN0LmFwcGx5JScsIHRydWUpIHx8IGNhbGxCb3VuZCgnJUZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSUnKTtcblxuLy8gaHR0cHM6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWNhbGxcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBDYWxsKEYsIFYpIHtcblx0dmFyIGFyZ3VtZW50c0xpc3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IFtdO1xuXHRpZiAoIUlzQXJyYXkoYXJndW1lbnRzTGlzdCkpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogb3B0aW9uYWwgYGFyZ3VtZW50c0xpc3RgLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIExpc3QnKTtcblx0fVxuXHRyZXR1cm4gJGFwcGx5KEYsIFYsIGFyZ3VtZW50c0xpc3QpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xudmFyIGlzTGVhZGluZ1N1cnJvZ2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNMZWFkaW5nU3Vycm9nYXRlJyk7XG52YXIgaXNUcmFpbGluZ1N1cnJvZ2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNUcmFpbGluZ1N1cnJvZ2F0ZScpO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4vVHlwZScpO1xudmFyIFVURjE2U3Vycm9nYXRlUGFpclRvQ29kZVBvaW50ID0gcmVxdWlyZSgnLi9VVEYxNlN1cnJvZ2F0ZVBhaXJUb0NvZGVQb2ludCcpO1xuXG52YXIgJGNoYXJBdCA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5jaGFyQXQnKTtcbnZhciAkY2hhckNvZGVBdCA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5jaGFyQ29kZUF0Jyk7XG5cbi8vIGh0dHBzOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi8xMi4wLyNzZWMtY29kZXBvaW50YXRcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBDb2RlUG9pbnRBdChzdHJpbmcsIHBvc2l0aW9uKSB7XG5cdGlmIChUeXBlKHN0cmluZykgIT09ICdTdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IGBzdHJpbmdgIG11c3QgYmUgYSBTdHJpbmcnKTtcblx0fVxuXHR2YXIgc2l6ZSA9IHN0cmluZy5sZW5ndGg7XG5cdGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gc2l6ZSkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdBc3NlcnRpb24gZmFpbGVkOiBgcG9zaXRpb25gIG11c3QgYmUgPj0gMCwgYW5kIDwgdGhlIGxlbmd0aCBvZiBgc3RyaW5nYCcpO1xuXHR9XG5cdHZhciBmaXJzdCA9ICRjaGFyQ29kZUF0KHN0cmluZywgcG9zaXRpb24pO1xuXHR2YXIgY3AgPSAkY2hhckF0KHN0cmluZywgcG9zaXRpb24pO1xuXHR2YXIgZmlyc3RJc0xlYWRpbmcgPSBpc0xlYWRpbmdTdXJyb2dhdGUoZmlyc3QpO1xuXHR2YXIgZmlyc3RJc1RyYWlsaW5nID0gaXNUcmFpbGluZ1N1cnJvZ2F0ZShmaXJzdCk7XG5cdGlmICghZmlyc3RJc0xlYWRpbmcgJiYgIWZpcnN0SXNUcmFpbGluZykge1xuXHRcdHJldHVybiB7XG5cdFx0XHQnW1tDb2RlUG9pbnRdXSc6IGNwLFxuXHRcdFx0J1tbQ29kZVVuaXRDb3VudF1dJzogMSxcblx0XHRcdCdbW0lzVW5wYWlyZWRTdXJyb2dhdGVdXSc6IGZhbHNlXG5cdFx0fTtcblx0fVxuXHRpZiAoZmlyc3RJc1RyYWlsaW5nIHx8IChwb3NpdGlvbiArIDEgPT09IHNpemUpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdCdbW0NvZGVQb2ludF1dJzogY3AsXG5cdFx0XHQnW1tDb2RlVW5pdENvdW50XV0nOiAxLFxuXHRcdFx0J1tbSXNVbnBhaXJlZFN1cnJvZ2F0ZV1dJzogdHJ1ZVxuXHRcdH07XG5cdH1cblx0dmFyIHNlY29uZCA9ICRjaGFyQ29kZUF0KHN0cmluZywgcG9zaXRpb24gKyAxKTtcblx0aWYgKCFpc1RyYWlsaW5nU3Vycm9nYXRlKHNlY29uZCkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0J1tbQ29kZVBvaW50XV0nOiBjcCxcblx0XHRcdCdbW0NvZGVVbml0Q291bnRdXSc6IDEsXG5cdFx0XHQnW1tJc1VucGFpcmVkU3Vycm9nYXRlXV0nOiB0cnVlXG5cdFx0fTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0J1tbQ29kZVBvaW50XV0nOiBVVEYxNlN1cnJvZ2F0ZVBhaXJUb0NvZGVQb2ludChmaXJzdCwgc2Vjb25kKSxcblx0XHQnW1tDb2RlVW5pdENvdW50XV0nOiAyLFxuXHRcdCdbW0lzVW5wYWlyZWRTdXJyb2dhdGVdXSc6IGZhbHNlXG5cdH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYygnJVR5cGVFcnJvciUnKTtcblxudmFyIERlZmluZU93blByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaGVscGVycy9EZWZpbmVPd25Qcm9wZXJ0eScpO1xuXG52YXIgRnJvbVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vRnJvbVByb3BlcnR5RGVzY3JpcHRvcicpO1xudmFyIE9yZGluYXJ5R2V0T3duUHJvcGVydHkgPSByZXF1aXJlKCcuL09yZGluYXJ5R2V0T3duUHJvcGVydHknKTtcbnZhciBJc0RhdGFEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9Jc0RhdGFEZXNjcmlwdG9yJyk7XG52YXIgSXNFeHRlbnNpYmxlID0gcmVxdWlyZSgnLi9Jc0V4dGVuc2libGUnKTtcbnZhciBJc1Byb3BlcnR5S2V5ID0gcmVxdWlyZSgnLi9Jc1Byb3BlcnR5S2V5Jyk7XG52YXIgU2FtZVZhbHVlID0gcmVxdWlyZSgnLi9TYW1lVmFsdWUnKTtcbnZhciBUeXBlID0gcmVxdWlyZSgnLi9UeXBlJyk7XG5cbi8vIGh0dHBzOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1jcmVhdGVkYXRhcHJvcGVydHlcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBDcmVhdGVEYXRhUHJvcGVydHkoTywgUCwgVikge1xuXHRpZiAoVHlwZShPKSAhPT0gJ09iamVjdCcpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogVHlwZShPKSBpcyBub3QgT2JqZWN0Jyk7XG5cdH1cblx0aWYgKCFJc1Byb3BlcnR5S2V5KFApKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IElzUHJvcGVydHlLZXkoUCkgaXMgbm90IHRydWUnKTtcblx0fVxuXHR2YXIgb2xkRGVzYyA9IE9yZGluYXJ5R2V0T3duUHJvcGVydHkoTywgUCk7XG5cdHZhciBleHRlbnNpYmxlID0gIW9sZERlc2MgfHwgSXNFeHRlbnNpYmxlKE8pO1xuXHR2YXIgaW1tdXRhYmxlID0gb2xkRGVzYyAmJiAoIW9sZERlc2NbJ1tbV3JpdGFibGVdXSddIHx8ICFvbGREZXNjWydbW0NvbmZpZ3VyYWJsZV1dJ10pO1xuXHRpZiAoaW1tdXRhYmxlIHx8ICFleHRlbnNpYmxlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHJldHVybiBEZWZpbmVPd25Qcm9wZXJ0eShcblx0XHRJc0RhdGFEZXNjcmlwdG9yLFxuXHRcdFNhbWVWYWx1ZSxcblx0XHRGcm9tUHJvcGVydHlEZXNjcmlwdG9yLFxuXHRcdE8sXG5cdFx0UCxcblx0XHR7XG5cdFx0XHQnW1tDb25maWd1cmFibGVdXSc6IHRydWUsXG5cdFx0XHQnW1tFbnVtZXJhYmxlXV0nOiB0cnVlLFxuXHRcdFx0J1tbVmFsdWVdXSc6IFYsXG5cdFx0XHQnW1tXcml0YWJsZV1dJzogdHJ1ZVxuXHRcdH1cblx0KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkVHlwZUVycm9yID0gR2V0SW50cmluc2ljKCclVHlwZUVycm9yJScpO1xuXG52YXIgQ3JlYXRlRGF0YVByb3BlcnR5ID0gcmVxdWlyZSgnLi9DcmVhdGVEYXRhUHJvcGVydHknKTtcbnZhciBJc1Byb3BlcnR5S2V5ID0gcmVxdWlyZSgnLi9Jc1Byb3BlcnR5S2V5Jyk7XG52YXIgVHlwZSA9IHJlcXVpcmUoJy4vVHlwZScpO1xuXG4vLyAvLyBodHRwczovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtY3JlYXRlZGF0YXByb3BlcnR5b3J0aHJvd1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIENyZWF0ZURhdGFQcm9wZXJ0eU9yVGhyb3coTywgUCwgVikge1xuXHRpZiAoVHlwZShPKSAhPT0gJ09iamVjdCcpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogVHlwZShPKSBpcyBub3QgT2JqZWN0Jyk7XG5cdH1cblx0aWYgKCFJc1Byb3BlcnR5S2V5KFApKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IElzUHJvcGVydHlLZXkoUCkgaXMgbm90IHRydWUnKTtcblx0fVxuXHR2YXIgc3VjY2VzcyA9IENyZWF0ZURhdGFQcm9wZXJ0eShPLCBQLCBWKTtcblx0aWYgKCFzdWNjZXNzKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ3VuYWJsZSB0byBjcmVhdGUgZGF0YSBwcm9wZXJ0eScpO1xuXHR9XG5cdHJldHVybiBzdWNjZXNzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi9UeXBlJyk7XG5cbi8vIGh0dHBzOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1jcmVhdGVpdGVycmVzdWx0b2JqZWN0XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gQ3JlYXRlSXRlclJlc3VsdE9iamVjdCh2YWx1ZSwgZG9uZSkge1xuXHRpZiAoVHlwZShkb25lKSAhPT0gJ0Jvb2xlYW4nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IFR5cGUoZG9uZSkgaXMgbm90IEJvb2xlYW4nKTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRkb25lOiBkb25lXG5cdH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYygnJVR5cGVFcnJvciUnKTtcblxudmFyIERlZmluZU93blByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaGVscGVycy9EZWZpbmVPd25Qcm9wZXJ0eScpO1xuXG52YXIgRnJvbVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vRnJvbVByb3BlcnR5RGVzY3JpcHRvcicpO1xudmFyIElzRGF0YURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL0lzRGF0YURlc2NyaXB0b3InKTtcbnZhciBJc1Byb3BlcnR5S2V5ID0gcmVxdWlyZSgnLi9Jc1Byb3BlcnR5S2V5Jyk7XG52YXIgU2FtZVZhbHVlID0gcmVxdWlyZSgnLi9TYW1lVmFsdWUnKTtcbnZhciBUeXBlID0gcmVxdWlyZSgnLi9UeXBlJyk7XG5cbi8vIGh0dHBzOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1jcmVhdGVtZXRob2Rwcm9wZXJ0eVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIENyZWF0ZU1ldGhvZFByb3BlcnR5KE8sIFAsIFYpIHtcblx0aWYgKFR5cGUoTykgIT09ICdPYmplY3QnKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IFR5cGUoTykgaXMgbm90IE9iamVjdCcpO1xuXHR9XG5cblx0aWYgKCFJc1Byb3BlcnR5S2V5KFApKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IElzUHJvcGVydHlLZXkoUCkgaXMgbm90IHRydWUnKTtcblx0fVxuXG5cdHZhciBuZXdEZXNjID0ge1xuXHRcdCdbW0NvbmZpZ3VyYWJsZV1dJzogdHJ1ZSxcblx0XHQnW1tFbnVtZXJhYmxlXV0nOiBmYWxzZSxcblx0XHQnW1tWYWx1ZV1dJzogVixcblx0XHQnW1tXcml0YWJsZV1dJzogdHJ1ZVxuXHR9O1xuXHRyZXR1cm4gRGVmaW5lT3duUHJvcGVydHkoXG5cdFx0SXNEYXRhRGVzY3JpcHRvcixcblx0XHRTYW1lVmFsdWUsXG5cdFx0RnJvbVByb3BlcnR5RGVzY3JpcHRvcixcblx0XHRPLFxuXHRcdFAsXG5cdFx0bmV3RGVzY1xuXHQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMnKSgpO1xuXG52YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYygnJVR5cGVFcnJvciUnKTtcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IEdldEludHJpbnNpYygnJUl0ZXJhdG9yUHJvdG90eXBlJScsIHRydWUpO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IEdldEludHJpbnNpYygnJU9iamVjdC5kZWZpbmVQcm9wZXJ0eSUnLCB0cnVlKTtcblxudmFyIEFkdmFuY2VTdHJpbmdJbmRleCA9IHJlcXVpcmUoJy4vQWR2YW5jZVN0cmluZ0luZGV4Jyk7XG52YXIgQ3JlYXRlSXRlclJlc3VsdE9iamVjdCA9IHJlcXVpcmUoJy4vQ3JlYXRlSXRlclJlc3VsdE9iamVjdCcpO1xudmFyIENyZWF0ZU1ldGhvZFByb3BlcnR5ID0gcmVxdWlyZSgnLi9DcmVhdGVNZXRob2RQcm9wZXJ0eScpO1xudmFyIEdldCA9IHJlcXVpcmUoJy4vR2V0Jyk7XG52YXIgT3JkaW5hcnlPYmplY3RDcmVhdGUgPSByZXF1aXJlKCcuL09yZGluYXJ5T2JqZWN0Q3JlYXRlJyk7XG52YXIgUmVnRXhwRXhlYyA9IHJlcXVpcmUoJy4vUmVnRXhwRXhlYycpO1xudmFyIFNldCA9IHJlcXVpcmUoJy4vU2V0Jyk7XG52YXIgVG9MZW5ndGggPSByZXF1aXJlKCcuL1RvTGVuZ3RoJyk7XG52YXIgVG9TdHJpbmcgPSByZXF1aXJlKCcuL1RvU3RyaW5nJyk7XG52YXIgVHlwZSA9IHJlcXVpcmUoJy4vVHlwZScpO1xuXG52YXIgU0xPVCA9IHJlcXVpcmUoJ2ludGVybmFsLXNsb3QnKTtcblxudmFyIFJlZ0V4cFN0cmluZ0l0ZXJhdG9yID0gZnVuY3Rpb24gUmVnRXhwU3RyaW5nSXRlcmF0b3IoUiwgUywgZ2xvYmFsLCBmdWxsVW5pY29kZSkge1xuXHRpZiAoVHlwZShTKSAhPT0gJ1N0cmluZycpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYFNgIG11c3QgYmUgYSBzdHJpbmcnKTtcblx0fVxuXHRpZiAoVHlwZShnbG9iYWwpICE9PSAnQm9vbGVhbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYGdsb2JhbGAgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblx0fVxuXHRpZiAoVHlwZShmdWxsVW5pY29kZSkgIT09ICdCb29sZWFuJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgZnVsbFVuaWNvZGVgIG11c3QgYmUgYSBib29sZWFuJyk7XG5cdH1cblx0U0xPVC5zZXQodGhpcywgJ1tbSXRlcmF0aW5nUmVnRXhwXV0nLCBSKTtcblx0U0xPVC5zZXQodGhpcywgJ1tbSXRlcmF0ZWRTdHJpbmddXScsIFMpO1xuXHRTTE9ULnNldCh0aGlzLCAnW1tHbG9iYWxdXScsIGdsb2JhbCk7XG5cdFNMT1Quc2V0KHRoaXMsICdbW1VuaWNvZGVdXScsIGZ1bGxVbmljb2RlKTtcblx0U0xPVC5zZXQodGhpcywgJ1tbRG9uZV1dJywgZmFsc2UpO1xufTtcblxuaWYgKEl0ZXJhdG9yUHJvdG90eXBlKSB7XG5cdFJlZ0V4cFN0cmluZ0l0ZXJhdG9yLnByb3RvdHlwZSA9IE9yZGluYXJ5T2JqZWN0Q3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbn1cblxudmFyIFJlZ0V4cFN0cmluZ0l0ZXJhdG9yTmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG5cdHZhciBPID0gdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1pbnZhbGlkLXRoaXNcblx0aWYgKFR5cGUoTykgIT09ICdPYmplY3QnKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ3JlY2VpdmVyIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG5cdH1cblx0aWYgKFxuXHRcdCEoTyBpbnN0YW5jZW9mIFJlZ0V4cFN0cmluZ0l0ZXJhdG9yKVxuICAgICAgICB8fCAhU0xPVC5oYXMoTywgJ1tbSXRlcmF0aW5nUmVnRXhwXV0nKVxuICAgICAgICB8fCAhU0xPVC5oYXMoTywgJ1tbSXRlcmF0ZWRTdHJpbmddXScpXG4gICAgICAgIHx8ICFTTE9ULmhhcyhPLCAnW1tHbG9iYWxdXScpXG4gICAgICAgIHx8ICFTTE9ULmhhcyhPLCAnW1tVbmljb2RlXV0nKVxuICAgICAgICB8fCAhU0xPVC5oYXMoTywgJ1tbRG9uZV1dJylcblx0KSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1widGhpc1wiIHZhbHVlIG11c3QgYmUgYSBSZWdFeHBTdHJpbmdJdGVyYXRvciBpbnN0YW5jZScpO1xuXHR9XG5cdGlmIChTTE9ULmdldChPLCAnW1tEb25lXV0nKSkge1xuXHRcdHJldHVybiBDcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHVuZGVmaW5lZCwgdHJ1ZSk7XG5cdH1cblx0dmFyIFIgPSBTTE9ULmdldChPLCAnW1tJdGVyYXRpbmdSZWdFeHBdXScpO1xuXHR2YXIgUyA9IFNMT1QuZ2V0KE8sICdbW0l0ZXJhdGVkU3RyaW5nXV0nKTtcblx0dmFyIGdsb2JhbCA9IFNMT1QuZ2V0KE8sICdbW0dsb2JhbF1dJyk7XG5cdHZhciBmdWxsVW5pY29kZSA9IFNMT1QuZ2V0KE8sICdbW1VuaWNvZGVdXScpO1xuXHR2YXIgbWF0Y2ggPSBSZWdFeHBFeGVjKFIsIFMpO1xuXHRpZiAobWF0Y2ggPT09IG51bGwpIHtcblx0XHRTTE9ULnNldChPLCAnW1tEb25lXV0nLCB0cnVlKTtcblx0XHRyZXR1cm4gQ3JlYXRlSXRlclJlc3VsdE9iamVjdCh1bmRlZmluZWQsIHRydWUpO1xuXHR9XG5cdGlmIChnbG9iYWwpIHtcblx0XHR2YXIgbWF0Y2hTdHIgPSBUb1N0cmluZyhHZXQobWF0Y2gsICcwJykpO1xuXHRcdGlmIChtYXRjaFN0ciA9PT0gJycpIHtcblx0XHRcdHZhciB0aGlzSW5kZXggPSBUb0xlbmd0aChHZXQoUiwgJ2xhc3RJbmRleCcpKTtcblx0XHRcdHZhciBuZXh0SW5kZXggPSBBZHZhbmNlU3RyaW5nSW5kZXgoUywgdGhpc0luZGV4LCBmdWxsVW5pY29kZSk7XG5cdFx0XHRTZXQoUiwgJ2xhc3RJbmRleCcsIG5leHRJbmRleCwgdHJ1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiBDcmVhdGVJdGVyUmVzdWx0T2JqZWN0KG1hdGNoLCBmYWxzZSk7XG5cdH1cblx0U0xPVC5zZXQoTywgJ1tbRG9uZV1dJywgdHJ1ZSk7XG5cdHJldHVybiBDcmVhdGVJdGVyUmVzdWx0T2JqZWN0KG1hdGNoLCBmYWxzZSk7XG59O1xuQ3JlYXRlTWV0aG9kUHJvcGVydHkoUmVnRXhwU3RyaW5nSXRlcmF0b3IucHJvdG90eXBlLCAnbmV4dCcsIFJlZ0V4cFN0cmluZ0l0ZXJhdG9yTmV4dCk7XG5cbmlmIChoYXNTeW1ib2xzKSB7XG5cdGlmIChTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRpZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdFx0XHQkZGVmaW5lUHJvcGVydHkoUmVnRXhwU3RyaW5nSXRlcmF0b3IucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdFx0dmFsdWU6ICdSZWdFeHAgU3RyaW5nIEl0ZXJhdG9yJyxcblx0XHRcdFx0d3JpdGFibGU6IGZhbHNlXG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0UmVnRXhwU3RyaW5nSXRlcmF0b3IucHJvdG90eXBlW1N5bWJvbC50b1N0cmluZ1RhZ10gPSAnUmVnRXhwIFN0cmluZyBJdGVyYXRvcic7XG5cdFx0fVxuXHR9XG5cblx0aWYgKFN5bWJvbC5pdGVyYXRvciAmJiB0eXBlb2YgUmVnRXhwU3RyaW5nSXRlcmF0b3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gIT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgaXRlcmF0b3JGbiA9IGZ1bmN0aW9uIFN5bWJvbEl0ZXJhdG9yKCkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRDcmVhdGVNZXRob2RQcm9wZXJ0eShSZWdFeHBTdHJpbmdJdGVyYXRvci5wcm90b3R5cGUsIFN5bWJvbC5pdGVyYXRvciwgaXRlcmF0b3JGbik7XG5cdH1cbn1cblxuLy8gaHR0cHM6Ly8yNjIuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy8xMS4wLyNzZWMtY3JlYXRlcmVnZXhwc3RyaW5naXRlcmF0b3Jcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gQ3JlYXRlUmVnRXhwU3RyaW5nSXRlcmF0b3IoUiwgUywgZ2xvYmFsLCBmdWxsVW5pY29kZSkge1xuXHQvLyBhc3NlcnQgUi5nbG9iYWwgPT09IGdsb2JhbCAmJiBSLnVuaWNvZGUgPT09IGZ1bGxVbmljb2RlP1xuXHRyZXR1cm4gbmV3IFJlZ0V4cFN0cmluZ0l0ZXJhdG9yKFIsIFMsIGdsb2JhbCwgZnVsbFVuaWNvZGUpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG5cbnZhciBpc1Byb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNQcm9wZXJ0eURlc2NyaXB0b3InKTtcbnZhciBEZWZpbmVPd25Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvRGVmaW5lT3duUHJvcGVydHknKTtcblxudmFyIEZyb21Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL0Zyb21Qcm9wZXJ0eURlc2NyaXB0b3InKTtcbnZhciBJc0FjY2Vzc29yRGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vSXNBY2Nlc3NvckRlc2NyaXB0b3InKTtcbnZhciBJc0RhdGFEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9Jc0RhdGFEZXNjcmlwdG9yJyk7XG52YXIgSXNQcm9wZXJ0eUtleSA9IHJlcXVpcmUoJy4vSXNQcm9wZXJ0eUtleScpO1xudmFyIFNhbWVWYWx1ZSA9IHJlcXVpcmUoJy4vU2FtZVZhbHVlJyk7XG52YXIgVG9Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL1RvUHJvcGVydHlEZXNjcmlwdG9yJyk7XG52YXIgVHlwZSA9IHJlcXVpcmUoJy4vVHlwZScpO1xuXG4vLyBodHRwczovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtZGVmaW5lcHJvcGVydHlvcnRocm93XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gRGVmaW5lUHJvcGVydHlPclRocm93KE8sIFAsIGRlc2MpIHtcblx0aWYgKFR5cGUoTykgIT09ICdPYmplY3QnKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IFR5cGUoTykgaXMgbm90IE9iamVjdCcpO1xuXHR9XG5cblx0aWYgKCFJc1Byb3BlcnR5S2V5KFApKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IElzUHJvcGVydHlLZXkoUCkgaXMgbm90IHRydWUnKTtcblx0fVxuXG5cdHZhciBEZXNjID0gaXNQcm9wZXJ0eURlc2NyaXB0b3Ioe1xuXHRcdFR5cGU6IFR5cGUsXG5cdFx0SXNEYXRhRGVzY3JpcHRvcjogSXNEYXRhRGVzY3JpcHRvcixcblx0XHRJc0FjY2Vzc29yRGVzY3JpcHRvcjogSXNBY2Nlc3NvckRlc2NyaXB0b3Jcblx0fSwgZGVzYykgPyBkZXNjIDogVG9Qcm9wZXJ0eURlc2NyaXB0b3IoZGVzYyk7XG5cdGlmICghaXNQcm9wZXJ0eURlc2NyaXB0b3Ioe1xuXHRcdFR5cGU6IFR5cGUsXG5cdFx0SXNEYXRhRGVzY3JpcHRvcjogSXNEYXRhRGVzY3JpcHRvcixcblx0XHRJc0FjY2Vzc29yRGVzY3JpcHRvcjogSXNBY2Nlc3NvckRlc2NyaXB0b3Jcblx0fSwgRGVzYykpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogRGVzYyBpcyBub3QgYSB2YWxpZCBQcm9wZXJ0eSBEZXNjcmlwdG9yJyk7XG5cdH1cblxuXHRyZXR1cm4gRGVmaW5lT3duUHJvcGVydHkoXG5cdFx0SXNEYXRhRGVzY3JpcHRvcixcblx0XHRTYW1lVmFsdWUsXG5cdFx0RnJvbVByb3BlcnR5RGVzY3JpcHRvcixcblx0XHRPLFxuXHRcdFAsXG5cdFx0RGVzY1xuXHQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG5cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gcmVxdWlyZSgnLi4vaGVscGVycy9tYXhTYWZlSW50ZWdlcicpO1xuXG52YXIgQ2FsbCA9IHJlcXVpcmUoJy4vQ2FsbCcpO1xudmFyIENyZWF0ZURhdGFQcm9wZXJ0eU9yVGhyb3cgPSByZXF1aXJlKCcuL0NyZWF0ZURhdGFQcm9wZXJ0eU9yVGhyb3cnKTtcbnZhciBHZXQgPSByZXF1aXJlKCcuL0dldCcpO1xudmFyIEhhc1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9IYXNQcm9wZXJ0eScpO1xudmFyIElzQXJyYXkgPSByZXF1aXJlKCcuL0lzQXJyYXknKTtcbnZhciBMZW5ndGhPZkFycmF5TGlrZSA9IHJlcXVpcmUoJy4vTGVuZ3RoT2ZBcnJheUxpa2UnKTtcbnZhciBUb1N0cmluZyA9IHJlcXVpcmUoJy4vVG9TdHJpbmcnKTtcblxuLy8gaHR0cHM6Ly8yNjIuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy8xMS4wLyNzZWMtZmxhdHRlbmludG9hcnJheVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBGbGF0dGVuSW50b0FycmF5KHRhcmdldCwgc291cmNlLCBzb3VyY2VMZW4sIHN0YXJ0LCBkZXB0aCkge1xuXHR2YXIgbWFwcGVyRnVuY3Rpb247XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gNSkge1xuXHRcdG1hcHBlckZ1bmN0aW9uID0gYXJndW1lbnRzWzVdO1xuXHR9XG5cblx0dmFyIHRhcmdldEluZGV4ID0gc3RhcnQ7XG5cdHZhciBzb3VyY2VJbmRleCA9IDA7XG5cdHdoaWxlIChzb3VyY2VJbmRleCA8IHNvdXJjZUxlbikge1xuXHRcdHZhciBQID0gVG9TdHJpbmcoc291cmNlSW5kZXgpO1xuXHRcdHZhciBleGlzdHMgPSBIYXNQcm9wZXJ0eShzb3VyY2UsIFApO1xuXHRcdGlmIChleGlzdHMgPT09IHRydWUpIHtcblx0XHRcdHZhciBlbGVtZW50ID0gR2V0KHNvdXJjZSwgUCk7XG5cdFx0XHRpZiAodHlwZW9mIG1hcHBlckZ1bmN0aW9uICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSA2KSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IHRoaXNBcmcgaXMgcmVxdWlyZWQgd2hlbiBtYXBwZXJGdW5jdGlvbiBpcyBwcm92aWRlZCcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsZW1lbnQgPSBDYWxsKG1hcHBlckZ1bmN0aW9uLCBhcmd1bWVudHNbNl0sIFtlbGVtZW50LCBzb3VyY2VJbmRleCwgc291cmNlXSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgc2hvdWxkRmxhdHRlbiA9IGZhbHNlO1xuXHRcdFx0aWYgKGRlcHRoID4gMCkge1xuXHRcdFx0XHRzaG91bGRGbGF0dGVuID0gSXNBcnJheShlbGVtZW50KTtcblx0XHRcdH1cblx0XHRcdGlmIChzaG91bGRGbGF0dGVuKSB7XG5cdFx0XHRcdHZhciBlbGVtZW50TGVuID0gTGVuZ3RoT2ZBcnJheUxpa2UoZWxlbWVudCk7XG5cdFx0XHRcdHRhcmdldEluZGV4ID0gRmxhdHRlbkludG9BcnJheSh0YXJnZXQsIGVsZW1lbnQsIGVsZW1lbnRMZW4sIHRhcmdldEluZGV4LCBkZXB0aCAtIDEpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRhcmdldEluZGV4ID49IE1BWF9TQUZFX0lOVEVHRVIpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW5kZXggdG9vIGxhcmdlJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Q3JlYXRlRGF0YVByb3BlcnR5T3JUaHJvdyh0YXJnZXQsIFRvU3RyaW5nKHRhcmdldEluZGV4KSwgZWxlbWVudCk7XG5cdFx0XHRcdHRhcmdldEluZGV4ICs9IDE7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHNvdXJjZUluZGV4ICs9IDE7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0SW5kZXg7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzZXJ0UmVjb3JkID0gcmVxdWlyZSgnLi4vaGVscGVycy9hc3NlcnRSZWNvcmQnKTtcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuL1R5cGUnKTtcblxuLy8gaHR0cHM6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWZyb21wcm9wZXJ0eWRlc2NyaXB0b3JcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBGcm9tUHJvcGVydHlEZXNjcmlwdG9yKERlc2MpIHtcblx0aWYgKHR5cGVvZiBEZXNjID09PSAndW5kZWZpbmVkJykge1xuXHRcdHJldHVybiBEZXNjO1xuXHR9XG5cblx0YXNzZXJ0UmVjb3JkKFR5cGUsICdQcm9wZXJ0eSBEZXNjcmlwdG9yJywgJ0Rlc2MnLCBEZXNjKTtcblxuXHR2YXIgb2JqID0ge307XG5cdGlmICgnW1tWYWx1ZV1dJyBpbiBEZXNjKSB7XG5cdFx0b2JqLnZhbHVlID0gRGVzY1snW1tWYWx1ZV1dJ107XG5cdH1cblx0aWYgKCdbW1dyaXRhYmxlXV0nIGluIERlc2MpIHtcblx0XHRvYmoud3JpdGFibGUgPSBEZXNjWydbW1dyaXRhYmxlXV0nXTtcblx0fVxuXHRpZiAoJ1tbR2V0XV0nIGluIERlc2MpIHtcblx0XHRvYmouZ2V0ID0gRGVzY1snW1tHZXRdXSddO1xuXHR9XG5cdGlmICgnW1tTZXRdXScgaW4gRGVzYykge1xuXHRcdG9iai5zZXQgPSBEZXNjWydbW1NldF1dJ107XG5cdH1cblx0aWYgKCdbW0VudW1lcmFibGVdXScgaW4gRGVzYykge1xuXHRcdG9iai5lbnVtZXJhYmxlID0gRGVzY1snW1tFbnVtZXJhYmxlXV0nXTtcblx0fVxuXHRpZiAoJ1tbQ29uZmlndXJhYmxlXV0nIGluIERlc2MpIHtcblx0XHRvYmouY29uZmlndXJhYmxlID0gRGVzY1snW1tDb25maWd1cmFibGVdXSddO1xuXHR9XG5cdHJldHVybiBvYmo7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYygnJVR5cGVFcnJvciUnKTtcblxudmFyIGluc3BlY3QgPSByZXF1aXJlKCdvYmplY3QtaW5zcGVjdCcpO1xuXG52YXIgSXNQcm9wZXJ0eUtleSA9IHJlcXVpcmUoJy4vSXNQcm9wZXJ0eUtleScpO1xudmFyIFR5cGUgPSByZXF1aXJlKCcuL1R5cGUnKTtcblxuLyoqXG4gKiA3LjMuMSBHZXQgKE8sIFApIC0gaHR0cHM6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWdldC1vLXBcbiAqIDEuIEFzc2VydDogVHlwZShPKSBpcyBPYmplY3QuXG4gKiAyLiBBc3NlcnQ6IElzUHJvcGVydHlLZXkoUCkgaXMgdHJ1ZS5cbiAqIDMuIFJldHVybiBPLltbR2V0XV0oUCwgTykuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBHZXQoTywgUCkge1xuXHQvLyA3LjMuMS4xXG5cdGlmIChUeXBlKE8pICE9PSAnT2JqZWN0Jykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdBc3NlcnRpb24gZmFpbGVkOiBUeXBlKE8pIGlzIG5vdCBPYmplY3QnKTtcblx0fVxuXHQvLyA3LjMuMS4yXG5cdGlmICghSXNQcm9wZXJ0eUtleShQKSkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdBc3NlcnRpb24gZmFpbGVkOiBJc1Byb3BlcnR5S2V5KFApIGlzIG5vdCB0cnVlLCBnb3QgJyArIGluc3BlY3QoUCkpO1xuXHR9XG5cdC8vIDcuMy4xLjNcblx0cmV0dXJuIE9bUF07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYygnJVR5cGVFcnJvciUnKTtcbnZhciAkYXN5bmNJdGVyYXRvciA9IEdldEludHJpbnNpYygnJVN5bWJvbC5hc3luY0l0ZXJhdG9yJScsIHRydWUpO1xuXG52YXIgaW5zcGVjdCA9IHJlcXVpcmUoJ29iamVjdC1pbnNwZWN0Jyk7XG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzJykoKTtcblxudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gcmVxdWlyZSgnLi4vaGVscGVycy9nZXRJdGVyYXRvck1ldGhvZCcpO1xudmFyIEFkdmFuY2VTdHJpbmdJbmRleCA9IHJlcXVpcmUoJy4vQWR2YW5jZVN0cmluZ0luZGV4Jyk7XG52YXIgQ2FsbCA9IHJlcXVpcmUoJy4vQ2FsbCcpO1xudmFyIEdldE1ldGhvZCA9IHJlcXVpcmUoJy4vR2V0TWV0aG9kJyk7XG52YXIgSXNBcnJheSA9IHJlcXVpcmUoJy4vSXNBcnJheScpO1xudmFyIFR5cGUgPSByZXF1aXJlKCcuL1R5cGUnKTtcblxuLy8gaHR0cHM6Ly8yNjIuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy85LjAvI3NlYy1nZXRpdGVyYXRvclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBHZXRJdGVyYXRvcihvYmosIGhpbnQsIG1ldGhvZCkge1xuXHR2YXIgYWN0dWFsSGludCA9IGhpbnQ7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuXHRcdGFjdHVhbEhpbnQgPSAnc3luYyc7XG5cdH1cblx0aWYgKGFjdHVhbEhpbnQgIT09ICdzeW5jJyAmJiBhY3R1YWxIaW50ICE9PSAnYXN5bmMnKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJBc3NlcnRpb24gZmFpbGVkOiBgaGludGAgbXVzdCBiZSBvbmUgb2YgJ3N5bmMnIG9yICdhc3luYycsIGdvdCBcIiArIGluc3BlY3QoaGludCkpO1xuXHR9XG5cblx0dmFyIGFjdHVhbE1ldGhvZCA9IG1ldGhvZDtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG5cdFx0aWYgKGFjdHVhbEhpbnQgPT09ICdhc3luYycpIHtcblx0XHRcdGlmIChoYXNTeW1ib2xzICYmICRhc3luY0l0ZXJhdG9yKSB7XG5cdFx0XHRcdGFjdHVhbE1ldGhvZCA9IEdldE1ldGhvZChvYmosICRhc3luY0l0ZXJhdG9yKTtcblx0XHRcdH1cblx0XHRcdGlmIChhY3R1YWxNZXRob2QgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcihcImFzeW5jIGZyb20gc3luYyBpdGVyYXRvcnMgYXJlbid0IGN1cnJlbnRseSBzdXBwb3J0ZWRcIik7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFjdHVhbE1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kKFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0QWR2YW5jZVN0cmluZ0luZGV4OiBBZHZhbmNlU3RyaW5nSW5kZXgsXG5cdFx0XHRcdFx0R2V0TWV0aG9kOiBHZXRNZXRob2QsXG5cdFx0XHRcdFx0SXNBcnJheTogSXNBcnJheSxcblx0XHRcdFx0XHRUeXBlOiBUeXBlXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG9ialxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblx0dmFyIGl0ZXJhdG9yID0gQ2FsbChhY3R1YWxNZXRob2QsIG9iaik7XG5cdGlmIChUeXBlKGl0ZXJhdG9yKSAhPT0gJ09iamVjdCcpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCByZXR1cm4gYW4gb2JqZWN0Jyk7XG5cdH1cblxuXHRyZXR1cm4gaXRlcmF0b3I7XG5cblx0Ly8gVE9ETzogVGhpcyBzaG91bGQgcmV0dXJuIGFuIEl0ZXJhdG9yUmVjb3JkXG5cdC8qXG5cdHZhciBuZXh0TWV0aG9kID0gR2V0VihpdGVyYXRvciwgJ25leHQnKTtcblx0cmV0dXJuIHtcblx0XHQnW1tJdGVyYXRvcl1dJzogaXRlcmF0b3IsXG5cdFx0J1tbTmV4dE1ldGhvZF1dJzogbmV4dE1ldGhvZCxcblx0XHQnW1tEb25lXV0nOiBmYWxzZVxuXHR9O1xuXHQqL1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG5cbnZhciBHZXRWID0gcmVxdWlyZSgnLi9HZXRWJyk7XG52YXIgSXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4vSXNDYWxsYWJsZScpO1xudmFyIElzUHJvcGVydHlLZXkgPSByZXF1aXJlKCcuL0lzUHJvcGVydHlLZXknKTtcblxuLyoqXG4gKiA3LjMuOSAtIGh0dHBzOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1nZXRtZXRob2RcbiAqIDEuIEFzc2VydDogSXNQcm9wZXJ0eUtleShQKSBpcyB0cnVlLlxuICogMi4gTGV0IGZ1bmMgYmUgR2V0VihPLCBQKS5cbiAqIDMuIFJldHVybklmQWJydXB0KGZ1bmMpLlxuICogNC4gSWYgZnVuYyBpcyBlaXRoZXIgdW5kZWZpbmVkIG9yIG51bGwsIHJldHVybiB1bmRlZmluZWQuXG4gKiA1LiBJZiBJc0NhbGxhYmxlKGZ1bmMpIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gKiA2LiBSZXR1cm4gZnVuYy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEdldE1ldGhvZChPLCBQKSB7XG5cdC8vIDcuMy45LjFcblx0aWYgKCFJc1Byb3BlcnR5S2V5KFApKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IElzUHJvcGVydHlLZXkoUCkgaXMgbm90IHRydWUnKTtcblx0fVxuXG5cdC8vIDcuMy45LjJcblx0dmFyIGZ1bmMgPSBHZXRWKE8sIFApO1xuXG5cdC8vIDcuMy45LjRcblx0aWYgKGZ1bmMgPT0gbnVsbCkge1xuXHRcdHJldHVybiB2b2lkIDA7XG5cdH1cblxuXHQvLyA3LjMuOS41XG5cdGlmICghSXNDYWxsYWJsZShmdW5jKSkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKFAgKyAnaXMgbm90IGEgZnVuY3Rpb24nKTtcblx0fVxuXG5cdC8vIDcuMy45LjZcblx0cmV0dXJuIGZ1bmM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYygnJVR5cGVFcnJvciUnKTtcblxudmFyIElzUHJvcGVydHlLZXkgPSByZXF1aXJlKCcuL0lzUHJvcGVydHlLZXknKTtcbnZhciBUb09iamVjdCA9IHJlcXVpcmUoJy4vVG9PYmplY3QnKTtcblxuLyoqXG4gKiA3LjMuMiBHZXRWIChWLCBQKVxuICogMS4gQXNzZXJ0OiBJc1Byb3BlcnR5S2V5KFApIGlzIHRydWUuXG4gKiAyLiBMZXQgTyBiZSBUb09iamVjdChWKS5cbiAqIDMuIFJldHVybklmQWJydXB0KE8pLlxuICogNC4gUmV0dXJuIE8uW1tHZXRdXShQLCBWKS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEdldFYoViwgUCkge1xuXHQvLyA3LjMuMi4xXG5cdGlmICghSXNQcm9wZXJ0eUtleShQKSkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdBc3NlcnRpb24gZmFpbGVkOiBJc1Byb3BlcnR5S2V5KFApIGlzIG5vdCB0cnVlJyk7XG5cdH1cblxuXHQvLyA3LjMuMi4yLTNcblx0dmFyIE8gPSBUb09iamVjdChWKTtcblxuXHQvLyA3LjMuMi40XG5cdHJldHVybiBPW1BdO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG5cbnZhciBJc1Byb3BlcnR5S2V5ID0gcmVxdWlyZSgnLi9Jc1Byb3BlcnR5S2V5Jyk7XG52YXIgVHlwZSA9IHJlcXVpcmUoJy4vVHlwZScpO1xuXG4vLyBodHRwczovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtaGFzcHJvcGVydHlcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBIYXNQcm9wZXJ0eShPLCBQKSB7XG5cdGlmIChUeXBlKE8pICE9PSAnT2JqZWN0Jykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdBc3NlcnRpb24gZmFpbGVkOiBgT2AgbXVzdCBiZSBhbiBPYmplY3QnKTtcblx0fVxuXHRpZiAoIUlzUHJvcGVydHlLZXkoUCkpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogYFBgIG11c3QgYmUgYSBQcm9wZXJ0eSBLZXknKTtcblx0fVxuXHRyZXR1cm4gUCBpbiBPO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG5cbnZhciBDYWxsID0gcmVxdWlyZSgnLi9DYWxsJyk7XG52YXIgSXNBcnJheSA9IHJlcXVpcmUoJy4vSXNBcnJheScpO1xudmFyIEdldFYgPSByZXF1aXJlKCcuL0dldFYnKTtcbnZhciBJc1Byb3BlcnR5S2V5ID0gcmVxdWlyZSgnLi9Jc1Byb3BlcnR5S2V5Jyk7XG5cbi8vIGh0dHBzOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1pbnZva2VcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBJbnZva2UoTywgUCkge1xuXHRpZiAoIUlzUHJvcGVydHlLZXkoUCkpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogUCBtdXN0IGJlIGEgUHJvcGVydHkgS2V5Jyk7XG5cdH1cblx0dmFyIGFyZ3VtZW50c0xpc3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IFtdO1xuXHRpZiAoIUlzQXJyYXkoYXJndW1lbnRzTGlzdCkpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogb3B0aW9uYWwgYGFyZ3VtZW50c0xpc3RgLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIExpc3QnKTtcblx0fVxuXHR2YXIgZnVuYyA9IEdldFYoTywgUCk7XG5cdHJldHVybiBDYWxsKGZ1bmMsIE8sIGFyZ3VtZW50c0xpc3QpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IHJlcXVpcmUoJ2hhcycpO1xuXG52YXIgYXNzZXJ0UmVjb3JkID0gcmVxdWlyZSgnLi4vaGVscGVycy9hc3NlcnRSZWNvcmQnKTtcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuL1R5cGUnKTtcblxuLy8gaHR0cHM6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWlzYWNjZXNzb3JkZXNjcmlwdG9yXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gSXNBY2Nlc3NvckRlc2NyaXB0b3IoRGVzYykge1xuXHRpZiAodHlwZW9mIERlc2MgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0YXNzZXJ0UmVjb3JkKFR5cGUsICdQcm9wZXJ0eSBEZXNjcmlwdG9yJywgJ0Rlc2MnLCBEZXNjKTtcblxuXHRpZiAoIWhhcyhEZXNjLCAnW1tHZXRdXScpICYmICFoYXMoRGVzYywgJ1tbU2V0XV0nKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRBcnJheSA9IEdldEludHJpbnNpYygnJUFycmF5JScpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2xvYmFsLXJlcXVpcmVcbnZhciB0b1N0ciA9ICEkQXJyYXkuaXNBcnJheSAmJiByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJykoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcblxuLy8gaHR0cHM6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWlzYXJyYXlcblxubW9kdWxlLmV4cG9ydHMgPSAkQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBJc0FycmF5KGFyZ3VtZW50KSB7XG5cdHJldHVybiB0b1N0cihhcmd1bWVudCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBodHRwOi8vMjYyLmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvNS4xLyNzZWMtOS4xMVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2lzLWNhbGxhYmxlJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCcuLi9HZXRJbnRyaW5zaWMuanMnKTtcblxudmFyICRjb25zdHJ1Y3QgPSBHZXRJbnRyaW5zaWMoJyVSZWZsZWN0LmNvbnN0cnVjdCUnLCB0cnVlKTtcblxudmFyIERlZmluZVByb3BlcnR5T3JUaHJvdyA9IHJlcXVpcmUoJy4vRGVmaW5lUHJvcGVydHlPclRocm93Jyk7XG50cnkge1xuXHREZWZpbmVQcm9wZXJ0eU9yVGhyb3coe30sICcnLCB7ICdbW0dldF1dJzogZnVuY3Rpb24gKCkge30gfSk7XG59IGNhdGNoIChlKSB7XG5cdC8vIEFjY2Vzc29yIHByb3BlcnRpZXMgYXJlbid0IHN1cHBvcnRlZFxuXHREZWZpbmVQcm9wZXJ0eU9yVGhyb3cgPSBudWxsO1xufVxuXG4vLyBodHRwczovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtaXNjb25zdHJ1Y3RvclxuXG5pZiAoRGVmaW5lUHJvcGVydHlPclRocm93ICYmICRjb25zdHJ1Y3QpIHtcblx0dmFyIGlzQ29uc3RydWN0b3JNYXJrZXIgPSB7fTtcblx0dmFyIGJhZEFycmF5TGlrZSA9IHt9O1xuXHREZWZpbmVQcm9wZXJ0eU9yVGhyb3coYmFkQXJyYXlMaWtlLCAnbGVuZ3RoJywge1xuXHRcdCdbW0dldF1dJzogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhyb3cgaXNDb25zdHJ1Y3Rvck1hcmtlcjtcblx0XHR9LFxuXHRcdCdbW0VudW1lcmFibGVdXSc6IHRydWVcblx0fSk7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBJc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIGBSZWZsZWN0LmNvbnN0cnVjdGAgaW52b2tlcyBgSXNDb25zdHJ1Y3Rvcih0YXJnZXQpYCBiZWZvcmUgYEdldChhcmdzLCAnbGVuZ3RoJylgOlxuXHRcdFx0JGNvbnN0cnVjdChhcmd1bWVudCwgYmFkQXJyYXlMaWtlKTtcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdHJldHVybiBlcnIgPT09IGlzQ29uc3RydWN0b3JNYXJrZXI7XG5cdFx0fVxuXHR9O1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBJc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XG5cdFx0Ly8gdW5mb3J0dW5hdGVseSB0aGVyZSdzIG5vIHdheSB0byB0cnVseSBjaGVjayB0aGlzIHdpdGhvdXQgdHJ5L2NhdGNoIGBuZXcgYXJndW1lbnRgIGluIG9sZCBlbnZpcm9ubWVudHNcblx0XHRyZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09PSAnZnVuY3Rpb24nICYmICEhYXJndW1lbnQucHJvdG90eXBlO1xuXHR9O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gcmVxdWlyZSgnaGFzJyk7XG5cbnZhciBhc3NlcnRSZWNvcmQgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2Fzc2VydFJlY29yZCcpO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4vVHlwZScpO1xuXG4vLyBodHRwczovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtaXNkYXRhZGVzY3JpcHRvclxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIElzRGF0YURlc2NyaXB0b3IoRGVzYykge1xuXHRpZiAodHlwZW9mIERlc2MgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0YXNzZXJ0UmVjb3JkKFR5cGUsICdQcm9wZXJ0eSBEZXNjcmlwdG9yJywgJ0Rlc2MnLCBEZXNjKTtcblxuXHRpZiAoIWhhcyhEZXNjLCAnW1tWYWx1ZV1dJykgJiYgIWhhcyhEZXNjLCAnW1tXcml0YWJsZV1dJykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkT2JqZWN0ID0gR2V0SW50cmluc2ljKCclT2JqZWN0JScpO1xuXG52YXIgaXNQcmltaXRpdmUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2lzUHJpbWl0aXZlJyk7XG5cbnZhciAkcHJldmVudEV4dGVuc2lvbnMgPSAkT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zO1xudmFyICRpc0V4dGVuc2libGUgPSAkT2JqZWN0LmlzRXh0ZW5zaWJsZTtcblxuLy8gaHR0cHM6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWlzZXh0ZW5zaWJsZS1vXG5cbm1vZHVsZS5leHBvcnRzID0gJHByZXZlbnRFeHRlbnNpb25zXG5cdD8gZnVuY3Rpb24gSXNFeHRlbnNpYmxlKG9iaikge1xuXHRcdHJldHVybiAhaXNQcmltaXRpdmUob2JqKSAmJiAkaXNFeHRlbnNpYmxlKG9iaik7XG5cdH1cblx0OiBmdW5jdGlvbiBJc0V4dGVuc2libGUob2JqKSB7XG5cdFx0cmV0dXJuICFpc1ByaW1pdGl2ZShvYmopO1xuXHR9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWJzID0gcmVxdWlyZSgnLi9hYnMnKTtcbnZhciBmbG9vciA9IHJlcXVpcmUoJy4vZmxvb3InKTtcbnZhciBUeXBlID0gcmVxdWlyZSgnLi9UeXBlJyk7XG5cbnZhciAkaXNOYU4gPSByZXF1aXJlKCcuLi9oZWxwZXJzL2lzTmFOJyk7XG52YXIgJGlzRmluaXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Zpbml0ZScpO1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzaW50ZWdyYWxudW1iZXJcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBJc0ludGVncmFsTnVtYmVyKGFyZ3VtZW50KSB7XG5cdGlmIChUeXBlKGFyZ3VtZW50KSAhPT0gJ051bWJlcicgfHwgJGlzTmFOKGFyZ3VtZW50KSB8fCAhJGlzRmluaXRlKGFyZ3VtZW50KSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHR2YXIgYWJzVmFsdWUgPSBhYnMoYXJndW1lbnQpO1xuXHRyZXR1cm4gZmxvb3IoYWJzVmFsdWUpID09PSBhYnNWYWx1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIGh0dHBzOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1pc3Byb3BlcnR5a2V5XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gSXNQcm9wZXJ0eUtleShhcmd1bWVudCkge1xuXHRyZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYXJndW1lbnQgPT09ICdzeW1ib2wnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRtYXRjaCA9IEdldEludHJpbnNpYygnJVN5bWJvbC5tYXRjaCUnLCB0cnVlKTtcblxudmFyIGhhc1JlZ0V4cE1hdGNoZXIgPSByZXF1aXJlKCdpcy1yZWdleCcpO1xuXG52YXIgVG9Cb29sZWFuID0gcmVxdWlyZSgnLi9Ub0Jvb2xlYW4nKTtcblxuLy8gaHR0cHM6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWlzcmVnZXhwXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gSXNSZWdFeHAoYXJndW1lbnQpIHtcblx0aWYgKCFhcmd1bWVudCB8fCB0eXBlb2YgYXJndW1lbnQgIT09ICdvYmplY3QnKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGlmICgkbWF0Y2gpIHtcblx0XHR2YXIgaXNSZWdFeHAgPSBhcmd1bWVudFskbWF0Y2hdO1xuXHRcdGlmICh0eXBlb2YgaXNSZWdFeHAgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gVG9Cb29sZWFuKGlzUmVnRXhwKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGhhc1JlZ0V4cE1hdGNoZXIoYXJndW1lbnQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG5cbnZhciBDYWxsID0gcmVxdWlyZSgnLi9DYWxsJyk7XG52YXIgR2V0TWV0aG9kID0gcmVxdWlyZSgnLi9HZXRNZXRob2QnKTtcbnZhciBJc0NhbGxhYmxlID0gcmVxdWlyZSgnLi9Jc0NhbGxhYmxlJyk7XG52YXIgVHlwZSA9IHJlcXVpcmUoJy4vVHlwZScpO1xuXG4vLyBodHRwczovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtaXRlcmF0b3JjbG9zZVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pIHtcblx0aWYgKFR5cGUoaXRlcmF0b3IpICE9PSAnT2JqZWN0Jykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdBc3NlcnRpb24gZmFpbGVkOiBUeXBlKGl0ZXJhdG9yKSBpcyBub3QgT2JqZWN0Jyk7XG5cdH1cblx0aWYgKCFJc0NhbGxhYmxlKGNvbXBsZXRpb24pKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IGNvbXBsZXRpb24gaXMgbm90IGEgdGh1bmsgZm9yIGEgQ29tcGxldGlvbiBSZWNvcmQnKTtcblx0fVxuXHR2YXIgY29tcGxldGlvblRodW5rID0gY29tcGxldGlvbjtcblxuXHR2YXIgaXRlcmF0b3JSZXR1cm4gPSBHZXRNZXRob2QoaXRlcmF0b3IsICdyZXR1cm4nKTtcblxuXHRpZiAodHlwZW9mIGl0ZXJhdG9yUmV0dXJuID09PSAndW5kZWZpbmVkJykge1xuXHRcdHJldHVybiBjb21wbGV0aW9uVGh1bmsoKTtcblx0fVxuXG5cdHZhciBjb21wbGV0aW9uUmVjb3JkO1xuXHR0cnkge1xuXHRcdHZhciBpbm5lclJlc3VsdCA9IENhbGwoaXRlcmF0b3JSZXR1cm4sIGl0ZXJhdG9yLCBbXSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBpZiB3ZSBoaXQgaGVyZSwgdGhlbiBcImVcIiBpcyB0aGUgaW5uZXJSZXN1bHQgY29tcGxldGlvbiB0aGF0IG5lZWRzIHJlLXRocm93aW5nXG5cblx0XHQvLyBpZiB0aGUgY29tcGxldGlvbiBpcyBvZiB0eXBlIFwidGhyb3dcIiwgdGhpcyB3aWxsIHRocm93LlxuXHRcdGNvbXBsZXRpb25UaHVuaygpO1xuXHRcdGNvbXBsZXRpb25UaHVuayA9IG51bGw7IC8vIGVuc3VyZSBpdCdzIG5vdCBjYWxsZWQgdHdpY2UuXG5cblx0XHQvLyBpZiBub3QsIHRoZW4gcmV0dXJuIHRoZSBpbm5lclJlc3VsdCBjb21wbGV0aW9uXG5cdFx0dGhyb3cgZTtcblx0fVxuXHRjb21wbGV0aW9uUmVjb3JkID0gY29tcGxldGlvblRodW5rKCk7IC8vIGlmIGlubmVyUmVzdWx0IHdvcmtlZCwgdGhlbiB0aHJvdyBpZiB0aGUgY29tcGxldGlvbiBkb2VzXG5cdGNvbXBsZXRpb25UaHVuayA9IG51bGw7IC8vIGVuc3VyZSBpdCdzIG5vdCBjYWxsZWQgdHdpY2UuXG5cblx0aWYgKFR5cGUoaW5uZXJSZXN1bHQpICE9PSAnT2JqZWN0Jykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpdGVyYXRvciAucmV0dXJuIG11c3QgcmV0dXJuIGFuIG9iamVjdCcpO1xuXHR9XG5cblx0cmV0dXJuIGNvbXBsZXRpb25SZWNvcmQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYygnJVR5cGVFcnJvciUnKTtcblxudmFyIEdldCA9IHJlcXVpcmUoJy4vR2V0Jyk7XG52YXIgVG9Cb29sZWFuID0gcmVxdWlyZSgnLi9Ub0Jvb2xlYW4nKTtcbnZhciBUeXBlID0gcmVxdWlyZSgnLi9UeXBlJyk7XG5cbi8vIGh0dHBzOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1pdGVyYXRvcmNvbXBsZXRlXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gSXRlcmF0b3JDb21wbGV0ZShpdGVyUmVzdWx0KSB7XG5cdGlmIChUeXBlKGl0ZXJSZXN1bHQpICE9PSAnT2JqZWN0Jykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdBc3NlcnRpb24gZmFpbGVkOiBUeXBlKGl0ZXJSZXN1bHQpIGlzIG5vdCBPYmplY3QnKTtcblx0fVxuXHRyZXR1cm4gVG9Cb29sZWFuKEdldChpdGVyUmVzdWx0LCAnZG9uZScpKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkVHlwZUVycm9yID0gR2V0SW50cmluc2ljKCclVHlwZUVycm9yJScpO1xuXG52YXIgSW52b2tlID0gcmVxdWlyZSgnLi9JbnZva2UnKTtcbnZhciBUeXBlID0gcmVxdWlyZSgnLi9UeXBlJyk7XG5cbi8vIGh0dHBzOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1pdGVyYXRvcm5leHRcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBJdGVyYXRvck5leHQoaXRlcmF0b3IsIHZhbHVlKSB7XG5cdHZhciByZXN1bHQgPSBJbnZva2UoaXRlcmF0b3IsICduZXh0JywgYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBbXSA6IFt2YWx1ZV0pO1xuXHRpZiAoVHlwZShyZXN1bHQpICE9PSAnT2JqZWN0Jykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpdGVyYXRvciBuZXh0IG11c3QgcmV0dXJuIGFuIG9iamVjdCcpO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgSXRlcmF0b3JDb21wbGV0ZSA9IHJlcXVpcmUoJy4vSXRlcmF0b3JDb21wbGV0ZScpO1xudmFyIEl0ZXJhdG9yTmV4dCA9IHJlcXVpcmUoJy4vSXRlcmF0b3JOZXh0Jyk7XG5cbi8vIGh0dHBzOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1pdGVyYXRvcnN0ZXBcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBJdGVyYXRvclN0ZXAoaXRlcmF0b3IpIHtcblx0dmFyIHJlc3VsdCA9IEl0ZXJhdG9yTmV4dChpdGVyYXRvcik7XG5cdHZhciBkb25lID0gSXRlcmF0b3JDb21wbGV0ZShyZXN1bHQpO1xuXHRyZXR1cm4gZG9uZSA9PT0gdHJ1ZSA/IGZhbHNlIDogcmVzdWx0O1xufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYygnJVR5cGVFcnJvciUnKTtcblxudmFyIEdldCA9IHJlcXVpcmUoJy4vR2V0Jyk7XG52YXIgVHlwZSA9IHJlcXVpcmUoJy4vVHlwZScpO1xuXG4vLyBodHRwczovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtaXRlcmF0b3J2YWx1ZVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEl0ZXJhdG9yVmFsdWUoaXRlclJlc3VsdCkge1xuXHRpZiAoVHlwZShpdGVyUmVzdWx0KSAhPT0gJ09iamVjdCcpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogVHlwZShpdGVyUmVzdWx0KSBpcyBub3QgT2JqZWN0Jyk7XG5cdH1cblx0cmV0dXJuIEdldChpdGVyUmVzdWx0LCAndmFsdWUnKTtcbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG5cbnZhciBHZXQgPSByZXF1aXJlKCcuL0dldCcpO1xudmFyIFRvTGVuZ3RoID0gcmVxdWlyZSgnLi9Ub0xlbmd0aCcpO1xudmFyIFR5cGUgPSByZXF1aXJlKCcuL1R5cGUnKTtcblxuLy8gaHR0cHM6Ly8yNjIuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy8xMS4wLyNzZWMtbGVuZ3Rob2ZhcnJheWxpa2VcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBMZW5ndGhPZkFycmF5TGlrZShvYmopIHtcblx0aWYgKFR5cGUob2JqKSAhPT0gJ09iamVjdCcpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogYG9iamAgbXVzdCBiZSBhbiBPYmplY3QnKTtcblx0fVxuXHRyZXR1cm4gVG9MZW5ndGgoR2V0KG9iaiwgJ2xlbmd0aCcpKTtcbn07XG5cbi8vIFRPRE86IHVzZSB0aGlzIGFsbCBvdmVyXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkZ09QRCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJyk7XG52YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYygnJVR5cGVFcnJvciUnKTtcblxudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICRpc0VudW1lcmFibGUgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUnKTtcblxudmFyIGhhcyA9IHJlcXVpcmUoJ2hhcycpO1xuXG52YXIgSXNBcnJheSA9IHJlcXVpcmUoJy4vSXNBcnJheScpO1xudmFyIElzUHJvcGVydHlLZXkgPSByZXF1aXJlKCcuL0lzUHJvcGVydHlLZXknKTtcbnZhciBJc1JlZ0V4cCA9IHJlcXVpcmUoJy4vSXNSZWdFeHAnKTtcbnZhciBUb1Byb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vVG9Qcm9wZXJ0eURlc2NyaXB0b3InKTtcbnZhciBUeXBlID0gcmVxdWlyZSgnLi9UeXBlJyk7XG5cbi8vIGh0dHBzOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vcmRpbmFyeWdldG93bnByb3BlcnR5XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gT3JkaW5hcnlHZXRPd25Qcm9wZXJ0eShPLCBQKSB7XG5cdGlmIChUeXBlKE8pICE9PSAnT2JqZWN0Jykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdBc3NlcnRpb24gZmFpbGVkOiBPIG11c3QgYmUgYW4gT2JqZWN0Jyk7XG5cdH1cblx0aWYgKCFJc1Byb3BlcnR5S2V5KFApKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IFAgbXVzdCBiZSBhIFByb3BlcnR5IEtleScpO1xuXHR9XG5cdGlmICghaGFzKE8sIFApKSB7XG5cdFx0cmV0dXJuIHZvaWQgMDtcblx0fVxuXHRpZiAoISRnT1BEKSB7XG5cdFx0Ly8gRVMzIC8gSUUgOCBmYWxsYmFja1xuXHRcdHZhciBhcnJheUxlbmd0aCA9IElzQXJyYXkoTykgJiYgUCA9PT0gJ2xlbmd0aCc7XG5cdFx0dmFyIHJlZ2V4TGFzdEluZGV4ID0gSXNSZWdFeHAoTykgJiYgUCA9PT0gJ2xhc3RJbmRleCc7XG5cdFx0cmV0dXJuIHtcblx0XHRcdCdbW0NvbmZpZ3VyYWJsZV1dJzogIShhcnJheUxlbmd0aCB8fCByZWdleExhc3RJbmRleCksXG5cdFx0XHQnW1tFbnVtZXJhYmxlXV0nOiAkaXNFbnVtZXJhYmxlKE8sIFApLFxuXHRcdFx0J1tbVmFsdWVdXSc6IE9bUF0sXG5cdFx0XHQnW1tXcml0YWJsZV1dJzogdHJ1ZVxuXHRcdH07XG5cdH1cblx0cmV0dXJuIFRvUHJvcGVydHlEZXNjcmlwdG9yKCRnT1BEKE8sIFApKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkT2JqZWN0Q3JlYXRlID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmNyZWF0ZSUnLCB0cnVlKTtcbnZhciAkVHlwZUVycm9yID0gR2V0SW50cmluc2ljKCclVHlwZUVycm9yJScpO1xudmFyICRTeW50YXhFcnJvciA9IEdldEludHJpbnNpYygnJVN5bnRheEVycm9yJScpO1xuXG52YXIgSXNBcnJheSA9IHJlcXVpcmUoJy4vSXNBcnJheScpO1xudmFyIFR5cGUgPSByZXF1aXJlKCcuL1R5cGUnKTtcblxudmFyIGhhc1Byb3RvID0gISh7IF9fcHJvdG9fXzogbnVsbCB9IGluc3RhbmNlb2YgT2JqZWN0KTtcblxuLy8gaHR0cHM6Ly8yNjIuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy82LjAvI3NlYy1vYmplY3RjcmVhdGVcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBPcmRpbmFyeU9iamVjdENyZWF0ZShwcm90bykge1xuXHRpZiAocHJvdG8gIT09IG51bGwgJiYgVHlwZShwcm90bykgIT09ICdPYmplY3QnKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IGBwcm90b2AgbXVzdCBiZSBudWxsIG9yIGFuIG9iamVjdCcpO1xuXHR9XG5cdHZhciBhZGRpdGlvbmFsSW50ZXJuYWxTbG90c0xpc3QgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IFtdIDogYXJndW1lbnRzWzFdO1xuXHRpZiAoIUlzQXJyYXkoYWRkaXRpb25hbEludGVybmFsU2xvdHNMaXN0KSkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdBc3NlcnRpb24gZmFpbGVkOiBgYWRkaXRpb25hbEludGVybmFsU2xvdHNMaXN0YCBtdXN0IGJlIGFuIEFycmF5Jyk7XG5cdH1cblx0Ly8gdmFyIGludGVybmFsU2xvdHNMaXN0ID0gWydbW1Byb3RvdHlwZV1dJywgJ1tbRXh0ZW5zaWJsZV1dJ107XG5cdGlmIChhZGRpdGlvbmFsSW50ZXJuYWxTbG90c0xpc3QubGVuZ3RoID4gMCkge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2VzLWFic3RyYWN0IGRvZXMgbm90IHlldCBzdXBwb3J0IGludGVybmFsIHNsb3RzJyk7XG5cdFx0Ly8gaW50ZXJuYWxTbG90c0xpc3QucHVzaCguLi5hZGRpdGlvbmFsSW50ZXJuYWxTbG90c0xpc3QpO1xuXHR9XG5cdC8vIHZhciBPID0gTWFrZUJhc2ljT2JqZWN0KGludGVybmFsU2xvdHNMaXN0KTtcblx0Ly8gc2V0UHJvdG8oTywgcHJvdG8pO1xuXHQvLyByZXR1cm4gTztcblxuXHRpZiAoJE9iamVjdENyZWF0ZSkge1xuXHRcdHJldHVybiAkT2JqZWN0Q3JlYXRlKHByb3RvKTtcblx0fVxuXHRpZiAoaGFzUHJvdG8pIHtcblx0XHRyZXR1cm4geyBfX3Byb3RvX186IHByb3RvIH07XG5cdH1cblxuXHRpZiAocHJvdG8gPT09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCduYXRpdmUgT2JqZWN0LmNyZWF0ZSBzdXBwb3J0IGlzIHJlcXVpcmVkIHRvIGNyZWF0ZSBudWxsIG9iamVjdHMnKTtcblx0fVxuXHR2YXIgVCA9IGZ1bmN0aW9uIFQoKSB7fTtcblx0VC5wcm90b3R5cGUgPSBwcm90bztcblx0cmV0dXJuIG5ldyBUKCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xudmFyIGNhbGxCaW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kJyk7XG5cbnZhciAkcmVzb2x2ZSA9IEdldEludHJpbnNpYygnJVByb21pc2UucmVzb2x2ZSUnLCB0cnVlKTtcbnZhciAkUHJvbWlzZVJlc29sdmUgPSAkcmVzb2x2ZSAmJiBjYWxsQmluZCgkcmVzb2x2ZSk7XG5cbi8vIGh0dHBzOi8vMjYyLmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvOS4wLyNzZWMtcHJvbWlzZS1yZXNvbHZlXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gUHJvbWlzZVJlc29sdmUoQywgeCkge1xuXHRpZiAoISRQcm9taXNlUmVzb2x2ZSkge1xuXHRcdHRocm93IG5ldyBTeW50YXhFcnJvcignVGhpcyBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IFByb21pc2VzLicpO1xuXHR9XG5cdHJldHVybiAkUHJvbWlzZVJlc29sdmUoQywgeCk7XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkVHlwZUVycm9yID0gR2V0SW50cmluc2ljKCclVHlwZUVycm9yJScpO1xuXG52YXIgcmVnZXhFeGVjID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpKCdSZWdFeHAucHJvdG90eXBlLmV4ZWMnKTtcblxudmFyIENhbGwgPSByZXF1aXJlKCcuL0NhbGwnKTtcbnZhciBHZXQgPSByZXF1aXJlKCcuL0dldCcpO1xudmFyIElzQ2FsbGFibGUgPSByZXF1aXJlKCcuL0lzQ2FsbGFibGUnKTtcbnZhciBUeXBlID0gcmVxdWlyZSgnLi9UeXBlJyk7XG5cbi8vIGh0dHBzOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1yZWdleHBleGVjXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gUmVnRXhwRXhlYyhSLCBTKSB7XG5cdGlmIChUeXBlKFIpICE9PSAnT2JqZWN0Jykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdBc3NlcnRpb24gZmFpbGVkOiBgUmAgbXVzdCBiZSBhbiBPYmplY3QnKTtcblx0fVxuXHRpZiAoVHlwZShTKSAhPT0gJ1N0cmluZycpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogYFNgIG11c3QgYmUgYSBTdHJpbmcnKTtcblx0fVxuXHR2YXIgZXhlYyA9IEdldChSLCAnZXhlYycpO1xuXHRpZiAoSXNDYWxsYWJsZShleGVjKSkge1xuXHRcdHZhciByZXN1bHQgPSBDYWxsKGV4ZWMsIFIsIFtTXSk7XG5cdFx0aWYgKHJlc3VsdCA9PT0gbnVsbCB8fCBUeXBlKHJlc3VsdCkgPT09ICdPYmplY3QnKSB7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignXCJleGVjXCIgbWV0aG9kIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBPYmplY3QnKTtcblx0fVxuXHRyZXR1cm4gcmVnZXhFeGVjKFIsIFMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi81L0NoZWNrT2JqZWN0Q29lcmNpYmxlJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciAkaXNOYU4gPSByZXF1aXJlKCcuLi9oZWxwZXJzL2lzTmFOJyk7XG5cbi8vIGh0dHA6Ly8yNjIuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy81LjEvI3NlYy05LjEyXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gU2FtZVZhbHVlKHgsIHkpIHtcblx0aWYgKHggPT09IHkpIHsgLy8gMCA9PT0gLTAsIGJ1dCB0aGV5IGFyZSBub3QgaWRlbnRpY2FsLlxuXHRcdGlmICh4ID09PSAwKSB7IHJldHVybiAxIC8geCA9PT0gMSAvIHk7IH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gJGlzTmFOKHgpICYmICRpc05hTih5KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciAkaXNOYU4gPSByZXF1aXJlKCcuLi9oZWxwZXJzL2lzTmFOJyk7XG5cbi8vIGh0dHBzOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1zYW1ldmFsdWV6ZXJvXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gU2FtZVZhbHVlWmVybyh4LCB5KSB7XG5cdHJldHVybiAoeCA9PT0geSkgfHwgKCRpc05hTih4KSAmJiAkaXNOYU4oeSkpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG5cbnZhciBJc1Byb3BlcnR5S2V5ID0gcmVxdWlyZSgnLi9Jc1Byb3BlcnR5S2V5Jyk7XG52YXIgU2FtZVZhbHVlID0gcmVxdWlyZSgnLi9TYW1lVmFsdWUnKTtcbnZhciBUeXBlID0gcmVxdWlyZSgnLi9UeXBlJyk7XG5cbi8vIElFIDkgZG9lcyBub3QgdGhyb3cgaW4gc3RyaWN0IG1vZGUgd2hlbiB3cml0YWJpbGl0eS9jb25maWd1cmFiaWxpdHkvZXh0ZW5zaWJpbGl0eSBpcyB2aW9sYXRlZFxudmFyIG5vVGhyb3dPblN0cmljdFZpb2xhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG5cdHRyeSB7XG5cdFx0ZGVsZXRlIFtdLmxlbmd0aDtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSgpKTtcblxuLy8gaHR0cHM6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXNldC1vLXAtdi10aHJvd1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFNldChPLCBQLCBWLCBUaHJvdykge1xuXHRpZiAoVHlwZShPKSAhPT0gJ09iamVjdCcpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogYE9gIG11c3QgYmUgYW4gT2JqZWN0Jyk7XG5cdH1cblx0aWYgKCFJc1Byb3BlcnR5S2V5KFApKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQ6IGBQYCBtdXN0IGJlIGEgUHJvcGVydHkgS2V5Jyk7XG5cdH1cblx0aWYgKFR5cGUoVGhyb3cpICE9PSAnQm9vbGVhbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogYFRocm93YCBtdXN0IGJlIGEgQm9vbGVhbicpO1xuXHR9XG5cdGlmIChUaHJvdykge1xuXHRcdE9bUF0gPSBWOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG5cdFx0aWYgKG5vVGhyb3dPblN0cmljdFZpb2xhdGlvbiAmJiAhU2FtZVZhbHVlKE9bUF0sIFYpKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQXR0ZW1wdGVkIHRvIGFzc2lnbiB0byByZWFkb25seSBwcm9wZXJ0eS4nKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0dHJ5IHtcblx0XHRPW1BdID0gVjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuXHRcdHJldHVybiBub1Rocm93T25TdHJpY3RWaW9sYXRpb24gPyBTYW1lVmFsdWUoT1tQXSwgVikgOiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkc3BlY2llcyA9IEdldEludHJpbnNpYygnJVN5bWJvbC5zcGVjaWVzJScsIHRydWUpO1xudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG5cbnZhciBJc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9Jc0NvbnN0cnVjdG9yJyk7XG52YXIgVHlwZSA9IHJlcXVpcmUoJy4vVHlwZScpO1xuXG4vLyBodHRwczovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc3BlY2llc2NvbnN0cnVjdG9yXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3Rvcikge1xuXHRpZiAoVHlwZShPKSAhPT0gJ09iamVjdCcpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQXNzZXJ0aW9uIGZhaWxlZDogVHlwZShPKSBpcyBub3QgT2JqZWN0Jyk7XG5cdH1cblx0dmFyIEMgPSBPLmNvbnN0cnVjdG9yO1xuXHRpZiAodHlwZW9mIEMgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0cmV0dXJuIGRlZmF1bHRDb25zdHJ1Y3Rvcjtcblx0fVxuXHRpZiAoVHlwZShDKSAhPT0gJ09iamVjdCcpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignTy5jb25zdHJ1Y3RvciBpcyBub3QgYW4gT2JqZWN0Jyk7XG5cdH1cblx0dmFyIFMgPSAkc3BlY2llcyA/IENbJHNwZWNpZXNdIDogdm9pZCAwO1xuXHRpZiAoUyA9PSBudWxsKSB7XG5cdFx0cmV0dXJuIGRlZmF1bHRDb25zdHJ1Y3Rvcjtcblx0fVxuXHRpZiAoSXNDb25zdHJ1Y3RvcihTKSkge1xuXHRcdHJldHVybiBTO1xuXHR9XG5cdHRocm93IG5ldyAkVHlwZUVycm9yKCdubyBjb25zdHJ1Y3RvciBmb3VuZCcpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gaHR0cDovLzI2Mi5lY21hLWludGVybmF0aW9uYWwub3JnLzUuMS8jc2VjLTkuMlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvQm9vbGVhbih2YWx1ZSkgeyByZXR1cm4gISF2YWx1ZTsgfTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEVTNVRvSW50ZWdlciA9IHJlcXVpcmUoJy4uLzUvVG9JbnRlZ2VyJyk7XG5cbnZhciBUb051bWJlciA9IHJlcXVpcmUoJy4vVG9OdW1iZXInKTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi8xMS4wLyNzZWMtdG9pbnRlZ2VyXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gVG9JbnRlZ2VyKHZhbHVlKSB7XG5cdHZhciBudW1iZXIgPSBUb051bWJlcih2YWx1ZSk7XG5cdGlmIChudW1iZXIgIT09IDApIHtcblx0XHRudW1iZXIgPSBFUzVUb0ludGVnZXIobnVtYmVyKTtcblx0fVxuXHRyZXR1cm4gbnVtYmVyID09PSAwID8gMCA6IG51bWJlcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gcmVxdWlyZSgnLi4vaGVscGVycy9tYXhTYWZlSW50ZWdlcicpO1xuXG52YXIgVG9JbnRlZ2VyT3JJbmZpbml0eSA9IHJlcXVpcmUoJy4vVG9JbnRlZ2VyT3JJbmZpbml0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvTGVuZ3RoKGFyZ3VtZW50KSB7XG5cdHZhciBsZW4gPSBUb0ludGVnZXJPckluZmluaXR5KGFyZ3VtZW50KTtcblx0aWYgKGxlbiA8PSAwKSB7IHJldHVybiAwOyB9IC8vIGluY2x1ZGVzIGNvbnZlcnRpbmcgLTAgdG8gKzBcblx0aWYgKGxlbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHsgcmV0dXJuIE1BWF9TQUZFX0lOVEVHRVI7IH1cblx0cmV0dXJuIGxlbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkVHlwZUVycm9yID0gR2V0SW50cmluc2ljKCclVHlwZUVycm9yJScpO1xudmFyICROdW1iZXIgPSBHZXRJbnRyaW5zaWMoJyVOdW1iZXIlJyk7XG52YXIgJFJlZ0V4cCA9IEdldEludHJpbnNpYygnJVJlZ0V4cCUnKTtcbnZhciAkcGFyc2VJbnRlZ2VyID0gR2V0SW50cmluc2ljKCclcGFyc2VJbnQlJyk7XG5cbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG52YXIgcmVnZXhUZXN0ZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlZ2V4VGVzdGVyJyk7XG52YXIgaXNQcmltaXRpdmUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2lzUHJpbWl0aXZlJyk7XG5cbnZhciAkc3RyU2xpY2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc2xpY2UnKTtcbnZhciBpc0JpbmFyeSA9IHJlZ2V4VGVzdGVyKC9eMGJbMDFdKyQvaSk7XG52YXIgaXNPY3RhbCA9IHJlZ2V4VGVzdGVyKC9eMG9bMC03XSskL2kpO1xudmFyIGlzSW52YWxpZEhleExpdGVyYWwgPSByZWdleFRlc3RlcigvXlstK10weFswLTlhLWZdKyQvaSk7XG52YXIgbm9uV1MgPSBbJ1xcdTAwODUnLCAnXFx1MjAwYicsICdcXHVmZmZlJ10uam9pbignJyk7XG52YXIgbm9uV1NyZWdleCA9IG5ldyAkUmVnRXhwKCdbJyArIG5vbldTICsgJ10nLCAnZycpO1xudmFyIGhhc05vbldTID0gcmVnZXhUZXN0ZXIobm9uV1NyZWdleCk7XG5cbi8vIHdoaXRlc3BhY2UgZnJvbTogaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTUuNS40LjIwXG4vLyBpbXBsZW1lbnRhdGlvbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9ibG9iL3YzLjQuMC9lczUtc2hpbS5qcyNMMTMwNC1MMTMyNFxudmFyIHdzID0gW1xuXHQnXFx4MDlcXHgwQVxceDBCXFx4MENcXHgwRFxceDIwXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDMnLFxuXHQnXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjgnLFxuXHQnXFx1MjAyOVxcdUZFRkYnXG5dLmpvaW4oJycpO1xudmFyIHRyaW1SZWdleCA9IG5ldyBSZWdFeHAoJyheWycgKyB3cyArICddKyl8KFsnICsgd3MgKyAnXSskKScsICdnJyk7XG52YXIgJHJlcGxhY2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUucmVwbGFjZScpO1xudmFyICR0cmltID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdHJldHVybiAkcmVwbGFjZSh2YWx1ZSwgdHJpbVJlZ2V4LCAnJyk7XG59O1xuXG52YXIgVG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL1RvUHJpbWl0aXZlJyk7XG5cbi8vIGh0dHBzOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b251bWJlclxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvTnVtYmVyKGFyZ3VtZW50KSB7XG5cdHZhciB2YWx1ZSA9IGlzUHJpbWl0aXZlKGFyZ3VtZW50KSA/IGFyZ3VtZW50IDogVG9QcmltaXRpdmUoYXJndW1lbnQsICROdW1iZXIpO1xuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBhIFN5bWJvbCB2YWx1ZSB0byBhIG51bWJlcicpO1xuXHR9XG5cdGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0NvbnZlcnNpb24gZnJvbSBcXCdCaWdJbnRcXCcgdG8gXFwnbnVtYmVyXFwnIGlzIG5vdCBhbGxvd2VkLicpO1xuXHR9XG5cdGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0aWYgKGlzQmluYXJ5KHZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIFRvTnVtYmVyKCRwYXJzZUludGVnZXIoJHN0clNsaWNlKHZhbHVlLCAyKSwgMikpO1xuXHRcdH0gZWxzZSBpZiAoaXNPY3RhbCh2YWx1ZSkpIHtcblx0XHRcdHJldHVybiBUb051bWJlcigkcGFyc2VJbnRlZ2VyKCRzdHJTbGljZSh2YWx1ZSwgMiksIDgpKTtcblx0XHR9IGVsc2UgaWYgKGhhc05vbldTKHZhbHVlKSB8fCBpc0ludmFsaWRIZXhMaXRlcmFsKHZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIE5hTjtcblx0XHR9XG5cdFx0dmFyIHRyaW1tZWQgPSAkdHJpbSh2YWx1ZSk7XG5cdFx0aWYgKHRyaW1tZWQgIT09IHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gVG9OdW1iZXIodHJpbW1lZCk7XG5cdFx0fVxuXG5cdH1cblx0cmV0dXJuICROdW1iZXIodmFsdWUpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRPYmplY3QgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QlJyk7XG5cbnZhciBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi9SZXF1aXJlT2JqZWN0Q29lcmNpYmxlJyk7XG5cbi8vIGh0dHBzOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b29iamVjdFxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvT2JqZWN0KHZhbHVlKSB7XG5cdFJlcXVpcmVPYmplY3RDb2VyY2libGUodmFsdWUpO1xuXHRyZXR1cm4gJE9iamVjdCh2YWx1ZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCdlcy10by1wcmltaXRpdmUvZXMyMDE1Jyk7XG5cbi8vIGh0dHBzOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b3ByaW1pdGl2ZVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvUHJpbWl0aXZlKGlucHV0KSB7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdHJldHVybiB0b1ByaW1pdGl2ZShpbnB1dCwgYXJndW1lbnRzWzFdKTtcblx0fVxuXHRyZXR1cm4gdG9QcmltaXRpdmUoaW5wdXQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IHJlcXVpcmUoJ2hhcycpO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYygnJVR5cGVFcnJvciUnKTtcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuL1R5cGUnKTtcbnZhciBUb0Jvb2xlYW4gPSByZXF1aXJlKCcuL1RvQm9vbGVhbicpO1xudmFyIElzQ2FsbGFibGUgPSByZXF1aXJlKCcuL0lzQ2FsbGFibGUnKTtcblxuLy8gaHR0cHM6Ly8yNjIuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy81LjEvI3NlYy04LjEwLjVcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBUb1Byb3BlcnR5RGVzY3JpcHRvcihPYmopIHtcblx0aWYgKFR5cGUoT2JqKSAhPT0gJ09iamVjdCcpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignVG9Qcm9wZXJ0eURlc2NyaXB0b3IgcmVxdWlyZXMgYW4gb2JqZWN0Jyk7XG5cdH1cblxuXHR2YXIgZGVzYyA9IHt9O1xuXHRpZiAoaGFzKE9iaiwgJ2VudW1lcmFibGUnKSkge1xuXHRcdGRlc2NbJ1tbRW51bWVyYWJsZV1dJ10gPSBUb0Jvb2xlYW4oT2JqLmVudW1lcmFibGUpO1xuXHR9XG5cdGlmIChoYXMoT2JqLCAnY29uZmlndXJhYmxlJykpIHtcblx0XHRkZXNjWydbW0NvbmZpZ3VyYWJsZV1dJ10gPSBUb0Jvb2xlYW4oT2JqLmNvbmZpZ3VyYWJsZSk7XG5cdH1cblx0aWYgKGhhcyhPYmosICd2YWx1ZScpKSB7XG5cdFx0ZGVzY1snW1tWYWx1ZV1dJ10gPSBPYmoudmFsdWU7XG5cdH1cblx0aWYgKGhhcyhPYmosICd3cml0YWJsZScpKSB7XG5cdFx0ZGVzY1snW1tXcml0YWJsZV1dJ10gPSBUb0Jvb2xlYW4oT2JqLndyaXRhYmxlKTtcblx0fVxuXHRpZiAoaGFzKE9iaiwgJ2dldCcpKSB7XG5cdFx0dmFyIGdldHRlciA9IE9iai5nZXQ7XG5cdFx0aWYgKHR5cGVvZiBnZXR0ZXIgIT09ICd1bmRlZmluZWQnICYmICFJc0NhbGxhYmxlKGdldHRlcikpIHtcblx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdnZXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cdFx0fVxuXHRcdGRlc2NbJ1tbR2V0XV0nXSA9IGdldHRlcjtcblx0fVxuXHRpZiAoaGFzKE9iaiwgJ3NldCcpKSB7XG5cdFx0dmFyIHNldHRlciA9IE9iai5zZXQ7XG5cdFx0aWYgKHR5cGVvZiBzZXR0ZXIgIT09ICd1bmRlZmluZWQnICYmICFJc0NhbGxhYmxlKHNldHRlcikpIHtcblx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdzZXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cdFx0fVxuXHRcdGRlc2NbJ1tbU2V0XV0nXSA9IHNldHRlcjtcblx0fVxuXG5cdGlmICgoaGFzKGRlc2MsICdbW0dldF1dJykgfHwgaGFzKGRlc2MsICdbW1NldF1dJykpICYmIChoYXMoZGVzYywgJ1tbVmFsdWVdXScpIHx8IGhhcyhkZXNjLCAnW1tXcml0YWJsZV1dJykpKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0ludmFsaWQgcHJvcGVydHkgZGVzY3JpcHRvci4gQ2Fubm90IGJvdGggc3BlY2lmeSBhY2Nlc3NvcnMgYW5kIGEgdmFsdWUgb3Igd3JpdGFibGUgYXR0cmlidXRlJyk7XG5cdH1cblx0cmV0dXJuIGRlc2M7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJFN0cmluZyA9IEdldEludHJpbnNpYygnJVN0cmluZyUnKTtcblxudmFyIFRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9Ub1ByaW1pdGl2ZScpO1xudmFyIFRvU3RyaW5nID0gcmVxdWlyZSgnLi9Ub1N0cmluZycpO1xuXG4vLyBodHRwczovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9wcm9wZXJ0eWtleVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvUHJvcGVydHlLZXkoYXJndW1lbnQpIHtcblx0dmFyIGtleSA9IFRvUHJpbWl0aXZlKGFyZ3VtZW50LCAkU3RyaW5nKTtcblx0cmV0dXJuIHR5cGVvZiBrZXkgPT09ICdzeW1ib2wnID8ga2V5IDogVG9TdHJpbmcoa2V5KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkU3RyaW5nID0gR2V0SW50cmluc2ljKCclU3RyaW5nJScpO1xudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG5cbi8vIGh0dHBzOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b3N0cmluZ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvU3RyaW5nKGFyZ3VtZW50KSB7XG5cdGlmICh0eXBlb2YgYXJndW1lbnQgPT09ICdzeW1ib2wnKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nJyk7XG5cdH1cblx0cmV0dXJuICRTdHJpbmcoYXJndW1lbnQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFRvTnVtYmVyID0gcmVxdWlyZSgnLi9Ub051bWJlcicpO1xuXG4vLyBodHRwOi8vMjYyLmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvNS4xLyNzZWMtOS42XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gVG9VaW50MzIoeCkge1xuXHRyZXR1cm4gVG9OdW1iZXIoeCkgPj4+IDA7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVM1VHlwZSA9IHJlcXVpcmUoJy4uLzUvVHlwZScpO1xuXG4vLyBodHRwczovLzI2Mi5lY21hLWludGVybmF0aW9uYWwub3JnLzExLjAvI3NlYy1lY21hc2NyaXB0LWRhdGEtdHlwZXMtYW5kLXZhbHVlc1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFR5cGUoeCkge1xuXHRpZiAodHlwZW9mIHggPT09ICdzeW1ib2wnKSB7XG5cdFx0cmV0dXJuICdTeW1ib2wnO1xuXHR9XG5cdGlmICh0eXBlb2YgeCA9PT0gJ2JpZ2ludCcpIHtcblx0XHRyZXR1cm4gJ0JpZ0ludCc7XG5cdH1cblx0cmV0dXJuIEVTNVR5cGUoeCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYygnJVR5cGVFcnJvciUnKTtcbnZhciAkZnJvbUNoYXJDb2RlID0gR2V0SW50cmluc2ljKCclU3RyaW5nLmZyb21DaGFyQ29kZSUnKTtcblxudmFyIGlzTGVhZGluZ1N1cnJvZ2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNMZWFkaW5nU3Vycm9nYXRlJyk7XG52YXIgaXNUcmFpbGluZ1N1cnJvZ2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNUcmFpbGluZ1N1cnJvZ2F0ZScpO1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8yMDIwLyNzZWMtdXRmMTZkZWNvZGVzdXJyb2dhdGVwYWlyXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gVVRGMTZEZWNvZGVTdXJyb2dhdGVQYWlyKGxlYWQsIHRyYWlsKSB7XG5cdGlmICghaXNMZWFkaW5nU3Vycm9nYXRlKGxlYWQpIHx8ICFpc1RyYWlsaW5nU3Vycm9nYXRlKHRyYWlsKSkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdBc3NlcnRpb24gZmFpbGVkOiBgbGVhZGAgbXVzdCBiZSBhIGxlYWRpbmcgc3Vycm9nYXRlIGNoYXIgY29kZSwgYW5kIGB0cmFpbGAgbXVzdCBiZSBhIHRyYWlsaW5nIHN1cnJvZ2F0ZSBjaGFyIGNvZGUnKTtcblx0fVxuXHQvLyB2YXIgY3AgPSAobGVhZCAtIDB4RDgwMCkgKiAweDQwMCArICh0cmFpbCAtIDB4REMwMCkgKyAweDEwMDAwO1xuXHRyZXR1cm4gJGZyb21DaGFyQ29kZShsZWFkKSArICRmcm9tQ2hhckNvZGUodHJhaWwpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRhYnMgPSBHZXRJbnRyaW5zaWMoJyVNYXRoLmFicyUnKTtcblxuLy8gaHR0cDovLzI2Mi5lY21hLWludGVybmF0aW9uYWwub3JnLzUuMS8jc2VjLTUuMlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFicyh4KSB7XG5cdHJldHVybiAkYWJzKHgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gdmFyIG1vZHVsbyA9IHJlcXVpcmUoJy4vbW9kdWxvJyk7XG52YXIgJGZsb29yID0gTWF0aC5mbG9vcjtcblxuLy8gaHR0cDovLzI2Mi5lY21hLWludGVybmF0aW9uYWwub3JnLzUuMS8jc2VjLTUuMlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZsb29yKHgpIHtcblx0Ly8gcmV0dXJuIHggLSBtb2R1bG8oeCwgMSk7XG5cdHJldHVybiAkZmxvb3IoeCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYygnJVR5cGVFcnJvciUnKTtcblxuLy8gaHR0cDovLzI2Mi5lY21hLWludGVybmF0aW9uYWwub3JnLzUuMS8jc2VjLTkuMTBcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBDaGVja09iamVjdENvZXJjaWJsZSh2YWx1ZSwgb3B0TWVzc2FnZSkge1xuXHRpZiAodmFsdWUgPT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKG9wdE1lc3NhZ2UgfHwgKCdDYW5ub3QgY2FsbCBtZXRob2Qgb24gJyArIHZhbHVlKSk7XG5cdH1cblx0cmV0dXJuIHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFicyA9IHJlcXVpcmUoJy4vYWJzJyk7XG52YXIgZmxvb3IgPSByZXF1aXJlKCcuL2Zsb29yJyk7XG52YXIgVG9OdW1iZXIgPSByZXF1aXJlKCcuL1RvTnVtYmVyJyk7XG5cbnZhciAkaXNOYU4gPSByZXF1aXJlKCcuLi9oZWxwZXJzL2lzTmFOJyk7XG52YXIgJGlzRmluaXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Zpbml0ZScpO1xudmFyICRzaWduID0gcmVxdWlyZSgnLi4vaGVscGVycy9zaWduJyk7XG5cbi8vIGh0dHA6Ly8yNjIuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy81LjEvI3NlYy05LjRcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBUb0ludGVnZXIodmFsdWUpIHtcblx0dmFyIG51bWJlciA9IFRvTnVtYmVyKHZhbHVlKTtcblx0aWYgKCRpc05hTihudW1iZXIpKSB7IHJldHVybiAwOyB9XG5cdGlmIChudW1iZXIgPT09IDAgfHwgISRpc0Zpbml0ZShudW1iZXIpKSB7IHJldHVybiBudW1iZXI7IH1cblx0cmV0dXJuICRzaWduKG51bWJlcikgKiBmbG9vcihhYnMobnVtYmVyKSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL1RvUHJpbWl0aXZlJyk7XG5cbi8vIGh0dHA6Ly8yNjIuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy81LjEvI3NlYy05LjNcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBUb051bWJlcih2YWx1ZSkge1xuXHR2YXIgcHJpbSA9IFRvUHJpbWl0aXZlKHZhbHVlLCBOdW1iZXIpO1xuXHRpZiAodHlwZW9mIHByaW0gIT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuICtwcmltOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWltcGxpY2l0LWNvZXJjaW9uXG5cdH1cblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuXHR2YXIgdHJpbW1lZCA9IHByaW0ucmVwbGFjZSgvXlsgXFx0XFx4MGJcXGZcXHhhMFxcdWZlZmZcXG5cXHJcXHUyMDI4XFx1MjAyOVxcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHUwMDg1XSt8WyBcXHRcXHgwYlxcZlxceGEwXFx1ZmVmZlxcblxcclxcdTIwMjhcXHUyMDI5XFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdTAwODVdKyQvZywgJycpO1xuXHRpZiAoKC9eMFtvYl18XlsrLV0weC8pLnRlc3QodHJpbW1lZCkpIHtcblx0XHRyZXR1cm4gTmFOO1xuXHR9XG5cblx0cmV0dXJuICt0cmltbWVkOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWltcGxpY2l0LWNvZXJjaW9uXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBodHRwOi8vMjYyLmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvNS4xLyNzZWMtOS4xXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXMtdG8tcHJpbWl0aXZlL2VzNScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBodHRwczovLzI2Mi5lY21hLWludGVybmF0aW9uYWwub3JnLzUuMS8jc2VjLThcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBUeXBlKHgpIHtcblx0aWYgKHggPT09IG51bGwpIHtcblx0XHRyZXR1cm4gJ051bGwnO1xuXHR9XG5cdGlmICh0eXBlb2YgeCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRyZXR1cm4gJ1VuZGVmaW5lZCc7XG5cdH1cblx0aWYgKHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB4ID09PSAnb2JqZWN0Jykge1xuXHRcdHJldHVybiAnT2JqZWN0Jztcblx0fVxuXHRpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XG5cdFx0cmV0dXJuICdOdW1iZXInO1xuXHR9XG5cdGlmICh0eXBlb2YgeCA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0cmV0dXJuICdCb29sZWFuJztcblx0fVxuXHRpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuICdTdHJpbmcnO1xuXHR9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJGFicyA9IEdldEludHJpbnNpYygnJU1hdGguYWJzJScpO1xuXG4vLyBodHRwOi8vMjYyLmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvNS4xLyNzZWMtNS4yXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYWJzKHgpIHtcblx0cmV0dXJuICRhYnMoeCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyB2YXIgbW9kdWxvID0gcmVxdWlyZSgnLi9tb2R1bG8nKTtcbnZhciAkZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4vLyBodHRwOi8vMjYyLmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvNS4xLyNzZWMtNS4yXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmxvb3IoeCkge1xuXHQvLyByZXR1cm4geCAtIG1vZHVsbyh4LCAxKTtcblx0cmV0dXJuICRmbG9vcih4KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIFRPRE86IHJlbW92ZSwgc2VtdmVyLW1ham9yXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmRlZmluZVByb3BlcnR5JScsIHRydWUpO1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IG51bGw7XG5cdH1cbn1cblxuLy8gbm9kZSB2MC42IGhhcyBhIGJ1ZyB3aGVyZSBhcnJheSBsZW5ndGhzIGNhbiBiZSBTZXQgYnV0IG5vdCBEZWZpbmVkXG52YXIgaGFzQXJyYXlMZW5ndGhEZWZpbmVCdWcgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KFtdLCAnbGVuZ3RoJywgeyB2YWx1ZTogMSB9KS5sZW5ndGggPT09IDA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnbG9iYWwtcmVxdWlyZVxudmFyIGlzQXJyYXkgPSBoYXNBcnJheUxlbmd0aERlZmluZUJ1ZyAmJiByZXF1aXJlKCcuLi8yMDIwL0lzQXJyYXknKTsgLy8gdGhpcyBkb2VzIG5vdCBkZXBlbmQgb24gYW55IG90aGVyIEFPcy5cblxudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICRpc0VudW1lcmFibGUgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUnKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gRGVmaW5lT3duUHJvcGVydHkoSXNEYXRhRGVzY3JpcHRvciwgU2FtZVZhbHVlLCBGcm9tUHJvcGVydHlEZXNjcmlwdG9yLCBPLCBQLCBkZXNjKSB7XG5cdGlmICghJGRlZmluZVByb3BlcnR5KSB7XG5cdFx0aWYgKCFJc0RhdGFEZXNjcmlwdG9yKGRlc2MpKSB7XG5cdFx0XHQvLyBFUzMgZG9lcyBub3Qgc3VwcG9ydCBnZXR0ZXJzL3NldHRlcnNcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKCFkZXNjWydbW0NvbmZpZ3VyYWJsZV1dJ10gfHwgIWRlc2NbJ1tbV3JpdGFibGVdXSddKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gZmFsbGJhY2sgZm9yIEVTM1xuXHRcdGlmIChQIGluIE8gJiYgJGlzRW51bWVyYWJsZShPLCBQKSAhPT0gISFkZXNjWydbW0VudW1lcmFibGVdXSddKSB7XG5cdFx0XHQvLyBhIG5vbi1lbnVtZXJhYmxlIGV4aXN0aW5nIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gcHJvcGVydHkgZG9lcyBub3QgZXhpc3QgYXQgYWxsLCBvciBleGlzdHMgYnV0IGlzIGVudW1lcmFibGVcblx0XHR2YXIgViA9IGRlc2NbJ1tbVmFsdWVdXSddO1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuXHRcdE9bUF0gPSBWOyAvLyB3aWxsIHVzZSBbW0RlZmluZV1dXG5cdFx0cmV0dXJuIFNhbWVWYWx1ZShPW1BdLCBWKTtcblx0fVxuXHRpZiAoXG5cdFx0aGFzQXJyYXlMZW5ndGhEZWZpbmVCdWdcblx0XHQmJiBQID09PSAnbGVuZ3RoJ1xuXHRcdCYmICdbW1ZhbHVlXV0nIGluIGRlc2Ncblx0XHQmJiBpc0FycmF5KE8pXG5cdFx0JiYgTy5sZW5ndGggIT09IGRlc2NbJ1tbVmFsdWVdXSddXG5cdCkge1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuXHRcdE8ubGVuZ3RoID0gZGVzY1snW1tWYWx1ZV1dJ107XG5cdFx0cmV0dXJuIE8ubGVuZ3RoID09PSBkZXNjWydbW1ZhbHVlXV0nXTtcblx0fVxuXG5cdCRkZWZpbmVQcm9wZXJ0eShPLCBQLCBGcm9tUHJvcGVydHlEZXNjcmlwdG9yKGRlc2MpKTtcblx0cmV0dXJuIHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYygnJVR5cGVFcnJvciUnKTtcbnZhciAkU3ludGF4RXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVTeW50YXhFcnJvciUnKTtcblxudmFyIGhhcyA9IHJlcXVpcmUoJ2hhcycpO1xuXG52YXIgcHJlZGljYXRlcyA9IHtcblx0Ly8gaHR0cHM6Ly8yNjIuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy82LjAvI3NlYy1wcm9wZXJ0eS1kZXNjcmlwdG9yLXNwZWNpZmljYXRpb24tdHlwZVxuXHQnUHJvcGVydHkgRGVzY3JpcHRvcic6IGZ1bmN0aW9uIGlzUHJvcGVydHlEZXNjcmlwdG9yKFR5cGUsIERlc2MpIHtcblx0XHRpZiAoVHlwZShEZXNjKSAhPT0gJ09iamVjdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0dmFyIGFsbG93ZWQgPSB7XG5cdFx0XHQnW1tDb25maWd1cmFibGVdXSc6IHRydWUsXG5cdFx0XHQnW1tFbnVtZXJhYmxlXV0nOiB0cnVlLFxuXHRcdFx0J1tbR2V0XV0nOiB0cnVlLFxuXHRcdFx0J1tbU2V0XV0nOiB0cnVlLFxuXHRcdFx0J1tbVmFsdWVdXSc6IHRydWUsXG5cdFx0XHQnW1tXcml0YWJsZV1dJzogdHJ1ZVxuXHRcdH07XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gRGVzYykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cdFx0XHRpZiAoaGFzKERlc2MsIGtleSkgJiYgIWFsbG93ZWRba2V5XSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGlzRGF0YSA9IGhhcyhEZXNjLCAnW1tWYWx1ZV1dJyk7XG5cdFx0dmFyIElzQWNjZXNzb3IgPSBoYXMoRGVzYywgJ1tbR2V0XV0nKSB8fCBoYXMoRGVzYywgJ1tbU2V0XV0nKTtcblx0XHRpZiAoaXNEYXRhICYmIElzQWNjZXNzb3IpIHtcblx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdQcm9wZXJ0eSBEZXNjcmlwdG9ycyBtYXkgbm90IGJlIGJvdGggYWNjZXNzb3IgYW5kIGRhdGEgZGVzY3JpcHRvcnMnKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXNzZXJ0UmVjb3JkKFR5cGUsIHJlY29yZFR5cGUsIGFyZ3VtZW50TmFtZSwgdmFsdWUpIHtcblx0dmFyIHByZWRpY2F0ZSA9IHByZWRpY2F0ZXNbcmVjb3JkVHlwZV07XG5cdGlmICh0eXBlb2YgcHJlZGljYXRlICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcigndW5rbm93biByZWNvcmQgdHlwZTogJyArIHJlY29yZFR5cGUpO1xuXHR9XG5cdGlmICghcHJlZGljYXRlKFR5cGUsIHZhbHVlKSkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKGFyZ3VtZW50TmFtZSArICcgbXVzdCBiZSBhICcgKyByZWNvcmRUeXBlKTtcblx0fVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scycpKCk7XG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICRpdGVyYXRvciA9IEdldEludHJpbnNpYygnJVN5bWJvbC5pdGVyYXRvciUnLCB0cnVlKTtcbnZhciAkc3RyaW5nU2xpY2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc2xpY2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRJdGVyYXRvck1ldGhvZChFUywgaXRlcmFibGUpIHtcblx0dmFyIHVzaW5nSXRlcmF0b3I7XG5cdGlmIChoYXNTeW1ib2xzKSB7XG5cdFx0dXNpbmdJdGVyYXRvciA9IEVTLkdldE1ldGhvZChpdGVyYWJsZSwgJGl0ZXJhdG9yKTtcblx0fSBlbHNlIGlmIChFUy5Jc0FycmF5KGl0ZXJhYmxlKSkge1xuXHRcdHVzaW5nSXRlcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgaSA9IC0xO1xuXHRcdFx0dmFyIGFyciA9IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW52YWxpZC10aGlzXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRuZXh0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0aSArPSAxO1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRkb25lOiBpID49IGFyci5sZW5ndGgsXG5cdFx0XHRcdFx0XHR2YWx1ZTogYXJyW2ldXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9O1xuXHR9IGVsc2UgaWYgKEVTLlR5cGUoaXRlcmFibGUpID09PSAnU3RyaW5nJykge1xuXHRcdHVzaW5nSXRlcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRuZXh0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dmFyIG5leHRJbmRleCA9IEVTLkFkdmFuY2VTdHJpbmdJbmRleChpdGVyYWJsZSwgaSwgdHJ1ZSk7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gJHN0cmluZ1NsaWNlKGl0ZXJhYmxlLCBpLCBuZXh0SW5kZXgpO1xuXHRcdFx0XHRcdGkgPSBuZXh0SW5kZXg7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdGRvbmU6IG5leHRJbmRleCA+IGl0ZXJhYmxlLmxlbmd0aCxcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4gdXNpbmdJdGVyYXRvcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkZ09QRCA9IEdldEludHJpbnNpYygnJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlJywgdHJ1ZSk7XG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRChbXSwgJ2xlbmd0aCcpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZ09QRFxuXHRcdCRnT1BEID0gbnVsbDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICRnT1BEO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGlzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIChhKSB7IHJldHVybiBhICE9PSBhOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbiAoeCkgeyByZXR1cm4gdHlwZW9mIHggPT09ICdudW1iZXInICYmICEkaXNOYU4oeCkgJiYgeCAhPT0gSW5maW5pdHkgJiYgeCAhPT0gLUluZmluaXR5OyB9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzTGVhZGluZ1N1cnJvZ2F0ZShjaGFyQ29kZSkge1xuXHRyZXR1cm4gdHlwZW9mIGNoYXJDb2RlID09PSAnbnVtYmVyJyAmJiBjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gaXNOYU4oYSkge1xuXHRyZXR1cm4gYSAhPT0gYTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlID09PSBudWxsIHx8ICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgaGFzID0gcmVxdWlyZSgnaGFzJyk7XG52YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYygnJVR5cGVFcnJvciUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBJc1Byb3BlcnR5RGVzY3JpcHRvcihFUywgRGVzYykge1xuXHRpZiAoRVMuVHlwZShEZXNjKSAhPT0gJ09iamVjdCcpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0dmFyIGFsbG93ZWQgPSB7XG5cdFx0J1tbQ29uZmlndXJhYmxlXV0nOiB0cnVlLFxuXHRcdCdbW0VudW1lcmFibGVdXSc6IHRydWUsXG5cdFx0J1tbR2V0XV0nOiB0cnVlLFxuXHRcdCdbW1NldF1dJzogdHJ1ZSxcblx0XHQnW1tWYWx1ZV1dJzogdHJ1ZSxcblx0XHQnW1tXcml0YWJsZV1dJzogdHJ1ZVxuXHR9O1xuXG5cdGZvciAodmFyIGtleSBpbiBEZXNjKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcblx0XHRpZiAoaGFzKERlc2MsIGtleSkgJiYgIWFsbG93ZWRba2V5XSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdGlmIChFUy5Jc0RhdGFEZXNjcmlwdG9yKERlc2MpICYmIEVTLklzQWNjZXNzb3JEZXNjcmlwdG9yKERlc2MpKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1Byb3BlcnR5IERlc2NyaXB0b3JzIG1heSBub3QgYmUgYm90aCBhY2Nlc3NvciBhbmQgZGF0YSBkZXNjcmlwdG9ycycpO1xuXHR9XG5cdHJldHVybiB0cnVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1RyYWlsaW5nU3Vycm9nYXRlKGNoYXJDb2RlKSB7XG5cdHJldHVybiB0eXBlb2YgY2hhckNvZGUgPT09ICdudW1iZXInICYmIGNoYXJDb2RlID49IDB4REMwMCAmJiBjaGFyQ29kZSA8PSAweERGRkY7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJE1hdGggPSBHZXRJbnRyaW5zaWMoJyVNYXRoJScpO1xudmFyICROdW1iZXIgPSBHZXRJbnRyaW5zaWMoJyVOdW1iZXIlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gJE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8ICRNYXRoLnBvdygyLCA1MykgLSAxO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJHRlc3QgPSBHZXRJbnRyaW5zaWMoJ1JlZ0V4cC5wcm90b3R5cGUudGVzdCcpO1xuXG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCdjYWxsLWJpbmQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZWdleFRlc3RlcihyZWdleCkge1xuXHRyZXR1cm4gY2FsbEJpbmQoJHRlc3QsIHJlZ2V4KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2lnbihudW1iZXIpIHtcblx0cmV0dXJuIG51bWJlciA+PSAwID8gMSA6IC0xO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IGdsb2JhbC1yZXF1aXJlOiAwICovXG4vLyB0aGUgY29kZSBpcyBzdHJ1Y3R1cmVkIHRoaXMgd2F5IHNvIHRoYXQgYnVuZGxlcnMgY2FuXG4vLyBhbGlhcyBvdXQgYGhhcy1zeW1ib2xzYCB0byBgKCkgPT4gdHJ1ZWAgb3IgYCgpID0+IGZhbHNlYCBpZiB5b3VyIHRhcmdldFxuLy8gZW52aXJvbm1lbnRzJyBTeW1ib2wgY2FwYWJpbGl0aWVzIGFyZSBrbm93biwgYW5kIHRoZW4gdXNlXG4vLyBkZWFkIGNvZGUgZWxpbWluYXRpb24gb24gdGhlIHJlc3Qgb2YgdGhpcyBtb2R1bGUuXG4vL1xuLy8gU2ltaWxhcmx5LCBgaXNhcnJheWAgY2FuIGJlIGFsaWFzZWQgdG8gYEFycmF5LmlzQXJyYXlgIGlmXG4vLyBhdmFpbGFibGUgaW4gYWxsIHRhcmdldCBlbnZpcm9ubWVudHMuXG5cbnZhciBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJ2lzLWFyZ3VtZW50cycpO1xuXG5pZiAocmVxdWlyZSgnaGFzLXN5bWJvbHMnKSgpIHx8IHJlcXVpcmUoJ2hhcy1zeW1ib2xzL3NoYW1zJykoKSkge1xuXHR2YXIgJGl0ZXJhdG9yID0gU3ltYm9sLml0ZXJhdG9yO1xuXHQvLyBTeW1ib2wgaXMgYXZhaWxhYmxlIG5hdGl2ZWx5IG9yIHNoYW1tZWRcblx0Ly8gbmF0aXZlbHk6XG5cdC8vICAtIENocm9tZSA+PSAzOFxuXHQvLyAgLSBFZGdlIDEyLTE0PywgRWRnZSA+PSAxNSBmb3Igc3VyZVxuXHQvLyAgLSBGRiA+PSAzNlxuXHQvLyAgLSBTYWZhcmkgPj0gOVxuXHQvLyAgLSBub2RlID49IDAuMTJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRJdGVyYXRvcihpdGVyYWJsZSkge1xuXHRcdC8vIGFsdGVybmF0aXZlbHksIGBpdGVyYWJsZVskaXRlcmF0b3JdPy4oKWBcblx0XHRpZiAoaXRlcmFibGUgIT0gbnVsbCAmJiB0eXBlb2YgaXRlcmFibGVbJGl0ZXJhdG9yXSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiBpdGVyYWJsZVskaXRlcmF0b3JdKCk7XG5cdFx0fVxuXHRcdGlmIChpc0FyZ3VtZW50cyhpdGVyYWJsZSkpIHtcblx0XHRcdC8vIGFyZ3VtZW50cyBvYmplY3RzIGxhY2sgU3ltYm9sLml0ZXJhdG9yXG5cdFx0XHQvLyAtIG5vZGUgMC4xMlxuXHRcdFx0cmV0dXJuIEFycmF5LnByb3RvdHlwZVskaXRlcmF0b3JdLmNhbGwoaXRlcmFibGUpO1xuXHRcdH1cblx0fTtcbn0gZWxzZSB7XG5cdC8vIFN5bWJvbCBpcyBub3QgYXZhaWxhYmxlLCBuYXRpdmUgb3Igc2hhbW1lZFxuXHR2YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcblx0dmFyIGlzU3RyaW5nID0gcmVxdWlyZSgnaXMtc3RyaW5nJyk7XG5cdHZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cdHZhciAkTWFwID0gR2V0SW50cmluc2ljKCclTWFwJScsIHRydWUpO1xuXHR2YXIgJFNldCA9IEdldEludHJpbnNpYygnJVNldCUnLCB0cnVlKTtcblx0dmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblx0dmFyICRhcnJheVB1c2ggPSBjYWxsQm91bmQoJ0FycmF5LnByb3RvdHlwZS5wdXNoJyk7XG5cdHZhciAkY2hhckNvZGVBdCA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5jaGFyQ29kZUF0Jyk7XG5cdHZhciAkc3RyaW5nU2xpY2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc2xpY2UnKTtcblxuXHR2YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gZnVuY3Rpb24gYWR2YW5jZVN0cmluZ0luZGV4KFMsIGluZGV4KSB7XG5cdFx0dmFyIGxlbmd0aCA9IFMubGVuZ3RoO1xuXHRcdGlmICgoaW5kZXggKyAxKSA+PSBsZW5ndGgpIHtcblx0XHRcdHJldHVybiBpbmRleCArIDE7XG5cdFx0fVxuXG5cdFx0dmFyIGZpcnN0ID0gJGNoYXJDb2RlQXQoUywgaW5kZXgpO1xuXHRcdGlmIChmaXJzdCA8IDB4RDgwMCB8fCBmaXJzdCA+IDB4REJGRikge1xuXHRcdFx0cmV0dXJuIGluZGV4ICsgMTtcblx0XHR9XG5cblx0XHR2YXIgc2Vjb25kID0gJGNoYXJDb2RlQXQoUywgaW5kZXggKyAxKTtcblx0XHRpZiAoc2Vjb25kIDwgMHhEQzAwIHx8IHNlY29uZCA+IDB4REZGRikge1xuXHRcdFx0cmV0dXJuIGluZGV4ICsgMTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaW5kZXggKyAyO1xuXHR9O1xuXG5cdHZhciBnZXRBcnJheUl0ZXJhdG9yID0gZnVuY3Rpb24gZ2V0QXJyYXlJdGVyYXRvcihhcnJheWxpa2UpIHtcblx0XHR2YXIgaSA9IDA7XG5cdFx0cmV0dXJuIHtcblx0XHRcdG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG5cdFx0XHRcdHZhciBkb25lID0gaSA+PSBhcnJheWxpa2UubGVuZ3RoO1xuXHRcdFx0XHR2YXIgdmFsdWU7XG5cdFx0XHRcdGlmICghZG9uZSkge1xuXHRcdFx0XHRcdHZhbHVlID0gYXJyYXlsaWtlW2ldO1xuXHRcdFx0XHRcdGkgKz0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGRvbmU6IGRvbmUsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fTtcblx0fTtcblxuXHR2YXIgZ2V0Tm9uQ29sbGVjdGlvbkl0ZXJhdG9yID0gZnVuY3Rpb24gZ2V0Tm9uQ29sbGVjdGlvbkl0ZXJhdG9yKGl0ZXJhYmxlLCBub1ByaW1vcmRpYWxDb2xsZWN0aW9ucykge1xuXHRcdGlmIChpc0FycmF5KGl0ZXJhYmxlKSB8fCBpc0FyZ3VtZW50cyhpdGVyYWJsZSkpIHtcblx0XHRcdHJldHVybiBnZXRBcnJheUl0ZXJhdG9yKGl0ZXJhYmxlKTtcblx0XHR9XG5cdFx0aWYgKGlzU3RyaW5nKGl0ZXJhYmxlKSkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0bmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcblx0XHRcdFx0XHR2YXIgbmV4dEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KGl0ZXJhYmxlLCBpKTtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSAkc3RyaW5nU2xpY2UoaXRlcmFibGUsIGksIG5leHRJbmRleCk7XG5cdFx0XHRcdFx0aSA9IG5leHRJbmRleDtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZG9uZTogbmV4dEluZGV4ID4gaXRlcmFibGUubGVuZ3RoLFxuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBlczYtc2hpbSBhbmQgZXMtc2hpbXMnIGVzLW1hcCB1c2UgYSBzdHJpbmcgXCJfZXM2LXNoaW0gaXRlcmF0b3JfXCIgcHJvcGVydHkgb24gZGlmZmVyZW50IGl0ZXJhYmxlcywgc3VjaCBhcyBNYXBJdGVyYXRvci5cblx0XHRpZiAobm9Qcmltb3JkaWFsQ29sbGVjdGlvbnMgJiYgdHlwZW9mIGl0ZXJhYmxlWydfZXM2LXNoaW0gaXRlcmF0b3JfJ10gIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gaXRlcmFibGVbJ19lczYtc2hpbSBpdGVyYXRvcl8nXSgpO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoISRNYXAgJiYgISRTZXQpIHtcblx0XHQvLyB0aGUgb25seSBsYW5ndWFnZSBpdGVyYWJsZXMgYXJlIEFycmF5LCBTdHJpbmcsIGFyZ3VtZW50c1xuXHRcdC8vIC0gU2FmYXJpIDw9IDYuMFxuXHRcdC8vIC0gQ2hyb21lIDwgMzhcblx0XHQvLyAtIG5vZGUgPCAwLjEyXG5cdFx0Ly8gLSBGRiA8IDEzXG5cdFx0Ly8gLSBJRSA8IDExXG5cdFx0Ly8gLSBFZGdlIDwgMTFcblxuXHRcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0SXRlcmF0b3IoaXRlcmFibGUpIHtcblx0XHRcdGlmIChpdGVyYWJsZSAhPSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBnZXROb25Db2xsZWN0aW9uSXRlcmF0b3IoaXRlcmFibGUsIHRydWUpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0Ly8gZWl0aGVyIE1hcCBvciBTZXQgYXJlIGF2YWlsYWJsZSwgYnV0IFN5bWJvbCBpcyBub3Rcblx0XHQvLyAtIGVzNi1zaGltIG9uIGFuIEVTNSBicm93c2VyXG5cdFx0Ly8gLSBTYWZhcmkgNi4yIChtYXliZSA2LjE/KVxuXHRcdC8vIC0gRkYgdlsxMywgMzYpXG5cdFx0Ly8gLSBJRSAxMVxuXHRcdC8vIC0gRWRnZSAxMVxuXHRcdC8vIC0gU2FmYXJpIHZbNiwgOSlcblxuXHRcdHZhciBpc01hcCA9IHJlcXVpcmUoJ2lzLW1hcCcpO1xuXHRcdHZhciBpc1NldCA9IHJlcXVpcmUoJ2lzLXNldCcpO1xuXG5cdFx0Ly8gRmlyZWZveCA+PSAyNywgSUUgMTEsIFNhZmFyaSA2LjIgLSA5LCBFZGdlIDExLCBlczYtc2hpbSBpbiBvbGRlciBlbnZzLCBhbGwgaGF2ZSBmb3JFYWNoXG5cdFx0dmFyICRtYXBGb3JFYWNoID0gY2FsbEJvdW5kKCdNYXAucHJvdG90eXBlLmZvckVhY2gnLCB0cnVlKTtcblx0XHR2YXIgJHNldEZvckVhY2ggPSBjYWxsQm91bmQoJ1NldC5wcm90b3R5cGUuZm9yRWFjaCcsIHRydWUpO1xuXHRcdGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXByb2Nlc3MudmVyc2lvbnMgfHwgIXByb2Nlc3MudmVyc2lvbnMubm9kZSkgeyAvLyBcImlmIGlzIG5vdCBub2RlXCJcblxuXHRcdFx0Ly8gRmlyZWZveCAxNyAtIDI2IGhhcyBgLml0ZXJhdG9yKClgLCB3aG9zZSBpdGVyYXRvciBgLm5leHQoKWAgZWl0aGVyXG5cdFx0XHQvLyByZXR1cm5zIGEgdmFsdWUsIG9yIHRocm93cyBhIFN0b3BJdGVyYXRpb24gb2JqZWN0LiBUaGVzZSBicm93c2Vyc1xuXHRcdFx0Ly8gZG8gbm90IGhhdmUgYW55IG90aGVyIG1lY2hhbmlzbSBmb3IgaXRlcmF0aW9uLlxuXHRcdFx0dmFyICRtYXBJdGVyYXRvciA9IGNhbGxCb3VuZCgnTWFwLnByb3RvdHlwZS5pdGVyYXRvcicsIHRydWUpO1xuXHRcdFx0dmFyICRzZXRJdGVyYXRvciA9IGNhbGxCb3VuZCgnU2V0LnByb3RvdHlwZS5pdGVyYXRvcicsIHRydWUpO1xuXHRcdFx0dmFyIGdldFN0b3BJdGVyYXRpb25JdGVyYXRvciA9IGZ1bmN0aW9uIChpdGVyYXRvcikge1xuXHRcdFx0XHR2YXIgZG9uZSA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdGRvbmU6IGRvbmUsXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWU6IGRvbmUgPyB1bmRlZmluZWQgOiBpdGVyYXRvci5uZXh0KClcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdFx0ZG9uZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0ZG9uZTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZTogdW5kZWZpbmVkXG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0Ly8gRmlyZWZveCAyNy0zNSwgYW5kIHNvbWUgb2xkZXIgZXM2LXNoaW0gdmVyc2lvbnMsIHVzZSBhIHN0cmluZyBcIkBAaXRlcmF0b3JcIiBwcm9wZXJ0eVxuXHRcdC8vIHRoaXMgcmV0dXJucyBhIHByb3BlciBpdGVyYXRvciBvYmplY3QsIHNvIHdlIHNob3VsZCB1c2UgaXQgaW5zdGVhZCBvZiBmb3JFYWNoLlxuXHRcdC8vIG5ld2VyIGVzNi1zaGltIHZlcnNpb25zIHVzZSBhIHN0cmluZyBcIl9lczYtc2hpbSBpdGVyYXRvcl9cIiBwcm9wZXJ0eS5cblx0XHR2YXIgJG1hcEF0QXRJdGVyYXRvciA9IGNhbGxCb3VuZCgnTWFwLnByb3RvdHlwZS5AQGl0ZXJhdG9yJywgdHJ1ZSkgfHwgY2FsbEJvdW5kKCdNYXAucHJvdG90eXBlLl9lczYtc2hpbSBpdGVyYXRvcl8nLCB0cnVlKTtcblx0XHR2YXIgJHNldEF0QXRJdGVyYXRvciA9IGNhbGxCb3VuZCgnU2V0LnByb3RvdHlwZS5AQGl0ZXJhdG9yJywgdHJ1ZSkgfHwgY2FsbEJvdW5kKCdTZXQucHJvdG90eXBlLl9lczYtc2hpbSBpdGVyYXRvcl8nLCB0cnVlKTtcblxuXHRcdHZhciBnZXRDb2xsZWN0aW9uSXRlcmF0b3IgPSBmdW5jdGlvbiBnZXRDb2xsZWN0aW9uSXRlcmF0b3IoaXRlcmFibGUpIHtcblx0XHRcdGlmIChpc01hcChpdGVyYWJsZSkpIHtcblx0XHRcdFx0aWYgKCRtYXBJdGVyYXRvcikge1xuXHRcdFx0XHRcdHJldHVybiBnZXRTdG9wSXRlcmF0aW9uSXRlcmF0b3IoJG1hcEl0ZXJhdG9yKGl0ZXJhYmxlKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCRtYXBBdEF0SXRlcmF0b3IpIHtcblx0XHRcdFx0XHRyZXR1cm4gJG1hcEF0QXRJdGVyYXRvcihpdGVyYWJsZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCRtYXBGb3JFYWNoKSB7XG5cdFx0XHRcdFx0dmFyIGVudHJpZXMgPSBbXTtcblx0XHRcdFx0XHQkbWFwRm9yRWFjaChpdGVyYWJsZSwgZnVuY3Rpb24gKHYsIGspIHtcblx0XHRcdFx0XHRcdCRhcnJheVB1c2goZW50cmllcywgW2ssIHZdKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRyZXR1cm4gZ2V0QXJyYXlJdGVyYXRvcihlbnRyaWVzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGlzU2V0KGl0ZXJhYmxlKSkge1xuXHRcdFx0XHRpZiAoJHNldEl0ZXJhdG9yKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGdldFN0b3BJdGVyYXRpb25JdGVyYXRvcigkc2V0SXRlcmF0b3IoaXRlcmFibGUpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoJHNldEF0QXRJdGVyYXRvcikge1xuXHRcdFx0XHRcdHJldHVybiAkc2V0QXRBdEl0ZXJhdG9yKGl0ZXJhYmxlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoJHNldEZvckVhY2gpIHtcblx0XHRcdFx0XHR2YXIgdmFsdWVzID0gW107XG5cdFx0XHRcdFx0JHNldEZvckVhY2goaXRlcmFibGUsIGZ1bmN0aW9uICh2KSB7XG5cdFx0XHRcdFx0XHQkYXJyYXlQdXNoKHZhbHVlcywgdik7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0cmV0dXJuIGdldEFycmF5SXRlcmF0b3IodmFsdWVzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEl0ZXJhdG9yKGl0ZXJhYmxlKSB7XG5cdFx0XHRyZXR1cm4gZ2V0Q29sbGVjdGlvbkl0ZXJhdG9yKGl0ZXJhYmxlKSB8fCBnZXROb25Db2xsZWN0aW9uSXRlcmF0b3IoaXRlcmFibGUpO1xuXHRcdH07XG5cdH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdldEl0ZXJhdG9yID0gcmVxdWlyZSgnZXMtZ2V0LWl0ZXJhdG9yJyk7XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbnZhciBpdGVyYXRlID0gcmVxdWlyZSgnaXRlcmF0ZS1pdGVyYXRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGl0ZXJhdGVWYWx1ZShpdGVyYWJsZSkge1xuXHR2YXIgaXRlcmF0b3IgPSBnZXRJdGVyYXRvcihpdGVyYWJsZSk7XG5cdGlmICghaXRlcmF0b3IpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignbm9uLWl0ZXJhYmxlIHZhbHVlIHByb3ZpZGVkJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0cmV0dXJuIGl0ZXJhdGUoaXRlcmF0b3IsIGFyZ3VtZW50c1sxXSk7XG5cdH1cblx0cmV0dXJuIGl0ZXJhdGUoaXRlcmF0b3IpO1xufTtcbiIsImNvbnN0IGNoYXJhY3RlcnMgPSB7XG4gIGE6IHtcbiAgICBzcHJpdGU6ICdjaDEnLFxuICAgIG1zZzogJ3RlbGwgbWUgbW9yZScsXG4gIH0sXG4gIGI6IHtcbiAgICBzcHJpdGU6ICdjaDInLFxuICAgIG1zZzogJ3dvdyBkdWRlJyxcbiAgfSxcbiAgY2xvdWR5bWFuOiB7XG4gICAgc3ByaXRlOiAnY2xvdWR5bWFuJyxcbiAgICBtc2c6ICdpdHMgYSBjbG91ZHkgbmlnaHQuLi4nLFxuICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2hhcmFjdGVycztcbiIsImltcG9ydCBLIGZyb20gJy4uL2Z1bmN0aW9ucy9pbml0LmpzJztcblxuaW1wb3J0IHsgdGFsaywgY2xvdWR5VGFsayB9IGZyb20gJy4vdGFsa2luZy5qcyc7XG5cbmNvbnN0IHBsYXllck9uZSA9ICgpID0+IHtcbiAgY29uc3QgcGxheWVyID0gSy5nZXQoJ3BsYXllck9uZScpWzBdO1xuXG4gIGxldCBoYXNLZXkgPSBmYWxzZTtcblxuICBwbGF5ZXIub3ZlcmxhcHMoJ2tleScsIChrZXkpID0+IHtcbiAgICBLLnBsYXkoJ2NvaW4nKTtcbiAgICBLLmRlc3Ryb3koa2V5KTtcbiAgICBoYXNLZXkgPSB0cnVlO1xuICB9KTtcblxuICBwbGF5ZXIub3ZlcmxhcHMoJ2Rvb3IxJywgKCkgPT4ge1xuICAgIGlmIChoYXNLZXkpIHtcbiAgICAgIEsucGxheSgnaGl0Jyk7XG4gICAgICBLLmdvKCd0d28nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFsaygnd2hlcmV6IGRleSBrZXk/Jyk7XG4gICAgfVxuICB9KTtcblxuICBsZXQgZmluYWxEb29yID0gZmFsc2U7XG5cbiAgcGxheWVyLm92ZXJsYXBzKCdmaW5hbERvb3InLCAoKSA9PiB7XG4gICAgaWYgKGZpbmFsRG9vcikge1xuICAgICAgSy5nbygnd2luJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhbGsoJ2RpZCB5b3UgdGFsayB0byB0aGUgQ2xvdWR5bWFuPycpO1xuICAgIH1cbiAgfSk7XG5cbiAgcGxheWVyLm92ZXJsYXBzKCdjaDEnLCAoY2gpID0+IHtcbiAgICBLLnBsYXkoJ2FhYScpO1xuICAgIHRhbGsoY2gubXNnKTtcbiAgfSk7XG5cbiAgcGxheWVyLm92ZXJsYXBzKCdjaDInLCAoY2gpID0+IHtcbiAgICBLLnBsYXkoJ2hhaGEnKTtcbiAgICB0YWxrKGNoLm1zZyk7XG4gIH0pO1xuXG4gIHBsYXllci5vdmVybGFwcygnY2xvdWR5bWFuJywgKGNoKSA9PiB7XG4gICAgSy5wbGF5KCdheXknKTtcbiAgICBjbG91ZHlUYWxrKGNoLm1zZyk7XG4gICAgZmluYWxEb29yID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcGxheWVyLmFjdGlvbigoKSA9PiB7XG4gICAgcGxheWVyLnJlc29sdmUoKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHBsYXllcjtcbn07XG5leHBvcnQgZGVmYXVsdCBwbGF5ZXJPbmU7XG4iLCJpbXBvcnQgSyBmcm9tICcuLi9mdW5jdGlvbnMvaW5pdC5qcyc7XG5cbmxldCB0YWxraW5nID0gW107XG5cbmV4cG9ydCBjb25zdCBpZlRhbGtpbmcgPSAoKSA9PiB7XG4gIGlmICh0YWxraW5nWzBdKSB7XG4gICAgZm9yIChjb25zdCB0IG9mIHRhbGtpbmcpIHtcbiAgICAgIEsuZGVzdHJveSh0KTtcbiAgICB9XG4gICAgdGFsa2luZyA9IFtdO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgdGFsayA9IChtZXNzYWdlKSA9PiB7XG4gIGlmVGFsa2luZygpO1xuICB0YWxraW5nLnB1c2goXG4gICAgSy5hZGQoW1xuICAgICAgSy50ZXh0KG1lc3NhZ2UsIDcsIHsgd2lkdGg6IDE0MCB9KSxcbiAgICAgIEsucG9zKEsud2lkdGgoKSAvIDIsIEsuaGVpZ2h0KCkgLSAxMSksXG4gICAgICBLLm9yaWdpbignY2VudGVyJyksXG4gICAgXSksXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgY2xvdWR5VGFsayA9IChtZXNzYWdlKSA9PiB7XG4gIGlmVGFsa2luZygpO1xuICB0YWxraW5nLnB1c2goXG4gICAgSy5hZGQoW0sudGV4dChtZXNzYWdlKSwgSy5wb3MoSy53aWR0aCgpIC8gMiwgMTEpLCBLLm9yaWdpbignY2VudGVyJyldKSxcbiAgKTtcbn07XG4iLCJpbXBvcnQgcGxheWVyT25lIGZyb20gJy4uL2NvbnRlbnQvcGxheWVyLmpzJztcbmltcG9ydCB7IGlmVGFsa2luZyB9IGZyb20gJy4uL2NvbnRlbnQvdGFsa2luZy5qcyc7XG5cbmltcG9ydCBLIGZyb20gJy4vaW5pdC5qcyc7XG5pbXBvcnQgJy4vem9vbS5qcyc7XG5cbmxldCBnZXRNb3ZpbmcgPSAoKSA9PiB7fTtcbmxldCBpc0Rvd24gPSBmYWxzZTtcbmxldCBkaXJlY3Rpb247XG5sZXQgdGltZXI7XG5sZXQgc291bmQgPSBmYWxzZTtcblxuY29uc3QgY29udHJvbHMgPSAoKSA9PiB7XG4gIGNvbnN0IHBsYXllciA9IHBsYXllck9uZSgpO1xuICBjb25zdCBTUEVFRCA9IDgwO1xuXG4gIGNvbnN0IGRpcmVjdG9yaWVzID0ge1xuICAgIGxlZnQ6IEsudmVjMigtMSwgMCksXG4gICAgdXA6IEsudmVjMigwLCAtMSksXG4gICAgcmlnaHQ6IEsudmVjMigxLCAwKSxcbiAgICBkb3duOiBLLnZlYzIoMCwgMSksXG4gIH07XG5cbiAgY29uc3QgZGlyZWN0aW9uS2V5cyA9IE9iamVjdC5rZXlzKGRpcmVjdG9yaWVzKTtcbiAgZm9yIChjb25zdCBrZXkgb2YgZGlyZWN0aW9uS2V5cykge1xuICAgIEsua2V5UHJlc3Moa2V5LCBpZlRhbGtpbmcpO1xuICAgIEsua2V5RG93bihrZXksICgpID0+IHtcbiAgICAgIHBsYXllci5tb3ZlKGRpcmVjdG9yaWVzW2tleV0uc2NhbGUoU1BFRUQpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldE1vdmluZyA9ICgpID0+IHtcbiAgICBpZlRhbGtpbmcoKTtcbiAgICB0aW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGlmIChpc0Rvd24pIHtcbiAgICAgICAgcGxheWVyLm1vdmUoZGlyZWN0b3JpZXNbZGlyZWN0aW9uXS5zY2FsZShTUEVFRCkpO1xuICAgICAgfVxuICAgIH0sIDE1KTtcbiAgfTtcbn07XG5cbmNvbnN0IHBsYXllck1vdmUgPSAoZXZlbnQpID0+IHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gIGlmIChcbiAgICBldmVudC50eXBlICE9PSAnbW91c2V1cCcgJiZcbiAgICBldmVudC50eXBlICE9PSAndG91Y2hlbmQnICYmXG4gICAgZXZlbnQudHlwZSAhPT0gJ3RvdWNoY2FuY2VsJyAmJlxuICAgIChldmVudC50YXJnZXQuaWQgPT09ICd1cCcgfHxcbiAgICAgIGV2ZW50LnRhcmdldC5pZCA9PT0gJ3JpZ2h0JyB8fFxuICAgICAgZXZlbnQudGFyZ2V0LmlkID09PSAnZG93bicgfHxcbiAgICAgIGV2ZW50LnRhcmdldC5pZCA9PT0gJ2xlZnQnKVxuICApIHtcbiAgICBpZiAoXG4gICAgICBldmVudC5idXR0b25zID09PSAxIHx8XG4gICAgICBldmVudC5idXR0b25zID09PSAzIHx8XG4gICAgICBldmVudC50eXBlID09PSAndG91Y2hzdGFydCcgfHxcbiAgICAgIGV2ZW50LnR5cGUgPT09ICd0b3VjaG1vdmUnXG4gICAgKSB7XG4gICAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgIGlzRG93biA9IHRydWU7XG4gICAgICBkaXJlY3Rpb24gPSBldmVudC50YXJnZXQuaWQ7XG4gICAgICBnZXRNb3ZpbmcoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgaXNEb3duID0gZmFsc2U7XG4gIH1cbn07XG5cbmNvbnN0IGJsYWNrU2NyZWVuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2JsYWNrU2NyZWVuJyk7XG5jb25zdCB0aXRsZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0aXRsZScpO1xuXG5jb25zdCB0b3VjaFN0YXJ0ID0gKCkgPT4ge1xuICBpZiAoIXNvdW5kICYmIGdldENvbXB1dGVkU3R5bGUodGl0bGUpLm9wYWNpdHkgPT09ICcxJykge1xuICAgIEsucGxheSgnY29pbicpO1xuICAgIHNvdW5kID0gdHJ1ZTtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY29udHJvbHMnKS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2FsbCc7XG4gICAgYmxhY2tTY3JlZW4uc3R5bGUuYW5pbWF0aW9uID0gJ2ZhZGVPdXQgLjRzIGxpbmVhciAwcyBmb3J3YXJkcyc7XG4gICAgdGl0bGUuc3R5bGUuYW5pbWF0aW9uID0gJ2ZhZGVPdXQgLjJzIGxpbmVhciAwcyBmb3J3YXJkcyc7XG4gICAgY29udHJvbHMoKTtcbiAgfVxufTtcblxuYmxhY2tTY3JlZW4uYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdG91Y2hTdGFydCk7XG5ibGFja1NjcmVlbi5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdG91Y2hTdGFydCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xudGl0bGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdG91Y2hTdGFydCk7XG50aXRsZS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdG91Y2hTdGFydCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBwbGF5ZXJNb3ZlKTtcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBwbGF5ZXJNb3ZlKTtcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHBsYXllck1vdmUpO1xuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHBsYXllck1vdmUsIGZhbHNlLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHBsYXllck1vdmUsIGZhbHNlKTtcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHBsYXllck1vdmUsIGZhbHNlLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHBsYXllck1vdmUsIGZhbHNlKTtcblxuZXhwb3J0IGRlZmF1bHQgY29udHJvbHM7XG4iLCJpbXBvcnQga2Fib29tIGZyb20gJ2thYm9vbSc7XG5cbmNvbnN0IEsgPSBrYWJvb20oe1xuICBjYW52YXM6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNnYW1lJyksXG4gIGNsZWFyQ29sb3I6IFswLCAwLCAwLCAxXSxcbiAgY3Jpc3A6IHRydWUsXG4gIGZ1bGxzY3JlZW46IGZhbHNlLFxuICB3aWR0aDogMjA1LFxuICBoZWlnaHQ6IDIwNSxcbiAgc2NhbGU6IDEsXG4gIGRlYnVnOiBmYWxzZSxcbiAgZ2xvYmFsOiBmYWxzZSxcbiAgcGx1Z2luczogW10sXG59KTtcblxuSy5sb2FkUm9vdCgnY2xvdWR5bWFuL2NsaWVudC9wdWJsaWMvJyk7XG5LLmxvYWRTcHJpdGUoJ2NoMScsICdhc3NldHMvc3ByaXRlcy9jaDEucG5nJyk7XG5LLmxvYWRTcHJpdGUoJ2NoMicsICdhc3NldHMvc3ByaXRlcy9jaDIucG5nJyk7XG5LLmxvYWRTcHJpdGUoJ2Nsb3VkeW1hbicsICdhc3NldHMvc3ByaXRlcy9jbG91ZHltYW4ucG5nJyk7XG5LLmxvYWRTcHJpdGUoJ2Rvb3InLCAnYXNzZXRzL3Nwcml0ZXMvZG9vci5wbmcnKTtcbksubG9hZFNwcml0ZSgnZ3V5JywgJ2Fzc2V0cy9zcHJpdGVzL2d1eS5wbmcnKTtcbksubG9hZFNwcml0ZSgna2V5JywgJ2Fzc2V0cy9zcHJpdGVzL2tleS5wbmcnKTtcbksubG9hZFNwcml0ZSgnc3RlZWwnLCAnYXNzZXRzL3Nwcml0ZXMvc3RlZWwucG5nJyk7XG5cbksubG9hZFNvdW5kKCdjb2luJywgJ2Fzc2V0cy9zb3VuZHMvY29pbi5tcDMnKTtcbksubG9hZFNvdW5kKCdoaXQnLCAnYXNzZXRzL3NvdW5kcy9oaXQubXAzJyk7XG5LLmxvYWRTb3VuZCgnYXl5JywgJ2Fzc2V0cy9zb3VuZHMvYXl5Lm1wMycpO1xuSy5sb2FkU291bmQoJ21tbScsICdhc3NldHMvc291bmRzL21tbS5tcDMnKTtcbksubG9hZFNvdW5kKCdoYWhhJywgJ2Fzc2V0cy9zb3VuZHMvaGFoYS5tcDMnKTtcbksubG9hZFNvdW5kKCdhYWEnLCAnYXNzZXRzL3NvdW5kcy9hYWEubXAzJyk7XG5LLmxvYWRTb3VuZCgncHJpb3JpdGllcycsICdhc3NldHMvc291bmRzL3ByaW9yaXRpZXMubXAzJyk7XG5cbmV4cG9ydCBkZWZhdWx0IEs7XG4iLCJsZXQgaXNab29tZWQgPSBmYWxzZTtcblxuY29uc3Qgem9vbSA9ICgpID0+IHtcbiAgaWYgKCFpc1pvb21lZCkge1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNib2R5Jykuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSAnZmxleC1zdGFydCc7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2FwcCcpLnN0eWxlLmp1c3RpZnlDb250ZW50ID0gJ2ZsZXgtc3RhcnQnO1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNhcHAnKS5zdHlsZS5oZWlnaHQgPSAnMTkwJSc7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3pvb20nKS5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0aXRsZScpLnN0eWxlLnRyYW5zZm9ybSA9ICdzY2FsZSgyLjEpJztcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjYmFja2dyb3VuZCcpLnN0eWxlLm1heFdpZHRoID0gJ25vbmUnO1xuICAgIGlzWm9vbWVkID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjYm9keScpLnN0eWxlLmp1c3RpZnlDb250ZW50ID0gJ2NlbnRlcic7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2FwcCcpLnN0eWxlLmp1c3RpZnlDb250ZW50ID0gJ2NlbnRlcic7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2FwcCcpLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjem9vbScpLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGl0bGUnKS5zdHlsZS50cmFuc2Zvcm0gPSAnc2NhbGUoMSknO1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNiYWNrZ3JvdW5kJykuc3R5bGUubWF4V2lkdGggPSAnMTAwJSc7XG4gICAgaXNab29tZWQgPSBmYWxzZTtcbiAgfVxufTtcblxuZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3pvb20nKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHpvb20pO1xuXG5pZiAoZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICdjb250ZXh0bWVudScsXG4gICAgKGV2ZW50XykgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjem9vbScpKS52aXNpYmlsaXR5ID09PVxuICAgICAgICAndmlzaWJsZSdcbiAgICAgICkge1xuICAgICAgICB6b29tKCk7XG4gICAgICB9XG4gICAgICBldmVudF8ucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuICAgIGZhbHNlLFxuICApO1xufSBlbHNlIHtcbiAgZG9jdW1lbnQuYXR0YWNoRXZlbnQoJ29uY29udGV4dG1lbnUnLCAoKSA9PiB7XG4gICAgaWYgKFxuICAgICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3pvb20nKSkudmlzaWJpbGl0eSA9PT1cbiAgICAgICd2aXNpYmxlJ1xuICAgICkge1xuICAgICAgem9vbSgpO1xuICAgIH1cbiAgICB3aW5kb3cuZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgY2hhcmFjdGVycyBmcm9tICcuLi9jb250ZW50L2NoYXJhY3RlcnMuanMnO1xuaW1wb3J0IEsgZnJvbSAnLi4vZnVuY3Rpb25zL2luaXQuanMnO1xuXG5jb25zdCBvbmUgPSAoKSA9PiB7XG4gIGNvbnN0IGxldmVsID0gW1xuICAgICc9PT09PT09fD09PT09PT0nLFxuICAgICc9ICAgICA9ID0gICA9JD0nLFxuICAgICc9IGEgICA9ID0gYSA9ID0nLFxuICAgICc9ICAgICA9ID0gICA9ID0nLFxuICAgICc9ICAgICAgICAgICAgID0nLFxuICAgICc9ICAgID09PT09PT09PT0nLFxuICAgICc9IGIgICAgICAgICAgID0nLFxuICAgICc9PT09PT09PT09PWEgID0nLFxuICAgICc9ICAgICAgICAgID0gID0nLFxuICAgICc9ICA9PT09PT0gID0gID0nLFxuICAgICc9ICA9YiAgID0gID0gID0nLFxuICAgICc9ICA9ICA9ID0gID0gID0nLFxuICAgICc9ICA9ICA9ID0gID0gID0nLFxuICAgICc9ICAgICA9QD0gICAgID0nLFxuICAgICc9PT09PT09PT09PT09PT0nLFxuICBdO1xuXG4gIEsuYWRkTGV2ZWwobGV2ZWwsIHtcbiAgICB3aWR0aDogMTEsXG4gICAgaGVpZ2h0OiAxMSxcbiAgICBwb3M6IEsudmVjMigyMCwgMjApLFxuICAgICc9JzogW0suc3ByaXRlKCdzdGVlbCcpLCBLLnNvbGlkKCldLFxuICAgICQ6IFtLLnNwcml0ZSgna2V5JyksICdrZXknXSxcbiAgICAnQCc6IFtLLnNwcml0ZSgnZ3V5JyksICdwbGF5ZXJPbmUnXSxcbiAgICAnfCc6IFtLLnNwcml0ZSgnZG9vcicpLCBLLnNvbGlkKCksICdkb29yMSddLFxuICAgIGFueShjaCkge1xuICAgICAgY29uc3QgY2hhciA9IGNoYXJhY3RlcnNbY2hdO1xuICAgICAgaWYgKGNoYXIpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBLLnNwcml0ZShjaGFyLnNwcml0ZSksXG4gICAgICAgICAgSy5zb2xpZCgpLFxuICAgICAgICAgIGNoYXIuc3ByaXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1zZzogY2hhci5tc2csXG4gICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGFyO1xuICAgIH0sXG4gIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgb25lO1xuIiwiLyogZXNsaW50LWRpc2FibGUgc29uYXJqcy9uby1kdXBsaWNhdGUtc3RyaW5nICovXG5pbXBvcnQgY2hhcmFjdGVycyBmcm9tICcuLi9jb250ZW50L2NoYXJhY3RlcnMuanMnO1xuaW1wb3J0IGNvbnRyb2xzIGZyb20gJy4uL2Z1bmN0aW9ucy9jb250cm9scy5qcyc7XG5pbXBvcnQgSyBmcm9tICcuLi9mdW5jdGlvbnMvaW5pdC5qcyc7XG5cbmNvbnN0IHR3byA9ICgpID0+IHtcbiAgY29uc3QgbGV2ZWwgPSBbXG4gICAgJz09PT09PT1GPT09PT09PScsXG4gICAgJz0gICAgICAgICAgICAgPScsXG4gICAgJz0gICAgICAgICAgICAgPScsXG4gICAgJz0gICAgICEgICAgICAgPScsXG4gICAgJz0gICAgICAgICAgICAgPScsXG4gICAgJz0gICAgICAgICAgICAgPScsXG4gICAgJz0gICAgICAgICAgICAgPScsXG4gICAgJz0gICAgICAgICAgICAgPScsXG4gICAgJz0gICAgICAgICAgICAgPScsXG4gICAgJz0gICAgICAgICAgICAgPScsXG4gICAgJz0gICAgICAgICAgICAgPScsXG4gICAgJz0gICAgICAgICAgICAgPScsXG4gICAgJz0gICAgICAgICAgICAgPScsXG4gICAgJz0gICAgICBAICAgICAgPScsXG4gICAgJz09PT09PT09PT09PT09PScsXG4gIF07XG5cbiAgSy5hZGRMZXZlbChsZXZlbCwge1xuICAgIHdpZHRoOiAxMSxcbiAgICBoZWlnaHQ6IDExLFxuICAgIHBvczogSy52ZWMyKDIwLCAyMCksXG4gICAgJz0nOiBbSy5zcHJpdGUoJ3N0ZWVsJyksIEsuc29saWQoKV0sXG4gICAgJ0AnOiBbSy5zcHJpdGUoJ2d1eScpLCAncGxheWVyT25lJ10sXG4gICAgJyEnOiBbXG4gICAgICBLLnNwcml0ZShjaGFyYWN0ZXJzLmNsb3VkeW1hbi5zcHJpdGUpLFxuICAgICAgSy5zb2xpZCgpLFxuICAgICAgY2hhcmFjdGVycy5jbG91ZHltYW4uc3ByaXRlLFxuICAgICAgeyBtc2c6IGNoYXJhY3RlcnMuY2xvdWR5bWFuLm1zZyB9LFxuICAgIF0sXG4gICAgRjogW0suc3ByaXRlKCdkb29yJyksIEsuc29saWQoKSwgJ2ZpbmFsRG9vciddLFxuICB9KTtcbiAgY29udHJvbHMoKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHR3bztcbiIsImltcG9ydCBLIGZyb20gJy4uL2Z1bmN0aW9ucy9pbml0LmpzJztcblxuY29uc3Qgd2luID0gKCkgPT4ge1xuICBLLnBsYXkoJ3ByaW9yaXRpZXMnKTtcbiAgSy5hZGQoW1xuICAgIEsudGV4dCgneW91IHdpbiEnKSxcbiAgICBLLnBvcyhLLndpZHRoKCkgLyAyLCBLLmhlaWdodCgpIC8gMiksXG4gICAgSy5vcmlnaW4oJ2NlbnRlcicpLFxuICBdKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHdpbjtcbiIsInZhciBKZT1PYmplY3QuZGVmaW5lUHJvcGVydHksUXQ9T2JqZWN0LmRlZmluZVByb3BlcnRpZXM7dmFyIEp0PU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO3ZhciBldD1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO3ZhciBlbj1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LHRuPU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7dmFyIHR0PSh0LGUsbyk9PmUgaW4gdD9KZSh0LGUse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm99KTp0W2VdPW8sbGU9KHQsZSk9Pntmb3IodmFyIG8gaW4gZXx8KGU9e30pKWVuLmNhbGwoZSxvKSYmdHQodCxvLGVbb10pO2lmKGV0KWZvcih2YXIgbyBvZiBldChlKSl0bi5jYWxsKGUsbykmJnR0KHQsbyxlW29dKTtyZXR1cm4gdH0sd2U9KHQsZSk9PlF0KHQsSnQoZSkpO3ZhciByPSh0LGUpPT5KZSh0LFwibmFtZVwiLHt2YWx1ZTplLGNvbmZpZ3VyYWJsZTohMH0pO3ZhciBmZT0odCxlKT0+KCk9Pih0JiYoZT10KHQ9MCkpLGUpLG5uPSh0LGUpPT4oKT0+KGV8fHQoKGU9e2V4cG9ydHM6e319KS5leHBvcnRzLGUpLGUuZXhwb3J0cyk7ZnVuY3Rpb24gbnQodCl7cmV0dXJuIHQqTWF0aC5QSS8xODB9ZnVuY3Rpb24gcnQodCl7cmV0dXJuIHQqMTgwL01hdGguUEl9ZnVuY3Rpb24gYWUodCxlLG8pe3JldHVybiBlPm8/YWUodCxvLGUpOk1hdGgubWluKE1hdGgubWF4KHQsZSksbyl9ZnVuY3Rpb24gRGUodCxlLG8pe3JldHVybiB0KyhlLXQpKm99ZnVuY3Rpb24gdmUodCxlLG8saSxtKXtyZXR1cm4gaSsodC1lKS8oby1lKSoobS1pKX1mdW5jdGlvbiBzdCh0LGUsbyxpLG0pe3JldHVybiBhZSh2ZSh0LGUsbyxpLG0pLGksbSl9ZnVuY3Rpb24gZiguLi50KXtpZih0Lmxlbmd0aD09PTApcmV0dXJuIGYoMCwwKTtpZih0Lmxlbmd0aD09PTEpe2lmKHR5cGVvZiB0WzBdPT1cIm51bWJlclwiKXJldHVybiBmKHRbMF0sdFswXSk7aWYoUmUodFswXSkpcmV0dXJuIGYodFswXS54LHRbMF0ueSk7aWYoQXJyYXkuaXNBcnJheSh0WzBdKSYmdFswXS5sZW5ndGg9PT0yKXJldHVybiBmLmFwcGx5KG51bGwsdFswXSl9cmV0dXJue3g6dFswXSx5OnRbMV0sY2xvbmUoKXtyZXR1cm4gZih0aGlzLngsdGhpcy55KX0sYWRkKC4uLmUpe2xldCBvPWYoLi4uZSk7cmV0dXJuIGYodGhpcy54K28ueCx0aGlzLnkrby55KX0sc3ViKC4uLmUpe2xldCBvPWYoLi4uZSk7cmV0dXJuIGYodGhpcy54LW8ueCx0aGlzLnktby55KX0sc2NhbGUoZSl7cmV0dXJuIGYodGhpcy54KmUsdGhpcy55KmUpfSxkaXN0KC4uLmUpe2xldCBvPWYoLi4uZSk7cmV0dXJuIE1hdGguc3FydCgodGhpcy54LW8ueCkqKHRoaXMueC1vLngpKyh0aGlzLnktby55KSoodGhpcy55LW8ueSkpfSxsZW4oKXtyZXR1cm4gdGhpcy5kaXN0KGYoMCwwKSl9LHVuaXQoKXtyZXR1cm4gdGhpcy5zY2FsZSgxL3RoaXMubGVuKCkpfSxub3JtYWwoKXtyZXR1cm4gZih0aGlzLnksLXRoaXMueCl9LGRvdCguLi5lKXtsZXQgbz1mKC4uLmUpO3JldHVybiBmKHRoaXMueCpvLngsdGhpcy55Km8ueSl9LGFuZ2xlKC4uLmUpe2xldCBvPWYoLi4uZSk7cmV0dXJuIE1hdGguYXRhbjIodGhpcy55LW8ueSx0aGlzLngtby54KX0sbGVycChlLG8pe3JldHVybiBmKERlKHRoaXMueCxlLngsbyksRGUodGhpcy55LGUueSxvKSl9LGVxKGUpe3JldHVybiB0aGlzLng9PT1lLngmJnRoaXMueT09PWUueX0sc3RyKCl7cmV0dXJuYCgke3RoaXMueH0sICR7dGhpcy55fSlgfX19ZnVuY3Rpb24gb3QodCl7cmV0dXJuIGYoTWF0aC5jb3ModCksTWF0aC5zaW4odCkpfWZ1bmN0aW9uIFRlKHQsZSxvKXtyZXR1cm57eDp0LHk6ZSx6Om8seHkoKXtyZXR1cm4gZih0aGlzLngsdGhpcy55KX19fWZ1bmN0aW9uIFJlKHQpe3JldHVybiB0IT09dm9pZCAwJiZ0LnghPT12b2lkIDAmJnQueSE9PXZvaWQgMH1mdW5jdGlvbiBpdCh0KXtyZXR1cm4gdCE9PXZvaWQgMCYmdC54IT09dm9pZCAwJiZ0LnkhPT12b2lkIDAmJnQueiE9PXZvaWQgMH1mdW5jdGlvbiB5ZSh0KXtyZXR1cm4gdCE9PXZvaWQgMCYmdC5yIT09dm9pZCAwJiZ0LmchPT12b2lkIDAmJnQuYiE9PXZvaWQgMCYmdC5hIT09dm9pZCAwfWZ1bmN0aW9uIGF0KHQpe2lmKHQhPT12b2lkIDAmJkFycmF5LmlzQXJyYXkodC5tKSYmdC5tLmxlbmd0aD09PTE2KXJldHVybiB0fWZ1bmN0aW9uIFZlKC4uLnQpe2lmKHQubGVuZ3RoPT09MClyZXR1cm4gWSgpO2lmKHQubGVuZ3RoPT09MSl7aWYoeWUodFswXSkpcmV0dXJuIFkodFswXSk7aWYoQXJyYXkuaXNBcnJheSh0WzBdKSYmdFswXS5sZW5ndGg9PT0zKXJldHVybiBWZS5hcHBseShudWxsLHRbMF0pfXJldHVybiBZKHRbMF0sdFsxXSx0WzJdLDEpfWZ1bmN0aW9uIFkoLi4udCl7dmFyIGU7aWYodC5sZW5ndGg9PT0wKXJldHVybiBZKDEsMSwxLDEpO2lmKHQubGVuZ3RoPT09MSl7aWYoeWUodFswXSkpcmV0dXJuIFkodFswXS5yLHRbMF0uZyx0WzBdLmIsdFswXS5hKTtpZihBcnJheS5pc0FycmF5KHRbMF0pJiZ0WzBdLmxlbmd0aD09PTQpcmV0dXJuIFkuYXBwbHkobnVsbCx0WzBdKX1yZXR1cm57cjp0WzBdLGc6dFsxXSxiOnRbMl0sYTooZT10WzNdKSE9bnVsbD9lOjEsY2xvbmUoKXtyZXR1cm4gWSh0aGlzLnIsdGhpcy5nLHRoaXMuYix0aGlzLmEpfSxsaWdodGVuKG8pe3JldHVybiBZKHRoaXMucitvLHRoaXMuZytvLHRoaXMuYitvLHRoaXMuYSl9LGRhcmtlbihvKXtyZXR1cm4gdGhpcy5saWdodGVuKC1vKX0saW52ZXJ0KCl7cmV0dXJuIFkoMS10aGlzLnIsMS10aGlzLmcsMS10aGlzLmIsdGhpcy5hKX0saXNEYXJrKG89LjUpe3JldHVybiB0aGlzLnIrdGhpcy5nK3RoaXMuYjwzKm99LGlzTGlnaHQobz0uNSl7cmV0dXJuIHRoaXMucit0aGlzLmcrdGhpcy5iPjMqb30sZXEobyl7cmV0dXJuIHRoaXMucj09PW8uciYmdGhpcy5nPT09by5nJiZ0aGlzLmI9PT1vLmcmJnRoaXMuYT09PW8uYX19fWZ1bmN0aW9uIG9lKHQsZSxvLGkpe3JldHVybnt4OnQseTplLHc6byxoOmksY2xvbmUoKXtyZXR1cm4gb2UodGhpcy54LHRoaXMueSx0aGlzLncsdGhpcy5oKX0sZXEobSl7cmV0dXJuIHRoaXMueD09PW0ueCYmdGhpcy55PT09bS55JiZ0aGlzLnc9PT1tLncmJnRoaXMuaD09PW0uaH19fWZ1bmN0aW9uIGVlKHQpe3JldHVybnttOnQ/Wy4uLnRdOlsxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwxXSxjbG9uZSgpe3JldHVybiBlZSh0aGlzLm0pfSxtdWx0KGUpe2xldCBvPVtdO2ZvcihsZXQgaT0wO2k8NDtpKyspZm9yKGxldCBtPTA7bTw0O20rKylvW2kqNCttXT10aGlzLm1bMCo0K21dKmUubVtpKjQrMF0rdGhpcy5tWzEqNCttXSplLm1baSo0KzFdK3RoaXMubVsyKjQrbV0qZS5tW2kqNCsyXSt0aGlzLm1bMyo0K21dKmUubVtpKjQrM107cmV0dXJuIGVlKG8pfSxtdWx0VmVjNChlKXtyZXR1cm57eDplLngqdGhpcy5tWzBdK2UueSp0aGlzLm1bNF0rZS56KnRoaXMubVs4XStlLncqdGhpcy5tWzEyXSx5OmUueCp0aGlzLm1bMV0rZS55KnRoaXMubVs1XStlLnoqdGhpcy5tWzldK2Uudyp0aGlzLm1bMTNdLHo6ZS54KnRoaXMubVsyXStlLnkqdGhpcy5tWzZdK2Uueip0aGlzLm1bMTBdK2Uudyp0aGlzLm1bMTRdLHc6ZS54KnRoaXMubVszXStlLnkqdGhpcy5tWzddK2Uueip0aGlzLm1bMTFdK2Uudyp0aGlzLm1bMTVdfX0sbXVsdFZlYzMoZSl7bGV0IG89dGhpcy5tdWx0VmVjNCh7eDplLngseTplLnksejplLnosdzoxfSk7cmV0dXJuIFRlKG8ueCxvLnksby56KX0sbXVsdFZlYzIoZSl7cmV0dXJuIGYoZS54KnRoaXMubVswXStlLnkqdGhpcy5tWzRdKzAqdGhpcy5tWzhdKzEqdGhpcy5tWzEyXSxlLngqdGhpcy5tWzFdK2UueSp0aGlzLm1bNV0rMCp0aGlzLm1bOV0rMSp0aGlzLm1bMTNdKX0sdHJhbnNsYXRlKGUpe3JldHVybiB0aGlzLm11bHQoZWUoWzEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLGUueCxlLnksMCwxXSkpfSxzY2FsZShlKXtyZXR1cm4gdGhpcy5tdWx0KGVlKFtlLngsMCwwLDAsMCxlLnksMCwwLDAsMCwxLDAsMCwwLDAsMV0pKX0scm90YXRlWChlKXtyZXR1cm4gdGhpcy5tdWx0KGVlKFsxLDAsMCwwLDAsTWF0aC5jb3MoZSksLU1hdGguc2luKGUpLDAsMCxNYXRoLnNpbihlKSxNYXRoLmNvcyhlKSwwLDAsMCwwLDFdKSl9LHJvdGF0ZVkoZSl7cmV0dXJuIHRoaXMubXVsdChlZShbTWF0aC5jb3MoZSksMCwtTWF0aC5zaW4oZSksMCwwLDEsMCwwLE1hdGguc2luKGUpLDAsTWF0aC5jb3MoZSksMCwwLDAsMCwxXSkpfSxyb3RhdGVaKGUpe3JldHVybiB0aGlzLm11bHQoZWUoW01hdGguY29zKGUpLC1NYXRoLnNpbihlKSwwLDAsTWF0aC5zaW4oZSksTWF0aC5jb3MoZSksMCwwLDAsMCwxLDAsMCwwLDAsMV0pKX0saW52ZXJ0KCl7bGV0IGU9W10sbz10aGlzLm1bMTBdKnRoaXMubVsxNV0tdGhpcy5tWzE0XSp0aGlzLm1bMTFdLGk9dGhpcy5tWzldKnRoaXMubVsxNV0tdGhpcy5tWzEzXSp0aGlzLm1bMTFdLG09dGhpcy5tWzldKnRoaXMubVsxNF0tdGhpcy5tWzEzXSp0aGlzLm1bMTBdLHY9dGhpcy5tWzhdKnRoaXMubVsxNV0tdGhpcy5tWzEyXSp0aGlzLm1bMTFdLEE9dGhpcy5tWzhdKnRoaXMubVsxNF0tdGhpcy5tWzEyXSp0aGlzLm1bMTBdLFI9dGhpcy5tWzhdKnRoaXMubVsxM10tdGhpcy5tWzEyXSp0aGlzLm1bOV0sJD10aGlzLm1bNl0qdGhpcy5tWzE1XS10aGlzLm1bMTRdKnRoaXMubVs3XSxrPXRoaXMubVs1XSp0aGlzLm1bMTVdLXRoaXMubVsxM10qdGhpcy5tWzddLEk9dGhpcy5tWzVdKnRoaXMubVsxNF0tdGhpcy5tWzEzXSp0aGlzLm1bNl0saj10aGlzLm1bNF0qdGhpcy5tWzE1XS10aGlzLm1bMTJdKnRoaXMubVs3XSxUPXRoaXMubVs0XSp0aGlzLm1bMTRdLXRoaXMubVsxMl0qdGhpcy5tWzZdLHc9dGhpcy5tWzVdKnRoaXMubVsxNV0tdGhpcy5tWzEzXSp0aGlzLm1bN10sUz10aGlzLm1bNF0qdGhpcy5tWzEzXS10aGlzLm1bMTJdKnRoaXMubVs1XSxVPXRoaXMubVs2XSp0aGlzLm1bMTFdLXRoaXMubVsxMF0qdGhpcy5tWzddLEI9dGhpcy5tWzVdKnRoaXMubVsxMV0tdGhpcy5tWzldKnRoaXMubVs3XSxfPXRoaXMubVs1XSp0aGlzLm1bMTBdLXRoaXMubVs5XSp0aGlzLm1bNl0sRz10aGlzLm1bNF0qdGhpcy5tWzExXS10aGlzLm1bOF0qdGhpcy5tWzddLHk9dGhpcy5tWzRdKnRoaXMubVsxMF0tdGhpcy5tWzhdKnRoaXMubVs2XSxIPXRoaXMubVs0XSp0aGlzLm1bOV0tdGhpcy5tWzhdKnRoaXMubVs1XTtlWzBdPXRoaXMubVs1XSpvLXRoaXMubVs2XSppK3RoaXMubVs3XSptLGVbNF09LSh0aGlzLm1bNF0qby10aGlzLm1bNl0qdit0aGlzLm1bN10qQSksZVs4XT10aGlzLm1bNF0qaS10aGlzLm1bNV0qdit0aGlzLm1bN10qUixlWzEyXT0tKHRoaXMubVs0XSptLXRoaXMubVs1XSpBK3RoaXMubVs2XSpSKSxlWzFdPS0odGhpcy5tWzFdKm8tdGhpcy5tWzJdKmkrdGhpcy5tWzNdKm0pLGVbNV09dGhpcy5tWzBdKm8tdGhpcy5tWzJdKnYrdGhpcy5tWzNdKkEsZVs5XT0tKHRoaXMubVswXSppLXRoaXMubVsxXSp2K3RoaXMubVszXSpSKSxlWzEzXT10aGlzLm1bMF0qbS10aGlzLm1bMV0qQSt0aGlzLm1bMl0qUixlWzJdPXRoaXMubVsxXSokLXRoaXMubVsyXSprK3RoaXMubVszXSpJLGVbNl09LSh0aGlzLm1bMF0qJC10aGlzLm1bMl0qait0aGlzLm1bM10qVCksZVsxMF09dGhpcy5tWzBdKnctdGhpcy5tWzFdKmordGhpcy5tWzNdKlMsZVsxNF09LSh0aGlzLm1bMF0qSS10aGlzLm1bMV0qVCt0aGlzLm1bMl0qUyksZVszXT0tKHRoaXMubVsxXSpVLXRoaXMubVsyXSpCK3RoaXMubVszXSpfKSxlWzddPXRoaXMubVswXSpVLXRoaXMubVsyXSpHK3RoaXMubVszXSp5LGVbMTFdPS0odGhpcy5tWzBdKkItdGhpcy5tWzFdKkcrdGhpcy5tWzNdKkgpLGVbMTVdPXRoaXMubVswXSpfLXRoaXMubVsxXSp5K3RoaXMubVsyXSpIO2xldCBNPXRoaXMubVswXSplWzBdK3RoaXMubVsxXSplWzRdK3RoaXMubVsyXSplWzhdK3RoaXMubVszXSplWzEyXTtmb3IobGV0IHE9MDtxPDQ7cSsrKWZvcihsZXQgSj0wO0o8NDtKKyspZVtxKjQrSl0qPTEvTTtyZXR1cm4gZWUoZSl9fX1mdW5jdGlvbiB1dCh0LGUsbyl7cmV0dXJuIHQrKE1hdGguc2luKG8pKzEpLzIqKGUtdCl9ZnVuY3Rpb24gWGUodCl7cmV0dXJue3NlZWQ6dCxnZW4oLi4uZSl7aWYoZS5sZW5ndGg9PT0wKXJldHVybiB0aGlzLnNlZWQ9KHJuKnRoaXMuc2VlZCtzbiklY3QsdGhpcy5zZWVkL2N0O2lmKGUubGVuZ3RoPT09MSl7aWYodHlwZW9mIGVbMF09PVwibnVtYmVyXCIpcmV0dXJuIHRoaXMuZ2VuKDAsZVswXSk7aWYoUmUoZVswXSkpcmV0dXJuIHRoaXMuZ2VuKGYoMCwwKSxlWzBdKTtpZih5ZShlWzBdKSlyZXR1cm4gdGhpcy5nZW4oWSgwLDAsMCwwKSxlWzBdKX1lbHNlIGlmKGUubGVuZ3RoPT09Mil7aWYodHlwZW9mIGVbMF09PVwibnVtYmVyXCImJnR5cGVvZiBlWzFdPT1cIm51bWJlclwiKXJldHVybiB0aGlzLmdlbigpKihlWzFdLWVbMF0pK2VbMF07aWYoUmUoZVswXSkmJlJlKGVbMV0pKXJldHVybiBmKHRoaXMuZ2VuKGVbMF0ueCxlWzFdLngpLHRoaXMuZ2VuKGVbMF0ueSxlWzFdLnkpKTtpZih5ZShlWzBdKSYmeWUoZVsxXSkpcmV0dXJuIFkodGhpcy5nZW4oZVswXS5yLGVbMV0uciksdGhpcy5nZW4oZVswXS5nLGVbMV0uZyksdGhpcy5nZW4oZVswXS5iLGVbMV0uYiksdGhpcy5nZW4oZVswXS5hLGVbMV0uYSkpfX19fWZ1bmN0aW9uIGZ0KHQpe2R0LnNlZWQ9dH1mdW5jdGlvbiBQZSguLi50KXtyZXR1cm4gZHQuZ2VuKC4uLnQpfWZ1bmN0aW9uIGh0KHQpe3JldHVybiBQZSgpPD10fWZ1bmN0aW9uIG10KHQpe3JldHVybiB0W01hdGguZmxvb3IoUGUodC5sZW5ndGgpKV19ZnVuY3Rpb24gWWUodCxlKXtyZXR1cm4gdC5wMi54Pj1lLnAxLngmJnQucDEueDw9ZS5wMi54JiZ0LnAyLnk+PWUucDEueSYmdC5wMS55PD1lLnAyLnl9ZnVuY3Rpb24gbHQodCxlKXtyZXR1cm4gdC5wMi54PmUucDEueCYmdC5wMS54PGUucDIueCYmdC5wMi55PmUucDEueSYmdC5wMS55PGUucDIueX1mdW5jdGlvbiBwdCh0LGUpe3JldHVybiBlLng+PXQucDEueCYmZS54PD10LnAyLngmJmUueT49dC5wMS55JiZlLnk8dC5wMi55fXZhciBybixzbixjdCxkdCx4ZT1mZSgoKT0+e3IobnQsXCJkZWcycmFkXCIpO3IocnQsXCJyYWQyZGVnXCIpO3IoYWUsXCJjbGFtcFwiKTtyKERlLFwibGVycFwiKTtyKHZlLFwibWFwXCIpO3Ioc3QsXCJtYXBjXCIpO3IoZixcInZlYzJcIik7cihvdCxcInZlYzJGcm9tQW5nbGVcIik7cihUZSxcInZlYzNcIik7cihSZSxcImlzVmVjMlwiKTtyKGl0LFwiaXNWZWMzXCIpO3IoeWUsXCJpc0NvbG9yXCIpO3IoYXQsXCJpc01hdDRcIik7cihWZSxcInJnYlwiKTtyKFksXCJyZ2JhXCIpO3Iob2UsXCJxdWFkXCIpO3IoZWUsXCJtYXQ0XCIpO3IodXQsXCJ3YXZlXCIpO3JuPTExMDM1MTUyNDUsc249MTIzNDUsY3Q9MjE0NzQ4MzY0OCxkdD1YZShEYXRlLm5vdygpKTtyKFhlLFwibWFrZVJuZ1wiKTtyKGZ0LFwicmFuZFNlZWRcIik7cihQZSxcInJhbmRcIik7cihodCxcImNoYW5jZVwiKTtyKG10LFwiY2hvb3NlXCIpO3IoWWUsXCJjb2xSZWN0UmVjdFwiKTtyKGx0LFwib3ZlcmxhcFJlY3RSZWN0XCIpO3IocHQsXCJjb2xSZWN0UHRcIil9KTtmdW5jdGlvbiAkZSh0LGUpe2xldCBvPXR5cGVvZiB0LGk9dHlwZW9mIGU7aWYobyE9PWkpcmV0dXJuITE7aWYobz09PVwib2JqZWN0XCImJmk9PT1cIm9iamVjdFwiKXtsZXQgbT1PYmplY3Qua2V5cyh0KSx2PU9iamVjdC5rZXlzKGUpO2lmKG0ubGVuZ3RoIT09di5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBBIG9mIG0pe2xldCBSPXRbQV0sJD1lW0FdO2lmKCEodHlwZW9mIFI9PVwiZnVuY3Rpb25cIiYmdHlwZW9mICQ9PVwiZnVuY3Rpb25cIikmJiEkZShSLCQpKXJldHVybiExfXJldHVybiEwfXJldHVybiB0PT09ZX12YXIgYnQ9ZmUoKCk9PntyKCRlLFwiZGVlcEVxXCIpfSk7ZnVuY3Rpb24gTGUodCl7c3dpdGNoKHQpe2Nhc2VcInRvcGxlZnRcIjpyZXR1cm4gZigtMSwtMSk7Y2FzZVwidG9wXCI6cmV0dXJuIGYoMCwtMSk7Y2FzZVwidG9wcmlnaHRcIjpyZXR1cm4gZigxLC0xKTtjYXNlXCJsZWZ0XCI6cmV0dXJuIGYoLTEsMCk7Y2FzZVwiY2VudGVyXCI6cmV0dXJuIGYoMCwwKTtjYXNlXCJyaWdodFwiOnJldHVybiBmKDEsMCk7Y2FzZVwiYm90bGVmdFwiOnJldHVybiBmKC0xLDEpO2Nhc2VcImJvdFwiOnJldHVybiBmKDAsMSk7Y2FzZVwiYm90cmlnaHRcIjpyZXR1cm4gZigxLDEpO2RlZmF1bHQ6cmV0dXJuIHR9fWZ1bmN0aW9uIHh0KHQsZSl7bGV0IG89KCgpPT57c3dpdGNoKGUudGV4RmlsdGVyKXtjYXNlXCJsaW5lYXJcIjpyZXR1cm4gdC5MSU5FQVI7Y2FzZVwibmVhcmVzdFwiOnJldHVybiB0Lk5FQVJFU1Q7ZGVmYXVsdDpyZXR1cm4gdC5ORUFSRVNUfX0pKCksaT0oKCk9Pnt2YXIgSztsZXQgaD1BKFdlLEtlKSx4PXYobmV3IEltYWdlRGF0YShuZXcgVWludDhDbGFtcGVkQXJyYXkoWzI1NSwyNTUsMjU1LDI1NV0pLDEsMSkpLGI9KEs9ZS5jbGVhckNvbG9yKSE9bnVsbD9LOlkoMCwwLDAsMSk7dC5jbGVhckNvbG9yKGIucixiLmcsYi5iLGIuYSksdC5lbmFibGUodC5CTEVORCksdC5ibGVuZEZ1bmNTZXBhcmF0ZSh0LlNSQ19BTFBIQSx0Lk9ORV9NSU5VU19TUkNfQUxQSEEsdC5PTkUsdC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtsZXQgTD10LmNyZWF0ZUJ1ZmZlcigpO3QuYmluZEJ1ZmZlcih0LkFSUkFZX0JVRkZFUixMKSx0LmJ1ZmZlckRhdGEodC5BUlJBWV9CVUZGRVIsTmUqNCx0LkRZTkFNSUNfRFJBVyksdC5iaW5kQnVmZmVyKHQuQVJSQVlfQlVGRkVSLG51bGwpO2xldCB6PXQuY3JlYXRlQnVmZmVyKCk7dC5iaW5kQnVmZmVyKHQuRUxFTUVOVF9BUlJBWV9CVUZGRVIseiksdC5idWZmZXJEYXRhKHQuRUxFTUVOVF9BUlJBWV9CVUZGRVIsTmUqMix0LkRZTkFNSUNfRFJBVyksdC5iaW5kQnVmZmVyKHQuRUxFTUVOVF9BUlJBWV9CVUZGRVIsbnVsbCk7bGV0IFY9dihuZXcgSW1hZ2VEYXRhKG5ldyBVaW50OENsYW1wZWRBcnJheShbMTI4LDEyOCwxMjgsMjU1LDE5MCwxOTAsMTkwLDI1NSwxOTAsMTkwLDE5MCwyNTUsMTI4LDEyOCwxMjgsMjU1XSksMiwyKSk7cmV0dXJue2RyYXdDYWxsczowLGxhc3REcmF3Q2FsbHM6MCxkZWZQcm9nOmgsY3VyUHJvZzpoLGRlZlRleDp4LGN1clRleDp4LGN1clVuaWZvcm06e30sdmJ1ZjpMLGlidWY6eix2cXVldWU6W10saXF1ZXVlOltdLHRyYW5zZm9ybTplZSgpLHRyYW5zZm9ybVN0YWNrOltdLGNsZWFyQ29sb3I6YixiZ1RleDpWfX0pKCk7SSgpLGooKTtmdW5jdGlvbiBtKGgpe3JldHVybiBNYXRoLmxvZyhoKS9NYXRoLmxvZygyKSUxPT0wfXIobSxcInBvd2VyT2ZUd29cIik7ZnVuY3Rpb24gdihoKXtsZXQgeD10LmNyZWF0ZVRleHR1cmUoKTt0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCx4KSx0LnRleEltYWdlMkQodC5URVhUVVJFXzJELDAsdC5SR0JBLHQuUkdCQSx0LlVOU0lHTkVEX0JZVEUsaCksdC50ZXhQYXJhbWV0ZXJpKHQuVEVYVFVSRV8yRCx0LlRFWFRVUkVfTUlOX0ZJTFRFUixvKSx0LnRleFBhcmFtZXRlcmkodC5URVhUVVJFXzJELHQuVEVYVFVSRV9NQUdfRklMVEVSLG8pO2xldCBiPSgoKT0+bShoLndpZHRoKSYmbShoLmhlaWdodCk/dC5SRVBFQVQ6dC5DTEFNUF9UT19FREdFKSgpO3JldHVybiB0LnRleFBhcmFtZXRlcmkodC5URVhUVVJFXzJELHQuVEVYVFVSRV9XUkFQX1MsYiksdC50ZXhQYXJhbWV0ZXJpKHQuVEVYVFVSRV8yRCx0LlRFWFRVUkVfV1JBUF9ULGIpLHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELG51bGwpLHt3aWR0aDpoLndpZHRoLGhlaWdodDpoLmhlaWdodCxiaW5kKCl7dC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQseCl9LHVuYmluZCgpe3QuYmluZFRleHR1cmUodC5URVhUVVJFXzJELG51bGwpfX19cih2LFwibWFrZVRleFwiKTtmdW5jdGlvbiBBKGg9V2UseD1LZSl7bGV0IGIsTD1vbi5yZXBsYWNlKFwie3t1c2VyfX1cIixoIT1udWxsP2g6V2UpLHo9YW4ucmVwbGFjZShcInt7dXNlcn19XCIseCE9bnVsbD94OktlKSxWPXQuY3JlYXRlU2hhZGVyKHQuVkVSVEVYX1NIQURFUiksSz10LmNyZWF0ZVNoYWRlcih0LkZSQUdNRU5UX1NIQURFUik7aWYodC5zaGFkZXJTb3VyY2UoVixMKSx0LnNoYWRlclNvdXJjZShLLHopLHQuY29tcGlsZVNoYWRlcihWKSx0LmNvbXBpbGVTaGFkZXIoSyksYj10LmdldFNoYWRlckluZm9Mb2coVikpdGhyb3cgbmV3IEVycm9yKGIpO2lmKGI9dC5nZXRTaGFkZXJJbmZvTG9nKEspKXRocm93IG5ldyBFcnJvcihiKTtsZXQgQz10LmNyZWF0ZVByb2dyYW0oKTtpZih0LmF0dGFjaFNoYWRlcihDLFYpLHQuYXR0YWNoU2hhZGVyKEMsSyksdC5iaW5kQXR0cmliTG9jYXRpb24oQywwLFwiYV9wb3NcIiksdC5iaW5kQXR0cmliTG9jYXRpb24oQywxLFwiYV91dlwiKSx0LmJpbmRBdHRyaWJMb2NhdGlvbihDLDIsXCJhX2NvbG9yXCIpLHQubGlua1Byb2dyYW0oQyksKGI9dC5nZXRQcm9ncmFtSW5mb0xvZyhDKSkmJmIhPT1gXG5gKXRocm93IG5ldyBFcnJvcihiKTtyZXR1cm57YmluZCgpe3QudXNlUHJvZ3JhbShDKX0sdW5iaW5kKCl7dC51c2VQcm9ncmFtKG51bGwpfSxiaW5kQXR0cmlicygpe3QudmVydGV4QXR0cmliUG9pbnRlcigwLDMsdC5GTE9BVCwhMSxJZSo0LDApLHQuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoMCksdC52ZXJ0ZXhBdHRyaWJQb2ludGVyKDEsMix0LkZMT0FULCExLEllKjQsMTIpLHQuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoMSksdC52ZXJ0ZXhBdHRyaWJQb2ludGVyKDIsNCx0LkZMT0FULCExLEllKjQsMjApLHQuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoMil9LHNlbmQoUCl7dGhpcy5iaW5kKCk7Zm9yKGxldCBYIGluIFApe2xldCBGPVBbWF0sWj10LmdldFVuaWZvcm1Mb2NhdGlvbihDLFgpO3R5cGVvZiBGPT1cIm51bWJlclwiP3QudW5pZm9ybTFmKFosRik6YXQoRik/dC51bmlmb3JtTWF0cml4NGZ2KFosITEsbmV3IEZsb2F0MzJBcnJheShGLm0pKTp5ZShGKT90LnVuaWZvcm00ZihaLEYucixGLmcsRi5iLEYuYSk6aXQoRik/dC51bmlmb3JtM2YoWixGLngsRi55LEYueik6UmUoRikmJnQudW5pZm9ybTJmKFosRi54LEYueSl9dGhpcy51bmJpbmQoKX19fXIoQSxcIm1ha2VQcm9ncmFtXCIpO2Z1bmN0aW9uIFIoaCx4LGIsTCl7bGV0IHo9aC53aWR0aC94LFY9aC5oZWlnaHQvYixLPTEveixDPTEvVixQPXt9LFg9TC5zcGxpdChcIlwiKS5lbnRyaWVzKCk7Zm9yKGxldFtGLFpdb2YgWClQW1pdPWYoRiV6KkssTWF0aC5mbG9vcihGL3opKkMpO3JldHVybnt0ZXg6aCxtYXA6UCxxdzpLLHFoOkN9fXIoUixcIm1ha2VGb250XCIpO2Z1bmN0aW9uICQoaCx4LGI9aS5kZWZUZXgsTD1pLmRlZlByb2csej17fSl7Yj1iIT1udWxsP2I6aS5kZWZUZXgsTD1MIT1udWxsP0w6aS5kZWZQcm9nLChiIT09aS5jdXJUZXh8fEwhPT1pLmN1clByb2d8fCEkZShpLmN1clVuaWZvcm0seil8fGkudnF1ZXVlLmxlbmd0aCtoLmxlbmd0aCpJZT5OZXx8aS5pcXVldWUubGVuZ3RoK3gubGVuZ3RoPk5lKSYmaygpLGkuY3VyVGV4PWIsaS5jdXJQcm9nPUwsaS5jdXJVbmlmb3JtPXo7bGV0IFY9eC5tYXAoQz0+QytpLnZxdWV1ZS5sZW5ndGgvSWUpLEs9aC5tYXAoQz0+e2xldCBQPXcoaS50cmFuc2Zvcm0ubXVsdFZlYzIoQy5wb3MueHkoKSkpO3JldHVybltQLngsUC55LEMucG9zLnosQy51di54LEMudXYueSxDLmNvbG9yLnIsQy5jb2xvci5nLEMuY29sb3IuYixDLmNvbG9yLmFdfSkuZmxhdCgpO1YuZm9yRWFjaChDPT5pLmlxdWV1ZS5wdXNoKEMpKSxLLmZvckVhY2goQz0+aS52cXVldWUucHVzaChDKSl9cigkLFwiZHJhd1Jhd1wiKTtmdW5jdGlvbiBrKCl7IWkuY3VyVGV4fHwhaS5jdXJQcm9nfHxpLnZxdWV1ZS5sZW5ndGg9PT0wfHxpLmlxdWV1ZS5sZW5ndGg9PT0wfHwoaS5jdXJQcm9nLnNlbmQoaS5jdXJVbmlmb3JtKSx0LmJpbmRCdWZmZXIodC5BUlJBWV9CVUZGRVIsaS52YnVmKSx0LmJ1ZmZlclN1YkRhdGEodC5BUlJBWV9CVUZGRVIsMCxuZXcgRmxvYXQzMkFycmF5KGkudnF1ZXVlKSksdC5iaW5kQnVmZmVyKHQuRUxFTUVOVF9BUlJBWV9CVUZGRVIsaS5pYnVmKSx0LmJ1ZmZlclN1YkRhdGEodC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwwLG5ldyBVaW50MTZBcnJheShpLmlxdWV1ZSkpLGkuY3VyUHJvZy5iaW5kKCksaS5jdXJQcm9nLmJpbmRBdHRyaWJzKCksaS5jdXJUZXguYmluZCgpLHQuZHJhd0VsZW1lbnRzKHQuVFJJQU5HTEVTLGkuaXF1ZXVlLmxlbmd0aCx0LlVOU0lHTkVEX1NIT1JULDApLGkuY3VyVGV4LnVuYmluZCgpLGkuY3VyUHJvZy51bmJpbmQoKSx0LmJpbmRCdWZmZXIodC5BUlJBWV9CVUZGRVIsbnVsbCksdC5iaW5kQnVmZmVyKHQuRUxFTUVOVF9BUlJBWV9CVUZGRVIsbnVsbCksaS5pcXVldWU9W10saS52cXVldWU9W10saS5kcmF3Q2FsbHMrKyl9cihrLFwiZmx1c2hcIik7ZnVuY3Rpb24gSSgpe3QuY2xlYXIodC5DT0xPUl9CVUZGRVJfQklUKSxlLmNsZWFyQ29sb3J8fHEoe3dpZHRoOmhlKCksaGVpZ2h0OnBlKCkscXVhZDpvZSgwLDAsaGUoKSpiZSgpL3l0LHBlKCkqYmUoKS95dCksdGV4OmkuYmdUZXh9KSxpLmRyYXdDYWxscz0wLGkudHJhbnNmb3JtU3RhY2s9W10saS50cmFuc2Zvcm09ZWUoKX1yKEksXCJmcmFtZVN0YXJ0XCIpO2Z1bmN0aW9uIGooKXtrKCksaS5sYXN0RHJhd0NhbGxzPWkuZHJhd0NhbGxzfXIoaixcImZyYW1lRW5kXCIpO2Z1bmN0aW9uIFQoKXtyZXR1cm4gaS5sYXN0RHJhd0NhbGxzfXIoVCxcImRyYXdDYWxsc1wiKTtmdW5jdGlvbiB3KGgpe3JldHVybiBmKGgueC9oZSgpKjItMSwtaC55L3BlKCkqMisxKX1yKHcsXCJ0b05EQ1wiKTtmdW5jdGlvbiBTKGgpe2kudHJhbnNmb3JtPWguY2xvbmUoKX1yKFMsXCJwdXNoTWF0cml4XCIpO2Z1bmN0aW9uIFUoaCl7IWh8fGgueD09PTAmJmgueT09PTB8fChpLnRyYW5zZm9ybT1pLnRyYW5zZm9ybS50cmFuc2xhdGUoaCkpfXIoVSxcInB1c2hUcmFuc2xhdGVcIik7ZnVuY3Rpb24gQihoKXshaHx8aC54PT09MSYmaC55PT09MXx8KGkudHJhbnNmb3JtPWkudHJhbnNmb3JtLnNjYWxlKGgpKX1yKEIsXCJwdXNoU2NhbGVcIik7ZnVuY3Rpb24gXyhoKXshaHx8KGkudHJhbnNmb3JtPWkudHJhbnNmb3JtLnJvdGF0ZVgoaCkpfXIoXyxcInB1c2hSb3RhdGVYXCIpO2Z1bmN0aW9uIEcoaCl7IWh8fChpLnRyYW5zZm9ybT1pLnRyYW5zZm9ybS5yb3RhdGVZKGgpKX1yKEcsXCJwdXNoUm90YXRlWVwiKTtmdW5jdGlvbiB5KGgpeyFofHwoaS50cmFuc2Zvcm09aS50cmFuc2Zvcm0ucm90YXRlWihoKSl9cih5LFwicHVzaFJvdGF0ZVpcIik7ZnVuY3Rpb24gSCgpe2kudHJhbnNmb3JtU3RhY2sucHVzaChpLnRyYW5zZm9ybS5jbG9uZSgpKX1yKEgsXCJwdXNoVHJhbnNmb3JtXCIpO2Z1bmN0aW9uIE0oKXtpLnRyYW5zZm9ybVN0YWNrLmxlbmd0aD4wJiYoaS50cmFuc2Zvcm09aS50cmFuc2Zvcm1TdGFjay5wb3AoKSl9cihNLFwicG9wVHJhbnNmb3JtXCIpO2Z1bmN0aW9uIHEoaD17fSl7dmFyIFoscmU7bGV0IHg9aC53aWR0aHx8MCxiPWguaGVpZ2h0fHwwLEw9aC5wb3N8fGYoMCwwKSxWPUxlKGgub3JpZ2lufHxIZSkuZG90KGYoeCxiKS5zY2FsZSgtLjUpKSxLPWYoKFo9aC5zY2FsZSkhPW51bGw/WjoxKSxDPWgucm90fHwwLFA9aC5xdWFkfHxvZSgwLDAsMSwxKSxYPTEtKChyZT1oLnopIT1udWxsP3JlOjApLEY9aC5jb2xvcnx8WSgxLDEsMSwxKTtIKCksVShMKSxCKEspLHkoQyksVShWKSwkKFt7cG9zOlRlKC14LzIsYi8yLFgpLHV2OmYoUC54LFAueStQLmgpLGNvbG9yOkZ9LHtwb3M6VGUoLXgvMiwtYi8yLFgpLHV2OmYoUC54LFAueSksY29sb3I6Rn0se3BvczpUZSh4LzIsLWIvMixYKSx1djpmKFAueCtQLncsUC55KSxjb2xvcjpGfSx7cG9zOlRlKHgvMixiLzIsWCksdXY6ZihQLngrUC53LFAueStQLmgpLGNvbG9yOkZ9XSxbMCwxLDMsMSwyLDNdLGgudGV4LGgucHJvZyxoLnVuaWZvcm0pLE0oKX1yKHEsXCJkcmF3UXVhZFwiKTtmdW5jdGlvbiBKKGgseD17fSl7dmFyIFY7bGV0IGI9KFY9eC5xdWFkKSE9bnVsbD9WOm9lKDAsMCwxLDEpLEw9aC53aWR0aCpiLncsej1oLmhlaWdodCpiLmg7cSh3ZShsZSh7fSx4KSx7dGV4OmgscXVhZDpiLHdpZHRoOkwsaGVpZ2h0Onp9KSl9cihKLFwiZHJhd1RleHR1cmVcIik7ZnVuY3Rpb24gRShoLHgsYixMPXt9KXtxKHdlKGxlKHt9LEwpLHtwb3M6aCx3aWR0aDp4LGhlaWdodDpifSkpfXIoRSxcImRyYXdSZWN0XCIpO2Z1bmN0aW9uIE8oaCx4LGIsTD17fSl7bGV0IHo9TGUoTC5vcmlnaW58fEhlKS5kb3QoZih4LGIpKS5zY2FsZSguNSksVj1oLmFkZChmKC14LzIsLWIvMikpLnN1Yih6KSxLPWguYWRkKGYoLXgvMixiLzIpKS5zdWIoeiksQz1oLmFkZChmKHgvMixiLzIpKS5zdWIoeiksUD1oLmFkZChmKHgvMiwtYi8yKSkuc3ViKHopO3RlKFYsSyxMKSx0ZShLLEMsTCksdGUoQyxQLEwpLHRlKFAsVixMKX1yKE8sXCJkcmF3UmVjdFN0cm9rZVwiKTtmdW5jdGlvbiB0ZShoLHgsYj17fSl7bGV0IEw9Yi53aWR0aHx8MSx6PWguZGlzdCh4KSxWPU1hdGguUEkvMi1oLmFuZ2xlKHgpO3Eod2UobGUoe30sYikse3BvczpoLmFkZCh4KS5zY2FsZSguNSksd2lkdGg6TCxoZWlnaHQ6eixyb3Q6VixvcmlnaW46XCJjZW50ZXJcIn0pKX1yKHRlLFwiZHJhd0xpbmVcIik7ZnVuY3Rpb24gbmUoaCx4LGI9e30pe2xldCBMPShoK1wiXCIpLnNwbGl0KFwiXCIpLHo9eC5xdyp4LnRleC53aWR0aCxWPXgucWgqeC50ZXguaGVpZ2h0LEs9Yi5zaXplfHxWLEM9ZihLL1YpLmRvdChmKGIuc2NhbGV8fDEpKSxQPUMueCp6LFg9Qy55KlYsRj0wLFo9WCxyZT0wLGdlPVtbXV07Zm9yKGxldCBpZSBvZiBMKShpZT09PWBcbmB8fChiLndpZHRoP0YrUD5iLndpZHRoOiExKSkmJihaKz1YLEY9MCxnZS5wdXNoKFtdKSksaWUhPT1gXG5gJiYoZ2VbZ2UubGVuZ3RoLTFdLnB1c2goaWUpLEYrPVApLHJlPU1hdGgubWF4KHJlLEYpO2Iud2lkdGgmJihyZT1iLndpZHRoKTtsZXQgRmU9W10sR2U9ZihiLnBvc3x8MCksc2U9TGUoYi5vcmlnaW58fEhlKS5zY2FsZSguNSksbWU9LXNlLngqUC0oc2UueCsuNSkqKHJlLVApLENlPS1zZS55KlgtKHNlLnkrLjUpKihaLVgpO3JldHVybiBnZS5mb3JFYWNoKChpZSxVZSk9PntsZXQgTWU9KHJlLWllLmxlbmd0aCpQKSooc2UueCsuNSk7aWUuZm9yRWFjaCgoQWUsQmUpPT57bGV0IF9lPXgubWFwW0FlXSxqZT1CZSpQLHFlPVVlKlg7X2UmJkZlLnB1c2goe3RleDp4LnRleCxxdWFkOm9lKF9lLngsX2UueSx4LnF3LHgucWgpLGNoOkFlLHBvczpmKEdlLngramUrbWUrTWUsR2UueStxZStDZSksY29sb3I6Yi5jb2xvcixvcmlnaW46Yi5vcmlnaW4sc2NhbGU6Qyx6OmIuen0pfSl9KSx7d2lkdGg6cmUsaGVpZ2h0OlosY2hhcnM6RmV9fXIobmUsXCJmbXRUZXh0XCIpO2Z1bmN0aW9uIHVlKGgseCxiPXt9KXtjZShuZShoLHgsYikpfXIodWUsXCJkcmF3VGV4dFwiKTtmdW5jdGlvbiBjZShoKXtmb3IobGV0IHggb2YgaC5jaGFycylxKHt0ZXg6eC50ZXgsd2lkdGg6eC50ZXgud2lkdGgqeC5xdWFkLncsaGVpZ2h0OngudGV4LmhlaWdodCp4LnF1YWQuaCxwb3M6eC5wb3Msc2NhbGU6eC5zY2FsZSxjb2xvcjp4LmNvbG9yLHF1YWQ6eC5xdWFkLG9yaWdpbjpcImNlbnRlclwiLHo6eC56fSl9cihjZSxcImRyYXdGbXRUZXh0XCIpO2Z1bmN0aW9uIGhlKCl7cmV0dXJuIHQuZHJhd2luZ0J1ZmZlcldpZHRoL2JlKCl9cihoZSxcIndpZHRoXCIpO2Z1bmN0aW9uIHBlKCl7cmV0dXJuIHQuZHJhd2luZ0J1ZmZlckhlaWdodC9iZSgpfXIocGUsXCJoZWlnaHRcIik7ZnVuY3Rpb24gYmUoKXt2YXIgaDtyZXR1cm4oaD1lLnNjYWxlKSE9bnVsbD9oOjF9cihiZSxcInNjYWxlXCIpO2Z1bmN0aW9uIEVlKCl7cmV0dXJuIGkuY2xlYXJDb2xvci5jbG9uZSgpfXJldHVybiByKEVlLFwiY2xlYXJDb2xvclwiKSx7d2lkdGg6aGUsaGVpZ2h0OnBlLHNjYWxlOmJlLG1ha2VUZXg6dixtYWtlUHJvZ3JhbTpBLG1ha2VGb250OlIsZHJhd1RleHR1cmU6SixkcmF3VGV4dDp1ZSxkcmF3Rm10VGV4dDpjZSxkcmF3UmVjdDpFLGRyYXdSZWN0U3Ryb2tlOk8sZHJhd0xpbmU6dGUsZm10VGV4dDpuZSxmcmFtZVN0YXJ0OkksZnJhbWVFbmQ6aixwdXNoVHJhbnNmb3JtOkgscG9wVHJhbnNmb3JtOk0scHVzaE1hdHJpeDpTLGRyYXdDYWxsczpULGNsZWFyQ29sb3I6RWV9fXZhciBIZSxJZSxOZSx5dCxvbixhbixXZSxLZSxndD1mZSgoKT0+e3hlKCk7YnQoKTtIZT1cInRvcGxlZnRcIixJZT05LE5lPTY1NTM2LHl0PTY0LG9uPWBcbmF0dHJpYnV0ZSB2ZWMzIGFfcG9zO1xuYXR0cmlidXRlIHZlYzIgYV91djtcbmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7XG5cbnZhcnlpbmcgdmVjMyB2X3BvcztcbnZhcnlpbmcgdmVjMiB2X3V2O1xudmFyeWluZyB2ZWM0IHZfY29sb3I7XG5cbnZlYzQgZGVmX3ZlcnQoKSB7XG5cdHJldHVybiB2ZWM0KGFfcG9zLCAxLjApO1xufVxuXG57e3VzZXJ9fVxuXG52b2lkIG1haW4oKSB7XG5cdHZlYzQgcG9zID0gdmVydChhX3BvcywgYV91diwgYV9jb2xvcik7XG5cdHZfcG9zID0gYV9wb3M7XG5cdHZfdXYgPSBhX3V2O1xuXHR2X2NvbG9yID0gYV9jb2xvcjtcblx0Z2xfUG9zaXRpb24gPSBwb3M7XG59XG5gLGFuPWBcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXG52YXJ5aW5nIHZlYzMgdl9wb3M7XG52YXJ5aW5nIHZlYzIgdl91djtcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xuXG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleDtcblxudmVjNCBkZWZfZnJhZygpIHtcblx0cmV0dXJuIHZfY29sb3IgKiB0ZXh0dXJlMkQodV90ZXgsIHZfdXYpO1xufVxuXG57e3VzZXJ9fVxuXG52b2lkIG1haW4oKSB7XG5cdGdsX0ZyYWdDb2xvciA9IGZyYWcodl9wb3MsIHZfdXYsIHZfY29sb3IsIHVfdGV4KTtcblx0aWYgKGdsX0ZyYWdDb2xvci5hID09IDAuMCkge1xuXHRcdGRpc2NhcmQ7XG5cdH1cbn1cbmAsV2U9YFxudmVjNCB2ZXJ0KHZlYzMgcG9zLCB2ZWMyIHV2LCB2ZWM0IGNvbG9yKSB7XG5cdHJldHVybiBkZWZfdmVydCgpO1xufVxuYCxLZT1gXG52ZWM0IGZyYWcodmVjMyBwb3MsIHZlYzIgdXYsIHZlYzQgY29sb3IsIHNhbXBsZXIyRCB0ZXgpIHtcblx0cmV0dXJuIGRlZl9mcmFnKCk7XG59XG5gO3IoTGUsXCJvcmlnaW5QdFwiKTtyKHh0LFwiZ2Z4SW5pdFwiKX0pO2Z1bmN0aW9uIHd0KHQpe3JldHVybiB0PT09XCJwcmVzc2VkXCJ8fHQ9PT1cInJwcmVzc2VkXCI/XCJkb3duXCI6dD09PVwicmVsZWFzZWRcIj9cInVwXCI6dH1mdW5jdGlvbiB2dCh0PXt9KXt2YXIgcSxKO2xldCBlPXtjYW52YXM6KHE9dC5jYW52YXMpIT1udWxsP3E6KCgpPT57dmFyIE87bGV0IEU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtyZXR1cm4oKE89dC5yb290KSE9bnVsbD9POmRvY3VtZW50LmJvZHkpLmFwcGVuZENoaWxkKEUpLEV9KSgpLGtleVN0YXRlczp7fSxjaGFySW5wdXR0ZWQ6W10sbW91c2VTdGF0ZTpcInVwXCIsbW91c2VQb3M6ZigwLDApLHRpbWU6MCxyZWFsVGltZTowLHNraXBUaW1lOiExLGR0OjAsc2NhbGU6KEo9dC5zY2FsZSkhPW51bGw/SjoxLGlzVG91Y2g6ITEsbG9vcElEOm51bGwsc3RvcHBlZDohMSxmcHM6MCxmcHNCdWY6W10sZnBzVGltZXI6MH0sbz17QXJyb3dMZWZ0OlwibGVmdFwiLEFycm93UmlnaHQ6XCJyaWdodFwiLEFycm93VXA6XCJ1cFwiLEFycm93RG93bjpcImRvd25cIixcIiBcIjpcInNwYWNlXCJ9LGk9W1wic3BhY2VcIixcImxlZnRcIixcInJpZ2h0XCIsXCJ1cFwiLFwiZG93blwiLFwidGFiXCIsXCJmMVwiLFwiZjJcIixcImYzXCIsXCJmNFwiLFwiZjVcIixcImY2XCIsXCJmN1wiLFwiZjhcIixcImY5XCIsXCJmMTBcIixcImYxMVwiXTt0LmZ1bGxzY3JlZW4/KGUuY2FudmFzLndpZHRoPXdpbmRvdy5pbm5lcldpZHRoLGUuY2FudmFzLmhlaWdodD13aW5kb3cuaW5uZXJIZWlnaHQpOihlLmNhbnZhcy53aWR0aD0odC53aWR0aHx8NjQwKSplLnNjYWxlLGUuY2FudmFzLmhlaWdodD0odC5oZWlnaHR8fDQ4MCkqZS5zY2FsZSk7bGV0IG09W1wib3V0bGluZTogbm9uZVwiLFwiY3Vyc29yOiBkZWZhdWx0XCJdO3QuY3Jpc3AmJihtLnB1c2goXCJpbWFnZS1yZW5kZXJpbmc6IHBpeGVsYXRlZFwiKSxtLnB1c2goXCJpbWFnZS1yZW5kZXJpbmc6IGNyaXNwLWVkZ2VzXCIpKSxlLmNhbnZhcy5zdHlsZT1tLmpvaW4oXCI7XCIpLGUuY2FudmFzLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsXCIwXCIpO2xldCB2PWUuY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiLHthbnRpYWxpYXM6ITAsZGVwdGg6ITAsc3RlbmNpbDohMCxhbHBoYTohMCxwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ITB9KTtlLmlzVG91Y2g9XCJvbnRvdWNoc3RhcnRcImluIHdpbmRvd3x8bmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzPjB8fG5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzPjAsZS5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLEU9PntlLm1vdXNlUG9zPWYoRS5vZmZzZXRYLEUub2Zmc2V0WSkuc2NhbGUoMS9lLnNjYWxlKX0pLGUuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwoKT0+e2UubW91c2VTdGF0ZT1cInByZXNzZWRcIn0pLGUuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsKCk9PntlLm1vdXNlU3RhdGU9XCJyZWxlYXNlZFwifSksZS5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIixFPT57bGV0IE89RS50b3VjaGVzWzBdO2UubW91c2VQb3M9ZihPLmNsaWVudFgsTy5jbGllbnRZKS5zY2FsZSgxL2Uuc2NhbGUpLGUubW91c2VTdGF0ZT1cInByZXNzZWRcIn0pLGUuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIixFPT57bGV0IE89RS50b3VjaGVzWzBdO2UubW91c2VQb3M9ZihPLmNsaWVudFgsTy5jbGllbnRZKS5zY2FsZSgxL2Uuc2NhbGUpfSksZS5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIixFPT57bGV0IE89b1tFLmtleV18fEUua2V5LnRvTG93ZXJDYXNlKCk7aS5pbmNsdWRlcyhPKSYmRS5wcmV2ZW50RGVmYXVsdCgpLE8ubGVuZ3RoPT09MSYmZS5jaGFySW5wdXR0ZWQucHVzaChPKSxPPT09XCJzcGFjZVwiJiZlLmNoYXJJbnB1dHRlZC5wdXNoKFwiIFwiKSxFLnJlcGVhdD9lLmtleVN0YXRlc1tPXT1cInJwcmVzc2VkXCI6ZS5rZXlTdGF0ZXNbT109XCJwcmVzc2VkXCJ9KSxlLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIixFPT57bGV0IE89b1tFLmtleV18fEUua2V5LnRvTG93ZXJDYXNlKCk7ZS5rZXlTdGF0ZXNbT109XCJyZWxlYXNlZFwifSksZS5jYW52YXMuZm9jdXMoKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCgpPT57c3dpdGNoKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSl7Y2FzZVwidmlzaWJsZVwiOmUuc2tpcFRpbWU9ITA7YnJlYWs7Y2FzZVwiaGlkZGVuXCI6YnJlYWt9fSk7ZnVuY3Rpb24gQSgpe3JldHVybiBlLm1vdXNlUG9zLmNsb25lKCl9cihBLFwibW91c2VQb3NcIik7ZnVuY3Rpb24gUigpe3JldHVybiBlLm1vdXNlU3RhdGU9PT1cInByZXNzZWRcIn1yKFIsXCJtb3VzZUNsaWNrZWRcIik7ZnVuY3Rpb24gJCgpe3JldHVybiBlLm1vdXNlU3RhdGU9PT1cInByZXNzZWRcInx8ZS5tb3VzZVN0YXRlPT09XCJkb3duXCJ9cigkLFwibW91c2VEb3duXCIpO2Z1bmN0aW9uIGsoKXtyZXR1cm4gZS5tb3VzZVN0YXRlPT09XCJyZWxlYXNlZFwifXIoayxcIm1vdXNlUmVsZWFzZWRcIik7ZnVuY3Rpb24gSShFKXtyZXR1cm4gZS5rZXlTdGF0ZXNbRV09PT1cInByZXNzZWRcIn1yKEksXCJrZXlQcmVzc2VkXCIpO2Z1bmN0aW9uIGooRSl7cmV0dXJuIGUua2V5U3RhdGVzW0VdPT09XCJwcmVzc2VkXCJ8fGUua2V5U3RhdGVzW0VdPT09XCJycHJlc3NlZFwifXIoaixcImtleVByZXNzZWRSZXBcIik7ZnVuY3Rpb24gVChFKXtyZXR1cm4gZS5rZXlTdGF0ZXNbRV09PT1cInByZXNzZWRcInx8ZS5rZXlTdGF0ZXNbRV09PT1cInJwcmVzc2VkXCJ8fGUua2V5U3RhdGVzW0VdPT09XCJkb3duXCJ9cihULFwia2V5RG93blwiKTtmdW5jdGlvbiB3KEUpe3JldHVybiBlLmtleVN0YXRlc1tFXT09PVwicmVsZWFzZWRcIn1yKHcsXCJrZXlSZWxlYXNlZFwiKTtmdW5jdGlvbiBTKCl7cmV0dXJuWy4uLmUuY2hhcklucHV0dGVkXX1yKFMsXCJjaGFySW5wdXR0ZWRcIik7ZnVuY3Rpb24gVSgpe3JldHVybiBlLmR0fXIoVSxcImR0XCIpO2Z1bmN0aW9uIEIoKXtyZXR1cm4gZS50aW1lfXIoQixcInRpbWVcIik7ZnVuY3Rpb24gXygpe3JldHVybiBlLmZwc31yKF8sXCJmcHNcIik7ZnVuY3Rpb24gRygpe3JldHVybiBlLmNhbnZhcy50b0RhdGFVUkwoKX1yKEcsXCJzY3JlZW5zaG90XCIpO2Z1bmN0aW9uIHkoRSl7cmV0dXJuIEUmJihlLmNhbnZhcy5zdHlsZS5jdXJzb3I9RSE9bnVsbD9FOlwiZGVmYXVsdFwiKSxlLmNhbnZhcy5zdHlsZS5jdXJzb3J9cih5LFwiY3Vyc29yXCIpO2Z1bmN0aW9uIEgoRSl7bGV0IE89cih0ZT0+e2xldCBuZT10ZS8xZTMsdWU9bmUtZS5yZWFsVGltZTtlLnJlYWxUaW1lPW5lLGUuc2tpcFRpbWV8fChlLmR0PXVlLGUudGltZSs9ZS5kdCxlLmZwc0J1Zi5wdXNoKDEvZS5kdCksZS5mcHNUaW1lcis9ZS5kdCxlLmZwc1RpbWVyPj0xJiYoZS5mcHNUaW1lcj0wLGUuZnBzPU1hdGgucm91bmQoZS5mcHNCdWYucmVkdWNlKChjZSxoZSk9PmNlK2hlKS9lLmZwc0J1Zi5sZW5ndGgpLGUuZnBzQnVmPVtdKSksZS5za2lwVGltZT0hMSxFKCk7Zm9yKGxldCBjZSBpbiBlLmtleVN0YXRlcyllLmtleVN0YXRlc1tjZV09d3QoZS5rZXlTdGF0ZXNbY2VdKTtlLm1vdXNlU3RhdGU9d3QoZS5tb3VzZVN0YXRlKSxlLmNoYXJJbnB1dHRlZD1bXSxlLnN0b3BwZWR8fChlLmxvb3BJRD1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoTykpfSxcImZyYW1lXCIpO2UubG9vcElEPXJlcXVlc3RBbmltYXRpb25GcmFtZShPKX1yKEgsXCJydW5cIik7ZnVuY3Rpb24gTSgpe2NhbmNlbEFuaW1hdGlvbkZyYW1lKGUubG9vcElEKSxlLnN0b3BwZWQ9ITB9cmV0dXJuIHIoTSxcInF1aXRcIikse2dsOnYsbW91c2VQb3M6QSxrZXlEb3duOlQsa2V5UHJlc3NlZDpJLGtleVByZXNzZWRSZXA6aixrZXlSZWxlYXNlZDp3LG1vdXNlRG93bjokLG1vdXNlQ2xpY2tlZDpSLG1vdXNlUmVsZWFzZWQ6ayxjaGFySW5wdXR0ZWQ6UyxjdXJzb3I6eSxkdDpVLHRpbWU6QixmcHM6XyxzY3JlZW5zaG90OkcscnVuOkgscXVpdDpNfX12YXIgUnQ9ZmUoKCk9Pnt4ZSgpO3Iod3QsXCJwcm9jZXNzQnRuU3RhdGVcIik7cih2dCxcImFwcEluaXRcIil9KTtmdW5jdGlvbiBFdCgpe2xldCB0PSgoKT0+e2xldCBtPW5ldyh3aW5kb3cuQXVkaW9Db250ZXh0fHx3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0KSx2PW0uY3JlYXRlR2FpbigpLEE9djtyZXR1cm4gQS5jb25uZWN0KG0uZGVzdGluYXRpb24pLHtjdHg6bSxnYWluTm9kZTp2LG1hc3Rlck5vZGU6QX19KSgpO2Z1bmN0aW9uIGUobSl7cmV0dXJuIG0hPT12b2lkIDAmJih0LmdhaW5Ob2RlLmdhaW4udmFsdWU9YWUobSxUdCxTdCkpLHQuZ2Fpbk5vZGUuZ2Fpbi52YWx1ZX1yKGUsXCJ2b2x1bWVcIik7ZnVuY3Rpb24gbyhtLHY9e2xvb3A6ITEsdm9sdW1lOjEsc3BlZWQ6MSxkZXR1bmU6MCxzZWVrOjB9KXt2YXIgdztsZXQgQT0hMSxSPXQuY3R4LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1IuYnVmZmVyPW0sUi5sb29wPSEhdi5sb29wO2xldCAkPXQuY3R4LmNyZWF0ZUdhaW4oKTtSLmNvbm5lY3QoJCksJC5jb25uZWN0KHQubWFzdGVyTm9kZSk7bGV0IGs9KHc9di5zZWVrKSE9bnVsbD93OjA7Ui5zdGFydCgwLGspO2xldCBJPXQuY3R4LmN1cnJlbnRUaW1lLWssaj1udWxsLFQ9e3N0b3AoKXtBfHwodGhpcy5wYXVzZSgpLEk9dC5jdHguY3VycmVudFRpbWUpfSxwbGF5KFMpe2lmKCFBKXJldHVybjtsZXQgVT1SO1I9dC5jdHguY3JlYXRlQnVmZmVyU291cmNlKCksUi5idWZmZXI9VS5idWZmZXIsUi5sb29wPVUubG9vcCxSLnBsYXliYWNrUmF0ZS52YWx1ZT1VLnBsYXliYWNrUmF0ZS52YWx1ZSxSLmRldHVuZSYmKFIuZGV0dW5lLnZhbHVlPVUuZGV0dW5lLnZhbHVlKSxSLmNvbm5lY3QoJCk7bGV0IEI9UyE9bnVsbD9TOnRoaXMudGltZSgpO1Iuc3RhcnQoMCxCKSxJPXQuY3R4LmN1cnJlbnRUaW1lLUIsQT0hMSxqPW51bGx9LHBhdXNlKCl7QXx8KFIuc3RvcCgpLEE9ITAsaj10LmN0eC5jdXJyZW50VGltZSl9LHBhdXNlZCgpe3JldHVybiBBfSxzdG9wcGVkKCl7cmV0dXJuIEF9LHNwZWVkKFMpe3JldHVybiBTIT09dm9pZCAwJiYoUi5wbGF5YmFja1JhdGUudmFsdWU9YWUoUyx1bixjbikpLFIucGxheWJhY2tSYXRlLnZhbHVlfSxkZXR1bmUoUyl7cmV0dXJuIFIuZGV0dW5lPyhTIT09dm9pZCAwJiYoUi5kZXR1bmUudmFsdWU9YWUoUyxkbixmbikpLFIuZGV0dW5lLnZhbHVlKTowfSx2b2x1bWUoUyl7cmV0dXJuIFMhPT12b2lkIDAmJigkLmdhaW4udmFsdWU9YWUoUyxUdCxTdCkpLCQuZ2Fpbi52YWx1ZX0sbG9vcCgpe1IubG9vcD0hMH0sdW5sb29wKCl7Ui5sb29wPSExfSxkdXJhdGlvbigpe3JldHVybiBtLmR1cmF0aW9ufSx0aW1lKCl7cmV0dXJuIEE/ai1JOnQuY3R4LmN1cnJlbnRUaW1lLUl9fTtyZXR1cm4gVC5zcGVlZCh2LnNwZWVkKSxULmRldHVuZSh2LmRldHVuZSksVC52b2x1bWUodi52b2x1bWUpLFR9cihvLFwicGxheVwiKTtmdW5jdGlvbiBpKCl7cmV0dXJuIHQuY3R4fXJldHVybiByKGksXCJjdHhcIikse2N0eDppLHZvbHVtZTplLHBsYXk6b319dmFyIFR0LFN0LHVuLGNuLGRuLGZuLEN0PWZlKCgpPT57eGUoKTtUdD0wLFN0PTMsdW49MCxjbj0zLGRuPS0xMjAwLGZuPTEyMDA7cihFdCxcImF1ZGlvSW5pdFwiKX0pO3ZhciBBdCxfdD1mZSgoKT0+e0F0PVwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUF2Z0FBQUFJQ0FZQUFBQ01MNHZUQUFBQUFYTlNSMElBcnM0YzZRQUFCbzFKUkVGVWVKemRXOXVPNVNnTUpLdjkvMS9PUG5RbkRhYktWUWI2ekdndGplWWt2bUpzWXdoOXRRTGM5MzEvLzd5dTYzcmV0ZGJhKy80aFRaNlpETVEzd0hWZFBlMWtYay82MEhlMkQvSjdITE1oR3lPd0hRS2ppL28vQlltdjQwRGVjUnErY2ZncjhsOGRoQmZSTFBGM3Y2RjlDdS9PYndGUFl4UkJGcHRFN21BL3dRMnlXTXdJLzFyK3kzQnEvaDRIM1R3SjNmbDE2eGN6NFVmUVBCK29wbEY5UUo3aWQrU2pNVmp6L3dmNWU1cksraEtmQjkrYTg2UHNaVEltKzdQNjk0Mmp1ZnNxU3ZnNy9FTkQ1V1NnNm9qTHQ3dXVyY2pMNnY4cGZRNGRvaW5JTDl2K2Y0SFRNZlEzZ29wUjVnT1ErNmp2aVBqN0VmTHZxUUdzUUZpWGIvQjdLTUJHYy9yUTN4MU9OdUhtQm1PUWZkOTNYd0RWZ3VQSS8zVXcvZmM4RHo1czQveE1vZ1UveFNjTktJTEpiNFc1US9ZeVh0dCtJV2N5RitHek1halk3ZWhaYkNLNXZmMnNHY3ptSitKNk82SjhwVDhkQjVIUHdQVTcwNi9rbnNqZlZSbHh2aGplMFpuNUgrRi9tLytrZjZ1QTFveHFQVkQxSmVxaitrSHVScjV4MFp6elU4bkpBTnJDYWxEUzVBNTR4VjlZbnlkK3AvNmJOWFNpQmZZNURrMXBrUHlPYnpJMHMxMGNlRnIrMytGWHNNcS9xaytCTTk3VHVzVTZiSXZwK0ZsZjF1ZnV5L09KQmg4MTdzL3ZsY0tPYU9IZ1JCT2V5dTBucHB0NHVJRUErZ2Nib0xMdjk2b0l1MThJRkxoZlNSb29NaDE5aHN2a0t5TmprQ282UitmWEMzeWEvZGRBZGpyZWt4SDJpOFZtaUgyM29HVE5ZeStuMmlCSHlQaFlqdFdWOElKdHl6MzhCVzZhNDJKTUt1SnRuMzBJZmdKVCtQZGt6aWF5YVAxVytPcFg2SjZIeUorYWM4TVhhSkV2TmZuR0doZVZvdzM0bmVBbi90YWczMGFCeVJmSTVQREJsWjl0ek5naEh1SkRNblpwR08zN3JNYW0vTC9KajJ3NndZLzhUSDFnUENOZlEzenhBSlRaM3dQS2tTOUVJUzlibTNPZmJEb25vZjlZV2d3N2dDSjB1cUYrMzkwL0pJczFRWkUreWhqa0tPY2lmTUtEZE1YM2tZYnhLQjN4bjhmc05aRVBQbTJTQlE3S0QvT2trZ1haZllWL1BWL1UvK3JvazBJc3dESCtIRHlDbUFjdVhzMUxIUDhnQnpUeWQ0ODdkSXJnQVBQZkM0ODl3SzZLL0d3am91WW9vNm5tWlFYVUhDdEE5UlRoZCt5WDg3ZkluOVgzVDhLa2wyeUMzemxTK05aSzlYVUNscnVGalUzMDkzSWNCRnVpOFU3OVpmZzc0RmxqN2RSSEpKLzFIcTU4eEFzM0pBZGdOYjlRRHhIQjlmOEpmZ1NWK2M5NlFhVm5DY1JoengzK3IraFhZOXF0cTFIbUt5K3VwM0Z0M1Q3Qk4wNmdXVkRHWmhJNUpMNGI2TWg5eW9sdTVUNml1a01ON000S1FxV1ovU0tZUDkrbFlKeUFPWXRQdmVNeTVJUGRaamEvL1hQVm5rdyt0QkhkUGUzNXc4a1dzM1VYK3RqTnJ0Z2d2cFd2TTNIOExpaGk1Zi9kRTFrVkQwNjhQTDdPK0ZjMno2NWVOc2V1REVmSEtveEZweDRmam05YlMrTGpGeUV1NEY4UDRncmFzMWdlcXE4UXpLOXdsSjNJV1lKazNUdFM4emJ2VjhNTjJxR3ZheFFPWHQzWWFmS2UyTmpOOFU4QTJoekdEUXBkZzM3eHF6dXJPYkIzZE9ZOXV5WUc4bkczN3BYanA5cmc3d1FtK3YwQTIwMUd2R3FVZDRLZkZsZWpnVW9ieENEaml4QVhvZDNOaVdWZlJhYTZZc1QwaGl0SVdXQXFYeXIrSmRoWUJESmJTZzMyWThmT0ZadlZEZHppQnEvY0FCUFk4V0VLcHhmMzFmZ25NTTJ4cTY4MXU5SFlhZ0FNLzZteERtTTBlWGFCTmhDRUxnS3QzNlorVmY5R1lvRExyc2c0OTZUWjh5Rmc2MjlkRUwrRDdzRHE0RkI4YklGN3hUYXhJMlg4UTlkSldmN1kva3MyaVBZR2YySHNXZjVIbk9vdlVIMm00ODk2UTlKRERzK3JWN1RkdUtzMitFY0xOZG5odk0vZitNcUNFcDh0TzQzN2g5QzJZRVAybkw3LzVXUjJHNzlzZ1l3R3FvMUVsSkh1NEY5bXNBa0M4NExzY3hkNEJnNS9hbnNHaFZPQUtmN01BdUJ1NE5DOHNlSjFtUTBsa3Uvb2tNMDkwTS9pUzhIdUFxL2l2eEovVG8xUk1yRGcvRzhPVHVWSHViNGUxai93Zzl4QnVGNWZiUEpWVGxUc2RPYVBybWRpSFZxSzNVTi93K1htejJyK0svbVFmNkc1Um5hdXdEdUhtODBvR3dDTGtaTWJITFlCL25rWW05TWQveUY2TkRhM1NSOXNOUE0vMHJEK2NwZ2Y4d3MrcWlmT0dOMzVYSzJiSHpuQmozeFdFS0hUeStRVDVIWWlHSjgza1czbFA1Wkk0TVRtS1UxYTlyY0ZiTnlGVDc2T3pWQytvbFAydFFZTEVKTmZHbU8yaVZzNEFVL25kL1B6ZWpySGlNNTh6L0JXdmpuenMrSjdRRXZ4emxjUWdGdXBKeFhmVnVTanVGUDExTkZwNGJJNzZJVm5wWi9hN2N4ZlJrTmlJeHRMOW40MWYxeWF5aHJuZ21yRzVMd1lkV2twL3gzNWg5WWcxV0M2dmxZTnVTdHZLZVpXK2g5emZSL2VJYm9IeEQxMkJtbDg3UFlnaUNaWlA1WjgxZkk1bHJtNWswZnhmV1ZqK3g5bFNnanA3WU9Pb0FBQUFBQkpSVTVFcmtKZ2dnPT1cIn0pO2Z1bmN0aW9uIGt0KHQpe2xldCBlPW5ldyBJbWFnZTtyZXR1cm4gZS5zcmM9dCxlLmNyb3NzT3JpZ2luPVwiYW5vbnltb3VzXCIsbmV3IFByb21pc2UoKG8saSk9PntlLm9ubG9hZD0oKT0+e28oZSl9LGUub25lcnJvcj0oKT0+e2koYGZhaWxlZCB0byBsb2FkICR7dH1gKX19KX1mdW5jdGlvbiBEdCh0KXtyZXR1cm4gdC5zdGFydHNXaXRoKFwiZGF0YTpcIil9ZnVuY3Rpb24gUHQodCxlLG89e30pe2xldCBpPXtsYXN0TG9hZGVySUQ6MCxsb2FkUm9vdDpcIlwiLGxvYWRlcnM6e30sc3ByaXRlczp7fSxzb3VuZHM6e30sZm9udHM6e30sc2hhZGVyczp7fX07ZnVuY3Rpb24gbShUKXt2YXIgUztsZXQgdz1pLmxhc3RMb2FkZXJJRDtpLmxvYWRlcnNbd109ITEsaS5sYXN0TG9hZGVySUQrKyxULmNhdGNoKChTPW8uZXJySGFuZGxlcikhPW51bGw/Uzpjb25zb2xlLmVycm9yKS5maW5hbGx5KCgpPT57aS5sb2FkZXJzW3ddPSEwfSl9cihtLFwiYWRkTG9hZGVyXCIpO2Z1bmN0aW9uIHYoKXtsZXQgVD0wLHc9MDtmb3IobGV0IFMgaW4gaS5sb2FkZXJzKVQrPTEsaS5sb2FkZXJzW1NdJiYodys9MSk7cmV0dXJuIHcvVH1yKHYsXCJsb2FkUHJvZ3Jlc3NcIik7ZnVuY3Rpb24gQShUKXtyZXR1cm4gVCYmKGkubG9hZFJvb3Q9VCksaS5sb2FkUm9vdH1yKEEsXCJsb2FkUm9vdFwiKTtmdW5jdGlvbiBSKFQsdyxTLFUsQj1tbil7bGV0IF89bmV3IFByb21pc2UoKEcseSk9PntsZXQgSD1EdCh3KT93OmkubG9hZFJvb3QrdztrdChIKS50aGVuKE09PntsZXQgcT10Lm1ha2VGb250KHQubWFrZVRleChNKSxTLFUsQik7aS5mb250c1tUXT1xLEcocSl9KS5jYXRjaCh5KX0pO3JldHVybiBtKF8pLF99cihSLFwibG9hZEZvbnRcIik7ZnVuY3Rpb24gJChULHcsUz17c2xpY2VYOjEsc2xpY2VZOjEsYW5pbXM6e319KXtmdW5jdGlvbiBVKF8sRyx5PXtzbGljZVg6MSxzbGljZVk6MSxncmlkV2lkdGg6MCxncmlkSGVpZ2h0OjAsYW5pbXM6e319KXtsZXQgSD1bXSxNPXQubWFrZVRleChHKSxxPXkuc2xpY2VYfHxNLndpZHRoLyh5LmdyaWRXaWR0aHx8TS53aWR0aCksSj15LnNsaWNlWXx8TS5oZWlnaHQvKHkuZ3JpZEhlaWdodHx8TS5oZWlnaHQpLEU9MS9xLE89MS9KO2ZvcihsZXQgbmU9MDtuZTxKO25lKyspZm9yKGxldCB1ZT0wO3VlPHE7dWUrKylILnB1c2gob2UodWUqRSxuZSpPLEUsTykpO2xldCB0ZT17dGV4Ok0sZnJhbWVzOkgsYW5pbXM6eS5hbmltc3x8e319O3JldHVybiBpLnNwcml0ZXNbX109dGUsdGV9cihVLFwibG9hZFJhd1Nwcml0ZVwiKTtsZXQgQj1uZXcgUHJvbWlzZSgoXyxHKT0+e2lmKCF3KXJldHVybiBHKGBleHBlY3RlZCBzcHJpdGUgc3JjIGZvciBcIiR7VH1cImApO2lmKHR5cGVvZiB3PT1cInN0cmluZ1wiKXtsZXQgeT1EdCh3KT93OmkubG9hZFJvb3QrdztrdCh5KS50aGVuKEg9PntfKFUoVCxILFMpKX0pLmNhdGNoKEcpfWVsc2UgXyhVKFQsdyxTKSl9KTtyZXR1cm4gbShCKSxCfXIoJCxcImxvYWRTcHJpdGVcIik7ZnVuY3Rpb24gayhULHcsUyxVPSExKXtmdW5jdGlvbiBCKEcseSxIKXtsZXQgTT10Lm1ha2VQcm9ncmFtKHksSCk7cmV0dXJuIGkuc2hhZGVyc1tHXT1NLE19cihCLFwibG9hZFJhd1NoYWRlclwiKTtsZXQgXz1uZXcgUHJvbWlzZSgoRyx5KT0+e2lmKCF3JiYhUylyZXR1cm4geShcIm5vIHNoYWRlclwiKTtmdW5jdGlvbiBIKE0pe3JldHVybiBNP2ZldGNoKGkubG9hZFJvb3QrTSkudGhlbihxPT57aWYocS5vaylyZXR1cm4gcS50ZXh0KCk7dGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gbG9hZCAke019YCl9KS5jYXRjaCh5KTpuZXcgUHJvbWlzZShxPT5xKG51bGwpKX1pZihyKEgsXCJyZXNvbHZlVXJsXCIpLFUpUHJvbWlzZS5hbGwoW0godyksSChTKV0pLnRoZW4oKFtNLHFdKT0+e0coQihULE0scSkpfSkuY2F0Y2goeSk7ZWxzZSB0cnl7RyhCKFQsdyxTKSl9Y2F0Y2goTSl7eShNKX19KTtyZXR1cm4gbShfKSxffXIoayxcImxvYWRTaGFkZXJcIik7ZnVuY3Rpb24gSShULHcpe2xldCBTPWkubG9hZFJvb3QrdyxVPW5ldyBQcm9taXNlKChCLF8pPT57aWYoIXcpcmV0dXJuIF8oYGV4cGVjdGVkIHNvdW5kIHNyYyBmb3IgXCIke1R9XCJgKTt0eXBlb2Ygdz09XCJzdHJpbmdcIiYmZmV0Y2goUykudGhlbihHPT57aWYoRy5vaylyZXR1cm4gRy5hcnJheUJ1ZmZlcigpO3Rocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGxvYWQgJHtTfWApfSkudGhlbihHPT5uZXcgUHJvbWlzZSgoeSxIKT0+e2UuY3R4KCkuZGVjb2RlQXVkaW9EYXRhKEcseSxIKX0pKS50aGVuKEc9PntpLnNvdW5kc1tUXT1HLEIoRyl9KS5jYXRjaChfKX0pO3JldHVybiBtKFUpLFV9cihJLFwibG9hZFNvdW5kXCIpO2Z1bmN0aW9uIGooKXtyZXR1cm4gaS5mb250c1tTZV19cmV0dXJuIHIoaixcImRlZkZvbnRcIiksUihTZSxBdCw4LDgpLHtsb2FkUm9vdDpBLGxvYWRTcHJpdGU6JCxsb2FkU291bmQ6SSxsb2FkRm9udDpSLGxvYWRTaGFkZXI6ayxsb2FkUHJvZ3Jlc3M6dixhZGRMb2FkZXI6bSxkZWZGb250Omosc3ByaXRlczppLnNwcml0ZXMsZm9udHM6aS5mb250cyxzb3VuZHM6aS5zb3VuZHMsc2hhZGVyczppLnNoYWRlcnN9fXZhciBtbixTZSxJdD1mZSgoKT0+e3hlKCk7X3QoKTttbj1cIiAhXFxcIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xcXFxdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+XCIsU2U9XCJ1bnNjaWlcIjtyKGt0LFwibG9hZEltZ1wiKTtyKER0LFwiaXNEYXRhVXJsXCIpO3IoUHQsXCJhc3NldHNJbml0XCIpfSk7ZnVuY3Rpb24gTHQodCxlLG89e21heDo4fSl7dmFyIGs7bGV0IGk9W10sbT0oaz1vLm1heCkhPW51bGw/azo4O2Z1bmN0aW9uIHYoKXtpLmxlbmd0aD5tJiYoaT1pLnNsaWNlKDAsbSkpO2xldCBJPWYoMCx0LmhlaWdodCgpKTtpLmZvckVhY2goKGosVCk9PntsZXQgdz12ZShULDAsbSwxLC41KSxTPXZlKFQsMCxtLC44LC4yKSxVPSgoKT0+e3N3aXRjaChqLnR5cGUpe2Nhc2VcImluZm9cIjpyZXR1cm4gWSgxLDEsMSx3KTtjYXNlXCJlcnJvclwiOnJldHVybiBZKDEsMCwuNSx3KX19KSgpLEI9dC5mbXRUZXh0KGoubXNnLGUuZGVmRm9udCgpLHtwb3M6SSxvcmlnaW46XCJib3RsZWZ0XCIsY29sb3I6VSxzaXplOmxuL3Quc2NhbGUoKSx3aWR0aDp0LndpZHRoKCl9KTt0LmRyYXdSZWN0KEksQi53aWR0aCxCLmhlaWdodCx7b3JpZ2luOlwiYm90bGVmdFwiLGNvbG9yOlkoMCwwLDAsUyl9KSx0LmRyYXdGbXRUZXh0KEIpLEkueS09Qi5oZWlnaHR9KX1yKHYsXCJkcmF3XCIpO2Z1bmN0aW9uIEEoSSl7Y29uc29sZS5lcnJvcihJKSxpLnVuc2hpZnQoe3R5cGU6XCJlcnJvclwiLG1zZzpJfSl9cihBLFwiZXJyb3JcIik7ZnVuY3Rpb24gUihJKXtpLnVuc2hpZnQoe3R5cGU6XCJpbmZvXCIsbXNnOkl9KX1yKFIsXCJpbmZvXCIpO2Z1bmN0aW9uICQoKXtpPVtdfXJldHVybiByKCQsXCJjbGVhclwiKSx7aW5mbzpSLGVycm9yOkEsZHJhdzp2LGNsZWFyOiR9fXZhciBsbixGdD1mZSgoKT0+e3hlKCk7bG49MTY7cihMdCxcImxvZ2dlckluaXRcIil9KTtmdW5jdGlvbiBHdCh0KXtsZXQgZT17fSxvPVtdLGk9bnVsbDtmdW5jdGlvbiBtKCl7cmV0dXJuIGkhPT1udWxsJiZpLnJlYWR5U3RhdGU9PT0xfXIobSxcImNvbm5lY3RlZFwiKTtmdW5jdGlvbiB2KCl7bGV0IGs9bmV3IFdlYlNvY2tldCh0KTtyZXR1cm4gbmV3IFByb21pc2UoKEksaik9PntrLm9ub3Blbj0oKT0+e0koayksaT1rO2ZvcihsZXQgVCBvZiBvKWsuc2VuZChUKX0say5vbmVycm9yPSgpPT57aihgZmFpbGVkIHRvIGNvbm5lY3QgdG8gJHt0fWApfSxrLm9ubWVzc2FnZT1UPT57bGV0IHc9SlNPTi5wYXJzZShULmRhdGEpO2lmKGVbdy50eXBlXSlmb3IobGV0IFMgb2YgZVt3LnR5cGVdKVMody5kYXRhLHcuaWQpfX0pfXIodixcImNvbm5lY3RcIik7ZnVuY3Rpb24gQShrLEkpe2Vba118fChlW2tdPVtdKSxlW2tdLnB1c2goSSl9cihBLFwicmVjdlwiKTtmdW5jdGlvbiBSKGssSSl7bGV0IGo9SlNPTi5zdHJpbmdpZnkoe3R5cGU6ayxkYXRhOkl9KTtpP2kuc2VuZChqKTpvLnB1c2goail9cihSLFwic2VuZFwiKTtmdW5jdGlvbiAkKCl7aSYmaS5jbG9zZSgpfXJldHVybiByKCQsXCJjbG9zZVwiKSx7Y29ubmVjdDp2LGNsb3NlOiQsY29ubmVjdGVkOm0scmVjdjpBLHNlbmQ6Un19dmFyIE10PWZlKCgpPT57cihHdCxcIm5ldEluaXRcIil9KTt2YXIgcG49bm4oKFVuLHF0KT0+e3hlKCk7Z3QoKTtSdCgpO0N0KCk7SXQoKTtGdCgpO010KCk7cXQuZXhwb3J0cz0odD17d2lkdGg6NjQwLGhlaWdodDo0ODAsc2NhbGU6MSxmdWxsc2NyZWVuOiExLGRlYnVnOiExLGNyaXNwOiExLGNhbnZhczpudWxsLGNvbm5lY3Q6bnVsbCxsb2dNYXg6OCxyb290OmRvY3VtZW50LmJvZHl9KT0+e2xldCBlPXZ0KHt3aWR0aDp0LndpZHRoLGhlaWdodDp0LmhlaWdodCxzY2FsZTp0LnNjYWxlLGZ1bGxzY3JlZW46dC5mdWxsc2NyZWVuLGNyaXNwOnQuY3Jpc3AsY2FudmFzOnQuY2FudmFzLHJvb3Q6dC5yb290fSksbz14dChlLmdsLHtjbGVhckNvbG9yOnQuY2xlYXJDb2xvcj9ZKHQuY2xlYXJDb2xvcik6dm9pZCAwLHNjYWxlOnQuc2NhbGUsdGV4RmlsdGVyOnQudGV4RmlsdGVyfSksaT1FdCgpLG09UHQobyxpLHtlcnJIYW5kbGVyOnM9Pnt2LmVycm9yKHMpfX0pLHY9THQobyxtLHttYXg6dC5sb2dNYXh9KSxBPSgoKT0+dC5jb25uZWN0P0d0KHQuY29ubmVjdCk6bnVsbCkoKTtmdW5jdGlvbiBSKHMsbil7aWYoIUEpdGhyb3cgbmV3IEVycm9yKFwibm90IGNvbm5lY3RlZCB0byBhbnkgd2Vic29ja2V0c1wiKTtBLnJlY3YocywoYSxkKT0+e3RyeXtuKGEsZCl9Y2F0Y2godSl7di5lcnJvcih1KX19KX1yKFIsXCJyZWN2XCIpO2Z1bmN0aW9uICQocyxuKXtpZighQSl0aHJvdyBuZXcgRXJyb3IoXCJub3QgY29ubmVjdGVkIHRvIGFueSB3ZWJzb2NrZXRzXCIpO0Euc2VuZChzLG4pfXIoJCxcInNlbmRcIik7ZnVuY3Rpb24gaygpe3JldHVybiBlLmR0KCkqVy50aW1lU2NhbGV9cihrLFwiZHRcIik7ZnVuY3Rpb24gSShzLG49e30pe2xldCBhPW0uc291bmRzW3NdO2lmKCFhKXRocm93IG5ldyBFcnJvcihgc291bmQgbm90IGZvdW5kOiBcIiR7c31cImApO3JldHVybiBpLnBsYXkoYSxuKX1yKEksXCJwbGF5XCIpO2Z1bmN0aW9uIGoocyl7dmFyIGE7bGV0IG49eSgpO3JldHVybiEoKGE9bi5sYXllcnNbcyE9bnVsbD9zOm4uZGVmTGF5ZXJdKT09bnVsbD92b2lkIDA6YS5ub0NhbSl9cihqLFwiaXNDYW1MYXllclwiKTtmdW5jdGlvbiBUKHMpe3JldHVybiBqKHMpP3koKS5jYW0ubXBvczplLm1vdXNlUG9zKCl9cihULFwibW91c2VQb3NcIik7ZnVuY3Rpb24gdyhzLG49e30pe3ZhciB1O2xldCBhPSgoKT0+dHlwZW9mIHM9PVwic3RyaW5nXCI/bS5zcHJpdGVzW3NdOnMpKCk7aWYoIWEpdGhyb3cgbmV3IEVycm9yKGBzcHJpdGUgbm90IGZvdW5kOiBcIiR7c31cImApO2xldCBkPWEuZnJhbWVzWyh1PW4uZnJhbWUpIT1udWxsP3U6MF07by5kcmF3VGV4dHVyZShhLnRleCx3ZShsZSh7fSxuKSx7cXVhZDpkfSkpfXIodyxcImRyYXdTcHJpdGVcIik7ZnVuY3Rpb24gUyhzLG49e30pe3ZhciB1O2xldCBhPSh1PW4uZm9udCkhPW51bGw/dTpTZSxkPW0uZm9udHNbYV07aWYoIWQpdGhyb3cgbmV3IEVycm9yKGBmb250IG5vdCBmb3VuZDogJHthfWApO28uZHJhd1RleHQocyxkLG4pfXIoUyxcImRyYXdUZXh0XCIpO2xldCBVPTk4MCxCPVwidG9wbGVmdFwiLF89e2xvYWRlZDohMSxzY2VuZXM6e30sY3VyU2NlbmU6bnVsbCxuZXh0U2NlbmU6bnVsbH07ZnVuY3Rpb24gRyhzLG4pe18uc2NlbmVzW3NdPXtpbml0Om4saW5pdGlhbGl6ZWQ6ITEsZXZlbnRzOnthZGQ6W10sdXBkYXRlOltdLGRyYXc6W10sZGVzdHJveTpbXSxrZXlEb3duOltdLGtleVByZXNzOltdLGtleVByZXNzUmVwOltdLGtleVJlbGVhc2U6W10sbW91c2VDbGljazpbXSxtb3VzZVJlbGVhc2U6W10sbW91c2VEb3duOltdLGNoYXJJbnB1dDpbXX0sYWN0aW9uOltdLHJlbmRlcjpbXSxvYmpzOm5ldyBNYXAsbGFzdE9iaklEOjAsdGltZXJzOnt9LGxhc3RUaW1lcklEOjAsY2FtOntwb3M6ZihvLndpZHRoKCkvMixvLmhlaWdodCgpLzIpLHNjYWxlOmYoMSwxKSxhbmdsZTowLHNoYWtlOjAsbXBvczpmKDApLG1hdHJpeDplZSgpfSxsYXllcnM6e30sZGVmTGF5ZXI6bnVsbCxncmF2aXR5OlUsZGF0YTp7fX19cihHLFwic2NlbmVcIik7ZnVuY3Rpb24geSgpe3JldHVybiBfLnNjZW5lc1tfLmN1clNjZW5lXX1yKHksXCJjdXJTY2VuZVwiKTtmdW5jdGlvbiBIKCl7cmV0dXJuIHkoKS5kYXRhfXIoSCxcInNjZW5lRGF0YVwiKTtmdW5jdGlvbiBNKCl7WChcImBcIiwoKT0+e1cuc2hvd0xvZz0hVy5zaG93TG9nLHYuaW5mbyhgc2hvdyBsb2c6ICR7Vy5zaG93TG9nP1wib25cIjpcIm9mZlwifWApfSksWChcImYxXCIsKCk9PntXLmluc3BlY3Q9IVcuaW5zcGVjdCx2LmluZm8oYGluc3BlY3Q6ICR7Vy5pbnNwZWN0P1wib25cIjpcIm9mZlwifWApfSksWChcImYyXCIsKCk9PntXLmNsZWFyTG9nKCl9KSxYKFwiZjhcIiwoKT0+e1cucGF1c2VkPSFXLnBhdXNlZCx2LmluZm8oYCR7Vy5wYXVzZWQ/XCJwYXVzZWRcIjpcInVucGF1c2VkXCJ9YCl9KSxYKFwiZjdcIiwoKT0+e1cudGltZVNjYWxlPWFlKFcudGltZVNjYWxlLS4yLDAsMiksdi5pbmZvKGB0aW1lIHNjYWxlOiAke1cudGltZVNjYWxlLnRvRml4ZWQoMSl9YCl9KSxYKFwiZjlcIiwoKT0+e1cudGltZVNjYWxlPWFlKFcudGltZVNjYWxlKy4yLDAsMiksdi5pbmZvKGB0aW1lIHNjYWxlOiAke1cudGltZVNjYWxlLnRvRml4ZWQoMSl9YCl9KSxYKFwiZjEwXCIsKCk9PntXLnN0ZXBGcmFtZSgpLHYuaW5mbyhcInN0ZXBwZWQgZnJhbWVcIil9KX1yKE0sXCJyZWdEZWJ1Z0lucHV0c1wiKTtmdW5jdGlvbiBxKHMsLi4ubil7Xy5uZXh0U2NlbmU9e25hbWU6cyxhcmdzOlsuLi5uXX19cihxLFwiZ29cIik7ZnVuY3Rpb24gSihzLC4uLm4pe0UocyksXy5jdXJTY2VuZT1zO2xldCBhPV8uc2NlbmVzW3NdO2lmKCFhKXRocm93IG5ldyBFcnJvcihgc2NlbmUgbm90IGZvdW5kOiAnJHtzfSdgKTtpZighYS5pbml0aWFsaXplZCl7dHJ5e2EuaW5pdCguLi5uKX1jYXRjaChkKXt2LmVycm9yKGQuc3RhY2spfXQuZGVidWcmJk0oKSxhLmluaXRpYWxpemVkPSEwfX1yKEosXCJnb1N5bmNcIik7ZnVuY3Rpb24gRShzKXtpZighXy5zY2VuZXNbc10pdGhyb3cgbmV3IEVycm9yKGBzY2VuZSBub3QgZm91bmQ6ICcke3N9J2ApO0cocyxfLnNjZW5lc1tzXS5pbml0KX1yKEUsXCJyZWxvYWRcIik7ZnVuY3Rpb24gTyhzLG4pe2xldCBhPXkoKTshYXx8KHMuZm9yRWFjaCgoZCx1KT0+e2EubGF5ZXJzW2RdPXthbHBoYToxLG9yZGVyOnUrMSxub0NhbTohMX19KSxuJiYoYS5kZWZMYXllcj1uKSl9cihPLFwibGF5ZXJzXCIpO2Z1bmN0aW9uIHRlKC4uLnMpe2xldCBuPXkoKS5jYW07cmV0dXJuIHMubGVuZ3RoPjAmJihuLnBvcz1mKC4uLnMpKSxuLnBvcy5jbG9uZSgpfXIodGUsXCJjYW1Qb3NcIik7ZnVuY3Rpb24gbmUoLi4ucyl7bGV0IG49eSgpLmNhbTtyZXR1cm4gcy5sZW5ndGg+MCYmKG4uc2NhbGU9ZiguLi5zKSksbi5zY2FsZS5jbG9uZSgpfXIobmUsXCJjYW1TY2FsZVwiKTtmdW5jdGlvbiB1ZShzKXtsZXQgbj15KCkuY2FtO3JldHVybiBzIT09dm9pZCAwJiYobi5hbmdsZT1zKSxuLmFuZ2xlfXIodWUsXCJjYW1Sb3RcIik7ZnVuY3Rpb24gY2Uocyl7bGV0IG49eSgpLmNhbTtuLnNoYWtlPXN9cihjZSxcImNhbVNoYWtlXCIpO2Z1bmN0aW9uIGhlKHMpe2xldCBuPXkoKTtzLmZvckVhY2goYT0+e24ubGF5ZXJzW2FdJiYobi5sYXllcnNbYV0ubm9DYW09ITApfSl9cihoZSxcImNhbUlnbm9yZVwiKTtmdW5jdGlvbiBwZShzKXtsZXQgbj17aGlkZGVuOiExLHBhdXNlZDohMSxfdGFnczpbXSxfaWQ6bnVsbCxfZXZlbnRzOnthZGQ6W10sdXBkYXRlOltdLGRyYXc6W10sZGVzdHJveTpbXSxpbnNwZWN0OltdfSx1c2UodSl7aWYodT09PXZvaWQgMClyZXR1cm47bGV0IHA9dHlwZW9mIHU7aWYocD09PVwic3RyaW5nXCIpe3RoaXMuX3RhZ3MucHVzaCh1KTtyZXR1cm59aWYocCE9PVwib2JqZWN0XCIpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGNvbXAgdHlwZTogJHtwfWApO2lmKEFycmF5LmlzQXJyYXkodSkpe2ZvcihsZXQgYyBvZiB1KXRoaXMudXNlKGMpO3JldHVybn1mb3IobGV0IGMgaW4gdSl7aWYodHlwZW9mIHVbY109PVwiZnVuY3Rpb25cIil7dGhpcy5fZXZlbnRzW2NdP3RoaXMuX2V2ZW50c1tjXS5wdXNoKHVbY10uYmluZCh0aGlzKSk6dGhpc1tjXT11W2NdLmJpbmQodGhpcyk7Y29udGludWV9dGhpc1tjXT11W2NdfX0sZXhpc3RzKCl7cmV0dXJuIHRoaXMuX2lkIT09dm9pZCAwfSxpcyh1KXtpZih1PT09XCIqXCIpcmV0dXJuITA7aWYoQXJyYXkuaXNBcnJheSh1KSl7Zm9yKGxldCBwIG9mIHUpaWYoIXRoaXMuX3RhZ3MuaW5jbHVkZXMocCkpcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuIHRoaXMuX3RhZ3MuaW5jbHVkZXModSl9LG9uKHUscCl7dGhpcy5fZXZlbnRzW3VdfHwodGhpcy5fZXZlbnRzW3VdPVtdKSx0aGlzLl9ldmVudHNbdV0ucHVzaChwKX0sYWN0aW9uKHUpe3RoaXMub24oXCJ1cGRhdGVcIix1KX0sdHJpZ2dlcih1LC4uLnApe2lmKHRoaXMuX2V2ZW50c1t1XSlmb3IobGV0IGcgb2YgdGhpcy5fZXZlbnRzW3VdKWcuY2FsbCh0aGlzLC4uLnApO2xldCBsPXkoKS5ldmVudHNbdV07aWYobClmb3IobGV0IGcgb2YgbCl0aGlzLmlzKGcudGFnKSYmZy5jYih0aGlzLC4uLnApfSxybVRhZyh1KXtsZXQgcD10aGlzLl90YWdzLmluZGV4T2YodSk7cD4tMSYmdGhpcy5fdGFncy5zcGxpY2UocCwxKX19O24udXNlKHMpO2xldCBhPXkoKSxkPWEubGFzdE9iaklEKys7YS5vYmpzLnNldChkLG4pLG4uX2lkPWQsbi50cmlnZ2VyKFwiYWRkXCIpO2ZvcihsZXQgdSBvZiBhLmV2ZW50cy5hZGQpbi5pcyh1LnRhZykmJnUuY2Iobik7cmV0dXJuIG59cihwZSxcImFkZFwiKTtmdW5jdGlvbiBiZShzKXtpZighcy5leGlzdHMoKSlyZXR1cm47bGV0IG49eSgpO24ub2Jqcy5kZWxldGUocy5faWQpO2xldCBhPW4ubGFzdE9iaklEKys7cmV0dXJuIG4ub2Jqcy5zZXQoYSxzKSxzLl9pZD1hLHN9cihiZSxcInJlYWRkXCIpO2Z1bmN0aW9uIEVlKHMsbixhKXtsZXQgZD15KCk7ZC5ldmVudHNbc118fChkLmV2ZW50c1tzXT1bXSksZC5ldmVudHNbc10ucHVzaCh7dGFnOm4sY2I6YX0pfXIoRWUsXCJvblwiKTtmdW5jdGlvbiBoKHMsbil7dHlwZW9mIHM9PVwiZnVuY3Rpb25cIiYmbj09PXZvaWQgMD95KCkuYWN0aW9uLnB1c2gocyk6dHlwZW9mIHM9PVwic3RyaW5nXCImJkVlKFwidXBkYXRlXCIscyxuKX1yKGgsXCJhY3Rpb25cIik7ZnVuY3Rpb24geChzLG4pe3R5cGVvZiBzPT1cImZ1bmN0aW9uXCImJm49PT12b2lkIDA/eSgpLnJlbmRlci5wdXNoKHMpOnR5cGVvZiBzPT1cInN0cmluZ1wiJiZFZShcInVwZGF0ZVwiLHMsbil9cih4LFwicmVuZGVyXCIpO2Z1bmN0aW9uIGIocyxuLGEpe2gocyxkPT57ZC5fY2hlY2tDb2xsaXNpb25zKG4sdT0+e2EoZCx1KX0pfSl9cihiLFwiY29sbGlkZXNcIik7ZnVuY3Rpb24gTChzLG4sYSl7aChzLGQ9PntkLl9jaGVja092ZXJsYXBzKG4sdT0+e2EoZCx1KX0pfSl9cihMLFwib3ZlcmxhcHNcIik7ZnVuY3Rpb24geihzLG4pe2gocyxhPT57YS5pc0NsaWNrZWQoKSYmbihhKX0pfXIoeixcImNsaWNrc1wiKTtmdW5jdGlvbiBWKHMsbil7cmV0dXJuIG5ldyBQcm9taXNlKGE9PntsZXQgZD15KCk7ZC50aW1lcnNbZC5sYXN0VGltZXJJRCsrXT17dGltZTpzLGNiOigpPT57biYmbigpLGEoKX19fSl9cihWLFwid2FpdFwiKTtmdW5jdGlvbiBLKHMsbil7bGV0IGE9ITEsZD1yKCgpPT57YXx8KG4oKSxWKHMsZCkpfSxcIm5ld0ZcIik7cmV0dXJuIGQoKSx7c3RvcCgpe2E9ITB9fX1yKEssXCJsb29wXCIpO2Z1bmN0aW9uIEMocyxuLGEpe2lmKEFycmF5LmlzQXJyYXkobikpZm9yKGxldCBkIG9mIG4pQyhzLGQsYSk7ZWxzZSB5KCkuZXZlbnRzW3NdLnB1c2goe2tleTpuLGNiOmF9KX1yKEMsXCJwdXNoS2V5RXZlbnRcIik7ZnVuY3Rpb24gUChzLG4pe0MoXCJrZXlEb3duXCIscyxuKX1yKFAsXCJrZXlEb3duXCIpO2Z1bmN0aW9uIFgocyxuKXtDKFwia2V5UHJlc3NcIixzLG4pfXIoWCxcImtleVByZXNzXCIpO2Z1bmN0aW9uIEYocyxuKXtDKFwia2V5UHJlc3NSZXBcIixzLG4pfXIoRixcImtleVByZXNzUmVwXCIpO2Z1bmN0aW9uIFoocyxuKXtDKFwia2V5UmVsZWFzZVwiLHMsbil9cihaLFwia2V5UmVsZWFzZVwiKTtmdW5jdGlvbiByZShzKXt5KCkuZXZlbnRzLmNoYXJJbnB1dC5wdXNoKHtjYjpzfSl9cihyZSxcImNoYXJJbnB1dFwiKTtmdW5jdGlvbiBnZShzKXt5KCkuZXZlbnRzLm1vdXNlRG93bi5wdXNoKHtjYjpzfSl9cihnZSxcIm1vdXNlRG93blwiKTtmdW5jdGlvbiBGZShzKXt5KCkuZXZlbnRzLm1vdXNlQ2xpY2sucHVzaCh7Y2I6c30pfXIoRmUsXCJtb3VzZUNsaWNrXCIpO2Z1bmN0aW9uIEdlKHMpe3koKS5ldmVudHMubW91c2VSZWxlYXNlLnB1c2goe2NiOnN9KX1yKEdlLFwibW91c2VSZWxlYXNlXCIpO2Z1bmN0aW9uIHNlKHMpe2xldCBuPXkoKSxhPVsuLi5uLm9ianMudmFsdWVzKCldLnNvcnQoKGQsdSk9Pnt2YXIgbCxnLEQsTixRLGRlO2xldCBwPShEPShnPW4ubGF5ZXJzWyhsPWQubGF5ZXIpIT1udWxsP2w6bi5kZWZMYXllcl0pPT1udWxsP3ZvaWQgMDpnLm9yZGVyKSE9bnVsbD9EOjAsYz0oZGU9KFE9bi5sYXllcnNbKE49dS5sYXllcikhPW51bGw/TjpuLmRlZkxheWVyXSk9PW51bGw/dm9pZCAwOlEub3JkZXIpIT1udWxsP2RlOjA7cmV0dXJuIHAtY30pO3JldHVybiBzP2EuZmlsdGVyKGQ9PmQuaXMocykpOmF9cihzZSxcImdldFwiKTtmdW5jdGlvbiBtZShzLG4pe3R5cGVvZiBzPT1cImZ1bmN0aW9uXCImJm49PT12b2lkIDA/c2UoKS5mb3JFYWNoKHMpOnR5cGVvZiBzPT1cInN0cmluZ1wiJiZzZShzKS5mb3JFYWNoKG4pfXIobWUsXCJldmVyeVwiKTtmdW5jdGlvbiBDZShzLG4pe3R5cGVvZiBzPT1cImZ1bmN0aW9uXCImJm49PT12b2lkIDA/c2UoKS5yZXZlcnNlKCkuZm9yRWFjaChzKTp0eXBlb2Ygcz09XCJzdHJpbmdcIiYmc2UocykucmV2ZXJzZSgpLmZvckVhY2gobil9cihDZSxcInJldmVyeVwiKTtmdW5jdGlvbiBpZShzKXtpZighcy5leGlzdHMoKSlyZXR1cm47bGV0IG49eSgpOyFufHwocy50cmlnZ2VyKFwiZGVzdHJveVwiKSxuLm9ianMuZGVsZXRlKHMuX2lkKSxkZWxldGUgcy5faWQpfXIoaWUsXCJkZXN0cm95XCIpO2Z1bmN0aW9uIFVlKHMpe21lKHMsbj0+e2llKG4pfSl9cihVZSxcImRlc3Ryb3lBbGxcIik7ZnVuY3Rpb24gTWUocyl7bGV0IG49eSgpO3JldHVybiBzIT09dm9pZCAwJiYobi5ncmF2aXR5PXMpLG4uZ3Jhdml0eX1yKE1lLFwiZ3Jhdml0eVwiKTtmdW5jdGlvbiBBZShzKXtsZXQgbj15KCk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKGBzY2VuZSBub3QgZm91bmQ6ICcke18uY3VyU2NlbmV9J2ApO2xldCBhPXN8fCFXLnBhdXNlZDtpZihhKWZvcihsZXQgYyBpbiBuLnRpbWVycyl7bGV0IGw9bi50aW1lcnNbY107bC50aW1lLT1rKCksbC50aW1lPD0wJiYobC5jYigpLGRlbGV0ZSBuLnRpbWVyc1tjXSl9aWYoQ2UoYz0+eyFjLnBhdXNlZCYmYSYmYy50cmlnZ2VyKFwidXBkYXRlXCIpfSksYSlmb3IobGV0IGMgb2Ygbi5hY3Rpb24pYygpO2xldCBkPWYoby53aWR0aCgpLG8uaGVpZ2h0KCkpLHU9bi5jYW0scD1vdChQZSgwLE1hdGguUEkqMikpLnNjYWxlKHUuc2hha2UpO3Uuc2hha2U9RGUodS5zaGFrZSwwLDUqaygpKSx1Lm1hdHJpeD1lZSgpLnRyYW5zbGF0ZShkLnNjYWxlKC41KSkuc2NhbGUodS5zY2FsZSkucm90YXRlWih1LmFuZ2xlKS50cmFuc2xhdGUoZC5zY2FsZSgtLjUpKS50cmFuc2xhdGUodS5wb3Muc2NhbGUoLTEpLmFkZChkLnNjYWxlKC41KSkuYWRkKHApKSx1Lm1wb3M9dS5tYXRyaXguaW52ZXJ0KCkubXVsdFZlYzIoZS5tb3VzZVBvcygpKSxtZShjPT57Yy5oaWRkZW58fChvLnB1c2hUcmFuc2Zvcm0oKSxqKGMubGF5ZXIpJiZvLnB1c2hNYXRyaXgodS5tYXRyaXgpLGMudHJpZ2dlcihcImRyYXdcIiksby5wb3BUcmFuc2Zvcm0oKSl9KTtmb3IobGV0IGMgb2Ygbi5yZW5kZXIpYygpfXIoQWUsXCJnYW1lRnJhbWVcIik7ZnVuY3Rpb24gQmUoKXtsZXQgcz15KCk7Zm9yKGxldCBuIG9mIHMuZXZlbnRzLmNoYXJJbnB1dCllLmNoYXJJbnB1dHRlZCgpLmZvckVhY2gobi5jYik7Zm9yKGxldCBuIG9mIHMuZXZlbnRzLmtleURvd24pZS5rZXlEb3duKG4ua2V5KSYmbi5jYigpO2ZvcihsZXQgbiBvZiBzLmV2ZW50cy5rZXlQcmVzcyllLmtleVByZXNzZWQobi5rZXkpJiZuLmNiKCk7Zm9yKGxldCBuIG9mIHMuZXZlbnRzLmtleVByZXNzUmVwKWUua2V5UHJlc3NlZFJlcChuLmtleSkmJm4uY2IoKTtmb3IobGV0IG4gb2Ygcy5ldmVudHMua2V5UmVsZWFzZSllLmtleVJlbGVhc2VkKG4ua2V5KSYmbi5jYigpO2ZvcihsZXQgbiBvZiBzLmV2ZW50cy5tb3VzZURvd24pZS5tb3VzZURvd24oKSYmbi5jYigpO2ZvcihsZXQgbiBvZiBzLmV2ZW50cy5tb3VzZUNsaWNrKWUubW91c2VDbGlja2VkKCkmJm4uY2IoKTtmb3IobGV0IG4gb2Ygcy5ldmVudHMubW91c2VSZWxlYXNlKWUubW91c2VSZWxlYXNlZCgpJiZuLmNiKCl9cihCZSxcImhhbmRsZUV2ZW50c1wiKTtmdW5jdGlvbiBfZSgpe3ZhciBjO2xldCBzPXkoKSxuPW51bGwsYT1tLmRlZkZvbnQoKSxkPVkoKGM9dC5pbnNwZWN0Q29sb3IpIT1udWxsP2M6WzAsMSwxLDFdKTtmdW5jdGlvbiB1KGwsZyxEKXtsZXQgTj1mKDQpLnNjYWxlKDEvRCksUT1vLmZtdFRleHQoZyxhLHtzaXplOjEyL0QscG9zOmwuYWRkKGYoTi54LE4ueSkpfSk7by5kcmF3UmVjdChsLFEud2lkdGgrTi54KjIsUS5oZWlnaHQrTi54KjIse2NvbG9yOlkoMCwwLDAsMSl9KSxvLmRyYXdGbXRUZXh0KFEpfXIodSxcImRyYXdJbnNwZWN0VHh0XCIpO2Z1bmN0aW9uIHAobCxnKXtsZXQgRD1qKGwubGF5ZXIpLE49by5zY2FsZSgpKihEPyhzLmNhbS5zY2FsZS54K3MuY2FtLnNjYWxlLnkpLzI6MSk7RCYmKG8ucHVzaFRyYW5zZm9ybSgpLG8ucHVzaE1hdHJpeChzLmNhbS5tYXRyaXgpKSxnKE4pLEQmJm8ucG9wVHJhbnNmb3JtKCl9cihwLFwiZHJhd09ialwiKSxDZShsPT57IWwuYXJlYXx8bC5oaWRkZW58fHAobCxnPT57bnx8bC5pc0hvdmVyZWQoKSYmKG49bCk7bGV0IEQ9KG49PT1sPzY6MikvZyxOPWwuX3dvcmxkQXJlYSgpLFE9Ti5wMi54LU4ucDEueCxkZT1OLnAyLnktTi5wMS55O28uZHJhd1JlY3RTdHJva2UoTi5wMSxRLGRlLHt3aWR0aDpELGNvbG9yOmR9KX0pfSksbiYmcChuLGw9PntsZXQgZz1UKG4ubGF5ZXIpLEQ9W107Zm9yKGxldCBOIG9mIG4uX3RhZ3MpRC5wdXNoKGBcIiR7Tn1cImApO2ZvcihsZXQgTiBvZiBuLl9ldmVudHMuaW5zcGVjdCl7bGV0IFE9TigpO2ZvcihsZXQgZGUgaW4gUSlELnB1c2goYCR7ZGV9OiAke1FbZGVdfWApfXUoZyxELmpvaW4oYFxuYCksbCl9KSx1KGYoMCksZS5mcHMoKStcIlwiLG8uc2NhbGUoKSl9cihfZSxcImRyYXdJbnNwZWN0XCIpO2Z1bmN0aW9uIGplKHMsLi4ubil7ZS5ydW4oKCk9PntpZihvLmZyYW1lU3RhcnQoKSxfLmxvYWRlZCl7dHJ5e2lmKCF5KCkpdGhyb3cgbmV3IEVycm9yKGBzY2VuZSBub3QgZm91bmQ6ICcke18uY3VyU2NlbmV9J2ApO0JlKCksQWUoKSxXLmluc3BlY3QmJl9lKCl9Y2F0Y2goYSl7di5lcnJvcihhLnN0YWNrKSxlLnF1aXQoKX1XLnNob3dMb2cmJnYuZHJhdygpLF8ubmV4dFNjZW5lJiYoSi5hcHBseShudWxsLFtfLm5leHRTY2VuZS5uYW1lLC4uLl8ubmV4dFNjZW5lLmFyZ3NdKSxfLm5leHRTY2VuZT1udWxsKX1lbHNle2xldCBhPW0ubG9hZFByb2dyZXNzKCk7aWYoYT09PTEpXy5sb2FkZWQ9ITAsSihzLC4uLm4pLEEmJkEuY29ubmVjdCgpLmNhdGNoKHYuZXJyb3IpO2Vsc2V7bGV0IGQ9by53aWR0aCgpLzIsdT0yNC9vLnNjYWxlKCkscD1mKG8ud2lkdGgoKS8yLG8uaGVpZ2h0KCkvMikuc3ViKGYoZC8yLHUvMikpO28uZHJhd1JlY3QoZigwKSxvLndpZHRoKCksby5oZWlnaHQoKSx7Y29sb3I6VmUoMCwwLDApfSksby5kcmF3UmVjdFN0cm9rZShwLGQsdSx7d2lkdGg6NC9vLnNjYWxlKCl9KSxvLmRyYXdSZWN0KHAsZCphLHUpfX1vLmZyYW1lRW5kKCl9KX1yKGplLFwic3RhcnRcIik7ZnVuY3Rpb24gcWUoLi4ucyl7cmV0dXJue3BvczpmKC4uLnMpLG1vdmUoLi4ubil7bGV0IGE9ZiguLi5uKSxkPWEueCprKCksdT1hLnkqaygpO3RoaXMucG9zLngrPWQsdGhpcy5wb3MueSs9dX0saW5zcGVjdCgpe3JldHVybntwb3M6YCgke35+dGhpcy5wb3MueH0sICR7fn50aGlzLnBvcy55fSlgfX19fXIocWUsXCJwb3NcIik7ZnVuY3Rpb24gWmUoLi4ucyl7cmV0dXJuIHMubGVuZ3RoPT09MD9aZSgxKTp7c2NhbGU6ZiguLi5zKSxmbGlwWChuKXt0aGlzLnNjYWxlLng9TWF0aC5zaWduKG4pKk1hdGguYWJzKHRoaXMuc2NhbGUueCl9LGZsaXBZKG4pe3RoaXMuc2NhbGUueT1NYXRoLnNpZ24obikqTWF0aC5hYnModGhpcy5zY2FsZS55KX19fXIoWmUsXCJzY2FsZVwiKTtmdW5jdGlvbiBPdChzKXtyZXR1cm57YW5nbGU6cyE9bnVsbD9zOjB9fXIoT3QsXCJyb3RhdGVcIik7ZnVuY3Rpb24gVnQoLi4ucyl7cmV0dXJue2NvbG9yOlkoLi4ucyl9fXIoVnQsXCJjb2xvclwiKTtmdW5jdGlvbiBOdChzKXtyZXR1cm57b3JpZ2luOnN9fXIoTnQsXCJvcmlnaW5cIik7ZnVuY3Rpb24gVXQocyl7cmV0dXJue2xheWVyOnMsaW5zcGVjdCgpe3ZhciBhO2xldCBuPXkoKTtyZXR1cm57bGF5ZXI6KGE9dGhpcy5sYXllcikhPW51bGw/YTpuLmRlZkxheWVyfX19fXIoVXQsXCJsYXllclwiKTtmdW5jdGlvbiB6ZShzLG4pe3ZhciBkLHU7bGV0IGE9eSgpO3JldHVybigoZD1zLmxheWVyKSE9bnVsbD9kOmEuZGVmTGF5ZXIpPT09KCh1PW4ubGF5ZXIpIT1udWxsP3U6YS5kZWZMYXllcil9cih6ZSxcImlzU2FtZUxheWVyXCIpO2Z1bmN0aW9uIFFlKHMsbil7bGV0IGE9e30sZD17fTtyZXR1cm57YXJlYTp7cDE6cyxwMjpufSxhcmVhV2lkdGgoKXtsZXR7cDE6dSxwMjpwfT10aGlzLl93b3JsZEFyZWEoKTtyZXR1cm4gcC54LXUueH0sYXJlYUhlaWdodCgpe2xldHtwMTp1LHAyOnB9PXRoaXMuX3dvcmxkQXJlYSgpO3JldHVybiBwLnktdS55fSxpc0NsaWNrZWQoKXtyZXR1cm4gZS5tb3VzZUNsaWNrZWQoKSYmdGhpcy5pc0hvdmVyZWQoKX0saXNIb3ZlcmVkKCl7cmV0dXJuIHRoaXMuaGFzUHQoVCh0aGlzLmxheWVyKSl9LGlzQ29sbGlkZWQodSl7aWYoIXUuYXJlYXx8IXplKHRoaXMsdSkpcmV0dXJuITE7bGV0IHA9dGhpcy5fd29ybGRBcmVhKCksYz11Ll93b3JsZEFyZWEoKTtyZXR1cm4gWWUocCxjKX0saXNPdmVybGFwcGVkKHUpe2lmKCF1LmFyZWF8fCF6ZSh0aGlzLHUpKXJldHVybiExO2xldCBwPXRoaXMuX3dvcmxkQXJlYSgpLGM9dS5fd29ybGRBcmVhKCk7cmV0dXJuIGx0KHAsYyl9LGNsaWNrcyh1KXt0aGlzLmFjdGlvbigoKT0+e3RoaXMuaXNDbGlja2VkKCkmJnUoKX0pfSxob3ZlcnModSl7dGhpcy5hY3Rpb24oKCk9Pnt0aGlzLmlzSG92ZXJlZCgpJiZ1KCl9KX0sY29sbGlkZXModSxwKXt0aGlzLmFjdGlvbigoKT0+e3RoaXMuX2NoZWNrQ29sbGlzaW9ucyh1LHApfSl9LG92ZXJsYXBzKHUscCl7dGhpcy5hY3Rpb24oKCk9Pnt0aGlzLl9jaGVja092ZXJsYXBzKHUscCl9KX0saGFzUHQodSl7bGV0IHA9dGhpcy5fd29ybGRBcmVhKCk7cmV0dXJuIHB0KHtwMTpwLnAxLHAyOnAucDJ9LHUpfSxyZXNvbHZlKCl7bGV0IHU9W107cmV0dXJuIG1lKHA9PntpZihwPT09dGhpc3x8IXAuc29saWR8fCFwLmFyZWF8fCF6ZSh0aGlzLHApKXJldHVybjtsZXQgYz10aGlzLl93b3JsZEFyZWEoKSxsPXAuX3dvcmxkQXJlYSgpO2lmKCFZZShjLGwpKXJldHVybjtsZXQgZz1jLnAyLngtbC5wMS54LEQ9bC5wMi54LWMucDEueCxOPWMucDIueS1sLnAxLnksUT1sLnAyLnktYy5wMS55LGRlPU1hdGgubWluKGcsRCxOLFEpLFp0PSgoKT0+e3N3aXRjaChkZSl7Y2FzZSBnOnJldHVybiB0aGlzLnBvcy54LT1nLFwicmlnaHRcIjtjYXNlIEQ6cmV0dXJuIHRoaXMucG9zLngrPUQsXCJsZWZ0XCI7Y2FzZSBOOnJldHVybiB0aGlzLnBvcy55LT1OLFwiYm90dG9tXCI7Y2FzZSBROnJldHVybiB0aGlzLnBvcy55Kz1RLFwidG9wXCJ9fSkoKTt1LnB1c2goe29iajpwLHNpZGU6WnR9KX0pLHV9LF9jaGVja0NvbGxpc2lvbnModSxwKXttZSh1LGM9Pnt0aGlzIT09YyYmKGFbYy5faWRdfHx0aGlzLmlzQ29sbGlkZWQoYykmJihwKGMpLGFbYy5faWRdPWMpKX0pO2ZvcihsZXQgYyBpbiBhKXtsZXQgbD1hW2NdO3RoaXMuaXNDb2xsaWRlZChsKXx8ZGVsZXRlIGFbY119fSxfY2hlY2tPdmVybGFwcyh1LHApe21lKHUsYz0+e3RoaXMhPT1jJiYoZFtjLl9pZF18fHRoaXMuaXNPdmVybGFwcGVkKGMpJiYocChjKSxkW2MuX2lkXT1jKSl9KTtmb3IobGV0IGMgaW4gZCl7bGV0IGw9ZFtjXTt0aGlzLmlzT3ZlcmxhcHBlZChsKXx8ZGVsZXRlIGRbY119fSxfd29ybGRBcmVhKCl7bGV0IHU9dGhpcy5hcmVhLHA9dGhpcy5wb3N8fGYoMCksYz10aGlzLnNjYWxlfHxmKDEpLGw9cC5hZGQodS5wMS5kb3QoYykpLGc9cC5hZGQodS5wMi5kb3QoYykpO3JldHVybntwMTpmKE1hdGgubWluKGwueCxnLngpLE1hdGgubWluKGwueSxnLnkpKSxwMjpmKE1hdGgubWF4KGwueCxnLngpLE1hdGgubWF4KGwueSxnLnkpKX19fX1yKFFlLFwiYXJlYVwiKTtmdW5jdGlvbiBPZShzLG4sYSl7bGV0IGQ9ZihzLG4pLHU9TGUoYXx8QikuZG90KGQpLnNjYWxlKC0uNSk7cmV0dXJuIFFlKHUuc3ViKGQuc2NhbGUoLjUpKSx1LmFkZChkLnNjYWxlKC41KSkpfXIoT2UsXCJnZXRBcmVhRnJvbVNpemVcIik7ZnVuY3Rpb24gQnQocyxuPXt9KXtsZXQgYT1tLnNwcml0ZXNbc107aWYoIWEpdGhyb3cgbmV3IEVycm9yKGBzcHJpdGUgbm90IGZvdW5kOiBcIiR7c31cImApO2xldCBkPWxlKHt9LGEuZnJhbWVzWzBdKTtuLnF1YWQmJihkLngrPW4ucXVhZC54KmQudyxkLnkrPW4ucXVhZC55KmQuaCxkLncqPW4ucXVhZC53LGQuaCo9bi5xdWFkLmgpO2xldCB1PWEudGV4LndpZHRoKmQudyxwPWEudGV4LmhlaWdodCpkLmgsYz1udWxsO3JldHVybnt3aWR0aDp1LGhlaWdodDpwLGFuaW1TcGVlZDpuLmFuaW1TcGVlZHx8LjEsZnJhbWU6bi5mcmFtZXx8MCxxdWFkOm4ucXVhZHx8b2UoMCwwLDEsMSksYWRkKCl7IXRoaXMuYXJlYSYmIW4ubm9BcmVhJiZ0aGlzLnVzZShPZSh0aGlzLndpZHRoLHRoaXMuaGVpZ2h0LHRoaXMub3JpZ2luKSl9LGRyYXcoKXtsZXQgbD15KCksZz1hLmZyYW1lc1t0aGlzLmZyYW1lXTt3KGEse3Bvczp0aGlzLnBvcyxzY2FsZTp0aGlzLnNjYWxlLHJvdDp0aGlzLmFuZ2xlLGNvbG9yOnRoaXMuY29sb3IsZnJhbWU6dGhpcy5mcmFtZSxvcmlnaW46dGhpcy5vcmlnaW4scXVhZDp0aGlzLnF1YWQscHJvZzptLnNoYWRlcnNbdGhpcy5zaGFkZXJdLHVuaWZvcm06dGhpcy51bmlmb3JtfSl9LHVwZGF0ZSgpe2lmKCFjKXJldHVybjtsZXQgbD1hLmFuaW1zW2MubmFtZV07Yy50aW1lcis9aygpLGMudGltZXI+PXRoaXMuYW5pbVNwZWVkJiYodGhpcy5mcmFtZSsrLHRoaXMuZnJhbWU+bC50byYmKGMubG9vcD90aGlzLmZyYW1lPWwuZnJvbToodGhpcy5mcmFtZS0tLHRoaXMuc3RvcCgpKSksYyYmKGMudGltZXItPXRoaXMuYW5pbVNwZWVkKSl9LHBsYXkobCxnPSEwKXtsZXQgRD1hLmFuaW1zW2xdO2lmKCFEKXRocm93IG5ldyBFcnJvcihgYW5pbSBub3QgZm91bmQ6ICR7bH1gKTtjJiZ0aGlzLnN0b3AoKSxjPXtuYW1lOmwsbG9vcDpnLHRpbWVyOjB9LHRoaXMuZnJhbWU9RC5mcm9tLHRoaXMudHJpZ2dlcihcImFuaW1QbGF5XCIsbCl9LHN0b3AoKXtpZighYylyZXR1cm47bGV0IGw9Yy5uYW1lO2M9bnVsbCx0aGlzLnRyaWdnZXIoXCJhbmltRW5kXCIsbCl9LGNoYW5nZVNwcml0ZShsKXtpZihhPW0uc3ByaXRlc1tsXSwhYSl0aHJvdyBuZXcgRXJyb3IoYHNwcml0ZSBub3QgZm91bmQ6IFwiJHtsfVwiYCk7bGV0IGc9bGUoe30sYS5mcmFtZXNbMF0pO24ucXVhZCYmKGcueCs9bi5xdWFkLngqZy53LGcueSs9bi5xdWFkLnkqZy5oLGcudyo9bi5xdWFkLncsZy5oKj1uLnF1YWQuaCksdGhpcy53aWR0aD1hLnRleC53aWR0aCpnLncsdGhpcy5oZWlnaHQ9YS50ZXguaGVpZ2h0KmcuaCx0aGlzLmFyZWEmJiFuLm5vQXJlYSYmdGhpcy51c2UoT2UodGhpcy53aWR0aCx0aGlzLmhlaWdodCx0aGlzLm9yaWdpbikpLGM9bnVsbCx0aGlzLmZyYW1lPTB9LG51bUZyYW1lcygpe3JldHVybiBhLmZyYW1lcy5sZW5ndGh9LGN1ckFuaW0oKXtyZXR1cm4gYz09bnVsbD92b2lkIDA6Yy5uYW1lfSxpbnNwZWN0KCl7bGV0IGw9e307cmV0dXJuIGMmJihsLmN1ckFuaW09YFwiJHtjLm5hbWV9XCJgKSxsfX19cihCdCxcInNwcml0ZVwiKTtmdW5jdGlvbiBqdChzLG4sYT17fSl7cmV0dXJue3RleHQ6cyx0ZXh0U2l6ZTpuLGZvbnQ6YS5mb250LHdpZHRoOjAsaGVpZ2h0OjAsYWRkKCl7dmFyIGQsdSxwO2lmKCF0aGlzLmFyZWEmJiFhLm5vQXJlYSl7bGV0IGM9eSgpLGw9bS5mb250c1soZD10aGlzLmZvbnQpIT1udWxsP2Q6U2VdLGc9by5mbXRUZXh0KHRoaXMudGV4dCtcIlwiLGwse3Bvczp0aGlzLnBvcyxzY2FsZTp0aGlzLnNjYWxlLHJvdDp0aGlzLmFuZ2xlLHNpemU6dGhpcy50ZXh0U2l6ZSxvcmlnaW46dGhpcy5vcmlnaW4sY29sb3I6dGhpcy5jb2xvcix3aWR0aDphLndpZHRofSk7dGhpcy53aWR0aD1nLndpZHRoLygoKHU9dGhpcy5zY2FsZSk9PW51bGw/dm9pZCAwOnUueCl8fDEpLHRoaXMuaGVpZ2h0PWcuaGVpZ2h0LygoKHA9dGhpcy5zY2FsZSk9PW51bGw/dm9pZCAwOnAueSl8fDEpLHRoaXMudXNlKE9lKHRoaXMud2lkdGgsdGhpcy5oZWlnaHQsdGhpcy5vcmlnaW4pKX19LGRyYXcoKXt2YXIgYztsZXQgZD15KCksdT1tLmZvbnRzWyhjPXRoaXMuZm9udCkhPW51bGw/YzpTZV0scD1vLmZtdFRleHQodGhpcy50ZXh0K1wiXCIsdSx7cG9zOnRoaXMucG9zLHNjYWxlOnRoaXMuc2NhbGUscm90OnRoaXMuYW5nbGUsc2l6ZTp0aGlzLnRleHRTaXplLG9yaWdpbjp0aGlzLm9yaWdpbixjb2xvcjp0aGlzLmNvbG9yLHdpZHRoOmEud2lkdGh9KTt0aGlzLndpZHRoPXAud2lkdGgsdGhpcy5oZWlnaHQ9cC5oZWlnaHQsby5kcmF3Rm10VGV4dChwKX19fXIoanQsXCJ0ZXh0XCIpO2Z1bmN0aW9uIHp0KHMsbixhPXt9KXtyZXR1cm57d2lkdGg6cyxoZWlnaHQ6bixhZGQoKXshdGhpcy5hcmVhJiYhYS5ub0FyZWEmJnRoaXMudXNlKE9lKHRoaXMud2lkdGgsdGhpcy5oZWlnaHQsdGhpcy5vcmlnaW4pKX0sZHJhdygpe2xldCBkPXkoKTtvLmRyYXdSZWN0KHRoaXMucG9zLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQse3NjYWxlOnRoaXMuc2NhbGUscm90OnRoaXMuYW5nbGUsY29sb3I6dGhpcy5jb2xvcixvcmlnaW46dGhpcy5vcmlnaW4scHJvZzptLnNoYWRlcnNbdGhpcy5zaGFkZXJdLHVuaWZvcm06dGhpcy51bmlmb3JtfSl9fX1yKHp0LFwicmVjdFwiKTtmdW5jdGlvbiBYdCgpe3JldHVybntzb2xpZDohMH19cihYdCxcInNvbGlkXCIpO2xldCBZdD05NjAsJHQ9NDgwO2Z1bmN0aW9uIEh0KHM9e30pe3ZhciBwLGM7bGV0IG49MCxhPW51bGwsZD1udWxsLHU9KHA9cy5tYXhWZWwpIT1udWxsP3A6WXQ7cmV0dXJue2p1bXBGb3JjZTooYz1zLmp1bXBGb3JjZSkhPW51bGw/YzokdCx1cGRhdGUoKXt0aGlzLm1vdmUoMCxuKTtsZXQgbD10aGlzLnJlc29sdmUoKSxnPSExO2lmKGEmJighYS5leGlzdHMoKXx8IXRoaXMuaXNDb2xsaWRlZChhKT8oYT1udWxsLGQ9bnVsbCxnPSEwKTpkJiYodGhpcy5wb3M9dGhpcy5wb3MuYWRkKGEucG9zLnN1YihkKSksZD1hLnBvcy5jbG9uZSgpKSksIWEpe249TWF0aC5taW4obitNZSgpKmsoKSx1KTtmb3IobGV0IEQgb2YgbClELnNpZGU9PT1cImJvdHRvbVwiJiZuPjA/KGE9RC5vYmosbj0wLGQ9YS5wb3MuY2xvbmUoKSxnfHx0aGlzLnRyaWdnZXIoXCJncm91bmRlZFwiLGEpKTpELnNpZGU9PT1cInRvcFwiJiZuPDAmJihuPTAsdGhpcy50cmlnZ2VyKFwiaGVhZGJ1bXBcIixELm9iaikpfX0sY3VyUGxhdGZvcm0oKXtyZXR1cm4gYX0sZ3JvdW5kZWQoKXtyZXR1cm4gYSE9PW51bGx9LGZhbGxpbmcoKXtyZXR1cm4gbj4wfSxqdW1wKGwpe2E9bnVsbCxuPS1sfHwtdGhpcy5qdW1wRm9yY2V9fX1yKEh0LFwiYm9keVwiKTtmdW5jdGlvbiBXdChzLG49e30pe2xldCBhPW0uc2hhZGVyc1tzXTtyZXR1cm57c2hhZGVyOnMsdW5pZm9ybTpufX1yKFd0LFwic2hhZGVyXCIpO2xldCBXPXtwYXVzZWQ6ITEsaW5zcGVjdDohMSx0aW1lU2NhbGU6MSxzaG93TG9nOiEwLGZwczplLmZwcyxvYmpDb3VudCgpe3JldHVybiB5KCkub2Jqcy5zaXplfSxzdGVwRnJhbWUoKXtBZSghMCl9LGRyYXdDYWxsczpvLmRyYXdDYWxscyxjbGVhckxvZzp2LmNsZWFyLGxvZzp2LmluZm8sZXJyb3I6di5lcnJvcn07ZnVuY3Rpb24gS3QocyxuKXtsZXQgYT1bXSxkPWYobi5wb3N8fDApLHU9MCxwPXtnZXRQb3MoLi4uYyl7bGV0IGw9ZiguLi5jKTtyZXR1cm4gZihkLngrbC54Km4ud2lkdGgsZC55K2wueSpuLmhlaWdodCl9LHNwYXduKGMsbCl7bGV0IGc9KCgpPT57aWYoQXJyYXkuaXNBcnJheShjKSlyZXR1cm4gYztpZihuW2NdKXtpZih0eXBlb2YgbltjXT09XCJmdW5jdGlvblwiKXJldHVybiBuW2NdKCk7aWYoQXJyYXkuaXNBcnJheShuW2NdKSlyZXR1cm5bLi4ubltjXV19ZWxzZSBpZihuLmFueSlyZXR1cm4gbi5hbnkoYyl9KSgpO2lmKCFnKXJldHVybjtnLnB1c2gocWUoZC54K2wueCpuLndpZHRoLGQueStsLnkqbi5oZWlnaHQpKTtsZXQgRD1wZShnKTtyZXR1cm4gYS5wdXNoKEQpLEQudXNlKHtncmlkUG9zOmwuY2xvbmUoKSxzZXRHcmlkUG9zKE4pe3RoaXMuZ3JpZFBvcz1OLmNsb25lKCksdGhpcy5wb3M9ZihkLngrdGhpcy5ncmlkUG9zLngqbi53aWR0aCxkLnkrdGhpcy5ncmlkUG9zLnkqbi5oZWlnaHQpfSxtb3ZlTGVmdCgpe3RoaXMuc2V0R3JpZFBvcyh0aGlzLmdyaWRQb3MuYWRkKGYoLTEsMCkpKX0sbW92ZVJpZ2h0KCl7dGhpcy5zZXRHcmlkUG9zKHRoaXMuZ3JpZFBvcy5hZGQoZigxLDApKSl9LG1vdmVVcCgpe3RoaXMuc2V0R3JpZFBvcyh0aGlzLmdyaWRQb3MuYWRkKGYoMCwtMSkpKX0sbW92ZURvd24oKXt0aGlzLnNldEdyaWRQb3ModGhpcy5ncmlkUG9zLmFkZChmKDAsMSkpKX19KSxEfSx3aWR0aCgpe3JldHVybiB1Km4ud2lkdGh9LGhlaWdodCgpe3JldHVybiBzLmxlbmd0aCpuLmhlaWdodH0sZGVzdHJveSgpe2ZvcihsZXQgYyBvZiBhKWllKGMpfX07cmV0dXJuIHMuZm9yRWFjaCgoYyxsKT0+e2xldCBnPWMuc3BsaXQoXCJcIik7dT1NYXRoLm1heChnLmxlbmd0aCx1KSxnLmZvckVhY2goKEQsTik9PntwLnNwYXduKEQsZihOLGwpKX0pfSkscH1yKEt0LFwiYWRkTGV2ZWxcIik7bGV0IGtlPXtzdGFydDpqZSxsb2FkUm9vdDptLmxvYWRSb290LGxvYWRTcHJpdGU6bS5sb2FkU3ByaXRlLGxvYWRTb3VuZDptLmxvYWRTb3VuZCxsb2FkRm9udDptLmxvYWRGb250LGxvYWRTaGFkZXI6bS5sb2FkU2hhZGVyLGFkZExvYWRlcjptLmFkZExvYWRlcix3aWR0aDpvLndpZHRoLGhlaWdodDpvLmhlaWdodCxkdDprLHRpbWU6ZS50aW1lLHNjcmVlbnNob3Q6ZS5zY3JlZW5zaG90LHNjZW5lOkcsZ286cSxzY2VuZURhdGE6SCxsYXllcnM6TyxjYW1Qb3M6dGUsY2FtU2NhbGU6bmUsY2FtUm90OnVlLGNhbVNoYWtlOmNlLGNhbUlnbm9yZTpoZSxncmF2aXR5Ok1lLGFkZDpwZSxyZWFkZDpiZSxkZXN0cm95OmllLGRlc3Ryb3lBbGw6VWUsZ2V0OnNlLGV2ZXJ5Om1lLHJldmVyeTpDZSxzZW5kOiQscmVjdjpSLHBvczpxZSxzY2FsZTpaZSxyb3RhdGU6T3QsY29sb3I6VnQsb3JpZ2luOk50LGxheWVyOlV0LGFyZWE6UWUsc3ByaXRlOkJ0LHRleHQ6anQscmVjdDp6dCxzb2xpZDpYdCxib2R5Okh0LHNoYWRlcjpXdCxvbjpFZSxhY3Rpb246aCxyZW5kZXI6eCxjb2xsaWRlczpiLG92ZXJsYXBzOkwsY2xpY2tzOnosa2V5RG93bjpQLGtleVByZXNzOlgsa2V5UHJlc3NSZXA6RixrZXlSZWxlYXNlOlosY2hhcklucHV0OnJlLG1vdXNlRG93bjpnZSxtb3VzZUNsaWNrOkZlLG1vdXNlUmVsZWFzZTpHZSxtb3VzZVBvczpULGN1cnNvcjplLmN1cnNvcixrZXlJc0Rvd246ZS5rZXlEb3duLGtleUlzUHJlc3NlZDplLmtleVByZXNzZWQsa2V5SXNQcmVzc2VkUmVwOmUua2V5UHJlc3NlZFJlcCxrZXlJc1JlbGVhc2VkOmUua2V5UmVsZWFzZWQsbW91c2VJc0Rvd246ZS5tb3VzZURvd24sbW91c2VJc0NsaWNrZWQ6ZS5tb3VzZUNsaWNrZWQsbW91c2VJc1JlbGVhc2VkOmUubW91c2VSZWxlYXNlZCxsb29wOkssd2FpdDpWLHBsYXk6SSx2b2x1bWU6aS52b2x1bWUsbWFrZVJuZzpYZSxyYW5kOlBlLHJhbmRTZWVkOmZ0LHZlYzI6ZixyZ2I6VmUscmdiYTpZLHF1YWQ6b2UsY2hvb3NlOm10LGNoYW5jZTpodCxsZXJwOkRlLG1hcDp2ZSxtYXBjOnN0LHdhdmU6dXQsZGVnMnJhZDpudCxyYWQyZGVnOnJ0LGRyYXdTcHJpdGU6dyxkcmF3VGV4dDpTLGRyYXdSZWN0Om8uZHJhd1JlY3QsZHJhd1JlY3RTdHJva2U6by5kcmF3UmVjdFN0cm9rZSxkcmF3TGluZTpvLmRyYXdMaW5lLGRlYnVnOlcsYWRkTGV2ZWw6S3R9O2lmKHQucGx1Z2lucylmb3IobGV0IHMgb2YgdC5wbHVnaW5zKXtsZXQgbj1zKGtlKTtmb3IobGV0IGEgaW4gbilrZVthXT1uW2FdfWlmKHQuZ2xvYmFsKWZvcihsZXQgcyBpbiBrZSl3aW5kb3dbc109a2Vbc107cmV0dXJuIGtlfX0pO2V4cG9ydCBkZWZhdWx0IHBuKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rYWJvb20ubWpzLm1hcFxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHRpZDogbW9kdWxlSWQsXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiaW1wb3J0ICdhaXJibmItYnJvd3Nlci1zaGltcyc7XG5pbXBvcnQgJ3RoZS1uZXctY3NzLXJlc2V0L2Nzcy9yZXNldC5jc3MnO1xuaW1wb3J0ICcuL3N0eWxlcy5jc3MnO1xuaW1wb3J0IEsgZnJvbSAnLi9mdW5jdGlvbnMvaW5pdC5qcyc7XG5pbXBvcnQgb25lIGZyb20gJy4vc2NlbmVzL29uZS5qcyc7XG5pbXBvcnQgdHdvIGZyb20gJy4vc2NlbmVzL3R3by5qcyc7XG5pbXBvcnQgd2luIGZyb20gJy4vc2NlbmVzL3dpbi5qcyc7XG5pbXBvcnQgJy4vZnVuY3Rpb25zL2NvbnRyb2xzLmpzJztcblxuSy5zY2VuZSgnb25lJywgKCkgPT4gb25lKCkpO1xuSy5zY2VuZSgndHdvJywgKCkgPT4gdHdvKCkpO1xuSy5zY2VuZSgnd2luJywgd2luKTtcblxuSy5zdGFydCgnb25lJyk7XG4iXSwibmFtZXMiOlsiY2hhcmFjdGVycyIsImEiLCJzcHJpdGUiLCJtc2ciLCJiIiwiY2xvdWR5bWFuIiwiSyIsInRhbGsiLCJjbG91ZHlUYWxrIiwicGxheWVyT25lIiwicGxheWVyIiwiZ2V0IiwiaGFzS2V5Iiwib3ZlcmxhcHMiLCJrZXkiLCJwbGF5IiwiZGVzdHJveSIsImdvIiwiZmluYWxEb29yIiwiY2giLCJhY3Rpb24iLCJyZXNvbHZlIiwidGFsa2luZyIsImlmVGFsa2luZyIsInQiLCJtZXNzYWdlIiwicHVzaCIsImFkZCIsInRleHQiLCJ3aWR0aCIsInBvcyIsImhlaWdodCIsIm9yaWdpbiIsImdldE1vdmluZyIsImlzRG93biIsImRpcmVjdGlvbiIsInRpbWVyIiwic291bmQiLCJjb250cm9scyIsIlNQRUVEIiwiZGlyZWN0b3JpZXMiLCJsZWZ0IiwidmVjMiIsInVwIiwicmlnaHQiLCJkb3duIiwiZGlyZWN0aW9uS2V5cyIsIk9iamVjdCIsImtleXMiLCJrZXlQcmVzcyIsImtleURvd24iLCJtb3ZlIiwic2NhbGUiLCJzZXRJbnRlcnZhbCIsInBsYXllck1vdmUiLCJldmVudCIsInByZXZlbnREZWZhdWx0IiwicmV0dXJuVmFsdWUiLCJ0eXBlIiwidGFyZ2V0IiwiaWQiLCJidXR0b25zIiwiY2xlYXJJbnRlcnZhbCIsImJsYWNrU2NyZWVuIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwidGl0bGUiLCJ0b3VjaFN0YXJ0IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIm9wYWNpdHkiLCJzdHlsZSIsInBvaW50ZXJFdmVudHMiLCJhbmltYXRpb24iLCJhZGRFdmVudExpc3RlbmVyIiwicGFzc2l2ZSIsImthYm9vbSIsImNhbnZhcyIsImNsZWFyQ29sb3IiLCJjcmlzcCIsImZ1bGxzY3JlZW4iLCJkZWJ1ZyIsImdsb2JhbCIsInBsdWdpbnMiLCJsb2FkUm9vdCIsImxvYWRTcHJpdGUiLCJsb2FkU291bmQiLCJpc1pvb21lZCIsInpvb20iLCJqdXN0aWZ5Q29udGVudCIsInZpc2liaWxpdHkiLCJ0cmFuc2Zvcm0iLCJtYXhXaWR0aCIsImV2ZW50XyIsIndpbmRvdyIsImF0dGFjaEV2ZW50Iiwib25lIiwibGV2ZWwiLCJhZGRMZXZlbCIsInNvbGlkIiwiJCIsImFueSIsImNoYXIiLCJ0d28iLCJGIiwid2luIiwic2NlbmUiLCJzdGFydCJdLCJzb3VyY2VSb290IjoiIn0=